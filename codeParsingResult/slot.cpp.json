{
	"CheckPointReplicationSlots":{
		"body":"void CheckPointReplicationSlots(void)\r\n{\r\n    int i;\r\n    int nRet = 0;\r\n\r\n    ereport(DEBUG1, (errmsg(\"performing replication slot checkpoint\")));\r\n\r\n    /*\r\n     * Prevent any slot from being created/dropped while we're active. As we\r\n     * explicitly do *not* want to block iterating over replication_slots or\r\n     * acquiring a slot we cannot take the control lock - but that's OK,\r\n     * because holding ReplicationSlotAllocationLock is strictly stronger,\r\n     * and enough to guarantee that nobody can change the in_use bits on us.\r\n     */\r\n    LWLockAcquire(ReplicationSlotAllocationLock, LW_SHARED);\r\n\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_replication_slots; i++) {\r\n        ReplicationSlot* s = &t_thrd.slot_cxt.ReplicationSlotCtl->replication_slots[i];\r\n        char path[MAXPGPATH];\r\n\r\n        if (!s->in_use)\r\n            continue;\r\n\r\n        /* save the slot to disk, locking is handled in SaveSlotToPath() */\r\n        nRet = snprintf_s(path, MAXPGPATH, MAXPGPATH - 1, \"pg_replslot/%s\", NameStr(s->data.name));\r\n        securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n\r\n        if (unlikely(CheckFileExists(path) == FILE_NOT_EXIST)) {\r\n            CreateSlotOnDisk(s);\r\n        }\r\n        SaveSlotToPath(s, path, LOG);\r\n    }\r\n    LWLockRelease(ReplicationSlotAllocationLock);\r\n}",
		"comment":"/*\r\n * Flush all replication slots to disk.\r\n *\r\n * This needn't actually be part of a checkpoint, but it's a convenient\r\n * location.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"CheckPointReplicationSlots"
	},
	"CheckSlotRequirements":{
		"body":"void CheckSlotRequirements(void)\r\n{\r\n    if (g_instance.attr.attr_storage.max_replication_slots == 0)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\r\n                (errmsg(\"replication slots can only be used if max_replication_slots > 0\"))));\r\n\r\n    if (g_instance.attr.attr_storage.wal_level < WAL_LEVEL_ARCHIVE)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\r\n                errmsg(\"replication slots can only be used if wal_level >= archive\")));\r\n}",
		"comment":"/*\r\n * Check whether the server's configuration supports using replication\r\n * slots.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"CheckSlotRequirements"
	},
	"CreateSlotOnDisk":{
		"body":"void CreateSlotOnDisk(ReplicationSlot* slot)\r\n{\r\n    char tmppath[MAXPGPATH];\r\n    char path[MAXPGPATH];\r\n    struct stat st;\r\n    int nRet = 0;\r\n\r\n    /*\r\n     * No need to take out the io_in_progress_lock, nobody else can see this\r\n     * slot yet, so nobody else will write. We're reusing SaveSlotToPath which\r\n     * takes out the lock, if we'd take the lock here, we'd deadlock.\r\n     */\r\n    nRet = snprintf_s(path, sizeof(path), MAXPGPATH - 1, \"pg_replslot/%s\", NameStr(slot->data.name));\r\n    securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n\r\n    nRet = snprintf_s(tmppath, sizeof(tmppath), MAXPGPATH - 1, \"pg_replslot/%s.tmp\", NameStr(slot->data.name));\r\n    securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n\r\n    /*\r\n     * It's just barely possible that some previous effort to create or\r\n     * drop a slot with this name left a temp directory lying around.\r\n     * If that seems to be the case, try to remove it.  If the rmtree()\r\n     * fails, we'll error out at the mkdir() below, so we don't bother\r\n     * checking success.\r\n     */\r\n    if (stat(tmppath, &st) == 0 && S_ISDIR(st.st_mode)) {\r\n        if (!rmtree(tmppath, true)) {\r\n            ereport(ERROR, (errcode_for_file_access(), \r\n                errmsg(\"could not rm directory \\\"%s\\\": %m\", tmppath)));\r\n        }\r\n    }\r\n\r\n    /* Create and fsync the temporary slot directory. */\r\n    if (mkdir(tmppath, S_IRWXU) < 0)\r\n        ereport(ERROR, (errcode_for_file_access(),\r\n            errmsg(\"could not create directory \\\"%s\\\": %m\", tmppath)));\r\n    fsync_fname(tmppath, true);\r\n\r\n    /* Write the actual state file. */\r\n    slot->dirty = true; /* signal that we really need to write */\r\n    SaveSlotToPath(slot, tmppath, ERROR);\r\n\r\n    /* Rename the directory into place. */\r\n    if (rename(tmppath, path) != 0)\r\n        ereport(ERROR, (errcode_for_file_access(),\r\n            errmsg(\"could not rename file \\\"%s\\\" to \\\"%s\\\": %m\", tmppath, path)));\r\n\r\n    /*\r\n     * If we'd now fail - really unlikely - we wouldn't know whether this slot\r\n     * would persist after an OS crash or not - so, force a restart. The\r\n     * restart would try to fysnc this again till it works.\r\n     */\r\n    START_CRIT_SECTION();\r\n\r\n    fsync_fname(path, true);\r\n    fsync_fname(\"pg_replslot\", true);\r\n\r\n    END_CRIT_SECTION();\r\n\r\n    if (!RecoveryInProgress())\r\n        ereport(LOG, (errcode_for_file_access(),\r\n            errmsg(\"create slot \\\"%s\\\" on disk successfully\", path)));\r\n}",
		"comment":"/* ----\r\n * Manipulation of ondisk state of replication slots\r\n *\r\n * NB: none of the routines below should take any notice whether a slot is the\r\n * current one or not, that's all handled a layer above.\r\n * ----\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"CreateSlotOnDisk"
	},
	"RecoverReplSlotFile":{
		"body":"static void RecoverReplSlotFile(const ReplicationSlotOnDisk& cp, const char* name)\r\n{\r\n    int fd;\r\n    char path[MAXPGPATH];\r\n    errno_t rc = EOK;\r\n\r\n    rc = snprintf_s(path, sizeof(path), MAXPGPATH - 1, \"pg_replslot/%s/state\", name);\r\n    securec_check_ss(rc, \"\\0\", \"\\0\");\r\n\r\n    ereport(WARNING, (errmsg(\"recover the replication slot file %s\", name)));\r\n\r\n    fd = BasicOpenFile(path, O_TRUNC | O_WRONLY | PG_BINARY, S_IRUSR | S_IWUSR);\r\n    if (fd < 0)\r\n        ereport(PANIC, (errcode_for_file_access(), errmsg(\"recover failed could not open slot file \\\"%s\\\": %m\", path)));\r\n\r\n    errno = 0;\r\n    if ((write(fd, &cp, sizeof(cp))) != sizeof(cp)) {\r\n        /* if write didn't set errno, assume problem is no disk space */\r\n        if (errno == 0)\r\n            errno = ENOSPC;\r\n        ereport(\r\n            PANIC, (errcode_for_file_access(), errmsg(\"recover failed could not write to slot file \\\"%s\\\": %m\", path)));\r\n    }\r\n\r\n    /* fsync the temporary file */\r\n    if (pg_fsync(fd) != 0)\r\n        ereport(\r\n            PANIC, (errcode_for_file_access(), errmsg(\"recover failed could not fsync slot file \\\"%s\\\": %m\", path)));\r\n\r\n    if (close(fd))\r\n        ereport(\r\n            PANIC, (errcode_for_file_access(), errmsg(\"recover failed could not close slot file \\\"%s\\\": %m\", path)));\r\n}",
		"comment":"/*\r\n * when incorrect checksum is detected in slot file,\r\n * we should recover the slot file using the content of backup file\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"RecoverReplSlotFile"
	},
	"ReplicationSlotAcquire":{
		"body":"void ReplicationSlotAcquire(const char* name, bool isDummyStandby)\r\n{\r\n    ReplicationSlot* slot = NULL;\r\n    int i;\r\n    bool active = false;\r\n\r\n    Assert(t_thrd.slot_cxt.MyReplicationSlot == NULL);\r\n\r\n    ReplicationSlotValidateName(name, ERROR);\r\n\r\n    /* Search for the named slot and mark it active if we find it. */\r\n    LWLockAcquire(ReplicationSlotControlLock, LW_SHARED);\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_replication_slots; i++) {\r\n        ReplicationSlot* s = &t_thrd.slot_cxt.ReplicationSlotCtl->replication_slots[i];\r\n\r\n        if (s->in_use && strcmp(name, NameStr(s->data.name)) == 0) {\r\n            volatile ReplicationSlot* vslot = s;\r\n\r\n            SpinLockAcquire(&s->mutex);\r\n            active = vslot->active;\r\n            vslot->active = true;\r\n            SpinLockRelease(&s->mutex);\r\n            slot = s;\r\n            break;\r\n        }\r\n    }\r\n    LWLockRelease(ReplicationSlotControlLock);\r\n\r\n    /* If we did not find the slot or it was already active, error out. */\r\n    if (slot == NULL)\r\n        ereport(ERROR, (errcode(ERRCODE_UNDEFINED_OBJECT), errmsg(\"replication slot \\\"%s\\\" does not exist\", name)));\r\n    if (active) {\r\n        if (slot->data.database != InvalidOid || isDummyStandby != slot->data.isDummyStandby)\r\n            ereport(ERROR, (errcode(ERRCODE_OBJECT_IN_USE), errmsg(\"replication slot \\\"%s\\\" is already active\", name)));\r\n        else {\r\n            ereport(\r\n                WARNING, (errcode(ERRCODE_OBJECT_IN_USE), errmsg(\"replication slot \\\"%s\\\" is already active\", name)));\r\n        }\r\n    }\r\n    if (slot->data.database != InvalidOid) {\r\n        slot->candidate_restart_lsn = InvalidXLogRecPtr;\r\n        slot->candidate_restart_valid = InvalidXLogRecPtr;\r\n        slot->candidate_xmin_lsn = InvalidXLogRecPtr;\r\n        slot->candidate_catalog_xmin = InvalidTransactionId;\r\n    }\r\n\r\n    /* We made this slot active, so it's ours now. */\r\n    t_thrd.slot_cxt.MyReplicationSlot = slot;\r\n}",
		"comment":"/*\r\n * Find a previously created slot and mark it as used by this backend.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"ReplicationSlotAcquire"
	},
	"ReplicationSlotCreate":{
		"body":"void ReplicationSlotCreate(const char* name, ReplicationSlotPersistency persistency, bool isDummyStandby,\r\n    Oid databaseId, XLogRecPtr restart_lsn)\r\n{\r\n    ReplicationSlot* slot = NULL;\r\n    int i;\r\n    errno_t rc = 0;\r\n\r\n    Assert(t_thrd.slot_cxt.MyReplicationSlot == NULL);\r\n\r\n    (void)ReplicationSlotValidateName(name, ERROR);\r\n\r\n    /*\r\n     * If some other backend ran this code currently with us, we'd likely\r\n     * both allocate the same slot, and that would be bad.  We'd also be\r\n     * at risk of missing a name collision.  Also, we don't want to try to\r\n     * create a new slot while somebody's busy cleaning up an old one, because\r\n     * we might both be monkeying with the same directory.\r\n     */\r\n    LWLockAcquire(ReplicationSlotAllocationLock, LW_EXCLUSIVE);\r\n\r\n    /*\r\n     * Check for name collision, and identify an allocatable slot.  We need\r\n     * to hold ReplicationSlotControlLock in shared mode for this, so that\r\n     * nobody else can change the in_use flags while we're looking at them.\r\n     */\r\n    LWLockAcquire(ReplicationSlotControlLock, LW_SHARED);\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_replication_slots; i++) {\r\n        ReplicationSlot* s = &t_thrd.slot_cxt.ReplicationSlotCtl->replication_slots[i];\r\n\r\n        if (s->in_use && strcmp(name, NameStr(s->data.name)) == 0) {\r\n            LWLockRelease(ReplicationSlotControlLock);\r\n            LWLockRelease(ReplicationSlotAllocationLock);\r\n            if (databaseId == InvalidOid)\r\n                /* For physical replication slot, report WARNING to let libpqrcv continue */\r\n                ereport(WARNING,\r\n                    (errcode(ERRCODE_DUPLICATE_OBJECT), errmsg(\"replication slot \\\"%s\\\" already exists\", name)));\r\n            else\r\n                /* For logical replication slot, report ERROR followed PG9.4 */\r\n                ereport(\r\n                    ERROR, (errcode(ERRCODE_DUPLICATE_OBJECT), errmsg(\"replication slot \\\"%s\\\" already exists\", name)));\r\n            ReplicationSlotAcquire(name, isDummyStandby);\r\n            return;\r\n        }\r\n        if (!s->in_use && slot == NULL)\r\n            slot = s;\r\n    }\r\n    /* If all slots are in use, we're out of luck. */\r\n    if (slot == NULL) {\r\n        for (i = 0; i < g_instance.attr.attr_storage.max_replication_slots; i++) {\r\n            ReplicationSlot* s = &t_thrd.slot_cxt.ReplicationSlotCtl->replication_slots[i];\r\n\r\n            if (s->in_use) {\r\n                ereport(LOG, (errmsg(\"Slot Name: %s\", s->data.name.data)));\r\n            }\r\n        }\r\n\r\n        LWLockRelease(ReplicationSlotControlLock);\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),\r\n                errmsg(\"all replication slots are in use\"),\r\n                errhint(\"Free one or increase max_replication_slots.\")));\r\n    }\r\n\r\n    LWLockRelease(ReplicationSlotControlLock);\r\n\r\n    /*\r\n     * Since this slot is not in use, nobody should be looking at any\r\n     * part of it other than the in_use field unless they're trying to allocate\r\n     * it.  And since we hold ReplicationSlotAllocationLock, nobody except us\r\n     * can be doing that.  So it's safe to initialize the slot.\r\n     */\r\n    Assert(!slot->in_use);\r\n    slot->data.persistency = persistency;\r\n    slot->data.xmin = InvalidTransactionId;\r\n    slot->effective_xmin = InvalidTransactionId;\r\n    rc = strncpy_s(NameStr(slot->data.name), NAMEDATALEN, name, NAMEDATALEN - 1);\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n    NameStr(slot->data.name)[NAMEDATALEN - 1] = '\\0';\r\n    slot->data.database = databaseId;\r\n    slot->data.restart_lsn = restart_lsn;\r\n    slot->data.isDummyStandby = isDummyStandby;\r\n\r\n    /*\r\n     * Create the slot on disk.  We haven't actually marked the slot allocated\r\n     * yet, so no special cleanup is required if this errors out.\r\n     */\r\n    CreateSlotOnDisk(slot);\r\n\r\n    /*\r\n     * We need to briefly prevent any other backend from iterating over the\r\n     * slots while we flip the in_use flag. We also need to set the active\r\n     * flag while holding the ControlLock as otherwise a concurrent\r\n     * SlotAcquire() could acquire the slot as well.\r\n     */\r\n    LWLockAcquire(ReplicationSlotControlLock, LW_EXCLUSIVE);\r\n\r\n    slot->in_use = true;\r\n\r\n    /* We can now mark the slot active, and that makes it our slot. */\r\n    {\r\n        volatile ReplicationSlot* vslot = slot;\r\n\r\n        SpinLockAcquire(&slot->mutex);\r\n        vslot->active = true;\r\n        SpinLockRelease(&slot->mutex);\r\n        t_thrd.slot_cxt.MyReplicationSlot = slot;\r\n    }\r\n\r\n    LWLockRelease(ReplicationSlotControlLock);\r\n\r\n    /*\r\n     * Now that the slot has been marked as in_use and in_active, it's safe to\r\n     * let somebody else try to allocate a slot.\r\n     */\r\n    LWLockRelease(ReplicationSlotAllocationLock);\r\n}",
		"comment":"/*\r\n * Create a new replication slot and mark it as used by this backend.\r\n *\r\n * name: Name of the slot\r\n * db_specific: logical decoding is db specific; if the slot is going to\r\n *     be used for that pass true, otherwise false.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"ReplicationSlotCreate"
	},
	"ReplicationSlotDrop":{
		"body":"void ReplicationSlotDrop(const char* name)\r\n{\r\n    bool isLogical = false;\r\n\r\n    (void)ReplicationSlotValidateName(name, ERROR);\r\n\r\n    /*\r\n     * If some other backend ran this code currently with us, we might both\r\n     * try to free the same slot at the same time.  Or we might try to delete\r\n     * a slot with a certain name while someone else was trying to create a\r\n     * slot with the same name.\r\n     */\r\n    Assert(t_thrd.slot_cxt.MyReplicationSlot == NULL);\r\n\r\n    ReplicationSlotAcquire(name, false);\r\n    isLogical = (t_thrd.slot_cxt.MyReplicationSlot->data.database != InvalidOid);\r\n    ReplicationSlotDropAcquired();\r\n    if (PMstateIsRun() && !RecoveryInProgress() && isLogical) {\r\n        log_slot_drop(name);\r\n    }\r\n}",
		"comment":"/*\r\n * Permanently drop replication slot identified by the passed in name.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"ReplicationSlotDrop"
	},
	"ReplicationSlotDropAcquired":{
		"body":"static void ReplicationSlotDropAcquired(void)\r\n{\r\n    char path[MAXPGPATH];\r\n    char tmppath[MAXPGPATH];\r\n    ReplicationSlot* slot = t_thrd.slot_cxt.MyReplicationSlot;\r\n\r\n    Assert(t_thrd.slot_cxt.MyReplicationSlot != NULL);\r\n    /* slot isn't acquired anymore */\r\n    t_thrd.slot_cxt.MyReplicationSlot = NULL;\r\n\r\n    /*\r\n     * If some other backend ran this code concurrently with us, we might try\r\n     * to delete a slot with a certain name while someone else was trying to\r\n     * create a slot with the same name.\r\n     */\r\n    LWLockAcquire(ReplicationSlotAllocationLock, LW_EXCLUSIVE);\r\n\r\n    /* Generate pathnames. */\r\n    int nRet = snprintf_s(path, sizeof(path), MAXPGPATH - 1, \"pg_replslot/%s\", NameStr(slot->data.name));\r\n    securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n\r\n    nRet = snprintf_s(tmppath, sizeof(tmppath), MAXPGPATH - 1, \"pg_replslot/%s.tmp\", NameStr(slot->data.name));\r\n    securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n\r\n    /*\r\n* Rename the slot directory on disk, so that we'll no longer recognize\r\n* this as a valid slot.  Note that if this fails, we've got to mark the\r\n* slot inactive before bailing out.  If we're dropping a ephemeral slot,\r\n* we better never fail hard as the caller won't expect the slot to\r\n* survive and this might get called during error handling.\r\n\r\n */\r\n    if (rename(path, tmppath) == 0) {\r\n        /*\r\n         * We need to fsync() the directory we just renamed and its parent to\r\n         * make sure that our changes are on disk in a crash-safe fashion.  If\r\n         * fsync() fails, we can't be sure whether the changes are on disk or\r\n         * not.  For now, we handle that by panicking;\r\n         * StartupReplicationSlots() will try to straighten it out after\r\n         * restart.\r\n         */\r\n        START_CRIT_SECTION();\r\n        fsync_fname(tmppath, true);\r\n        fsync_fname(\"pg_replslot\", true);\r\n        END_CRIT_SECTION();\r\n    } else {\r\n        volatile ReplicationSlot* vslot = slot;\r\n\r\n        bool fail_softly = slot->data.persistency == RS_EPHEMERAL;\r\n        SpinLockAcquire(&slot->mutex);\r\n        vslot->active = false;\r\n        SpinLockRelease(&slot->mutex);\r\n\r\n        ereport(fail_softly ? WARNING : ERROR,\r\n            (errcode_for_file_access(), errmsg(\"could not rename \\\"%s\\\" to \\\"%s\\\": %m\", path, tmppath)));\r\n    }\r\n\r\n    /*\r\n     * The slot is definitely gone.  Lock out concurrent scans of the array\r\n     * long enough to kill it.  It's OK to clear the active flag here without\r\n     * grabbing the mutex because nobody else can be scanning the array here,\r\n     * and nobody can be attached to this slot and thus access it without\r\n     * scanning the array.\r\n     */\r\n    LWLockAcquire(ReplicationSlotControlLock, LW_EXCLUSIVE);\r\n    slot->active = false;\r\n    slot->in_use = false;\r\n    LWLockRelease(ReplicationSlotControlLock);\r\n\r\n    /*\r\n     * Slot is dead and doesn't prevent resource removal anymore, recompute\r\n     * limits.\r\n     */\r\n    ReplicationSlotsComputeRequiredXmin(false);\r\n    ReplicationSlotsComputeRequiredLSN(NULL);\r\n\r\n    /*\r\n     * If removing the directory fails, the worst thing that will happen is\r\n     * that the user won't be able to create a new slot with the same name\r\n     * until the next server restart.  We warn about it, but that's all.\r\n     */\r\n    if (!rmtree(tmppath, true))\r\n        ereport(WARNING, (errcode_for_file_access(), errmsg(\"could not remove directory \\\"%s\\\"\", tmppath)));\r\n\r\n    /*\r\n     * We release this at the very end, so that nobody starts trying to create\r\n     * a slot while we're still cleaning up the detritus of the old one.\r\n     */\r\n    LWLockRelease(ReplicationSlotAllocationLock);\r\n}",
		"comment":"/*\r\n * Permanently drop the currently acquired replication slot which will be\r\n * released by the point this function returns.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"ReplicationSlotDropAcquired"
	},
	"ReplicationSlotFind":{
		"body":"bool ReplicationSlotFind(const char* name)\r\n{\r\n    bool hasSlot = false;\r\n    ReplicationSlotValidateName(name, ERROR);\r\n\r\n    /* Search for the named slot and mark it active if we find it. */\r\n    LWLockAcquire(ReplicationSlotControlLock, LW_SHARED);\r\n    for (int i = 0; i < g_instance.attr.attr_storage.max_replication_slots; i++) {\r\n        ReplicationSlot* s = &t_thrd.slot_cxt.ReplicationSlotCtl->replication_slots[i];\r\n        if (s->in_use && strcmp(name, NameStr(s->data.name)) == 0) {\r\n            hasSlot = true;\r\n            break;\r\n        }\r\n    }\r\n    LWLockRelease(ReplicationSlotControlLock);\r\n    return hasSlot;\r\n}",
		"comment":"/*\r\n * Find out if we have a slot by slot name\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"ReplicationSlotFind"
	},
	"ReplicationSlotMarkDirty":{
		"body":"void ReplicationSlotMarkDirty(void)\r\n{\r\n    Assert(t_thrd.slot_cxt.MyReplicationSlot != NULL);\r\n\r\n    {\r\n        volatile ReplicationSlot* vslot = t_thrd.slot_cxt.MyReplicationSlot;\r\n\r\n        SpinLockAcquire(&vslot->mutex);\r\n        t_thrd.slot_cxt.MyReplicationSlot->just_dirtied = true;\r\n        t_thrd.slot_cxt.MyReplicationSlot->dirty = true;\r\n        SpinLockRelease(&vslot->mutex);\r\n    }\r\n}",
		"comment":"/*\r\n * Signal that it would be useful if the currently acquired slot would be\r\n * flushed out to disk.\r\n *\r\n * Note that the actual flush to disk can be delayed for a long time, if\r\n * required for correctness explicitly do a ReplicationSlotSave().\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"ReplicationSlotMarkDirty"
	},
	"ReplicationSlotPersist":{
		"body":"void ReplicationSlotPersist(void)\r\n{\r\n    ReplicationSlot* slot = t_thrd.slot_cxt.MyReplicationSlot;\r\n\r\n    Assert(slot != NULL);\r\n    Assert(slot->data.persistency != RS_PERSISTENT);\r\n    LWLockAcquire(LogicalReplicationSlotPersistentDataLock, LW_EXCLUSIVE);\r\n\r\n    {\r\n        volatile ReplicationSlot* vslot = slot;\r\n\r\n        SpinLockAcquire(&slot->mutex);\r\n        vslot->data.persistency = RS_PERSISTENT;\r\n        SpinLockRelease(&slot->mutex);\r\n    }\r\n    LWLockRelease(LogicalReplicationSlotPersistentDataLock);\r\n\r\n    ReplicationSlotMarkDirty();\r\n    ReplicationSlotSave();\r\n}",
		"comment":"/*\r\n * Convert a slot that's marked as RS_DROP_ON_ERROR to a RS_PERSISTENT slot,\r\n * guaranteeing it will be there after a eventual crash.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"ReplicationSlotPersist"
	},
	"ReplicationSlotRelease":{
		"body":"void ReplicationSlotRelease(void)\r\n{\r\n    ReplicationSlot* slot = t_thrd.slot_cxt.MyReplicationSlot;\r\n\r\n    if (slot == NULL || !slot->active) {\r\n        t_thrd.slot_cxt.MyReplicationSlot = NULL;\r\n        return;\r\n    }\r\n\r\n    if (slot->data.persistency == RS_EPHEMERAL) {\r\n        /*\r\n         * Delete the slot. There is no !PANIC case where this is allowed to\r\n         * fail, all that may happen is an incomplete cleanup of the on-disk\r\n         * data.\r\n         */\r\n        ReplicationSlotDropAcquired();\r\n    } else {\r\n        /* Mark slot inactive.  We're not freeing it, just disconnecting. */ volatile ReplicationSlot* vslot = slot;\r\n        SpinLockAcquire(&slot->mutex);\r\n        vslot->active = false;\r\n        SpinLockRelease(&slot->mutex);\r\n    }\r\n\r\n    /*\r\n     * If slot needed to temporarily restrain both data and catalog xmin to\r\n     * create the catalog snapshot, remove that temporary constraint.\r\n     * Snapshots can only be exported while the initial snapshot is still\r\n     * acquired.\r\n     */\r\n    if (!TransactionIdIsValid(slot->data.xmin) && TransactionIdIsValid(slot->effective_xmin)) {\r\n        SpinLockAcquire(&slot->mutex);\r\n        slot->effective_xmin = InvalidTransactionId;\r\n        SpinLockRelease(&slot->mutex);\r\n        ReplicationSlotsComputeRequiredXmin(false);\r\n    }\r\n\r\n    t_thrd.slot_cxt.MyReplicationSlot = NULL;\r\n    /* might not have been set when we've been a plain slot */\r\n    LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);\r\n    t_thrd.pgxact->vacuumFlags &= ~PROC_IN_LOGICAL_DECODING;\r\n    LWLockRelease(ProcArrayLock);\r\n}",
		"comment":"/*\r\n * Release a replication slot, this or another backend can ReAcquire it\r\n * later. Resources this slot requires will be preserved.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"ReplicationSlotRelease"
	},
	"ReplicationSlotReportRestartLSN":{
		"body":"void ReplicationSlotReportRestartLSN(void)\r\n{\r\n    int i;\r\n\r\n    if (g_instance.attr.attr_storage.max_replication_slots == 0)\r\n        return;\r\n\r\n    Assert(t_thrd.slot_cxt.ReplicationSlotCtl != NULL);\r\n\r\n    LWLockAcquire(ReplicationSlotControlLock, LW_SHARED);\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_replication_slots; i++) {\r\n        volatile ReplicationSlot* s = &t_thrd.slot_cxt.ReplicationSlotCtl->replication_slots[i];\r\n\r\n        if (!s->in_use)\r\n            continue;\r\n\r\n        ereport(LOG,\r\n            (errmsg(\"slotname: %s, dummy: %d, restartlsn: %X/%X\",\r\n                NameStr(s->data.name),\r\n                s->data.isDummyStandby,\r\n                (uint32)(s->data.restart_lsn >> 32),\r\n                (uint32)s->data.restart_lsn)));\r\n    }\r\n    LWLockRelease(ReplicationSlotControlLock);\r\n}",
		"comment":"/*\r\n * Report the restart LSN in replication slots.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"ReplicationSlotReportRestartLSN"
	},
	"ReplicationSlotSave":{
		"body":"void ReplicationSlotSave(void)\r\n{\r\n    char path[MAXPGPATH];\r\n    int nRet = 0;\r\n\r\n    Assert(t_thrd.slot_cxt.MyReplicationSlot != NULL);\r\n\r\n    nRet = snprintf_s(\r\n        path, MAXPGPATH, MAXPGPATH - 1, \"pg_replslot/%s\", NameStr(t_thrd.slot_cxt.MyReplicationSlot->data.name));\r\n    securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n    if (unlikely(CheckFileExists(path) == FILE_NOT_EXIST)) {\r\n        CreateSlotOnDisk(t_thrd.slot_cxt.MyReplicationSlot);\r\n    }\r\n\r\n    SaveSlotToPath(t_thrd.slot_cxt.MyReplicationSlot, path, ERROR);\r\n}",
		"comment":"/*\r\n * Serialize the currently acquired slot's state from memory to disk, thereby\r\n * guaranteeing the current state will survive a crash.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"ReplicationSlotSave"
	},
	"ReplicationSlotValidateName":{
		"body":"bool ReplicationSlotValidateName(const char* name, int elevel)\r\n{\r\n    const char* cp = NULL;\r\n\r\n    if (name == NULL) {\r\n        ereport(elevel, (errcode(ERRCODE_INVALID_NAME), errmsg(\"replication slot name should not be NULL.\")));\r\n        return false;\r\n    }\r\n\r\n    if (strlen(name) == 0) {\r\n        ereport(elevel, (errcode(ERRCODE_INVALID_NAME), errmsg(\"replication slot name \\\"%s\\\" is too short\", name)));\r\n        return false;\r\n    }\r\n\r\n    if (strlen(name) >= NAMEDATALEN) {\r\n        ereport(elevel, (errcode(ERRCODE_NAME_TOO_LONG), errmsg(\"replication slot name \\\"%s\\\" is too long\", name)));\r\n        return false;\r\n    }\r\n\r\n    for (cp = name; *cp; cp++) {\r\n        if (!((*cp >= 'a' && *cp <= 'z') || (*cp >= '0' && *cp <= '9') || (*cp == '_') || (*cp == '?') ||\r\n                (*cp == '<') || (*cp == '!') || (*cp == '-') || (*cp == '.'))) {\r\n            ereport(elevel,\r\n                (errcode(ERRCODE_INVALID_NAME),\r\n                    errmsg(\"replication slot name \\\"%s\\\" contains invalid character\", name),\r\n                    errhint(\"Replication slot names may only contain letters, numbers and the underscore character.\")));\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
		"comment":"/*\r\n * Check whether the passed slot name is valid and report errors at elevel.\r\n *\r\n * Slot names may consist out of [a-z0-9_]{1,NAMEDATALEN-1} which should allow\r\n * the name to be used as a directory name on every supported OS.\r\n *\r\n * Returns whether the directory name is valid or not if elevel < ERROR.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"ReplicationSlotValidateName"
	},
	"ReplicationSlotsComputeLogicalRestartLSN":{
		"body":"XLogRecPtr ReplicationSlotsComputeLogicalRestartLSN(void)\r\n{\r\n    XLogRecPtr result = InvalidXLogRecPtr;\r\n    int i;\r\n\r\n    if (g_instance.attr.attr_storage.max_replication_slots <= 0)\r\n        return InvalidXLogRecPtr;\r\n\r\n    LWLockAcquire(ReplicationSlotControlLock, LW_SHARED);\r\n\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_replication_slots; i++) {\r\n        ReplicationSlot* s = NULL;\r\n        XLogRecPtr restart_lsn;\r\n\r\n        s = &t_thrd.slot_cxt.ReplicationSlotCtl->replication_slots[i];\r\n\r\n        /* cannot change while ReplicationSlotCtlLock is held */\r\n        if (!s->in_use)\r\n            continue;\r\n\r\n        /* we're only interested in logical slots */\r\n        if (s->data.database == InvalidOid)\r\n            continue;\r\n\r\n        /* read once, it's ok if it increases while we're checking */\r\n        SpinLockAcquire(&s->mutex);\r\n        restart_lsn = s->data.restart_lsn;\r\n        SpinLockRelease(&s->mutex);\r\n\r\n        if (XLByteEQ(result, InvalidXLogRecPtr) || XLByteLT(restart_lsn, result))\r\n\r\n            result = restart_lsn;\r\n    }\r\n\r\n    LWLockRelease(ReplicationSlotControlLock);\r\n\r\n    return result;\r\n}",
		"comment":"/*\r\n * Compute the oldest WAL LSN required by *logical* decoding slots..\r\n *\r\n * Returns InvalidXLogRecPtr if logical decoding is disabled or no logicals\r\n * slots exist.\r\n *\r\n * NB: this returns a value >= ReplicationSlotsComputeRequiredLSN(), since it\r\n * ignores physical replication slots.\r\n *\r\n * The results aren't required frequently, so we don't maintain a precomputed\r\n * value like we do for ComputeRequiredLSN() and ComputeRequiredXmin().\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"ReplicationSlotsComputeLogicalRestartLSN"
	},
	"ReplicationSlotsComputeRequiredLSN":{
		"body":"void ReplicationSlotsComputeRequiredLSN(ReplicationSlotState* repl_slt_state)\r\n{\r\n    int i;\r\n    XLogRecPtr min_required = InvalidXLogRecPtr;\r\n    XLogRecPtr max_required = InvalidXLogRecPtr;\r\n    bool in_use = false;\r\n\r\n    if (g_instance.attr.attr_storage.max_replication_slots == 0) {\r\n        return;\r\n    }\r\n\r\n    Assert(t_thrd.slot_cxt.ReplicationSlotCtl != NULL);\r\n    /* server_mode must be set before computing LSN */\r\n    load_server_mode();\r\n\r\n    LWLockAcquire(ReplicationSlotControlLock, LW_SHARED);\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_replication_slots; i++) {\r\n        ReplicationSlot* s = &t_thrd.slot_cxt.ReplicationSlotCtl->replication_slots[i];\r\n        volatile ReplicationSlot* vslot = s;\r\n        SpinLockAcquire(&s->mutex);\r\n        XLogRecPtr restart_lsn;\r\n\r\n        if (t_thrd.xlog_cxt.server_mode != PRIMARY_MODE && t_thrd.xlog_cxt.server_mode != PENDING_MODE &&\r\n            s->data.database == InvalidOid) {\r\n            goto lock_release;\r\n        }\r\n\r\n        if (!s->in_use) {\r\n            goto lock_release;\r\n        }\r\n\r\n        {\r\n            in_use = true;\r\n            restart_lsn = vslot->data.restart_lsn;\r\n            SpinLockRelease(&s->mutex);\r\n        }\r\n\r\n        if ((!XLByteEQ(restart_lsn, InvalidXLogRecPtr)) &&\r\n            (XLByteEQ(min_required, InvalidXLogRecPtr) || XLByteLT(restart_lsn, min_required))) {\r\n            min_required = restart_lsn;\r\n        }\r\n\r\n        if (XLByteLT(max_required, restart_lsn)) {\r\n            max_required = restart_lsn;\r\n        }\r\n        continue;\r\n    lock_release:\r\n        SpinLockRelease(&s->mutex);\r\n    }\r\n    LWLockRelease(ReplicationSlotControlLock);\r\n\r\n    XLogSetReplicationSlotMinimumLSN(min_required);\r\n    XLogSetReplicationSlotMaximumLSN(max_required);\r\n    if (repl_slt_state != NULL) {\r\n        repl_slt_state->min_required = min_required;\r\n        repl_slt_state->max_required = max_required;\r\n        repl_slt_state->exist_in_use = in_use;\r\n    }\r\n}",
		"comment":"/*\r\n * Compute the oldest restart LSN across all slots and inform xlog module.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"ReplicationSlotsComputeRequiredLSN"
	},
	"ReplicationSlotsComputeRequiredXmin":{
		"body":"void ReplicationSlotsComputeRequiredXmin(bool already_locked)\r\n{\r\n    int i;\r\n    TransactionId agg_xmin = InvalidTransactionId;\r\n    TransactionId agg_catalog_xmin = InvalidTransactionId;\r\n\r\n    Assert(t_thrd.slot_cxt.ReplicationSlotCtl != NULL);\r\n    LWLockAcquire(ReplicationSlotControlLock, LW_SHARED);\r\n\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_replication_slots; i++) {\r\n        ReplicationSlot* s = &t_thrd.slot_cxt.ReplicationSlotCtl->replication_slots[i];\r\n        TransactionId effective_xmin;\r\n        TransactionId effective_catalog_xmin;\r\n\r\n        if (!s->in_use)\r\n            continue;\r\n\r\n        {\r\n            volatile ReplicationSlot* vslot = s;\r\n\r\n            SpinLockAcquire(&s->mutex);\r\n            effective_xmin = vslot->effective_xmin;\r\n            effective_catalog_xmin = vslot->effective_catalog_xmin;\r\n            SpinLockRelease(&s->mutex);\r\n        }\r\n\r\n        /* check the data xmin */\r\n        if (TransactionIdIsValid(effective_xmin) &&\r\n            (!TransactionIdIsValid(agg_xmin) || TransactionIdPrecedes(effective_xmin, agg_xmin)))\r\n            agg_xmin = effective_xmin;\r\n        /* check the catalog xmin */\r\n        if (TransactionIdIsValid(effective_catalog_xmin) &&\r\n            (!TransactionIdIsValid(agg_catalog_xmin) ||\r\n                TransactionIdPrecedes(effective_catalog_xmin, agg_catalog_xmin)))\r\n            agg_catalog_xmin = effective_catalog_xmin;\r\n    }\r\n    LWLockRelease(ReplicationSlotControlLock);\r\n\r\n    ProcArraySetReplicationSlotXmin(agg_xmin, agg_catalog_xmin, already_locked);\r\n}",
		"comment":"/*\r\n * Compute the oldest xmin across all slots and store it in the ProcArray.\r\n *\r\n * If already_locked is true, ProcArrayLock has already been acquired\r\n * exclusively.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"ReplicationSlotsComputeRequiredXmin"
	},
	"ReplicationSlotsCountDBSlots":{
		"body":"bool ReplicationSlotsCountDBSlots(Oid dboid, int* nslots, int* nactive)\r\n{\r\n    int i;\r\n\r\n    *nslots = *nactive = 0;\r\n\r\n    if (g_instance.attr.attr_storage.max_replication_slots <= 0)\r\n        return false;\r\n\r\n    LWLockAcquire(ReplicationSlotControlLock, LW_SHARED);\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_replication_slots; i++) {\r\n        volatile ReplicationSlot* s = NULL;\r\n\r\n        s = &t_thrd.slot_cxt.ReplicationSlotCtl->replication_slots[i];\r\n\r\n        /* cannot change while ReplicationSlotCtlLock is held */\r\n        if (!s->in_use)\r\n            continue;\r\n\r\n        /* not database specific, skip */\r\n        if (s->data.database == InvalidOid)\r\n            continue;\r\n\r\n        /* not our database, skip */\r\n        if (s->data.database != dboid)\r\n            continue;\r\n\r\n        /* count slots with spinlock held */\r\n        SpinLockAcquire(&s->mutex);\r\n        (*nslots)++;\r\n        if (s->active)\r\n            (*nactive)++;\r\n        SpinLockRelease(&s->mutex);\r\n    }\r\n    LWLockRelease(ReplicationSlotControlLock);\r\n\r\n    if (*nslots > 0) {\r\n        return true;\r\n    }\r\n    return false;\r\n}",
		"comment":"/*\r\n * ReplicationSlotsCountDBSlots -- count the number of slots that refer to the\r\n * passed database oid.\r\n *\r\n * Returns true if there are any slots referencing the database. *nslots will\r\n * be set to the absolute number of slots in the database, *nactive to ones\r\n * currently active.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"ReplicationSlotsCountDBSlots"
	},
	"ReplicationSlotsShmemInit":{
		"body":"void ReplicationSlotsShmemInit(void)\r\n{\r\n    bool found = false;\r\n\r\n    if (g_instance.attr.attr_storage.max_replication_slots == 0)\r\n        return;\r\n\r\n    t_thrd.slot_cxt.ReplicationSlotCtl =\r\n        (ReplicationSlotCtlData*)ShmemInitStruct(\"ReplicationSlot Ctl\", ReplicationSlotsShmemSize(), &found);\r\n\r\n    if (!found) {\r\n        int i;\r\n        errno_t rc = 0;\r\n\r\n        /* First time through, so initialize */\r\n        rc = memset_s(t_thrd.slot_cxt.ReplicationSlotCtl, ReplicationSlotsShmemSize(), 0, ReplicationSlotsShmemSize());\r\n        securec_check(rc, \"\\0\", \"\\0\");\r\n\r\n        for (i = 0; i < g_instance.attr.attr_storage.max_replication_slots; i++) {\r\n            ReplicationSlot* slot = &t_thrd.slot_cxt.ReplicationSlotCtl->replication_slots[i];\r\n\r\n            /* everything else is zeroed by the memset above */\r\n            SpinLockInit(&slot->mutex);\r\n            slot->io_in_progress_lock = LWLockAssign(LWTRANCHE_REPLICATION_SLOT);\r\n        }\r\n    }\r\n}",
		"comment":"/*\r\n * Allocate and initialize walsender-related shared memory.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"ReplicationSlotsShmemInit"
	},
	"ReplicationSlotsShmemSize":{
		"body":"Size ReplicationSlotsShmemSize(void)\r\n{\r\n    Size size = 0;\r\n\r\n    if (g_instance.attr.attr_storage.max_replication_slots == 0)\r\n        return size;\r\n\r\n    size = offsetof(ReplicationSlotCtlData, replication_slots);\r\n    size = add_size(size, mul_size((Size)g_instance.attr.attr_storage.max_replication_slots, sizeof(ReplicationSlot)));\r\n\r\n    return size;\r\n}",
		"comment":"/*\r\n * Report shared-memory space needed by ReplicationSlotShmemInit.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"ReplicationSlotsShmemSize"
	},
	"RestoreSlotFromDisk":{
		"body":"static void RestoreSlotFromDisk(const char* name)\r\n{\r\n    ReplicationSlotOnDisk cp;\r\n    int i;\r\n    char path[MAXPGPATH];\r\n    int fd;\r\n    bool restored = false;\r\n    int readBytes;\r\n    pg_crc32c checksum;\r\n    errno_t rc = EOK;\r\n    int ret;\r\n    bool ignore_bak = false;\r\n    bool retry = false;\r\n\r\n    /* no need to lock here, no concurrent access allowed yet\r\n     *\r\n     * delete temp file if it exists \r\n     */\r\n    rc = snprintf_s(path, sizeof(path), MAXPGPATH - 1, \"pg_replslot/%s/state.tmp\", name);\r\n    securec_check_ss(rc, \"\\0\", \"\\0\");\r\n\r\n    ret = unlink(path);\r\n    if (ret < 0 && errno != ENOENT)\r\n        ereport(PANIC, (errcode_for_file_access(), errmsg(\"could not unlink file \\\"%s\\\": %m\", path)));\r\n\r\n    /* unlink backup file if rename failed */\r\n    if (ret == 0) {\r\n        rc = snprintf_s(path, sizeof(path), MAXPGPATH - 1, \"pg_replslot/%s/state.backup\", name);\r\n        securec_check_ss(rc, \"\\0\", \"\\0\");\r\n        if (unlink(path) < 0 && errno != ENOENT)\r\n            ereport(PANIC, (errcode_for_file_access(), errmsg(\"could not unlink file \\\"%s\\\": %m\", path)));\r\n        ignore_bak = true;\r\n    }\r\n\r\n    rc = snprintf_s(path, sizeof(path), MAXPGPATH - 1, \"pg_replslot/%s/state\", name);\r\n    securec_check_ss(rc, \"\\0\", \"\\0\");\r\n\r\n    elog(DEBUG1, \"restoring replication slot from \\\"%s\\\"\", path);\r\n\r\nloop:\r\n    fd = BasicOpenFile(path, O_RDONLY | PG_BINARY, 0);\r\n\r\n    /*\r\n     * We do not need to handle this as we are rename()ing the directory into\r\n     * place only after we fsync()ed the state file.\r\n     */\r\n    if (fd < 0)\r\n        ereport(PANIC, (errcode_for_file_access(), errmsg(\"could not open file \\\"%s\\\": %m\", path)));\r\n\r\n    /*\r\n     * Sync state file before we're reading from it. We might have crashed\r\n     * while it wasn't synced yet and we shouldn't continue on that basis.\r\n     */\r\n    pgstat_report_waitevent(WAIT_EVENT_REPLICATION_SLOT_RESTORE_SYNC);\r\n    if (pg_fsync(fd) != 0) {\r\n        int save_errno = errno;\r\n        if (close(fd)) {\r\n            ereport(PANIC, (errcode_for_file_access(), errmsg(\"could not close file \\\"%s\\\": %m\", path)));\r\n        }\r\n        errno = save_errno;\r\n        ereport(PANIC, (errcode_for_file_access(), errmsg(\"could not fsync file \\\"%s\\\": %m\", path)));\r\n    }\r\n    pgstat_report_waitevent(WAIT_EVENT_END);\r\n\r\n    /* Also sync the parent directory */\r\n    START_CRIT_SECTION();\r\n    fsync_fname(path, true);\r\n    END_CRIT_SECTION();\r\n\r\n    /* read part of statefile that's guaranteed to be version independent */\r\n    pgstat_report_waitevent(WAIT_EVENT_REPLICATION_SLOT_READ);\r\n\r\n    errno = 0;\r\n    /* read the whole state file */\r\n    readBytes = read(fd, &cp, (uint32)sizeof(ReplicationSlotOnDisk));\r\n    pgstat_report_waitevent(WAIT_EVENT_END);\r\n    if (readBytes != sizeof(ReplicationSlotOnDisk)) {\r\n        int saved_errno = errno;\r\n        if (close(fd)) {\r\n            ereport(PANIC, (errcode_for_file_access(), errmsg(\"could not close file \\\"%s\\\": %m\", path)));\r\n        }\r\n        errno = saved_errno;\r\n        ereport(PANIC,\r\n            (errcode_for_file_access(),\r\n                errmsg(\"could not read file \\\"%s\\\", read %d of %u: %m\",\r\n                    path,\r\n                    readBytes,\r\n                    (uint32)sizeof(ReplicationSlotOnDisk))));\r\n    }\r\n    if (close(fd)) {\r\n        ereport(PANIC, (errcode_for_file_access(), errmsg(\"could not close file \\\"%s\\\": %m\", path)));\r\n    }\r\n\r\n    /* now verify the CRC */\r\n    INIT_CRC32C(checksum);\r\n    COMP_CRC32C(checksum, (char*)&cp + ReplicationSlotOnDiskConstantSize, ReplicationSlotOnDiskDynamicSize);\r\n    FIN_CRC32C(checksum);\r\n    if (!EQ_CRC32C(checksum, cp.checksum)) {\r\n        if (ignore_bak == false) {\r\n            ereport(WARNING,\r\n                (errmsg(\"replication slot file %s: checksum mismatch, is %u, should be %u, try backup file\",\r\n                    path,\r\n                    checksum,\r\n                    cp.checksum)));\r\n            rc = snprintf_s(path, sizeof(path), MAXPGPATH - 1, \"pg_replslot/%s/state.backup\", name);\r\n            securec_check_ss(rc, \"\\0\", \"\\0\");\r\n            ignore_bak = true;\r\n            retry = true;\r\n            goto loop;\r\n        } else {\r\n            ereport(PANIC,\r\n                (errmsg(\r\n                    \"replication slot file %s: checksum mismatch, is %u, should be %u\", path, checksum, cp.checksum)));\r\n        }\r\n    }\r\n    /* verify magic */\r\n    if (cp.magic != SLOT_MAGIC) {\r\n        if (ignore_bak == false) {\r\n            ereport(WARNING,\r\n                (errcode_for_file_access(),\r\n                    errmsg(\"replication slot file \\\"%s\\\" has wrong magic %u instead of %d, try backup file\",\r\n                        path,\r\n                        cp.magic,\r\n                        SLOT_MAGIC)));\r\n            rc = snprintf_s(path, sizeof(path), MAXPGPATH - 1, \"pg_replslot/%s/state.backup\", name);\r\n            securec_check_ss(rc, \"\\0\", \"\\0\");\r\n            ignore_bak = true;\r\n            retry = true;\r\n            goto loop;\r\n        } else {\r\n            ereport(PANIC,\r\n                (errcode_for_file_access(),\r\n                    errmsg(\r\n                        \"replication slot file \\\"%s\\\" has wrong magic %u instead of %d\", path, cp.magic, SLOT_MAGIC)));\r\n        }\r\n    }\r\n    /* boundary check on length */\r\n    if (cp.length != ReplicationSlotOnDiskDynamicSize) {\r\n        if (ignore_bak == false) {\r\n            ereport(WARNING,\r\n                (errcode_for_file_access(),\r\n                    errmsg(\"replication slot file \\\"%s\\\" has corrupted length %u, try backup file\", path, cp.length)));\r\n            rc = snprintf_s(path, sizeof(path), MAXPGPATH - 1, \"pg_replslot/%s/state.backup\", name);\r\n            securec_check_ss(rc, \"\\0\", \"\\0\");\r\n            ignore_bak = true;\r\n            retry = true;\r\n            goto loop;\r\n        } else {\r\n            ereport(PANIC,\r\n                (errcode_for_file_access(),\r\n                    errmsg(\"replication slot file \\\"%s\\\" has corrupted length %u\", path, cp.length)));\r\n        }\r\n    }\r\n\r\n    /*\r\n     * If we crashed with an ephemeral slot active, don't restore but delete it.\r\n     */\r\n    if (cp.slotdata.persistency != RS_PERSISTENT) {\r\n        rc = snprintf_s(path, MAXPGPATH, MAXPGPATH - 1, \"pg_replslot/%s\", name);\r\n        securec_check_ss(rc, \"\\0\", \"\\0\");\r\n        if (!rmtree(path, true)) {\r\n            ereport(WARNING, (errcode_for_file_access(), errmsg(\"could not remove directory \\\"%s\\\"\", path)));\r\n        }\r\n        fsync_fname(\"pg_replslot\", true);\r\n        return;\r\n    }\r\n\r\n    if (retry == true)\r\n        RecoverReplSlotFile(cp, name);\r\n\r\n    /* nothing can be active yet, don't lock anything */\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_replication_slots; i++) {\r\n        ReplicationSlot* slot = NULL;\r\n\r\n        slot = &t_thrd.slot_cxt.ReplicationSlotCtl->replication_slots[i];\r\n\r\n        if (slot->in_use)\r\n            continue;\r\n\r\n        /* restore the entire set of persistent data */\r\n        rc = memcpy_s(\r\n            &slot->data, sizeof(ReplicationSlotPersistentData), &cp.slotdata, sizeof(ReplicationSlotPersistentData));\r\n        securec_check(rc, \"\\0\", \"\\0\");\r\n\r\n        /* initialize in memory state */\r\n        slot->effective_xmin = slot->data.xmin;\r\n        slot->effective_catalog_xmin = slot->data.catalog_xmin;\r\n\r\n        slot->candidate_catalog_xmin = InvalidTransactionId;\r\n        slot->candidate_xmin_lsn = InvalidXLogRecPtr;\r\n        slot->candidate_restart_lsn = InvalidXLogRecPtr;\r\n        slot->candidate_restart_valid = InvalidXLogRecPtr;\r\n        slot->in_use = true;\r\n        slot->active = false;\r\n\r\n        restored = true;\r\n        break;\r\n    }\r\n\r\n    if (!restored)\r\n        ereport(PANIC,\r\n            (errmsg(\"too many replication slots active before shutdown\"),\r\n                errhint(\"Increase g_instance.attr.attr_storage.max_replication_slots and try again.\")));\r\n}",
		"comment":"/*\r\n * Load a single slot from disk into memory.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"RestoreSlotFromDisk"
	},
	"SaveSlotToPath":{
		"body":"static void SaveSlotToPath(ReplicationSlot* slot, const char* dir, int elevel)\r\n{\r\n    char tmppath[MAXPGPATH];\r\n    char path[MAXPGPATH];\r\n    const int STATE_FILE_NUM = 2;\r\n    char* fname[STATE_FILE_NUM];\r\n    int fd;\r\n    ReplicationSlotOnDisk cp;\r\n    bool was_dirty = false;\r\n    errno_t rc = EOK;\r\n\r\n    /* first check whether there's something to write out */\r\n    {\r\n        volatile ReplicationSlot* vslot = slot;\r\n\r\n        SpinLockAcquire(&vslot->mutex);\r\n        was_dirty = vslot->dirty;\r\n        vslot->just_dirtied = false;\r\n        SpinLockRelease(&vslot->mutex);\r\n    }\r\n\r\n    /* and don't do anything if there's nothing to write */\r\n    if (!was_dirty) {\r\n        return;\r\n    }\r\n\r\n    LWLockAcquire(slot->io_in_progress_lock, LW_EXCLUSIVE);\r\n\r\n    /* silence valgrind :( */\r\n    rc = memset_s(&cp, sizeof(ReplicationSlotOnDisk), 0, sizeof(ReplicationSlotOnDisk));\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n\r\n    fname[0] = \"%s/state.backup\";\r\n    fname[1] = \"%s/state.tmp\";\r\n\r\n    rc = snprintf_s(path, MAXPGPATH, MAXPGPATH - 1, \"%s/state\", dir);\r\n    securec_check_ss(rc, \"\\0\", \"\\0\");\r\n\r\n    for (int i = 0; i < STATE_FILE_NUM; i++) {\r\n        rc = snprintf_s(tmppath, MAXPGPATH, MAXPGPATH - 1, fname[i], dir);\r\n        securec_check_ss(rc, \"\\0\", \"\\0\");\r\n\r\n        fd = BasicOpenFile(tmppath, O_CREAT | O_WRONLY | PG_BINARY, S_IRUSR | S_IWUSR);\r\n        if (fd < 0) {\r\n            LWLockRelease(slot->io_in_progress_lock);\r\n            ereport(elevel, (errcode_for_file_access(), errmsg(\"could not create file \\\"%s\\\": %m\", tmppath)));\r\n            return;\r\n        }\r\n\r\n        cp.magic = SLOT_MAGIC;\r\n        INIT_CRC32C(cp.checksum);\r\n        cp.version = 1;\r\n        cp.length = ReplicationSlotOnDiskDynamicSize;\r\n\r\n        SpinLockAcquire(&slot->mutex);\r\n\r\n        rc = memcpy_s(\r\n            &cp.slotdata, sizeof(ReplicationSlotPersistentData), &slot->data, sizeof(ReplicationSlotPersistentData));\r\n        securec_check(rc, \"\\0\", \"\\0\");\r\n\r\n        SpinLockRelease(&slot->mutex);\r\n\r\n        COMP_CRC32C(cp.checksum, (char*)(&cp) + ReplicationSlotOnDiskConstantSize, ReplicationSlotOnDiskDynamicSize);\r\n        FIN_CRC32C(cp.checksum);\r\n\r\n        /* Causing errno to potentially come from a previous system call. */\r\n        errno = 0;\r\n        pgstat_report_waitevent(WAIT_EVENT_REPLICATION_SLOT_WRITE);\r\n        if ((write(fd, &cp, (uint32)sizeof(cp))) != sizeof(cp)) {\r\n            int save_errno = errno;\r\n            pgstat_report_waitevent(WAIT_EVENT_END);\r\n            if (close(fd)) {\r\n                ereport(elevel, (errcode_for_file_access(), errmsg(\"could not close file \\\"%s\\\": %m\", tmppath)));\r\n            }\r\n            /* if write didn't set errno, assume problem is no disk space */\r\n            errno = save_errno ? save_errno : ENOSPC;\r\n            LWLockRelease(slot->io_in_progress_lock);\r\n            ereport(elevel, (errcode_for_file_access(), errmsg(\"could not write to file \\\"%s\\\": %m\", tmppath)));\r\n            return;\r\n        }\r\n        pgstat_report_waitevent(WAIT_EVENT_END);\r\n\r\n        /* fsync the temporary file */\r\n        pgstat_report_waitevent(WAIT_EVENT_REPLICATION_SLOT_SYNC);\r\n        if (pg_fsync(fd) != 0) {\r\n            int save_errno = errno;\r\n            pgstat_report_waitevent(WAIT_EVENT_END);\r\n            if (close(fd)) {\r\n                ereport(elevel, (errcode_for_file_access(), errmsg(\"could not close file \\\"%s\\\": %m\", tmppath)));\r\n            }\r\n            errno = save_errno;\r\n            LWLockRelease(slot->io_in_progress_lock);\r\n            ereport(elevel, (errcode_for_file_access(), errmsg(\"could not fsync file \\\"%s\\\": %m\", tmppath)));\r\n            return;\r\n        }\r\n        pgstat_report_waitevent(WAIT_EVENT_END);\r\n        if (close(fd)) {\r\n            ereport(elevel, (errcode_for_file_access(), errmsg(\"could not close file \\\"%s\\\": %m\", tmppath)));\r\n        }\r\n    }\r\n\r\n    /* rename to permanent file, fsync file and directory */\r\n    if (rename(tmppath, path) != 0) {\r\n        LWLockRelease(slot->io_in_progress_lock);\r\n        ereport(elevel, (errcode_for_file_access(), errmsg(\"could not rename \\\"%s\\\" to \\\"%s\\\": %m\", tmppath, path)));\r\n        return;\r\n    }\r\n\r\n    /* Check CreateSlot() for the reasoning of using a crit. section. */\r\n    START_CRIT_SECTION();\r\n\r\n    fsync_fname(path, false);\r\n    fsync_fname(dir, true);\r\n    fsync_fname(\"pg_replslot\", true);\r\n\r\n    END_CRIT_SECTION();\r\n\r\n    /*\r\n     * Successfully wrote, unset dirty bit, unless somebody dirtied again\r\n     * already.\r\n     */\r\n    {\r\n        volatile ReplicationSlot* vslot = slot;\r\n\r\n        SpinLockAcquire(&vslot->mutex);\r\n        if (!vslot->just_dirtied)\r\n            vslot->dirty = false;\r\n        SpinLockRelease(&vslot->mutex);\r\n    }\r\n\r\n    LWLockRelease(slot->io_in_progress_lock);\r\n}",
		"comment":"/*\r\n * Shared functionality between saving and creating a replication slot.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"SaveSlotToPath"
	},
	"SetDummyStandbySlotLsnInvalid":{
		"body":"void SetDummyStandbySlotLsnInvalid(void)\r\n{\r\n    Assert(t_thrd.slot_cxt.MyReplicationSlot != NULL);\r\n\r\n    volatile ReplicationSlot* vslot = t_thrd.slot_cxt.MyReplicationSlot;\r\n\r\n    Assert(vslot->data.isDummyStandby);\r\n\r\n    if (!XLByteEQ(vslot->data.restart_lsn, InvalidXLogRecPtr)) {\r\n        SpinLockAcquire(&vslot->mutex);\r\n        vslot->data.restart_lsn = 0;\r\n        SpinLockRelease(&vslot->mutex);\r\n\r\n        ReplicationSlotMarkDirty();\r\n        ReplicationSlotsComputeRequiredLSN(NULL);\r\n    }\r\n}",
		"comment":"/*\r\n * Set dummy standby replication slot's lsn invalid\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"SetDummyStandbySlotLsnInvalid"
	},
	"StartupReplicationSlots":{
		"body":"void StartupReplicationSlots()\r\n{\r\n    DIR* replication_dir = NULL;\r\n    struct dirent* replication_de = NULL;\r\n    int nRet = 0;\r\n\r\n    ereport(DEBUG1, (errmsg(\"starting up replication slots\")));\r\n\r\n    /* restore all slots by iterating over all on-disk entries */\r\n    replication_dir = AllocateDir(\"pg_replslot\");\r\n    if (replication_dir == NULL) {\r\n        char tmppath[MAXPGPATH];\r\n\r\n        nRet = snprintf_s(tmppath, sizeof(tmppath), MAXPGPATH - 1, \"%s\", \"pg_replslot\");\r\n        securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n\r\n        if (mkdir(tmppath, S_IRWXU) < 0)\r\n            ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not create directory \\\"%s\\\": %m\", tmppath)));\r\n        fsync_fname(tmppath, true);\r\n        return;\r\n    }\r\n    while ((replication_de = ReadDir(replication_dir, \"pg_replslot\")) != NULL) {\r\n        struct stat statbuf;\r\n        char path[MAXPGPATH];\r\n\r\n        if (strcmp(replication_de->d_name, \".\") == 0 || strcmp(replication_de->d_name, \"..\") == 0)\r\n            continue;\r\n\r\n        nRet = snprintf_s(path, sizeof(path), MAXPGPATH - 1, \"pg_replslot/%s\", replication_de->d_name);\r\n        securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n\r\n        /* we're only creating directories here, skip if it's not our's */\r\n        if (lstat(path, &statbuf) == 0 && !S_ISDIR(statbuf.st_mode))\r\n            continue;\r\n\r\n        /* we crashed while a slot was being setup or deleted, clean up */\r\n        if (string_endswith(replication_de->d_name, \".tmp\")) {\r\n            if (!rmtree(path, true)) {\r\n                ereport(WARNING, (errcode_for_file_access(), errmsg(\"could not remove directory \\\"%s\\\"\", path)));\r\n                continue;\r\n            }\r\n            fsync_fname(\"pg_replslot\", true);\r\n            continue;\r\n        }\r\n\r\n        /* looks like a slot in a normal state, restore */\r\n        RestoreSlotFromDisk(replication_de->d_name);\r\n    }\r\n    FreeDir(replication_dir);\r\n\r\n    /* currently no slots exist, we're done. */\r\n    if (g_instance.attr.attr_storage.max_replication_slots <= 0) {\r\n        return;\r\n    }\r\n\r\n    /* Now that we have recovered all the data, compute replication xmin */\r\n    ReplicationSlotsComputeRequiredXmin(false);\r\n    ReplicationSlotsComputeRequiredLSN(NULL);\r\n}",
		"comment":"/*\r\n * Load all replication slots from disk into memory at server startup. This\r\n * needs to be run before we start crash recovery.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"StartupReplicationSlots"
	},
	"ValidateName":{
		"body":"bool ValidateName(const char* name)\r\n{\r\n    if (name == NULL) {\r\n        ereport(ERROR, (errcode(ERRCODE_INVALID_NAME), errmsg(\"replication slot name should not be NULL.\")));\r\n    }\r\n\r\n    if (strlen(name) == 0) {\r\n        ereport(ERROR, (errcode(ERRCODE_INVALID_NAME), errmsg(\"replication slot name \\\"%s\\\" is too short\", name)));\r\n        return false;\r\n    }\r\n\r\n    if (strlen(name) >= NAMEDATALEN - 1) {\r\n        ereport(ERROR, (errcode(ERRCODE_NAME_TOO_LONG), errmsg(\"replication slot name \\\"%s\\\" is too long\", name)));\r\n    }\r\n    const char* danger_character_list[] = {\";\", \"`\", \"\\\\\", \"'\", \"\\\"\", \">\", \"<\", \"&\", \"|\", \"!\", \"\\n\", NULL};\r\n    int i = 0;\r\n\r\n    for (i = 0; danger_character_list[i] != NULL; i++) {\r\n        if (strstr(name, danger_character_list[i]) != NULL) {\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_INVALID_NAME),\r\n                    errmsg(\"replication slot name \\\"%s\\\" contains invalid character\", name),\r\n                    errhint(\"Replication slot names may only contain letters, numbers and the underscore character.\")));\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}",
		"comment":"/*\r\n * Check whether the passed slot name is valid and report errors at elevel.\r\n *\r\n * Slot names may consist out of [a-z0-9_]{1,NAMEDATALEN-1} which should allow\r\n * the name to be used as a directory name on every supported OS.\r\n *\r\n * Returns whether the directory name is valid or not if elevel < ERROR.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"ValidateName"
	},
	"get_application_name":{
		"body":"static char* get_application_name(void)\r\n{\r\n#define INVALID_LINES_IDX (int)(~0)\r\n    char** optlines = NULL;\r\n    int lines_index = 0;\r\n    int optvalue_off;\r\n    int optvalue_len;\r\n    char arg_str[NAMEDATALEN] = {0};\r\n    const char* config_para_build = \"application_name\";\r\n    int rc;\r\n    char conf_path[MAXPGPATH] = {0};\r\n    char* trim_app_name = NULL;\r\n    char* app_name = NULL;\r\n    app_name = (char*)palloc0(MAXPGPATH);\r\n    rc = snprintf_s(conf_path, MAXPGPATH, MAXPGPATH - 1, \"%s/%s\", t_thrd.proc_cxt.DataDir, \"postgresql.conf\");\r\n    securec_check_ss_c(rc, \"\\0\", \"\\0\");\r\n\r\n    if ((optlines = (char**)read_guc_file(conf_path)) != NULL) {\r\n        lines_index = find_guc_option(optlines, config_para_build, NULL, NULL, &optvalue_off, &optvalue_len);\r\n        if (lines_index != INVALID_LINES_IDX) {\r\n            rc = strncpy_s(arg_str, NAMEDATALEN, optlines[lines_index] + optvalue_off, optvalue_len);\r\n            securec_check_c(rc, \"\\0\", \"\\0\");\r\n        }\r\n        /* first free one-dimensional array memory in case memory leak */\r\n        int i = 0;\r\n        while (optlines[i] != NULL) {\r\n            selfpfree(const_cast<char* >(optlines[i]));\r\n            optlines[i] = NULL;\r\n            i++;\r\n        }\r\n        selfpfree(optlines);\r\n        optlines = NULL;\r\n    } else {\r\n        return app_name;\r\n    }\r\n    /* construct slotname */\r\n    trim_app_name = trim_str(arg_str, NAMEDATALEN, '\\'');\r\n    if (trim_app_name != NULL) {\r\n        rc = snprintf_s(app_name, NAMEDATALEN, NAMEDATALEN - 1, \"%s\", trim_app_name);\r\n        securec_check_ss_c(rc, \"\\0\", \"\\0\");\r\n        pfree(trim_app_name);\r\n        trim_app_name = NULL;\r\n    }\r\n    return app_name;\r\n}",
		"comment":"/*\r\n * get the  application_name specified in postgresql.conf\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"get_application_name"
	},
	"get_my_slot_name":{
		"body":"char* get_my_slot_name(void)\r\n{\r\n    ReplConnInfo* conninfo = NULL;\r\n    errno_t retcode = EOK;\r\n\r\n    /* local and local port is the same, so we choose the first one is ok */\r\n    int repl_idx = 0;\r\n    char* slotname = NULL;\r\n    char* t_appilcation_name = NULL;\r\n    slotname = (char*)palloc0(NAMEDATALEN);\r\n    t_appilcation_name = get_application_name();\r\n    /* get current repl conninfo, */\r\n    conninfo = GetRepConnArray(&repl_idx);\r\n    if (u_sess->attr.attr_storage.PrimarySlotName != NULL) {\r\n        retcode = strncpy_s(slotname, NAMEDATALEN, u_sess->attr.attr_storage.PrimarySlotName, NAMEDATALEN - 1);\r\n        securec_check(retcode, \"\\0\", \"\\0\");\r\n    } else if (t_appilcation_name && strlen(t_appilcation_name) > 0) {\r\n        int rc = 0;\r\n        rc = snprintf_s(slotname, NAMEDATALEN, NAMEDATALEN - 1, \"%s\", t_appilcation_name);\r\n        securec_check_ss(rc, \"\\0\", \"\\0\");\r\n    } else if (g_instance.attr.attr_common.PGXCNodeName != NULL) {\r\n        int rc = 0;\r\n        if (IS_DN_DUMMY_STANDYS_MODE()) {\r\n            rc = snprintf_s(slotname, NAMEDATALEN, NAMEDATALEN - 1, \"%s\", g_instance.attr.attr_common.PGXCNodeName);\r\n        } else if (conninfo != NULL) {\r\n            rc = snprintf_s(slotname,\r\n                NAMEDATALEN,\r\n                NAMEDATALEN - 1,\r\n                \"%s_%s_%d\",\r\n                g_instance.attr.attr_common.PGXCNodeName,\r\n                conninfo->localhost,\r\n                conninfo->localport);\r\n        }\r\n        securec_check_ss(rc, \"\\0\", \"\\0\");\r\n    }\r\n    pfree(t_appilcation_name);\r\n    t_appilcation_name = NULL;\r\n    return slotname;\r\n}",
		"comment":"/*\r\n * get cur nodes slotname\r\n *\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"get_my_slot_name"
	},
	"string_endswith":{
		"body":"static bool string_endswith(const char* str, const char* end)\r\n{\r\n    size_t slen = strlen(str);\r\n    size_t elen = strlen(end);\r\n    /* can't be a postfix if longer */\r\n    if (elen > slen)\r\n        return false;\r\n\r\n    /* compare the end of the strings */\r\n    str += slen - elen;\r\n    return strcmp(str, end) == 0;\r\n}",
		"comment":"/*\r\n * Returns whether the string `str' has the postfix `end'.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"string_endswith"
	},
	"trim_str":{
		"body":"static char* trim_str(char* str, int str_len, char sep)\r\n{\r\n    int len;\r\n    char* begin = NULL;\r\n    char* end = NULL;\r\n    char* cur = NULL;\r\n    char* cpyStr = NULL;\r\n    errno_t rc;\r\n\r\n    if (str == NULL || str_len <= 0) {\r\n        return NULL;\r\n    }\r\n    cpyStr = (char*)palloc(str_len);\r\n    begin = str;\r\n    while (begin != NULL && (isspace((int)*begin) || *begin == sep)) {\r\n        begin++;\r\n    }\r\n    for (end = cur = begin; *cur != '\\0'; cur++) {\r\n        if (!isspace((int)*cur) && *cur != sep) {\r\n            end = cur;\r\n        }\r\n    }\r\n    if (*begin == '\\0') {\r\n        pfree(cpyStr);\r\n        cpyStr = NULL;\r\n        return NULL;\r\n    }\r\n    len = end - begin + 1;\r\n    rc = memmove_s(cpyStr, (uint32)str_len, begin, len);\r\n    securec_check_c(rc, \"\\0\", \"\\0\");\r\n    cpyStr[len] = '\\0';\r\n    return cpyStr;\r\n}",
		"comment":"/*\r\n * Get the string beside space or sep\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slot.cpp",
		"name":"trim_str"
	}
}