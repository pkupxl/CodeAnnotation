{
	"CanWriteBuffer":{
		"body":"static bool CanWriteBuffer(SMgrRelation smgr, ForkNumber forkNum, const char* path)\r\n{\r\n    if (CheckFileExists(path) == FILE_EXIST) {\r\n        return true;\r\n    } else {\r\n        /*\r\n         * In the case that the physical file is unlink and the fd of file is still held by other thread, the datawriter\r\n         * thead can not write data to shared buffer. Thus, it may dirty the shared buffer and the pendingOpsTable hash\r\n         * table, and it may cause coredump when doing checkpoint due to unlinked file.\r\n         */\r\n        if ((smgr->md_fd[forkNum] == NULL) && (FdRefcntIsZero(smgr, forkNum))) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}",
		"comment":"/* check whether the data writer thread can write data through shared buffer. */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datarcvwriter.cpp",
		"name":"CanWriteBuffer"
	},
	"CheckDatabaseReady":{
		"body":"static DataBaseDirState CheckDatabaseReady(Oid spcNode, Oid dbNode)\r\n{\r\n    char* dbpath = NULL;\r\n    struct stat st;\r\n    int nRet = 0;\r\n    DataBaseDirState dbDirState = NONEEXISTDATABASEDIR;\r\n\r\n    dbpath = GetDatabasePath(dbNode, spcNode);\r\n    pg_memory_barrier();\r\n\r\n    Assert(OidIsValid(spcNode));\r\nretry:\r\n    if (stat(dbpath, &st) < 0) {\r\n        pg_memory_barrier();\r\n        /* xlog already redo where we dropped the database, so we skip this record */\r\n        if (t_thrd.xlog_cxt.RedoDone) {\r\n            dbDirState = NONEEXISTDATABASEDIR;\r\n            ereport(LOG, (errmsg(\"skip the dropped database directory\")));\r\n            return dbDirState;\r\n        }\r\n        /* Directory does not exist? */\r\n        if (errno == ENOENT) {\r\n#if defined(HAVE_READLINK) || defined(WIN32)\r\n            char tbpath[64] = {0};\r\n            char linkpath[MAXPGPATH] = {0};\r\n            int rllen = 0;\r\n\r\n            /* wait if it's under global and base */\r\n            if (spcNode == GLOBALTABLESPACE_OID || spcNode == DEFAULTTABLESPACE_OID)\r\n                goto invalid_handle;\r\n\r\n            nRet = snprintf_s(tbpath, sizeof(tbpath), 63, \"pg_tblspc/%u\", spcNode);\r\n            securec_check_ss(nRet, \"\", \"\");\r\n\r\n            rllen = readlink(tbpath, linkpath, sizeof(linkpath));\r\n            if (rllen < 0) {\r\n                if (errno == EINVAL || errno == ENOTDIR) {\r\n                    pfree(dbpath);\r\n                    dbpath = NULL;\r\n                    ereport(PANIC, (errmsg(\"could not read symbolic link \\\"%s\\\": %m\", tbpath)));\r\n                } else if (errno == ENOENT) {\r\n                    ereport(DEBUG3, (errmsg(\"sleep a while waiting for tablespace \\\"%s\\\" ready\", tbpath)));\r\n                    goto invalid_handle;\r\n                } else {\r\n                    pfree(dbpath);\r\n                    dbpath = NULL;\r\n                    ereport(ERROR, (errcode_for_file_access(), errmsg(\"invalid tablespace link %s: %m\", tbpath)));\r\n                }\r\n            } else if (rllen >= (int)sizeof(linkpath)) {\r\n                pfree(dbpath);\r\n                dbpath = NULL;\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_WRONG_OBJECT_TYPE), errmsg(\"symbolic link \\\"%s\\\" target is too long\", tbpath)));\r\n            } else {\r\n                linkpath[rllen] = '\\0';\r\n                if (stat(linkpath, &st) < 0 || !S_ISDIR(st.st_mode))\r\n                    ereport(PANIC,\r\n                        (errcode(ERRCODE_WRONG_OBJECT_TYPE), errmsg(\"invalid tablespace directory %s: %m\", tbpath)));\r\n                goto invalid_handle;\r\n            }\r\n#else\r\n            /*\r\n             * If the platform does not have symbolic links, it should not be\r\n             * possible to have tablespaces - clearly somebody else created\r\n             * them. Warn about it and ignore.\r\n             */\r\n            pfree(dbpath);\r\n            dbpath = NULL;\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"tablespaces are not supported on this platform\")));\r\n#endif\r\n        } else {\r\n            pfree(dbpath);\r\n            dbpath = NULL;\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_WRONG_OBJECT_TYPE),\r\n                    errmsg(\"\\\"database %u/%u\\\" invalid directory : %m\", spcNode, dbNode)));\r\n        }\r\n    } else {\r\n        pfree(dbpath);\r\n        dbpath = NULL;\r\n        /* Is it not a directory? */\r\n        if (!S_ISDIR(st.st_mode))\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_WRONG_OBJECT_TYPE),\r\n                    errmsg(\"\\\"database %u/%u\\\" exists but is not a directory\", spcNode, dbNode)));\r\n        dbDirState = EXISTDATABASEDIR;\r\n        return dbDirState;\r\n    }\r\n\r\ninvalid_handle:\r\n    if ((t_thrd.int_cxt.ProcDiePending || t_thrd.proc_cxt.proc_exit_inprogress) &&\r\n        !t_thrd.datarcvwriter_cxt.AmDataReceiverForDummyStandby) {\r\n        ereport(WARNING,\r\n            (errcode(ERRCODE_ADMIN_SHUTDOWN),\r\n                errmsg(\"canceling the wait for database directory \\\"%s\\\" \"\r\n                       \"being created in recovery\",\r\n                    dbpath)));\r\n        pfree(dbpath);\r\n        dbpath = NULL;\r\n        dbDirState = DATABASEDIRCREATECANCEL;\r\n        return dbDirState;\r\n    }\r\n    ereport(LOG, (errmsg(\"waiting for database directory \\\"%s\\\" being created in recovery\", dbpath)));\r\n    pg_usleep(5000000L);\r\n    goto retry;\r\n}",
		"comment":"/*\r\n * We only handle path in pg_tblspc/. Wait until the tablepsace been redo\r\n * If the spcNode we got from the tablespace path does not exist. If the spcNode\r\n * is not a link, throw a error here.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datarcvwriter.cpp",
		"name":"CheckDatabaseReady"
	},
	"CloseDataFile":{
		"body":"extern void CloseDataFile(void)\r\n{\r\n    close(dummy_data_writer_file_fd);\r\n    dummy_data_writer_file_fd = -1;\r\n    dummy_data_writer_file_offset = 0;\r\n}",
		"comment":"/*\r\n * close data fd for rm data file\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datarcvwriter.cpp",
		"name":"CloseDataFile"
	},
	"DataRcvWrite":{
		"body":"int DataRcvWrite(void)\r\n{\r\n    /* Use volatile pointer to prevent code rearrangement */\r\n    volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n    char* writeBuf = NULL;\r\n    uint32 nbytes = 0;\r\n    uint32 remainbytes = 0;\r\n    DataQueuePtr curstartpos;\r\n    DataQueuePtr curendpos;\r\n\r\n    /* avoid concurrent WalDataRcvWrite by WalRcvWriteLock */\r\n    START_CRIT_SECTION();\r\n    LWLockAcquire(RcvWriteLock, LW_EXCLUSIVE);\r\n\r\n    SpinLockAcquire(&datarcv->mutex);\r\n    curstartpos.queueid = datarcv->localWritePosition.queueid;\r\n    curstartpos.queueoff = datarcv->localWritePosition.queueoff;\r\n    SpinLockRelease(&datarcv->mutex);\r\n\r\n    nbytes = GetFromDataQueue(writeBuf,\r\n        g_instance.attr.attr_storage.DataQueueBufSize * 1024,\r\n        curstartpos,\r\n        curendpos,\r\n        true,\r\n        t_thrd.dataqueue_cxt.DataWriterQueue);\r\n    if (nbytes == 0) {\r\n        LWLockRelease(RcvWriteLock);\r\n        END_CRIT_SECTION();\r\n        return 0;\r\n    }\r\n\r\n    /* Write data. */\r\n    if (dummyStandbyMode)\r\n        DummyStandbyDoDataWrite(writeBuf, nbytes);\r\n    else\r\n        remainbytes = DoDataWrite(writeBuf, nbytes);\r\n\r\n    /* Close all open files */\r\n    smgrcloseall();\r\n\r\n    /* Update share memory from the the next operation. */\r\n    nbytes -= remainbytes;\r\n    SpinLockAcquire(&datarcv->mutex);\r\n    datarcv->localWritePosition.queueid = curstartpos.queueid;\r\n    datarcv->localWritePosition.queueoff = curstartpos.queueoff;\r\n    DQByteAdvance(datarcv->localWritePosition, nbytes);\r\n    SpinLockRelease(&datarcv->mutex);\r\n\r\n    PopFromDataQueue(((DataRcvData*)datarcv)->localWritePosition, t_thrd.dataqueue_cxt.DataWriterQueue);\r\n\r\n    LWLockRelease(RcvWriteLock);\r\n    END_CRIT_SECTION();\r\n\r\n    return nbytes;\r\n}",
		"comment":"/*\r\n * Write data to disk.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datarcvwriter.cpp",
		"name":"DataRcvWrite"
	},
	"DataRcvWriterInProgress":{
		"body":"bool DataRcvWriterInProgress(void)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n\r\n    SpinLockAcquire(&datarcv->mutex);\r\n    if (datarcv->writerPid == 0) {\r\n        SpinLockRelease(&datarcv->mutex);\r\n        return false;\r\n    }\r\n    SpinLockRelease(&datarcv->mutex);\r\n    return true;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datarcvwriter.cpp",
		"name":"DataRcvWriterInProgress"
	},
	"DataRcvWriterMain":{
		"body":"void DataRcvWriterMain(void)\r\n{\r\n    sigjmp_buf localSigjmpBuf;\r\n    MemoryContext datarcvWriterContext;\r\n    t_thrd.xlog_cxt.InRecovery = true;\r\n\r\n    ereport(LOG, (errmsg(\"datarcvwriter thread started\")));\r\n    /*\r\n     * Reset some signals that are accepted by postmaster but not here\r\n     */\r\n    (void)gspqsignal(SIGHUP, DataRcvWriterSigHupHandler);\r\n    (void)gspqsignal(SIGINT, SIG_IGN);\r\n    (void)gspqsignal(SIGTERM, ReqShutdownHandler);\r\n    (void)gspqsignal(SIGQUIT, DataRcvWriterQuickDie); /* hard crash time */\r\n    (void)gspqsignal(SIGALRM, SIG_IGN);\r\n    (void)gspqsignal(SIGPIPE, SIG_IGN);\r\n    (void)gspqsignal(SIGUSR1, SIG_IGN);\r\n    (void)gspqsignal(SIGUSR2, SIG_IGN);\r\n\r\n    /*\r\n     * Reset some signals that are accepted by postmaster but not here\r\n     */\r\n    (void)gspqsignal(SIGCHLD, SIG_DFL);\r\n    (void)gspqsignal(SIGTTIN, SIG_DFL);\r\n    (void)gspqsignal(SIGTTOU, SIG_DFL);\r\n    (void)gspqsignal(SIGCONT, SIG_DFL);\r\n    (void)gspqsignal(SIGWINCH, SIG_DFL);\r\n\r\n    /* We allow SIGQUIT (quickdie) at all times */\r\n    (void)sigdelset(&t_thrd.libpq_cxt.BlockSig, SIGQUIT);\r\n\r\n    on_shmem_exit(ShutdownDataRcvWriter, 0);\r\n\r\n    /*\r\n     * Create a resource owner to keep track of our resources (currently only\r\n     * buffer pins).\r\n     */\r\n    t_thrd.utils_cxt.CurrentResourceOwner = ResourceOwnerCreate(NULL, \"DataReceive Writer\");\r\n\r\n    /*\r\n     * Create a memory context that we will do all our work in.  We do this so\r\n     * that we can reset the context during error recovery and thereby avoid\r\n     * possible memory leaks.  Formerly this code just ran in\r\n     * t_thrd.top_mem_cxt, but resetting that would be a really bad idea.\r\n     */\r\n    datarcvWriterContext = AllocSetContextCreate(t_thrd.top_mem_cxt,\r\n        \"DataReceive Writer\",\r\n        ALLOCSET_DEFAULT_MINSIZE,\r\n        ALLOCSET_DEFAULT_INITSIZE,\r\n        ALLOCSET_DEFAULT_MAXSIZE);\r\n    (void)MemoryContextSwitchTo(datarcvWriterContext);\r\n\r\n    /* init the dummy standby data num to write */\r\n    if (dummyStandbyMode) {\r\n        InitDummyDataNum();\r\n        t_thrd.datarcvwriter_cxt.dummy_data_writer_file_num++;\r\n        dummy_data_writer_file_offset = 0;\r\n    }\r\n\r\n    /*\r\n     * If an exception is encountered, processing resumes here.\r\n     *\r\n     * See notes in postgres.c about the design of this coding.\r\n     */\r\n    int curTryCounter = 0;\r\n    int *oldTryCounter = NULL;\r\n    if (sigsetjmp(localSigjmpBuf, 1) != 0) {\r\n        gstrace_tryblock_exit(true, oldTryCounter);\r\n\r\n        /* Since not using PG_TRY, must reset error stack by hand */\r\n        t_thrd.log_cxt.error_context_stack = NULL;\r\n\r\n        /* Prevent interrupts while cleaning up */\r\n        HOLD_INTERRUPTS();\r\n\r\n        /* Report the error to the server log */\r\n        EmitErrorReport();\r\n\r\n        /* abort async io, must before LWlock release */\r\n        AbortAsyncListIO();\r\n\r\n        /*\r\n         * These operations are really just a minimal subset of\r\n         * AbortTransaction().  We don't have very many resources to worry\r\n         * about in pagewriter, but we do have LWLocks, buffers, and temp files.\r\n         */\r\n        LWLockReleaseAll();\r\n        AbortBufferIO();\r\n        UnlockBuffers();\r\n        /* buffer pins are released here: */\r\n        ResourceOwnerRelease(t_thrd.utils_cxt.CurrentResourceOwner, RESOURCE_RELEASE_BEFORE_LOCKS, false, true);\r\n        /* we needn't bother with the other ResourceOwnerRelease phases */\r\n        AtEOXact_Buffers(false);\r\n\r\n        /* If waiting, get off wait queue (should only be needed after error) */\r\n        LockErrorCleanup();\r\n        LockReleaseCurrentOwner();\r\n\r\n        AtEOXact_Files();\r\n        AtEOXact_HashTables(false);\r\n\r\n        /*\r\n         * Now return to normal top-level context and clear ErrorContext for\r\n         * next time.\r\n         */\r\n        (void)MemoryContextSwitchTo(datarcvWriterContext);\r\n        FlushErrorState();\r\n\r\n        /* Close fd in data writer hash table if any. */\r\n        DataWriterHashRemove(false);\r\n\r\n        /* Flush any leaked data in the top-level context */\r\n        MemoryContextResetAndDeleteChildren(datarcvWriterContext);\r\n\r\n        /* Now we can allow interrupts again */\r\n        RESUME_INTERRUPTS();\r\n\r\n        /*\r\n         * Sleep at least 1 second after any error.  A write error is likely\r\n         * to be repeated, and we don't want to be filling the error logs as\r\n         * fast as we can.\r\n         */\r\n        pg_usleep(1000000L);\r\n\r\n        /*\r\n         * Close all open files after any error.  This is helpful on Windows,\r\n         * where holding deleted files open causes various strange errors.\r\n         * It's not clear we need it elsewhere, but shouldn't hurt.\r\n         */\r\n        smgrcloseall();\r\n    }\r\n    oldTryCounter = gstrace_tryblock_entry(&curTryCounter);\r\n\r\n    /* We can now handle ereport(ERROR) */\r\n    t_thrd.log_cxt.PG_exception_stack = &localSigjmpBuf;\r\n\r\n    /*\r\n     * Unblock signals (they were blocked when the postmaster forked us)\r\n     */\r\n    gs_signal_setmask(&t_thrd.libpq_cxt.UnBlockSig, NULL);\r\n    (void)gs_signal_unblock_sigusr2();\r\n\r\n    /*\r\n     * Use the recovery target timeline ID during recovery\r\n     */\r\n    if (!RecoveryInProgress())\r\n        ereport(FATAL, (errmsg(\"cannot continue Data streaming, recovery has already ended\")));\r\n\r\n    t_thrd.xlog_cxt.ThisTimeLineID = GetRecoveryTargetTLI();\r\n\r\n    /*\r\n     * register procLatch to datarcv shared memory\r\n     */\r\n    SetDataRcvWriterLatch();\r\n\r\n    /*\r\n     * init a hash table to store the rel file node fd.\r\n     */\r\n    DataWriterHashCreate();\r\n\r\n    /*\r\n     * Loop forever\r\n     */\r\n    for (;;) {\r\n        int rc;\r\n\r\n        /* Clear any already-pending wakeups */\r\n        ResetLatch(&t_thrd.proc->procLatch);\r\n\r\n        if (t_thrd.datarcvwriter_cxt.gotSIGHUP) {\r\n            t_thrd.datarcvwriter_cxt.gotSIGHUP = false;\r\n            ProcessConfigFile(PGC_SIGHUP);\r\n        }\r\n\r\n        while (!t_thrd.datarcvwriter_cxt.shutdownRequested && DataRcvWrite() > 0)\r\n            ;\r\n\r\n        if (t_thrd.datarcvwriter_cxt.shutdownRequested) {\r\n            ereport(LOG, (errmsg(\"datarcvwriter thread shut down\")));\r\n            /*\r\n             * From here on, elog(ERROR) should end with exit(1), not send\r\n             * control back to the sigsetjmp block above\r\n             */\r\n            u_sess->attr.attr_common.ExitOnAnyError = true;\r\n            /* Normal exit from the pagewriter is here */\r\n            proc_exit(0); /* done */\r\n        }\r\n\r\n        rc = WaitLatch(&t_thrd.proc->procLatch, WL_LATCH_SET | WL_TIMEOUT | WL_POSTMASTER_DEATH, (long)1000 /* ms */);\r\n        if (rc & WL_POSTMASTER_DEATH) {\r\n            ereport(LOG, (errmsg(\"datarcvwriter thread shut down with exit code 1\")));\r\n            gs_thread_exit(1);\r\n        }\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datarcvwriter.cpp",
		"name":"DataRcvWriterMain"
	},
	"DataRcvWriterQuickDie":{
		"body":"static void DataRcvWriterQuickDie(SIGNAL_ARGS)\r\n{\r\n    gs_signal_setmask(&t_thrd.libpq_cxt.BlockSig, NULL);\r\n\r\n    /*\r\n     * We DO NOT want to run proc_exit() callbacks -- we're here because\r\n     * shared memory may be corrupted, so we don't want to try to clean up our\r\n     * transaction.  Just nail the windows shut and get out of town.  Now that\r\n     * there's an atexit callback to prevent third-party code from breaking\r\n     * things by calling exit() directly, we have to reset the callbacks\r\n     * explicitly to make this work as intended.\r\n     */\r\n    on_exit_reset();\r\n\r\n    /*\r\n     * Note we do exit(2) not exit(0).    This is to force the postmaster into a\r\n     * system reset cycle if some idiot DBA sends a manual SIGQUIT to a random\r\n     * backend.  This is necessary precisely because we don't clean up our\r\n     * shared memory state.  (The \"dead man switch\" mechanism in pmsignal.c\r\n     * should ensure the postmaster sees this as a crash, too, but no harm in\r\n     * being doubly sure.)\r\n     */\r\n    gs_thread_exit(2);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datarcvwriter.cpp",
		"name":"DataRcvWriterQuickDie"
	},
	"DataRcvWriterSigHupHandler":{
		"body":"static void DataRcvWriterSigHupHandler(SIGNAL_ARGS)\r\n{\r\n    int saveErrno = errno;\r\n\r\n    t_thrd.datarcvwriter_cxt.gotSIGHUP = true;\r\n    if (t_thrd.proc) {\r\n        SetLatch(&t_thrd.proc->procLatch);\r\n    }\r\n\r\n    errno = saveErrno;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datarcvwriter.cpp",
		"name":"DataRcvWriterSigHupHandler"
	},
	"DataWriterHashCreate":{
		"body":"static void DataWriterHashCreate(void)\r\n{\r\n    /* if no the hash table we will create it */\r\n    if (t_thrd.datarcvwriter_cxt.data_writer_rel_tab == NULL) {\r\n        HASHCTL ctl;\r\n        errno_t rc = 0;\r\n        rc = memset_s(&ctl, sizeof(ctl), 0, sizeof(ctl));\r\n        securec_check(rc, \"\", \"\");\r\n        ctl.keysize = sizeof(data_writer_rel_key);\r\n        ctl.entrysize = sizeof(data_writer_rel);\r\n        ctl.hash = tag_hash;\r\n        t_thrd.datarcvwriter_cxt.data_writer_rel_tab =\r\n            hash_create(\"data writer rel table\", 100, &ctl, HASH_ELEM | HASH_FUNCTION);\r\n    } else\r\n        return;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datarcvwriter.cpp",
		"name":"DataWriterHashCreate"
	},
	"DataWriterHashRemove":{
		"body":"static void DataWriterHashRemove(bool flushdata)\r\n{\r\n#define ERRORDATA_FLUSH_NUM 5\r\n\r\n    HASH_SEQ_STATUS status;\r\n    data_writer_rel* hentry = NULL;\r\n    Relation reln;\r\n    CUStorage* cuStorage = NULL;\r\n\r\n    if (t_thrd.datarcvwriter_cxt.data_writer_rel_tab == NULL)\r\n        return;\r\n\r\n    /*\r\n     * After flush data failed five times, maybe the storage has damage,\r\n     * In order to prevent operation hang up, the process will PANIC.\r\n     */\r\n    if (t_thrd.datarcvwriter_cxt.dataRcvWriterFlushPageErrorCount++ >= ERRORDATA_FLUSH_NUM)\r\n        ereport(PANIC, (errmsg_internal(\"ERRORDATA_FLUSH_NUM exceeded\")));\r\n\r\n    hash_seq_init(&status, t_thrd.datarcvwriter_cxt.data_writer_rel_tab);\r\n    while ((hentry = (data_writer_rel*)hash_seq_search(&status)) != NULL) {\r\n        if (hentry->key.type == ROW_STORE && !g_instance.attr.attr_storage.enable_mix_replication) {\r\n            reln = hentry->reln;\r\n\r\n            if (flushdata) {\r\n                char* path = relpath(reln->rd_smgr->smgr_rnode, MAIN_FORKNUM);\r\n#ifdef ENABLE_MULTIPLE_NODES\r\n                LockRelFileNode(reln->rd_node, AccessExclusiveLock);\r\n#endif\r\n\r\n                /* do not sync the file if it not exists any more */\r\n                if (smgrexists(reln->rd_smgr, MAIN_FORKNUM) && CheckFileExists(path) == FILE_EXIST) {\r\n                    FlushRelationBuffers(reln);\r\n                    smgrimmedsync(reln->rd_smgr, MAIN_FORKNUM);\r\n                } else {\r\n                    ereport(WARNING,\r\n                        (errmsg(\"HA-DataWriterHashRemove: No File SYNC, rnode %u/%u/%u dose not exists\",\r\n                            reln->rd_node.spcNode,\r\n                            reln->rd_node.dbNode,\r\n                            reln->rd_node.relNode)));\r\n                }\r\n#ifdef ENABLE_MULTIPLE_NODES\r\n                UnlockRelFileNode(reln->rd_node, AccessExclusiveLock);\r\n#endif\r\n                pfree_ext(path);\r\n            }\r\n            RelationCloseSmgr(reln);\r\n            FreeFakeRelcacheEntry(reln);\r\n        } else if (hentry->key.type == COLUMN_STORE) {\r\n            cuStorage = hentry->cuStorage;\r\n            if (cuStorage != NULL) {\r\n                if (flushdata) {\r\n#ifdef ENABLE_MULTIPLE_NODES\r\n                    LockRelFileNode(hentry->key.node, AccessShareLock);\r\n#endif\r\n                    /*\r\n                     * unlink/truncate the cu file begin at 0, so we just check\r\n                     * whether the xxx_Cx.0 is exist.\r\n                     */\r\n                    if (cuStorage->IsDataFileExist(0)) {\r\n                        cuStorage->FlushDataFile();\r\n                    }\r\n#ifdef ENABLE_MULTIPLE_NODES\r\n                    UnlockRelFileNode(hentry->key.node, AccessShareLock);\r\n#endif\r\n                    if (u_sess->attr.attr_storage.HaModuleDebug)\r\n                        ereport(LOG,\r\n                            (errmsg(\"HA-DataWriterHashRemove: rnode %u/%u/%u, col %d\",\r\n                                hentry->key.node.spcNode,\r\n                                hentry->key.node.dbNode,\r\n                                hentry->key.node.relNode,\r\n                                hentry->key.attid)));\r\n                }\r\n                DELETE_EX(cuStorage);\r\n            }\r\n        }\r\n        hash_search(t_thrd.datarcvwriter_cxt.data_writer_rel_tab, (void*)&hentry->key, HASH_REMOVE, NULL);\r\n    }\r\n\r\n    /* Reset flush page error num after flush page successfully */\r\n    if (flushdata)\r\n        t_thrd.datarcvwriter_cxt.dataRcvWriterFlushPageErrorCount = 0;\r\n}",
		"comment":"/*\r\n * Remove relations in current data writer hash table, flush data if requested.\r\n * We use the hash table to cach the relation info we are handling to reduce the\r\n * overhead of IO.\r\n * Call the function once, after we handle all the data in data writer queue.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datarcvwriter.cpp",
		"name":"DataWriterHashRemove"
	},
	"DataWriterHashSearch":{
		"body":"static bool DataWriterHashSearch(const RelFileNode& node, int attid, ForkNumber forkno, StorageEngine type,\r\n    HASHACTION action, Relation& reln, CUStorage*& cuStorage)\r\n{\r\n    data_writer_rel_key key;\r\n    data_writer_rel* hentry = NULL;\r\n    bool found = false;\r\n    errno_t rc = 0;\r\n\r\n    rc = memset_s(&key, sizeof(data_writer_rel_key), 0, sizeof(data_writer_rel_key));\r\n    securec_check(rc, \"\", \"\");\r\n    key.node = node;\r\n    key.forkno = forkno;\r\n    key.attid = attid;\r\n    key.type = type;\r\n\r\n    if (t_thrd.datarcvwriter_cxt.data_writer_rel_tab == NULL) {\r\n        DataWriterHashCreate();\r\n    }\r\n\r\n    hentry = (data_writer_rel*)hash_search(t_thrd.datarcvwriter_cxt.data_writer_rel_tab, (void*)&key, action, &found);\r\n\r\n    if (action == HASH_FIND) {\r\n        /* if the action is find, we will get the fd  */\r\n        if (found) {\r\n            reln = hentry->reln;\r\n            cuStorage = hentry->cuStorage;\r\n        }\r\n    }\r\n\r\n    if (action == HASH_ENTER) {\r\n        /* if the action is enter, we will insert the fd  */\r\n        Assert(!found);\r\n        hentry->reln = reln;\r\n        hentry->cuStorage = cuStorage;\r\n    }\r\n\r\n    return found;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datarcvwriter.cpp",
		"name":"DataWriterHashSearch"
	},
	"DatabaseHashSearch":{
		"body":"static bool DatabaseHashSearch(Oid spcoid, Oid dboid)\r\n{\r\n    HASH_SEQ_STATUS status;\r\n    data_writer_rel* hentry = NULL;\r\n\r\n    if (t_thrd.datarcvwriter_cxt.data_writer_rel_tab == NULL)\r\n        return false; /* nothing to do */\r\n\r\n    hash_seq_init(&status, t_thrd.datarcvwriter_cxt.data_writer_rel_tab);\r\n\r\n    while ((hentry = (data_writer_rel*)hash_seq_search(&status)) != NULL) {\r\n        if (hentry->key.node.spcNode == spcoid && hentry->key.node.dbNode == dboid) {\r\n            hash_seq_term(&status);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datarcvwriter.cpp",
		"name":"DatabaseHashSearch"
	},
	"DoDataWrite":{
		"body":"uint32 DoDataWrite(char* buf, uint32 nbytes)\r\n{\r\n#define InvalidRelFileNode ((RelFileNode){0, 0, 0, -1})\r\n\r\n    RelFileNode curnode = InvalidRelFileNode;\r\n    RelFileNode prevnode = InvalidRelFileNode;\r\n    int curattid = -1;\r\n    int prevattid = -1;\r\n\r\n    DataElementHeaderData datahdr;\r\n    DataQueuePtr lastqueueoffset = {0, 0};\r\n    /* buf unit */\r\n    uint32 currentlen = 0;\r\n    int headerlen = sizeof(DataElementHeaderData);\r\n    Relation reln = NULL;\r\n    CUStorage* cuStorage = NULL;\r\n    errno_t errorno = EOK;\r\n\r\n#ifdef DATA_DEBUG\r\n    pg_crc32 crc;\r\n#endif\r\n\r\n    while (nbytes > 0) {\r\n        if (!g_instance.attr.attr_storage.enable_mix_replication) {\r\n            /* parse total_len for this slice of data */\r\n            errorno = memcpy_s(&currentlen, sizeof(uint32), buf, sizeof(uint32));\r\n            securec_check(errorno, \"\", \"\");\r\n            buf += sizeof(uint32);\r\n        }\r\n\r\n        /* parse data element header, and skip the header to parse payload below */\r\n        errorno = memcpy_s((void*)&datahdr, headerlen, buf, headerlen);\r\n        securec_check(errorno, \"\", \"\");\r\n        RelFileNodeCopy(curnode, datahdr.rnode, GETBUCKETID(datahdr.attid));\r\n        curattid = (int)GETATTID((uint32)datahdr.attid);\r\n        buf += headerlen;\r\n\r\n        if (!g_instance.attr.attr_storage.enable_mix_replication) {\r\n            Assert(currentlen == (sizeof(uint32) + (uint32)headerlen + datahdr.data_size));\r\n            /* for release version, if data is invalid, longjmp */\r\n            if (currentlen != (sizeof(uint32) + (uint32)headerlen + datahdr.data_size)) {\r\n                ereport(PANIC,\r\n                    (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\r\n                        errmsg(\"corrupt wal data write len %u bytes, \"\r\n                               \"the expected write data_size %u\",\r\n                            currentlen,\r\n                            datahdr.data_size)));\r\n            }\r\n        }\r\n        ereport(DEBUG5,\r\n            (errmsg(\"DoDataWrite write page: rnode[%u,%u,%u], blocknum[%u], \"\r\n                    \"pageoffset[%lu], size[%u], queueoffset[%u/%u], attid[%d]\",\r\n                datahdr.rnode.spcNode,\r\n                datahdr.rnode.dbNode,\r\n                datahdr.rnode.relNode,\r\n                datahdr.blocknum,\r\n                datahdr.offset,\r\n                datahdr.data_size,\r\n                datahdr.queue_offset.queueid,\r\n                datahdr.queue_offset.queueoff,\r\n                (int)GETATTID((uint32)datahdr.attid))));\r\n\r\n#ifdef DATA_DEBUG\r\n        INIT_CRC32(crc);\r\n        COMP_CRC32(crc, buf, datahdr.data_size);\r\n        FIN_CRC32(crc);\r\n\r\n        if (!EQ_CRC32(datahdr.data_crc, crc)) {\r\n            ereport(PANIC,\r\n                (errmsg(\"writing incorrect data page checksum at: \"\r\n                        \"rnode[%u,%u,%u], blocknum[%u], \"\r\n                        \"pageoffset[%u], size[%u], queueoffset[%u/%u]\",\r\n                    datahdr.rnode.spcNode,\r\n                    datahdr.rnode.dbNode,\r\n                    datahdr.rnode.relNode,\r\n                    datahdr.blocknum,\r\n                    datahdr.offset,\r\n                    datahdr.data_size,\r\n                    datahdr.queue_offset.queueid,\r\n                    datahdr.queue_offset.queueoff)));\r\n        }\r\n#endif\r\n        /* when enable_mix_replication is on, the ROW_STORE type is not supported now! */\r\n        if (g_instance.attr.attr_storage.enable_mix_replication && ROW_STORE == datahdr.type) {\r\n            Assert(false);\r\n            ereport(PANIC,\r\n                (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\r\n                    errmsg(\"The Row Store Heap Log SHOULD NOT BE synchronized in the WAL Streaming. \"\r\n                           \"Tracking the data header info: \"\r\n                           \"rnode[%u/%u/%u] blocknum[%u] pageoffset[%lu] \"\r\n                           \"size[%u] queueoffset[%u/%u].\",\r\n                        datahdr.rnode.spcNode,\r\n                        datahdr.rnode.dbNode,\r\n                        datahdr.rnode.relNode,\r\n                        datahdr.blocknum,\r\n                        datahdr.offset,\r\n                        datahdr.data_size,\r\n                        datahdr.queue_offset.queueid,\r\n                        datahdr.queue_offset.queueoff)));\r\n            return nbytes;\r\n        }\r\n\r\n        if ((memcmp(&curnode, &prevnode, sizeof(RelFileNode)) != 0) || (curattid != prevattid)) {\r\n            prevnode = curnode;\r\n            prevattid = curattid;\r\n\r\n            if (!DataWriterHashSearch(curnode, curattid, MAIN_FORKNUM, datahdr.type, HASH_FIND, reln, cuStorage)) {\r\n                /*\r\n                 * Before we open the smgr, we should insure that the database\r\n                 * directory of current relation is ready based on previous write.\r\n                 * If it's not ready, wait for recovery to create.\r\n                 */\r\n                if ((curnode.spcNode != GLOBALTABLESPACE_OID) && !DatabaseHashSearch(curnode.spcNode, curnode.dbNode)) {\r\n                    DataBaseDirState databaseDirState = CheckDatabaseReady(curnode.spcNode, curnode.dbNode);\r\n                    if (databaseDirState == DATABASEDIRCREATECANCEL) {\r\n                        /*\r\n                         * when enable_mix_replcation is off,\r\n                         * Cancel has been requested, give up the following write.\r\n                         * when enable_mix_replcation is on, ERROR\r\n                         */\r\n                        if (!g_instance.attr.attr_storage.enable_mix_replication) {\r\n                            WakeupDataRecovery();\r\n                        } else {\r\n                            ereport(ERROR,\r\n                                (errmsg(\"Failed to write the wal data: the database path %s doesn't exist.\",\r\n                                    GetDatabasePath(curnode.dbNode, curnode.spcNode))));\r\n                        }\r\n                        break;\r\n                    } else if (databaseDirState == NONEEXISTDATABASEDIR) {\r\n                        /* xlog is already redo where we dropped the database, so we skip this record */\r\n                        buf += datahdr.data_size;\r\n                        nbytes -= currentlen;\r\n                        continue;\r\n                    } else {\r\n                        /* database dir is already been created, go ahead */\r\n                        ;\r\n                    }\r\n                }\r\n\r\n                if (ROW_STORE == datahdr.type) {\r\n                    reln = CreateFakeRelcacheEntry(curnode);\r\n\r\n                    /* Open rel at the smgr level if not already done */\r\n                    RelationOpenSmgr(reln);\r\n\r\n                    /* insert it to the hash table */\r\n                    DataWriterHashSearch(curnode, curattid, MAIN_FORKNUM, ROW_STORE, HASH_ENTER, reln, cuStorage);\r\n                } else if (COLUMN_STORE == datahdr.type) {\r\n                    CFileNode cFileNode(curnode);\r\n                    cFileNode.m_forkNum = MAIN_FORKNUM;\r\n                    cFileNode.m_attid = curattid;\r\n\r\n                    cuStorage = New(CurrentMemoryContext) CUStorage(cFileNode);\r\n\r\n                    /* insert it to the hash table */\r\n                    DataWriterHashSearch(curnode, curattid, MAIN_FORKNUM, COLUMN_STORE, HASH_ENTER, reln, cuStorage);\r\n                }\r\n            }\r\n        }\r\n\r\n        /*\r\n         * Row store write data page by Buffer Manager API\r\n         *\r\n         * Lock relation for extension is nessesary for write received pages.\r\n         * We use this lock in reader, this doesn't comply with the principle\r\n         * of lock relation for extension, then read buffer, then lock buffer,\r\n         * then release relation extension. Cause standby server doesn't vacuum\r\n         * the pages, it's ok.\r\n         */\r\n        if (ROW_STORE == datahdr.type) {\r\n            Buffer buffer;\r\n            Page page;\r\n            SMgrRelation smgr;\r\n            char* path = NULL;\r\n\r\n#ifdef ENABLE_MULTIPLE_NODES\r\n            LockRelFileNode(curnode, AccessShareLock);\r\n#endif\r\n            smgr = smgropen(curnode, InvalidBackendId);\r\n            path = relpath(smgr->smgr_rnode, MAIN_FORKNUM);\r\n\r\n        retry:\r\n            /* Do not dirty the buffer any more if relation file was unlinked after we open it */\r\n            if (CanWriteBuffer(smgr, MAIN_FORKNUM, path) == true) {\r\n                /*\r\n                 * We use RBM_ZERO_ON_ERROR rather than RBM_ZERO_AND_LOCK here\r\n                 * 'cause if the page has not been loaded into buffer, buffer\r\n                 * manager would just allocate a zero buffer rather than read the\r\n                 * page from smgr. See more in ReadBuffer_common() comments inside.\r\n                 */\r\n                buffer = XLogReadBufferExtended(curnode, MAIN_FORKNUM, datahdr.blocknum, RBM_ZERO_ON_ERROR);\r\n                Assert(BufferIsValid(buffer));\r\n                LockBuffer(buffer, BUFFER_LOCK_EXCLUSIVE);\r\n                page = (Page)BufferGetPage(buffer);\r\n\r\n                /* Ignore pages with small LSN */\r\n                XLogRecPtr local_lsn;\r\n                XLogRecPtr peer_lsn;\r\n                local_lsn = PageGetLSN(page);\r\n                peer_lsn = PageGetLSN((Page)buf);\r\n                /*\r\n                 * In data page replicated scenes, maybe appear an old page to cover\r\n                 * an new page. Explame for two scenes:\r\n                 * 1: when standby is crash, page A will be copyed to dummystandby,\r\n                 *    then dummystandby is crash, stanby is ok, and primary update\r\n                 *    A to A', standby will get A', then primary is crash, stanby\r\n                 *    will failover, it will get page A to cover the page A'.\r\n                 * 2: when session1 is copying page A to table t1; session2 is update\r\n                 *    page A to A'; standby redo the A' first, then write the A, and\r\n                 *    A will cover A'.\r\n                 */\r\n                if (XLByteLT(peer_lsn, local_lsn))\r\n                    ; /* do nothing */\r\n                else {\r\n                    errno_t rc = 0;\r\n                    rc = memcpy_s(page, BLCKSZ, buf, datahdr.data_size);\r\n                    securec_check(rc, \"\", \"\");\r\n                    MarkBufferDirty(buffer);\r\n                }\r\n                UnlockReleaseBuffer(buffer);\r\n            } else {\r\n                /* check again */\r\n                if (CheckFileExists(path) == FILE_EXIST) {\r\n                    goto retry;\r\n                }\r\n                ereport(WARNING,\r\n                    (errmsg(\"HA-DoDataWrite: No File Write(file not exists), rnode %u/%u/%u, blockno %u \",\r\n                        curnode.spcNode,\r\n                        curnode.dbNode,\r\n                        curnode.relNode,\r\n                        datahdr.blocknum)));\r\n            }\r\n#ifdef ENABLE_MULTIPLE_NODES\r\n            UnlockRelFileNode(curnode, AccessShareLock);\r\n#endif\r\n\r\n            pfree_ext(path);\r\n\r\n            if (u_sess->attr.attr_storage.HaModuleDebug) {\r\n                ereport(LOG,\r\n                    (errmsg(\"HA-DoDataWrite: rnode %u/%u/%u, blockno %u \",\r\n                        curnode.spcNode,\r\n                        curnode.dbNode,\r\n                        curnode.relNode,\r\n                        datahdr.blocknum)));\r\n            }\r\n        } else if (COLUMN_STORE == datahdr.type) {\r\n            Assert(cuStorage->m_cnode.m_attid == GETATTID(datahdr.attid));\r\n            if (u_sess->attr.attr_storage.HaModuleDebug) {\r\n                check_cu_block(buf, datahdr.data_size);\r\n                ereport(LOG,\r\n                    (errmsg(\"HA-DoDataWrite: rnode %u/%u/%u, col %u, \"\r\n                            \"blockno %lu, cuUnitCount %u\",\r\n                        datahdr.rnode.spcNode,\r\n                        datahdr.rnode.dbNode,\r\n                        datahdr.rnode.relNode,\r\n                        GETATTID((uint)datahdr.attid),\r\n                        datahdr.offset / ALIGNOF_CUSIZE,\r\n                        datahdr.data_size / ALIGNOF_CUSIZE)));\r\n            }\r\n#ifdef ENABLE_MULTIPLE_NODES\r\n            LockRelFileNode(curnode, AccessShareLock);\r\n#endif\r\n\r\n            /* direct write the data file when column store */\r\n            cuStorage->SaveCU(buf, datahdr.offset, datahdr.data_size, false);\r\n\r\n#ifdef ENABLE_MULTIPLE_NODES\r\n            UnlockRelFileNode(curnode, AccessShareLock);\r\n#endif\r\n        }\r\n\r\n        buf += datahdr.data_size;\r\n\r\n        if (!g_instance.attr.attr_storage.enable_mix_replication) {\r\n            nbytes -= currentlen;\r\n            lastqueueoffset = datahdr.queue_offset;\r\n\r\n            /* Use volatile pointer to prevent code rearrangement */\r\n            volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n\r\n            ereport(DEBUG5,\r\n                (errmsg(\"recwriter: receive: %u/%u, local: %u/%u, offset %u/%u\",\r\n                    datarcv->receivePosition.queueid,\r\n                    datarcv->receivePosition.queueoff,\r\n                    datarcv->localWritePosition.queueid,\r\n                    datarcv->localWritePosition.queueoff,\r\n                    datahdr.queue_offset.queueid,\r\n                    datahdr.queue_offset.queueoff)));\r\n\r\n            WakeupDataRecovery();\r\n        } else\r\n            nbytes -= ((uint32)headerlen + datahdr.data_size);\r\n    }\r\n\r\n    /* Sync all relations to the disk and then clear the hash table */\r\n    DataWriterHashRemove(true);\r\n\r\n    /* Update shared-memory status when datareceiver is started */\r\n    if (!g_instance.attr.attr_storage.enable_mix_replication) {\r\n        volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n\r\n        SpinLockAcquire(&datarcv->mutex);\r\n        datarcv->receivePosition.queueid = lastqueueoffset.queueid;\r\n        datarcv->receivePosition.queueoff = lastqueueoffset.queueoff;\r\n        SpinLockRelease(&datarcv->mutex);\r\n    }\r\n\r\n    return nbytes;\r\n}",
		"comment":"/*\r\n * Write data to disk, the data is acquire by GetFromDataQueue.\r\n * 1. When enable_mix_replication is off, and Data sender/DataRcv started,\r\n *     we periodly Write old-format ROW_STORE and COLUMN_STORE data to disk\r\n * 2. When enable_mix_replication is on, the data is from WalRcv, and written to\r\n *     disk by walrcvwriter, for 'd'message. In this case, we have skip the new-format\r\n *     data when call DoDataWrite\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datarcvwriter.cpp",
		"name":"DoDataWrite"
	},
	"DummyStandbyDataRcvWrite":{
		"body":"static void DummyStandbyDataRcvWrite(char* buf, uint32 nbytes)\r\n{\r\n    ssize_t byteswritten;\r\n    char path[MAXPGPATH] = {0};\r\n    volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n\r\n    /* buf unit */\r\n    DataElementHeaderData dataehdr;\r\n    uint32 currentlen = 0;\r\n    int headerlen = sizeof(DataElementHeaderData);\r\n    uint32 caculatebytes = nbytes;\r\n    char* caculatebuf = buf;\r\n    int nRet = 0;\r\n\r\n    /*\r\n     * get  the file num to store:\r\n     *  1. If MAX_DUMMY_DATA_FILE <= dummy_data_writer_file_offset, open\r\n     *     the next file to store\r\n     *  2. If the current file can not store the nbytes, discard the current file space,\r\n     *     open the next file to store.\r\n     */\r\n    if (dummy_data_writer_file_offset >= MAX_DUMMY_DATA_FILE ||\r\n        (MAX_DUMMY_DATA_FILE - dummy_data_writer_file_offset < (uint32)(nbytes + sizeof(nbytes)))) {\r\n        ereport(DEBUG2, (errmsg(\"data file num %u\", t_thrd.datarcvwriter_cxt.dummy_data_writer_file_num)));\r\n        t_thrd.datarcvwriter_cxt.dummy_data_writer_file_num++;\r\n        dummy_data_writer_file_offset = 0;\r\n\r\n        if (dummy_data_writer_file_fd >= 0) {\r\n            close(dummy_data_writer_file_fd);\r\n            dummy_data_writer_file_fd = -1;\r\n        }\r\n    }\r\n\r\n    /* open the file */\r\n    if (dummy_data_writer_file_fd < 0) {\r\n        /* get the file path */\r\n        nRet = snprintf_s(path,\r\n            sizeof(path),\r\n            MAXPGPATH - 1,\r\n            \"base/dummy_standby/%u\",\r\n            t_thrd.datarcvwriter_cxt.dummy_data_writer_file_num);\r\n        securec_check_ss_c(nRet, \"\", \"\");\r\n\r\n        dummy_data_writer_file_fd = open(path, O_RDWR | O_CREAT | PG_BINARY, S_IRUSR | S_IWUSR);\r\n        if (dummy_data_writer_file_fd < 0)\r\n            ereport(PANIC,\r\n                (errcode_for_file_access(),\r\n                    errmsg(\"could not create data file \\\"%s\\\", dummy_data_writer_file_fd=%d: %m\",\r\n                        path,\r\n                        dummy_data_writer_file_fd)));\r\n    }\r\n\r\n    while (caculatebytes > 0) {\r\n        errno_t rc = 0;\r\n        rc = memcpy_s((void*)&currentlen, sizeof(uint32), caculatebuf, sizeof(uint32));\r\n        securec_check(rc, \"\", \"\");\r\n        caculatebuf += sizeof(uint32);\r\n\r\n        rc = memcpy_s((void*)&dataehdr, headerlen, caculatebuf, headerlen);\r\n        securec_check(rc, \"\", \"\");\r\n        caculatebuf += headerlen;\r\n        caculatebuf += dataehdr.data_size;\r\n        caculatebytes -= currentlen;\r\n    }\r\n\r\n    errno = 0;\r\n    /* OK to write the data */\r\n    byteswritten = write(dummy_data_writer_file_fd, &nbytes, sizeof(uint32));\r\n    if (byteswritten < (ssize_t)sizeof(uint32)) {\r\n        /* if write didn't set errno, assume no disk space */\r\n        if (errno == 0) {\r\n            errno = ENOSPC;\r\n        }\r\n        ereport(PANIC, (errcode_for_file_access(),\r\n            errmsg(\"could not write to data file %s buffer len %u, length %u: %m\", path, nbytes, nbytes)));\r\n    }\r\n\r\n    errno = 0;\r\n    byteswritten = write(dummy_data_writer_file_fd, buf, nbytes);\r\n    if (byteswritten < nbytes) {\r\n        /* if write didn't set errno, assume no disk space */\r\n        if (errno == 0)\r\n            errno = ENOSPC;\r\n        ereport(PANIC,\r\n            (errcode_for_file_access(),\r\n                errmsg(\"could not write to data file %s \"\r\n                       \"at offset %u, length %u: %m\",\r\n                    path,\r\n                    (uint32)dummy_data_writer_file_offset,\r\n                    nbytes)));\r\n    }\r\n\r\n    dummy_data_writer_file_offset = dummy_data_writer_file_offset + nbytes + sizeof(nbytes);\r\n\r\n    if (u_sess->attr.attr_storage.HaModuleDebug) {\r\n        ereport(LOG,\r\n            (errmsg(\"HA-DummyStandbyDataRcvWrite: fileno %u, nbytes %u, queueoffset %u/%u,\"\r\n                    \" dummy_data_writer_file_offset %u, dummy_data_writer_file_fd %d\",\r\n                t_thrd.datarcvwriter_cxt.dummy_data_writer_file_num,\r\n                nbytes,\r\n                dataehdr.queue_offset.queueid,\r\n                dataehdr.queue_offset.queueoff,\r\n                dummy_data_writer_file_offset,\r\n                dummy_data_writer_file_fd)));\r\n    }\r\n\r\n    /* use fdatasync to make sure the received data to flush the disk */\r\n    if (pg_fdatasync(dummy_data_writer_file_fd) != 0)\r\n        ereport(PANIC,\r\n            (errcode_for_file_access(),\r\n                errmsg(\"could not fdatasync data file num %u, fd %d: %m\",\r\n                    t_thrd.datarcvwriter_cxt.dummy_data_writer_file_num,\r\n                    dummy_data_writer_file_fd)));\r\n\r\n    /* Update shared-memory status */\r\n    SpinLockAcquire(&datarcv->mutex);\r\n    datarcv->receivePosition.queueid = dataehdr.queue_offset.queueid;\r\n    datarcv->receivePosition.queueoff = dataehdr.queue_offset.queueoff;\r\n    SpinLockRelease(&datarcv->mutex);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datarcvwriter.cpp",
		"name":"DummyStandbyDataRcvWrite"
	},
	"DummyStandbyDoDataWrite":{
		"body":"static void DummyStandbyDoDataWrite(char* buf, uint32 nbytes)\r\n{\r\n    uint32 sum = 0;\r\n    uint32 currentlen = 0;\r\n    char* caculatebuf = buf;\r\n    dummy_data_writer_use_file = true;\r\n    errno_t rc = 0;\r\n    while (nbytes > 0) {\r\n        rc = memcpy_s((void*)&currentlen, sizeof(uint32), caculatebuf, sizeof(uint32));\r\n        securec_check(rc, \"\", \"\");\r\n        if ((sum + currentlen) > (uint32)g_instance.attr.attr_storage.MaxSendSize * 1024) {\r\n            DummyStandbyDataRcvWrite(buf, (uint32)sum);\r\n            buf = caculatebuf;\r\n            sum = 0;\r\n        } else {\r\n            caculatebuf += currentlen;\r\n            sum += currentlen;\r\n            nbytes -= currentlen;\r\n        }\r\n    }\r\n    DummyStandbyDataRcvWrite(buf, (uint32)sum);\r\n    dummy_data_writer_use_file = false;\r\n}",
		"comment":"/*\r\n * Write data to disk of DummyStandby.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datarcvwriter.cpp",
		"name":"DummyStandbyDoDataWrite"
	},
	"EmptyDataRcvWriterLatch":{
		"body":"static void EmptyDataRcvWriterLatch(void)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n    SpinLockAcquire(&datarcv->mutex);\r\n    datarcv->datarcvWriterLatch = NULL;\r\n    datarcv->writerPid = 0;\r\n    SpinLockRelease(&datarcv->mutex);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datarcvwriter.cpp",
		"name":"EmptyDataRcvWriterLatch"
	},
	"InitDummyDataNum":{
		"body":"void InitDummyDataNum(void)\r\n{\r\n    DIR* dir = NULL;\r\n    struct dirent* de = NULL;\r\n    int max_num_file = 0;\r\n    int min_num_file = 0;\r\n    char* dirpath = DUMMY_STANDBY_DATADIR;\r\n\r\n    /* open the dir of base/dummy_standby */\r\n    errno = 0;\r\n    dir = AllocateDir(dirpath);\r\n    if (dir == NULL && errno == ENOENT) {\r\n        if (mkdir(dirpath, S_IRWXU) < 0) {\r\n            /* Failure other than not exists */\r\n            ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not create directory \\\"%s\\\": %m\", dirpath)));\r\n        }\r\n        dir = AllocateDir(dirpath);\r\n    }\r\n    if (dir == NULL) {\r\n        ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not open directory \\\"%s\\\": %m\", dirpath)));\r\n        return;\r\n    }\r\n\r\n    /* loop read the file name of base/dummy_standby */\r\n    while ((de = ReadDir(dir, dirpath)) != NULL) {\r\n        /* Skip special stuff */\r\n        if (strcmp(de->d_name, \".\") == 0 || strcmp(de->d_name, \"..\") == 0)\r\n            continue;\r\n\r\n        min_num_file = atoi(de->d_name);\r\n        break;\r\n    }\r\n\r\n    FreeDir(dir);\r\n    dir = AllocateDir(dirpath);\r\n\r\n    /* loop read the file name of base/dummy_standby */\r\n    while ((de = ReadDir(dir, dirpath)) != NULL) {\r\n        /* Skip special stuff */\r\n        if (strcmp(de->d_name, \".\") == 0 || strcmp(de->d_name, \"..\") == 0)\r\n            continue;\r\n\r\n        /* search the max num file */\r\n        max_num_file = Max(atoi(de->d_name), max_num_file);\r\n        min_num_file = Min(atoi(de->d_name), min_num_file);\r\n        ereport(DEBUG5,\r\n            (errmsg(\"InitDummyDataNum de->d_name=%s;   max_num_path=%d; min_num_file=%d.\",\r\n                de->d_name,\r\n                max_num_file,\r\n                min_num_file)));\r\n    }\r\n\r\n    t_thrd.datarcvwriter_cxt.dummy_data_writer_file_num = max_num_file;\r\n    t_thrd.datasender_cxt.dummy_data_read_file_num = min_num_file;\r\n    FreeDir(dir);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datarcvwriter.cpp",
		"name":"InitDummyDataNum"
	},
	"ReqShutdownHandler":{
		"body":"static void ReqShutdownHandler(SIGNAL_ARGS)\r\n{\r\n    int saveErrno = errno;\r\n\r\n    t_thrd.datarcvwriter_cxt.shutdownRequested = true;\r\n\r\n    /* cancel the wait for database directory */\r\n    t_thrd.int_cxt.ProcDiePending = true;\r\n    if (t_thrd.proc) {\r\n        SetLatch(&t_thrd.proc->procLatch);\r\n    }\r\n    errno = saveErrno;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datarcvwriter.cpp",
		"name":"ReqShutdownHandler"
	},
	"SetDataRcvWriterLatch":{
		"body":"static void SetDataRcvWriterLatch(void)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n    SpinLockAcquire(&datarcv->mutex);\r\n    datarcv->datarcvWriterLatch = &t_thrd.proc->procLatch;\r\n    datarcv->writerPid = t_thrd.proc_cxt.MyProcPid;\r\n    SpinLockRelease(&datarcv->mutex);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datarcvwriter.cpp",
		"name":"SetDataRcvWriterLatch"
	},
	"SetDataRcvWriterPID":{
		"body":"void SetDataRcvWriterPID(ThreadId tid)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n    SpinLockAcquire(&datarcv->mutex);\r\n    datarcv->writerPid = tid;\r\n    SpinLockRelease(&datarcv->mutex);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datarcvwriter.cpp",
		"name":"SetDataRcvWriterPID"
	},
	"ShutdownDataRcvWriter":{
		"body":"static void ShutdownDataRcvWriter(int code, Datum arg)\r\n{\r\n    /* If waiting, get off wait queue (should only be needed after error),clear WriterPid */\r\n    LockErrorCleanup();\r\n    LockReleaseCurrentOwner();\r\n    EmptyDataRcvWriterLatch();\r\n}",
		"comment":"/*\r\n * Called when the DataRcvWriterMain is ending.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datarcvwriter.cpp",
		"name":"ShutdownDataRcvWriter"
	}
}