{
	"AssignLsn":{
		"body":"bool AssignLsn(XLogRecPtr* lsn_ptr, const char* input)\r\n{\r\n    int len1 = 0;\r\n    int len2 = 0;\r\n    bool res = false;\r\n    uint32 xlogid = 0;\r\n    uint32 xrecoff = 0;\r\n\r\n    Assert(input != NULL && lsn_ptr != NULL);\r\n\r\n    /* Sanity check input format. */\r\n    len1 = strspn(input, \"0123456789abcdefABCDEF\");\r\n    if (len1 < 1 || len1 > MAXPG_LSNCOMPONENT || input[len1] != '/') {\r\n        goto exit;\r\n    }\r\n    len2 = strspn(input + len1 + 1, \"0123456789abcdefABCDEF\");\r\n    if (len2 < 1 || len2 > MAXPG_LSNCOMPONENT || input[len1 + 1 + len2] != '\\0') {\r\n        goto exit;\r\n    }\r\n    /* Decode result. */\r\n    xlogid = (uint32)strtoul(input, NULL, 16);\r\n    xrecoff = (uint32)strtoul(input + len1 + 1, NULL, 16);\r\n    *lsn_ptr = (((uint64)xlogid) << 32) + xrecoff;\r\n    res = true;\r\n\r\nexit:\r\n    return res;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logicalfuncs.cpp",
		"name":"AssignLsn"
	},
	"LogicalOutputPrepareWrite":{
		"body":"static void LogicalOutputPrepareWrite(LogicalDecodingContext* ctx, XLogRecPtr lsn, TransactionId xid, bool last_write)\r\n{\r\n    resetStringInfo(ctx->out);\r\n}",
		"comment":"/*\r\n * Prepare for a output plugin write.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logicalfuncs.cpp",
		"name":"LogicalOutputPrepareWrite"
	},
	"LogicalOutputWrite":{
		"body":"static void LogicalOutputWrite(LogicalDecodingContext* ctx, XLogRecPtr lsn, TransactionId xid, bool last_write)\r\n{\r\n    Datum values[3];\r\n    bool nulls[3];\r\n    DecodingOutputState* p = NULL;\r\n    char* str_lsn_temp = NULL;\r\n    int rc = 0;\r\n    /* SQL Datums can only be of a limited length... */\r\n    if ((uint32)ctx->out->len > MaxAllocSize - VARHDRSZ)\r\n        ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"too much output for sql interface\")));\r\n\r\n    p = (DecodingOutputState*)ctx->output_writer_private;\r\n\r\n    rc = memset_s(nulls, sizeof(nulls), 0, sizeof(nulls));\r\n    securec_check(rc, \"\", \"\");\r\n\r\n    str_lsn_temp = (char*)palloc0(str_lsn_len);\r\n    rc = sprintf_s(str_lsn_temp, str_lsn_len, \"%X/%X\", uint32(lsn >> 32), uint32(lsn));\r\n    securec_check_ss(rc, \"\", \"\");\r\n    values[0] = CStringGetTextDatum(str_lsn_temp);\r\n    values[1] = TransactionIdGetDatum(xid);\r\n\r\n    /*\r\n     * Assert ctx->out is in database encoding when we're writing textual\r\n     * output.\r\n     */\r\n    if (!p->binary_output) {\r\n        Assert(pg_verify_mbstr(GetDatabaseEncoding(), ctx->out->data, ctx->out->len, false));\r\n    }\r\n\r\n    /* ick, but cstring_to_text_with_len works for bytea perfectly fine */\r\n    values[2] = PointerGetDatum(cstring_to_text_with_len(ctx->out->data, (size_t)(uint)(ctx->out->len)));\r\n\r\n    tuplestore_putvalues(p->tupstore, p->tupdesc, values, nulls);\r\n    p->returned_rows++;\r\n}",
		"comment":"/*\r\n * Perform output plugin write into tuplestore.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logicalfuncs.cpp",
		"name":"LogicalOutputWrite"
	},
	"XLogRead":{
		"body":"static void XLogRead(char* buf, TimeLineID tli, XLogRecPtr startptr, Size count)\r\n{\r\n    char* p = NULL;\r\n    XLogRecPtr recptr = InvalidXLogRecPtr;\r\n    Size nbytes = 0;\r\n\r\n    p = buf;\r\n    recptr = startptr;\r\n    nbytes = count;\r\n\r\n    while (nbytes > 0) {\r\n        uint32 startoff;\r\n        int segbytes;\r\n        int readbytes;\r\n\r\n        startoff = uint32(recptr) % XLogSegSize;\r\n\r\n        if (t_thrd.logical_cxt.sendFd < 0 || !(((recptr) / XLogSegSize) == t_thrd.logical_cxt.sendSegNo)) {\r\n            char path[MAXPGPATH];\r\n\r\n            /* Switch to another logfile segment */\r\n            if (t_thrd.logical_cxt.sendFd >= 0) {\r\n                (void)close(t_thrd.logical_cxt.sendFd);\r\n            }\r\n\r\n            t_thrd.logical_cxt.sendSegNo = (recptr) / XLogSegSize;\r\n            int nRet = 0;\r\n            nRet = snprintf_s(path,\r\n                MAXPGPATH,\r\n                MAXPGPATH - 1,\r\n                XLOGDIR \"/%08X%08X%08X\",\r\n                tli,\r\n                (uint32)((t_thrd.logical_cxt.sendSegNo) / XLogSegmentsPerXLogId),\r\n                (uint32)((t_thrd.logical_cxt.sendSegNo) % XLogSegmentsPerXLogId));\r\n            securec_check_ss(nRet, \"\", \"\");\r\n\r\n            t_thrd.logical_cxt.sendFd = BasicOpenFile(path, O_RDONLY | PG_BINARY, 0);\r\n\r\n            if (t_thrd.logical_cxt.sendFd < 0) {\r\n                if (errno == ENOENT)\r\n                    ereport(ERROR,\r\n                        (errcode_for_file_access(), errmsg(\"requested WAL segment %s has already been removed\", path)));\r\n                else\r\n                    ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not open file \\\"%s\\\": %m\", path)));\r\n            }\r\n            t_thrd.logical_cxt.sendOff = 0;\r\n        }\r\n\r\n        /* Need to seek in the file? */\r\n        if (t_thrd.logical_cxt.sendOff != startoff) {\r\n            if (lseek(t_thrd.logical_cxt.sendFd, (off_t)startoff, SEEK_SET) < 0) {\r\n                char path[MAXPGPATH] = \"\\0\";\r\n\r\n                int nRet = snprintf_s(path, MAXPGPATH, MAXPGPATH - 1, XLOGDIR \"/%08X%08X%08X\", tli,\r\n                    (uint32)((t_thrd.logical_cxt.sendSegNo) / XLogSegmentsPerXLogId),\r\n                    (uint32)((t_thrd.logical_cxt.sendSegNo) % XLogSegmentsPerXLogId));\r\n                securec_check_ss(nRet, \"\", \"\");\r\n\r\n                ereport(ERROR, (errcode_for_file_access(),\r\n                    errmsg(\"could not seek in log segment %s to offset %u: %m\", path, startoff)));\r\n            }\r\n            t_thrd.logical_cxt.sendOff = startoff;\r\n        }\r\n\r\n        /* How many bytes are within this segment? */\r\n        if (nbytes > (XLogSegSize - startoff))\r\n            segbytes = XLogSegSize - startoff;\r\n        else {\r\n            segbytes = (int)(uint)nbytes;\r\n        }\r\n\r\n        readbytes = read(t_thrd.logical_cxt.sendFd, p, segbytes);\r\n        if (readbytes <= 0) {\r\n            char path[MAXPGPATH] = \"\\0\";\r\n\r\n            int nRet = snprintf_s(path, MAXPGPATH, MAXPGPATH - 1, XLOGDIR \"/%08X%08X%08X\", tli,\r\n                (uint32)((t_thrd.logical_cxt.sendSegNo) / XLogSegmentsPerXLogId),\r\n                (uint32)((t_thrd.logical_cxt.sendSegNo) % XLogSegmentsPerXLogId));\r\n            securec_check_ss(nRet, \"\", \"\");\r\n\r\n            ereport(ERROR, (errcode_for_file_access(),\r\n                errmsg(\"could not read from log segment %s, offset %u, length %lu: %m\",\r\n                    path, t_thrd.logical_cxt.sendOff, INT2ULONG(segbytes))));\r\n        }\r\n\r\n        /* Update state for read */\r\n        recptr += readbytes;\r\n\r\n        t_thrd.logical_cxt.sendOff += readbytes;\r\n        nbytes -= readbytes;\r\n        p += readbytes;\r\n    }\r\n}",
		"comment":"/*\r\n * This is duplicate code with pg_xlogdump, similar to walsender.c, but\r\n * we currently don't have the infrastructure (elog!) to share it.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logicalfuncs.cpp",
		"name":"XLogRead"
	},
	"check_permissions":{
		"body":"void check_permissions(void)\r\n{\r\n    if (!superuser() && !has_rolreplication(GetUserId()))\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\r\n                (errmsg(\"must be superuser or replication role to use replication slots\"))));\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logicalfuncs.cpp",
		"name":"check_permissions"
	},
	"logical_read_local_xlog_page":{
		"body":"int logical_read_local_xlog_page(XLogReaderState* state, XLogRecPtr targetPagePtr, int reqLen, XLogRecPtr targetRecPtr,\r\n    char* cur_page, TimeLineID* pageTLI)\r\n{\r\n    XLogRecPtr flushptr, loc;\r\n    int count;\r\n\r\n    loc = targetPagePtr + reqLen;\r\n\r\n    while (1) {\r\n        /*\r\n         * description: we're going to have to do something more intelligent about\r\n         * timelines on standbys. Use readTimeLineHistory() and\r\n         * tliOfPointInHistory() to get the proper LSN? For now we'll catch\r\n         * that case earlier, but the code and description is left in here for when\r\n         * that changes.\r\n         */\r\n        if (!RecoveryInProgress()) {\r\n            *pageTLI = t_thrd.xlog_cxt.ThisTimeLineID;\r\n            flushptr = GetFlushRecPtr();\r\n        } else\r\n            flushptr = GetXLogReplayRecPtr(pageTLI);\r\n\r\n        if (XLByteLE(loc, flushptr))\r\n            break;\r\n\r\n        CHECK_FOR_INTERRUPTS();\r\n        pg_usleep(1000L);\r\n    }\r\n\r\n    /* more than one block available */\r\n    if ((targetPagePtr) + XLOG_BLCKSZ <= (flushptr))\r\n        count = XLOG_BLCKSZ;\r\n    /* not enough data there */\r\n    else if ((targetPagePtr) + reqLen > (flushptr))\r\n        return -1;\r\n    /* part of the page available */\r\n    else\r\n        count = (flushptr) - (targetPagePtr);\r\n\r\n    XLogRead(cur_page, *pageTLI, targetPagePtr, XLOG_BLCKSZ);\r\n\r\n    return count;\r\n}",
		"comment":"/*\r\n * read_page callback for logical decoding contexts.\r\n *\r\n * Public because it would likely be very helpful for someone writing another\r\n * output method outside walsender, e.g. in a bgworker.\r\n *\r\n * description: The walsender has it's own version of this, but it relies on the\r\n * walsender's latch being set whenever WAL is flushed. No such infrastructure\r\n * exists for normal backends, so we have to do a check/sleep/repeat style of\r\n * loop for now.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logicalfuncs.cpp",
		"name":"logical_read_local_xlog_page"
	},
	"pg_logical_slot_get_binary_changes":{
		"body":"Datum pg_logical_slot_get_binary_changes(PG_FUNCTION_ARGS)\r\n{\r\n    Datum ret = pg_logical_slot_get_changes_guts(fcinfo, true, true);\r\n    return ret;\r\n}",
		"comment":"/*\r\n * SQL function returning the changestream in binary, consuming the data.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logicalfuncs.cpp",
		"name":"pg_logical_slot_get_binary_changes"
	},
	"pg_logical_slot_get_changes":{
		"body":"Datum pg_logical_slot_get_changes(PG_FUNCTION_ARGS)\r\n{\r\n    Datum ret = pg_logical_slot_get_changes_guts(fcinfo, true, false);\r\n    return ret;\r\n}",
		"comment":"/*\r\n * SQL function returning the changestream as text, consuming the data.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logicalfuncs.cpp",
		"name":"pg_logical_slot_get_changes"
	},
	"pg_logical_slot_get_changes_guts":{
		"body":"static Datum pg_logical_slot_get_changes_guts(FunctionCallInfo fcinfo, bool confirm, bool binary)\r\n{\r\n    Name name = PG_GETARG_NAME(0);\r\n    XLogRecPtr upto_lsn = InvalidXLogRecPtr;\r\n    int64 upto_nchanges = 0;\r\n    ReturnSetInfo* rsinfo = (ReturnSetInfo*)fcinfo->resultinfo;\r\n    MemoryContext per_query_ctx = NULL;\r\n    MemoryContext oldcontext = NULL;\r\n    XLogRecPtr end_of_wal = InvalidXLogRecPtr;\r\n    XLogRecPtr startptr = InvalidXLogRecPtr;\r\n    LogicalDecodingContext* ctx = NULL;\r\n    ResourceOwner old_resowner = t_thrd.utils_cxt.CurrentResourceOwner;\r\n    ArrayType* arr = NULL;\r\n    Size ndim = 0;\r\n    List* options = NIL;\r\n    DecodingOutputState* p = NULL;\r\n    int rc = 0;\r\n    char path[MAXPGPATH];\r\n    struct stat st;\r\n\r\n    check_permissions();\r\n    (void)ValidateName(NameStr(*name));\r\n    if (RecoveryInProgress() && confirm)\r\n        ereport(ERROR, (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION), errmsg(\"couldn't advance in recovery\")));\r\n\r\n    if (PG_ARGISNULL(1))\r\n        upto_lsn = InvalidXLogRecPtr;\r\n    else {\r\n        const char* str_upto_lsn = TextDatumGetCString(PG_GETARG_DATUM(1));\r\n        (void)ValidateName(str_upto_lsn);\r\n        if (!AssignLsn(&upto_lsn, str_upto_lsn)) {\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\r\n                    errmsg(\"invalid input syntax for type lsn: \\\"%s\\\" \"\r\n                           \"of start_lsn\",\r\n                        str_upto_lsn)));\r\n        }\r\n    }\r\n\r\n    if (PG_ARGISNULL(2))\r\n        upto_nchanges = 0;\r\n    else {\r\n        upto_nchanges = PG_GETARG_INT32(2);\r\n    }\r\n\r\n    /* check to see if caller supports us returning a tuplestore */\r\n    if (rsinfo == NULL || !IsA(rsinfo, ReturnSetInfo))\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\r\n                errmsg(\"set-valued function called in context that cannot accept a set\")));\r\n    if (!(rsinfo->allowedModes & SFRM_Materialize))\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\r\n                errmsg(\"materialize mode required, but it is not allowed in this context\")));\r\n\r\n    /* state to write output to */\r\n    p = (DecodingOutputState*)palloc0(sizeof(DecodingOutputState));\r\n\r\n    p->binary_output = binary;\r\n\r\n    /* Build a tuple descriptor for our result type */\r\n    if (get_call_result_type(fcinfo, NULL, &p->tupdesc) != TYPEFUNC_COMPOSITE)\r\n        ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"return type must be a row type\")));\r\n\r\n    CheckLogicalDecodingRequirements(u_sess->proc_cxt.MyDatabaseId);\r\n\r\n    arr = PG_GETARG_ARRAYTYPE_P(3);\r\n    ndim = (Size)(uint)(ARR_NDIM(arr));\r\n\r\n    per_query_ctx = rsinfo->econtext->ecxt_per_query_memory;\r\n    oldcontext = MemoryContextSwitchTo(per_query_ctx);\r\n\r\n    if (ndim > 1) {\r\n        ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"array must be one-dimensional\")));\r\n    } else if (array_contains_nulls(arr)) {\r\n        ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"array must not contain nulls\")));\r\n    } else if (ndim == 1) {\r\n        int nelems = 0;\r\n        Datum* datum_opts = NULL;\r\n        int i = 0;\r\n\r\n        AssertEreport(ARR_ELEMTYPE(arr) == TEXTOID, MOD_FUNCTION, \"must be TEXTOID\");\r\n\r\n        deconstruct_array(arr, TEXTOID, -1, false, 'i', &datum_opts, NULL, &nelems);\r\n\r\n        if (nelems % 2 != 0)\r\n            ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"array must have even number of elements\")));\r\n\r\n        for (i = 0; i < nelems; i += 2) {\r\n            char* dname = TextDatumGetCString(datum_opts[i]);\r\n            char* opt = TextDatumGetCString(datum_opts[i + 1]);\r\n            (void)ValidateName(dname);\r\n            options = lappend(options, makeDefElem(dname, (Node*)makeString(opt)));\r\n        }\r\n    }\r\n\r\n    p->tupstore = tuplestore_begin_heap(true, false, u_sess->attr.attr_memory.work_mem);\r\n    rsinfo->returnMode = SFRM_Materialize;\r\n    rsinfo->setResult = p->tupstore;\r\n    rsinfo->setDesc = p->tupdesc;\r\n\r\n    /* compute the current end-of-wal */\r\n    if (!RecoveryInProgress())\r\n        end_of_wal = GetFlushRecPtr();\r\n    else\r\n        end_of_wal = GetXLogReplayRecPtr(NULL);\r\n\r\n    CheckLogicalDecodingRequirements(u_sess->proc_cxt.MyDatabaseId);\r\n    ReplicationSlotAcquire(NameStr(*name), false);\r\n    rc = sprintf_s(path, sizeof(path), \"pg_replslot/%s/snap\", NameStr(t_thrd.slot_cxt.MyReplicationSlot->data.name));\r\n    securec_check_ss(rc, \"\", \"\");\r\n    if (stat(path, &st) == 0 && S_ISDIR(st.st_mode)) {\r\n        if (!rmtree(path, true))\r\n            ereport(ERROR, (errcode(ERRCODE_LOGICAL_DECODE_ERROR), errmsg(\"could not remove directory \\\"%s\\\"\", path)));\r\n    }\r\n    if (mkdir(path, S_IRWXU) < 0) {\r\n        ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not create directory \\\"%s\\\": %m\", path)));\r\n    }\r\n\r\n    PG_TRY();\r\n    {\r\n        ctx = CreateDecodingContext(InvalidXLogRecPtr,\r\n            options,\r\n            false,\r\n            logical_read_local_xlog_page,\r\n            LogicalOutputPrepareWrite,\r\n            LogicalOutputWrite);\r\n\r\n        (void)MemoryContextSwitchTo(oldcontext);\r\n\r\n        /*\r\n         * Check whether the output pluggin writes textual output if that's\r\n         * what we need.\r\n         */\r\n        if (!binary && ctx->options.output_type != OUTPUT_PLUGIN_TEXTUAL_OUTPUT)\r\n            ereport(\r\n                ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"output plugin cannot produce binary output\")));\r\n\r\n        ctx->output_writer_private = p;\r\n\r\n        startptr = t_thrd.slot_cxt.MyReplicationSlot->data.restart_lsn;\r\n\r\n        t_thrd.utils_cxt.CurrentResourceOwner =\r\n            ResourceOwnerCreate(t_thrd.utils_cxt.CurrentResourceOwner, \"logical decoding\");\r\n\r\n        /* invalidate non-timetravel entries */\r\n        InvalidateSystemCaches();\r\n\r\n        while ((!XLByteEQ(startptr, InvalidXLogRecPtr) && XLByteLT(startptr, end_of_wal)) ||\r\n               (!XLByteEQ(ctx->reader->EndRecPtr, InvalidXLogRecPtr) && XLByteLT(ctx->reader->EndRecPtr, end_of_wal))) {\r\n            XLogRecord* record = NULL;\r\n            char* errm = NULL;\r\n\r\n            record = XLogReadRecord(ctx->reader, startptr, &errm);\r\n            if (errm != NULL)\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_LOGICAL_DECODE_ERROR),\r\n                        errmsg(\"Stopped to parse any valid XLog Record at %X/%X: %s.\",\r\n                            (uint32)(ctx->reader->EndRecPtr >> 32),\r\n                            (uint32)ctx->reader->EndRecPtr,\r\n                            errm)));\r\n\r\n            startptr = InvalidXLogRecPtr;\r\n\r\n            /*\r\n             * The {begin_txn,change,commit_txn}_wrapper callbacks above will\r\n             * store the description into our tuplestore.\r\n             */\r\n            if (record != NULL)\r\n                LogicalDecodingProcessRecord(ctx, ctx->reader);\r\n\r\n            /* check limits */\r\n            if (!XLByteEQ(upto_lsn, InvalidXLogRecPtr) && XLByteLE(upto_lsn, ctx->reader->EndRecPtr))\r\n                break;\r\n            if (upto_nchanges != 0 && upto_nchanges <= p->returned_rows)\r\n                break;\r\n            CHECK_FOR_INTERRUPTS();\r\n        }\r\n    }\r\n    PG_CATCH();\r\n    {\r\n        /* clear all timetravel entries */\r\n        InvalidateSystemCaches();\r\n\r\n        PG_RE_THROW();\r\n    }\r\n    PG_END_TRY();\r\n\r\n    tuplestore_donestoring(tupstore);\r\n\r\n    t_thrd.utils_cxt.CurrentResourceOwner = old_resowner;\r\n\r\n    /*\r\n     * Next time, start where we left off. (Hunting things, the family\r\n     * business..)\r\n     */\r\n    if (!XLByteEQ(ctx->reader->EndRecPtr, InvalidXLogRecPtr) && confirm) {\r\n        LogicalConfirmReceivedLocation(ctx->reader->EndRecPtr);\r\n        log_slot_advance(&t_thrd.slot_cxt.MyReplicationSlot->data);\r\n    }\r\n\r\n    /* free context, call shutdown callback */\r\n    FreeDecodingContext(ctx);\r\n\r\n    ReplicationSlotRelease();\r\n    InvalidateSystemCaches();\r\n\r\n    return (Datum)0;\r\n}",
		"comment":"/*\r\n * Helper function for the various SQL callable logical decoding functions.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logicalfuncs.cpp",
		"name":"pg_logical_slot_get_changes_guts"
	},
	"pg_logical_slot_peek_binary_changes":{
		"body":"Datum pg_logical_slot_peek_binary_changes(PG_FUNCTION_ARGS)\r\n{\r\n    Datum ret = pg_logical_slot_get_changes_guts(fcinfo, false, true);\r\n    return ret;\r\n}",
		"comment":"/*\r\n * SQL function returning the changestream in binary, only peeking ahead.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logicalfuncs.cpp",
		"name":"pg_logical_slot_peek_binary_changes"
	},
	"pg_logical_slot_peek_changes":{
		"body":"Datum pg_logical_slot_peek_changes(PG_FUNCTION_ARGS)\r\n{\r\n    Datum ret = pg_logical_slot_get_changes_guts(fcinfo, false, false);\r\n    return ret;\r\n}",
		"comment":"/*\r\n * SQL function returning the changestream as text, only peeking ahead.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logicalfuncs.cpp",
		"name":"pg_logical_slot_peek_changes"
	}
}