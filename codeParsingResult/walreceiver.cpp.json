{
	"CalculateTimeout":{
		"body":"static inline TimestampTz CalculateTimeout(TimestampTz last_reply_time)\r\n{\r\n    return TimestampTzPlusMilliseconds(last_reply_time, u_sess->attr.attr_storage.wal_receiver_timeout / 2);\r\n}",
		"comment":"/* return timeout time */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"CalculateTimeout"
	},
	"ConfigFileTimer":{
		"body":"static void ConfigFileTimer(void)\r\n{\r\n    struct stat statbuf;\r\n    char bufTime[sizeof(ConfigModifyTimeMessage) + 1];\r\n    TimestampTz nowTime;\r\n\r\n    if (t_thrd.walreceiver_cxt.check_file_timeout > 0) {\r\n        nowTime = GetCurrentTimestamp();\r\n        if (TimestampDifferenceExceeds(t_thrd.walreceiver_cxt.last_sendfilereply_timestamp, nowTime,\r\n                t_thrd.walreceiver_cxt.check_file_timeout) ||\r\n            TimestampDifferenceExceeds(nowTime, t_thrd.walreceiver_cxt.last_sendfilereply_timestamp,\r\n                t_thrd.walreceiver_cxt.check_file_timeout)) {\r\n            errno_t errorno = EOK;\r\n            ereport(LOG, (errmsg(\"time is up to send file\")));\r\n            if (lstat(t_thrd.walreceiver_cxt.gucconf_file, &statbuf) != 0) {\r\n                if (errno != ENOENT) {\r\n                    ereport(ERROR, (errcode_for_file_access(),\r\n                        errmsg(\"could not stat file or directory \\\"%s\\\": %m\", t_thrd.walreceiver_cxt.gucconf_file)));\r\n                }\r\n            }\r\n            /* the configure file in standby has been change yet. */\r\n            if (t_thrd.walreceiver_cxt.standby_config_modify_time != statbuf.st_mtime) {\r\n                ereport(LOG, (errmsg(\"statbuf.st_mtime:%d is not equal to config_modify_time:%d\",\r\n                    (int)(statbuf.st_mtime), (int)(t_thrd.walreceiver_cxt.standby_config_modify_time))));\r\n                t_thrd.walreceiver_cxt.reply_modify_message->config_modify_time = 0;\r\n            } else {\r\n                ereport(LOG, (errmsg(\"the config file of standby has no change:%d\", (int)(statbuf.st_mtime))));\r\n                t_thrd.walreceiver_cxt.reply_modify_message->config_modify_time =\r\n                    t_thrd.walreceiver_cxt.Primary_config_modify_time;\r\n            }\r\n            bufTime[0] = 'A';\r\n            errorno = memcpy_s(&bufTime[1], sizeof(ConfigModifyTimeMessage),\r\n                t_thrd.walreceiver_cxt.reply_modify_message, sizeof(ConfigModifyTimeMessage));\r\n            securec_check(errorno, \"\\0\", \"\\0\");\r\n            libpqrcv_send(bufTime, sizeof(ConfigModifyTimeMessage) + 1);\r\n            /* save the current timestamp */\r\n            t_thrd.walreceiver_cxt.last_sendfilereply_timestamp = GetCurrentTimestamp();\r\n        }\r\n    }\r\n}",
		"comment":"/*\r\n * we check the configure file every check_file_timeout, if\r\n * the configure has been modified, send the modify time to standy.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"ConfigFileTimer"
	},
	"DisableWalRcvImmediateExit":{
		"body":"static void DisableWalRcvImmediateExit(void)\r\n{\r\n    t_thrd.walreceiver_cxt.WalRcvImmediateInterruptOK = false;\r\n    ProcessWalRcvInterrupts();\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"DisableWalRcvImmediateExit"
	},
	"EnableWalRcvImmediateExit":{
		"body":"static void EnableWalRcvImmediateExit(void)\r\n{\r\n    t_thrd.walreceiver_cxt.WalRcvImmediateInterruptOK = true;\r\n    ProcessWalRcvInterrupts();\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"EnableWalRcvImmediateExit"
	},
	"GetHeartbeatLastReplyTimestamp":{
		"body":"static TimestampTz GetHeartbeatLastReplyTimestamp()\r\n{\r\n    int replindex;\r\n    volatile HaShmemData* hashmdata = t_thrd.postmaster_cxt.HaShmData;\r\n    SpinLockAcquire(&hashmdata->mutex);\r\n    replindex = hashmdata->current_repl;\r\n    SpinLockRelease(&hashmdata->mutex);\r\n\r\n    return get_last_reply_timestamp(replindex);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"GetHeartbeatLastReplyTimestamp"
	},
	"GetPrimaryServiceAddress":{
		"body":"void GetPrimaryServiceAddress(char* address, size_t address_len)\r\n{\r\n    if (address == NULL || address_len == 0 || t_thrd.walreceiverfuncs_cxt.WalRcv == NULL)\r\n        return;\r\n\r\n    bool is_running = false;\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    int rc = 0;\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    is_running = walrcv->isRuning;\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    if (walrcv->pid == 0 || !is_running)\r\n        return;\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    rc = snprintf_s(address,\r\n        address_len,\r\n        (address_len - 1),\r\n        \"%s:%d\",\r\n        walrcv->conn_channel.remotehost,\r\n        walrcv->conn_channel.remoteservice);\r\n    securec_check_ss(rc, \"\\0\", \"\\0\");\r\n    SpinLockRelease(&walrcv->mutex);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"GetPrimaryServiceAddress"
	},
	"GetSyncPercent":{
		"body":"int GetSyncPercent(XLogRecPtr startLsn, XLogRecPtr totalLsn, XLogRecPtr hasCompleteLsn)\r\n{\r\n    int64 needSyncLogSum = 0;\r\n    int64 haveSyncLog = 0;\r\n    int haveCompletePer = 0;\r\n    int basePercent = 0;\r\n    XLogSegNo segno;\r\n\r\n    if (XLByteLE(totalLsn, hasCompleteLsn)) {\r\n        return HIGHEST_PERCENT;\r\n    }\r\n\r\n    /*\r\n     * When startLsn is invalid, standby is under streaming, so count percent base on\r\n     * maxlsn - wal_keep_segments*XLOG_SEG_SIZE, and percent is 90% ~ 100%\r\n     */\r\n    if (XLogRecPtrIsInvalid(startLsn)) {\r\n        XLByteToSeg(totalLsn, segno);\r\n        if (segno < WalGetSyncCountWindow()) {\r\n            startLsn = InvalidXLogRecPtr;\r\n        } else {\r\n            startLsn = totalLsn - (WalGetSyncCountWindow() * XLOG_SEG_SIZE);\r\n            basePercent = STREAMING_START_PERCENT;\r\n        }\r\n    }\r\n\r\n    needSyncLogSum = XLogDiff(totalLsn, startLsn);\r\n    haveSyncLog = XLogDiff(hasCompleteLsn, startLsn) + SizeOfXLogRecord - 1;\r\n\r\n    if (needSyncLogSum == 0) {\r\n        return HIGHEST_PERCENT;\r\n    } else {\r\n        haveCompletePer = (int)((HIGHEST_PERCENT - basePercent) * (haveSyncLog * 1.0 / needSyncLogSum)) + basePercent;\r\n    }\r\n    if (haveCompletePer > HIGHEST_PERCENT) {\r\n        haveCompletePer = HIGHEST_PERCENT;\r\n    } else if (haveCompletePer < 0) {\r\n        haveCompletePer = 0;\r\n    }\r\n    return haveCompletePer;\r\n}",
		"comment":"/*\r\n * get xlog sync percent between walsender and walreceiver.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"GetSyncPercent"
	},
	"MakeDebugLog":{
		"body":"void MakeDebugLog(TimestampTz sendTime, TimestampTz lastMsgReceiptTime, const char* msgFmt)\r\n{\r\n    char* sendtimeStr = NULL;\r\n    char* receipttimeStr = NULL;\r\n    /* Copy because timestamptz_to_str returns a static buffer */\r\n    sendtimeStr = pstrdup(timestamptz_to_str(sendTime));\r\n    receipttimeStr = pstrdup(timestamptz_to_str(lastMsgReceiptTime));\r\n    ereport(DEBUG2, (errmsg(msgFmt, sendtimeStr, receipttimeStr)));\r\n    pfree(sendtimeStr);\r\n    sendtimeStr = NULL;\r\n    pfree(receipttimeStr);\r\n    receipttimeStr = NULL;\r\n    return;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"MakeDebugLog"
	},
	"ProcessConfigFileMessage":{
		"body":"static bool ProcessConfigFileMessage(char* buf, Size len)\r\n{\r\n    struct stat statbuf;\r\n    ErrCode retcode = CODE_OK;\r\n    ConfFileLock filelock = {NULL, 0};\r\n    char conf_bak[MAXPGPATH];\r\n    int ret = 0;\r\n    char** reserve_item = NULL;\r\n\r\n    ret = snprintf_s(conf_bak, MAXPGPATH, MAXPGPATH - 1, \"%s/%s\", t_thrd.proc_cxt.DataDir, CONFIG_BAK_FILENAME);\r\n    securec_check_ss(ret, \"\\0\", \"\\0\");\r\n\r\n    if (lstat(t_thrd.walreceiver_cxt.gucconf_file, &statbuf) != 0) {\r\n        if (errno != ENOENT)\r\n            ereport(ERROR,\r\n                (errcode_for_file_access(),\r\n                    errmsg(\"could not stat file or directory \\\"%s\\\": %m\", t_thrd.walreceiver_cxt.gucconf_file)));\r\n        return false;\r\n    }\r\n\r\n    reserve_item = alloc_opt_lines(RESERVE_SIZE);\r\n    if (reserve_item == NULL) {\r\n        ereport(LOG, (errmsg(\"Alloc mem for reserved parameters failed\")));\r\n        return false;\r\n    }\r\n\r\n    /* 1. lock postgresql.conf */\r\n    if (get_file_lock(t_thrd.walreceiver_cxt.gucconf_lock_file, &filelock) != CODE_OK) {\r\n        release_opt_lines(reserve_item);\r\n        ereport(LOG, (errmsg(\"Modify the postgresql.conf failed : can not get the file lock \")));\r\n        return false;\r\n    }\r\n\r\n    /* 2. load reserved parameters to reserve_item(array in memeory) */\r\n    retcode = copy_asyn_lines(t_thrd.walreceiver_cxt.gucconf_file, reserve_item, g_reserve_param);\r\n    if (retcode != CODE_OK) {\r\n        release_opt_lines(reserve_item);\r\n        release_file_lock(&filelock);\r\n        ereport(LOG, (errmsg(\"copy asynchronization items failed: %s\\n\", gs_strerror(retcode))));\r\n        return false;\r\n    }\r\n\r\n    /* 3. genreate temp files and fill it with content from primary. */\r\n    retcode = generate_temp_file(buf, conf_bak, len);\r\n    if (retcode != CODE_OK) {\r\n        release_opt_lines(reserve_item);\r\n        release_file_lock(&filelock);\r\n        ereport(LOG, (errmsg(\"create %s failed: %s\\n\", conf_bak, gs_strerror(retcode))));\r\n        return false;\r\n    }\r\n\r\n    /* 4. adjust the info with reserved parameters, and sync to temp file. */\r\n    retcode = update_temp_file(conf_bak, reserve_item, g_reserve_param);\r\n    if (retcode != CODE_OK) {\r\n        release_file_lock(&filelock);\r\n        release_opt_lines(reserve_item);\r\n        ereport(LOG, (errmsg(\"update gaussdb config file failed: %s\\n\", gs_strerror(retcode))));\r\n        return false;\r\n    } else {\r\n        ereport(LOG, (errmsg(\"update gaussdb config file success\")));\r\n        if (rename(conf_bak, t_thrd.walreceiver_cxt.gucconf_file) != 0) {\r\n            release_file_lock(&filelock);\r\n            release_opt_lines(reserve_item);\r\n            ereport(LOG,\r\n                (errcode_for_file_access(),\r\n                    errmsg(\"could not rename \\\"%s\\\" to \\\"%s\\\": %m\", conf_bak, t_thrd.walreceiver_cxt.gucconf_file)));\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /* save the modify time of standby config file */\r\n    if (lstat(t_thrd.walreceiver_cxt.gucconf_file, &statbuf) != 0) {\r\n        if (errno != ENOENT) {\r\n            release_file_lock(&filelock);\r\n            release_opt_lines(reserve_item);\r\n            ereport(ERROR,\r\n                (errcode_for_file_access(),\r\n                    errmsg(\"could not stat file or directory \\\"%s\\\": %m\", t_thrd.walreceiver_cxt.gucconf_file)));\r\n            return false;\r\n        }\r\n    }\r\n    t_thrd.walreceiver_cxt.standby_config_modify_time = statbuf.st_mtime;\r\n\r\n    if (statbuf.st_size > 0) {\r\n        copy_file_internal(t_thrd.walreceiver_cxt.gucconf_file, t_thrd.walreceiver_cxt.temp_guc_conf_file, true);\r\n        ereport(DEBUG1,\r\n            (errmsg(\"copy %s to %s success\",\r\n                t_thrd.walreceiver_cxt.gucconf_file,\r\n                t_thrd.walreceiver_cxt.temp_guc_conf_file)));\r\n    }\r\n\r\n    release_file_lock(&filelock);\r\n    release_opt_lines(reserve_item);\r\n\r\n    /* notify postmaster the config file has changed */\r\n    if (gs_signal_send(PostmasterPid, SIGHUP) != 0) {\r\n        ereport(WARNING, (errmsg(\"send SIGHUP to PM failed\")));\r\n        return false;\r\n    }\r\n    return true;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"ProcessConfigFileMessage"
	},
	"ProcessEndXLogMessage":{
		"body":"static void ProcessEndXLogMessage(EndXLogMessage* endXLogMessage)\r\n{\r\n    ereport(dummyStandbyMode ? DEBUG2 : LOG, (errmsg(\"sync Secondary Standby xlog done\")));\r\n\r\n    if (endXLogMessage->percent == SYNC_DUMMY_STANDBY_END) {\r\n        SetWalRcvDummyStandbySyncPercent(SYNC_DUMMY_STANDBY_END);\r\n\r\n        if (dummyStandbyMode)\r\n            SyncSystemIdentifier();\r\n    }\r\n}",
		"comment":"/*\r\n * Process RmXLogMessage received from primary sender, message type is 'e'.\r\n * Refence searchBCMFiles\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"ProcessEndXLogMessage"
	},
	"ProcessKeepaliveMessage":{
		"body":"static void ProcessKeepaliveMessage(PrimaryKeepaliveMessage* keepalive)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    TimestampTz lastMsgReceiptTime = GetCurrentTimestamp();\r\n\r\n    /* Update shared-memory status */\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    walrcv->peer_role = keepalive->peer_role;\r\n    walrcv->peer_state = keepalive->peer_state;\r\n    walrcv->sender_sent_location = keepalive->walEnd;\r\n    walrcv->lastMsgSendTime = keepalive->sendTime;\r\n    walrcv->lastMsgReceiptTime = lastMsgReceiptTime;\r\n    SpinLockRelease(&walrcv->mutex);\r\n    wal_catchup = keepalive->catchup;\r\n\r\n    if (log_min_messages <= DEBUG2) {\r\n        MakeDebugLog(keepalive->sendTime, lastMsgReceiptTime, \"wal receive keep alive data sendtime %s receipttime %s\");\r\n        ereport(DEBUG2,\r\n            (errmsg(\"replication apply delay %d ms transfer latency %d ms\",\r\n                GetReplicationApplyDelay(),\r\n                GetReplicationTransferLatency())));\r\n    }\r\n}",
		"comment":"/*\r\n * Process ProcessKeepaliveMessage received from sender, message type is 'k'.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"ProcessKeepaliveMessage"
	},
	"ProcessRmXLogMessage":{
		"body":"static void ProcessRmXLogMessage(const RmXLogMessage* rmXLogMessage)\r\n{\r\n    XLogRecPtr lastFlushPtr = InvalidXLogRecPtr;\r\n\r\n    // check command source\r\n    if (rmXLogMessage->peer_role != PRIMARY_MODE) {\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INVALID_OPERATION),\r\n                errmsg(\"rm xlog comand is not from primary,peer_role=%d\", rmXLogMessage->peer_role)));\r\n    }\r\n\r\n    ereport(DEBUG2, (errmsg(\"received rm xlog message\")));\r\n\r\n    walRcvDataCleanup();\r\n    WalRcvXLogClose();\r\n\r\n    SpinLockAcquire(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n    lastFlushPtr = t_thrd.walreceiver_cxt.walRcvCtlBlock->flushPtr;\r\n    t_thrd.walreceiver_cxt.walRcvCtlBlock->receivePtr = t_thrd.walreceiver_cxt.walRcvCtlBlock->writePtr =\r\n        t_thrd.walreceiver_cxt.walRcvCtlBlock->flushPtr = InvalidXLogRecPtr;\r\n    t_thrd.walreceiver_cxt.walRcvCtlBlock->walStart = InvalidXLogRecPtr;\r\n    t_thrd.walreceiver_cxt.walRcvCtlBlock->walWriteOffset = t_thrd.walreceiver_cxt.walRcvCtlBlock->walFreeOffset = 0;\r\n    t_thrd.walreceiver_cxt.walRcvCtlBlock->walReadOffset = 0;\r\n    SpinLockRelease(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n\r\n    /* Now rm the WAL files. */\r\n    ProcessWSRmXLog();\r\n    if (!XLByteEQ(lastFlushPtr, InvalidXLogRecPtr)) {\r\n        ereport(LOG,\r\n            (errmsg(\"rm xlog command done, lastFlushPtr=%X/%X\", (uint32)(lastFlushPtr >> 32), (uint32)(lastFlushPtr))));\r\n    }\r\n    SyncSystemIdentifier();\r\n\r\n    /* Now rm the data file the same operation copyed from ProcessRmDataMessage() */\r\n    if (g_instance.attr.attr_storage.enable_mix_replication) {\r\n        while (true) {\r\n            if (!ws_dummy_data_writer_use_file) {\r\n                CloseWSDataFileOnDummyStandby();\r\n                break;\r\n            } else\r\n                pg_usleep(100000); /* sleep 0.1 s */\r\n        }\r\n\r\n        ProcessWSRmData();\r\n    }\r\n\r\n    return;\r\n}",
		"comment":"/*\r\n * Process RmXLogMessage received from primary sender, message type is 'x'.\r\n * Refence searchBCMFiles\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"ProcessRmXLogMessage"
	},
	"ProcessSwitchResponse":{
		"body":"static void ProcessSwitchResponse(int code)\r\n{\r\n    switch (code) {\r\n        case SWITCHOVER_PROMOTE_REQUEST: /* promote standby */\r\n            t_thrd.walreceiverfuncs_cxt.WalRcv->node_state = NODESTATE_STANDBY_PROMOTING;\r\n            SendPostmasterSignal(PMSIGNAL_PROMOTE_STANDBY);\r\n            break;\r\n\r\n        case SWITCHOVER_DEMOTE_FAILED: /* demote failed */\r\n            ereport(WARNING, (errmsg(\"primary demote failed\")));\r\n            break;\r\n\r\n        case SWITCHOVER_DEMOTE_CATCHUP_EXIST: /* demote failed */\r\n            t_thrd.walreceiverfuncs_cxt.WalRcv->node_state = NODESTATE_NORMAL;\r\n            SendPostmasterSignal(PMSIGNAL_ROLLBACK_STANDBY_PROMOTE);\r\n            ereport(LOG, (errmsg(\"catchup is still alive, switchover failed\")));\r\n            break;\r\n\r\n        default:\r\n            ereport(WARNING, (errmsg(\"unknown switchover response message received from primary\")));\r\n            break;\r\n    }\r\n}",
		"comment":"/*\r\n * process switchover response message from primary.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"ProcessSwitchResponse"
	},
	"ProcessWSRmData":{
		"body":"void ProcessWSRmData(void)\r\n{\r\n    DIR* dir = NULL;\r\n    struct dirent* de = NULL;\r\n    char data_path[MAXPGPATH] = {0};\r\n    int nRet = 0;\r\n\r\n    nRet = snprintf_s(data_path, MAXPGPATH, MAXPGPATH - 1, \"%s/%s\", t_thrd.proc_cxt.DataDir, DUMMY_STANDBY_DATADIR);\r\n    securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n\r\n    dir = AllocateDir(data_path);\r\n    while ((de = ReadDir(dir, data_path)) != NULL) {\r\n        if (strcmp(de->d_name, \".\") == 0 || strcmp(de->d_name, \"..\") == 0)\r\n            continue;\r\n\r\n        char path[MAXPGPATH] = {0};\r\n        nRet = snprintf_s(path, MAXPGPATH, MAXPGPATH - 1, \"%s/%s\", data_path, de->d_name);\r\n        securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n\r\n        ereport(LOG, (errmsg(\"delete data path %s on the dummy standby.\", path)));\r\n\r\n        (void)unlink(path);\r\n    }\r\n    FreeDir(dir);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"ProcessWSRmData"
	},
	"ProcessWSRmXLog":{
		"body":"void ProcessWSRmXLog(void)\r\n{\r\n    char xlog_path[MAXPGPATH] = {0};\r\n    int nRet = 0;\r\n\r\n    nRet = snprintf_s(xlog_path, MAXPGPATH, MAXPGPATH - 1, \"%s/%s\", t_thrd.proc_cxt.DataDir, XLOGDIR);\r\n    securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n\r\n    DIR* dir = NULL;\r\n    struct dirent* de;\r\n\r\n    dir = AllocateDir(xlog_path);\r\n    while ((de = ReadDir(dir, xlog_path)) != NULL) {\r\n        if (strcmp(de->d_name, \".\") == 0 || strcmp(de->d_name, \"..\") == 0)\r\n            continue;\r\n\r\n        char path[MAXPGPATH] = {0};\r\n        nRet = snprintf_s(path, MAXPGPATH, MAXPGPATH - 1, \"%s/%s\", xlog_path, de->d_name);\r\n        securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n\r\n        (void)unlink(path);\r\n    }\r\n    FreeDir(dir);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"ProcessWSRmXLog"
	},
	"ProcessWalDataHeaderMessage":{
		"body":"static void ProcessWalDataHeaderMessage(WalDataPageMessageHeader* msghdr)\r\n{\r\n    /* Use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    TimestampTz lastMsgReceiptTime = GetCurrentTimestamp();\r\n\r\n    Assert(msghdr);\r\n\r\n    /* Update shared-memory status */\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    walrcv->lastMsgSendTime = msghdr->sendTime;\r\n    walrcv->lastMsgReceiptTime = lastMsgReceiptTime;\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    if (log_min_messages <= DEBUG2) {\r\n        MakeDebugLog(\r\n            msghdr->sendTime, lastMsgReceiptTime, \"wal receive waldata header data sendtime %s receipttime %s\");\r\n    }\r\n}",
		"comment":"/*\r\n * Process WaldataHeaderMessage received from sender message type is 'd'.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"ProcessWalDataHeaderMessage"
	},
	"ProcessWalHeaderMessage":{
		"body":"static void ProcessWalHeaderMessage(const WalDataMessageHeader* msghdr)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    TimestampTz lastMsgReceiptTime = GetCurrentTimestamp();\r\n\r\n    /* Update shared-memory status */\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    walrcv->lastMsgSendTime = msghdr->sendTime;\r\n    walrcv->lastMsgReceiptTime = lastMsgReceiptTime;\r\n\r\n    walrcv->sender_sent_location = msghdr->sender_sent_location;\r\n\r\n    walrcv->sender_flush_location = msghdr->sender_flush_location;\r\n\r\n    walrcv->sender_replay_location = msghdr->sender_replay_location;\r\n\r\n    walrcv->sender_write_location = msghdr->sender_write_location;\r\n\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    /* Update the catchup flag */\r\n    wal_catchup = msghdr->catchup;\r\n\r\n    ereport(DEBUG2,\r\n        (errmsg(\"wal receiver data message: start %X/%X end %X/%X \"\r\n                \"sender_write %X/%X sender_flush %X/%X sender_replay %X/%X\",\r\n            (uint32)(msghdr->dataStart >> 32),\r\n            (uint32)msghdr->dataStart,\r\n            (uint32)(msghdr->sender_sent_location >> 32),\r\n            (uint32)msghdr->sender_sent_location,\r\n            (uint32)(msghdr->sender_write_location >> 32),\r\n            (uint32)msghdr->sender_write_location,\r\n            (uint32)(msghdr->sender_flush_location >> 32),\r\n            (uint32)msghdr->sender_flush_location,\r\n            (uint32)(msghdr->sender_replay_location >> 32),\r\n            (uint32)msghdr->sender_replay_location)));\r\n\r\n    if (log_min_messages <= DEBUG2) {\r\n        MakeDebugLog(msghdr->sendTime, lastMsgReceiptTime, \"wal receive wal header data sendtime %s receipttime %s\");\r\n        ereport(DEBUG2,\r\n            (errmsg(\"replication apply delay %d ms transfer latency %d ms\",\r\n                GetReplicationApplyDelay(),\r\n                GetReplicationTransferLatency())));\r\n    }\r\n\r\n    return;\r\n}",
		"comment":"/*\r\n * Process walHeaderMessage received from sender, message type is 'w'.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"ProcessWalHeaderMessage"
	},
	"ProcessWalRcvInterrupts":{
		"body":"void ProcessWalRcvInterrupts(void)\r\n{\r\n    /*\r\n     * Although walreceiver interrupt handling doesn't use the same scheme as\r\n     * regular backends, call CHECK_FOR_INTERRUPTS() to make sure we receive\r\n     * any incoming signals on Win32.\r\n     */\r\n    CHECK_FOR_INTERRUPTS();\r\n\r\n    if (t_thrd.walreceiver_cxt.got_SIGTERM) {\r\n        t_thrd.walreceiver_cxt.WalRcvImmediateInterruptOK = false;\r\n        ereport(FATAL,\r\n            (errcode(ERRCODE_ADMIN_SHUTDOWN), errmsg(\"terminating walreceiver process due to administrator command\")));\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"ProcessWalRcvInterrupts"
	},
	"ProcessWalSndrMessage":{
		"body":"static void ProcessWalSndrMessage(const XLogRecPtr* walEnd, TimestampTz sendTime)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n\r\n    TimestampTz lastMsgReceiptTime = GetCurrentTimestamp();\r\n\r\n    /* Update shared-memory status */\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    if (XLByteLT(walrcv->latestWalEnd, *walEnd))\r\n        walrcv->latestWalEndTime = sendTime;\r\n    walrcv->latestWalEnd = *walEnd;\r\n    walrcv->sender_sent_location = *walEnd;\r\n    walrcv->lastMsgSendTime = sendTime;\r\n    walrcv->lastMsgReceiptTime = lastMsgReceiptTime;\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    if (log_min_messages <= DEBUG2) {\r\n        int applyDelay;\r\n        applyDelay = GetReplicationApplyDelay();\r\n        MakeDebugLog(sendTime, lastMsgReceiptTime, \"wal receive walSndMsg sendtime %s receipttime %s\");\r\n        /* apply delay is not available */\r\n        if (applyDelay == -1) {\r\n            ereport(DEBUG2,\r\n                (errmsg(\"replication apply delay (N/A) transfer latency %d ms\", GetReplicationTransferLatency())));\r\n        } else {\r\n            ereport(DEBUG2,\r\n                (errmsg(\"replication apply delay %d ms transfer latency %d ms\",\r\n                    applyDelay,\r\n                    GetReplicationTransferLatency())));\r\n        }\r\n    }\r\n}",
		"comment":"/*\r\n * Keep track of important messages from primary.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"ProcessWalSndrMessage"
	},
	"RefuseConnect":{
		"body":"void RefuseConnect()\r\n{\r\n    WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n\r\n    knl_g_disconn_node_context_data disconn_node =\r\n        g_instance.comm_cxt.localinfo_cxt.disable_conn_node.disable_conn_node_data;\r\n    if (disconn_node.conn_mode == POLLING_CONNECTION) {\r\n        return;\r\n    }\r\n    if (disconn_node.conn_mode == SPECIFY_CONNECTION &&\r\n        strcmp(disconn_node.disable_conn_node_host, (char*)walrcv->conn_channel.remotehost) == 0 &&\r\n        disconn_node.disable_conn_node_port == walrcv->conn_channel.remoteport) {\r\n        return;\r\n    }\r\n    ereport(FATAL,\r\n        (errmsg(\"Refuse WAL streaming, connection mode is %d, connertion IP is %s:%d\\n\",\r\n            disconn_node.conn_mode,\r\n            disconn_node.disable_conn_node_host,\r\n            disconn_node.disable_conn_node_port)));\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"RefuseConnect"
	},
	"SyncSystemIdentifier":{
		"body":"void SyncSystemIdentifier(void)\r\n{\r\n    if (t_thrd.walreceiver_cxt.control_file_writed == 0) {\r\n        ereport(LOG, (errmsg(\"update secondary system identifier\")));\r\n\r\n        SetSystemIdentifier(sync_system_identifier);\r\n\r\n        t_thrd.walreceiver_cxt.control_file_writed++;\r\n        UpdateControlFile();\r\n    }\r\n}",
		"comment":"/*\r\n * update pg_control file.\r\n * only wal receiver set system_identifier.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"SyncSystemIdentifier"
	},
	"WSDataRcvCheck":{
		"body":"void WSDataRcvCheck(char* data_buf, Size nbytes)\r\n{\r\n    errno_t errorno = EOK;\r\n    char* cur_buf = NULL;\r\n    uint32 total_len = 0;\r\n    XLogRecPtr ref_xlog_ptr = InvalidXLogRecPtr;\r\n\r\n    cur_buf = data_buf;\r\n\r\n    errorno = memcpy_s(&total_len, sizeof(uint32), cur_buf, sizeof(uint32));\r\n    securec_check(errorno, \"\\0\", \"\\0\");\r\n    cur_buf += sizeof(uint32);\r\n\r\n    if (total_len != nbytes) {\r\n        Assert(false);\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INVALID_PARAMETER_VALUE),\r\n                errmsg(\"the corrupt data total len is %u bytes, the expected len is %lu bytes.\", total_len, nbytes)));\r\n    }\r\n\r\n    if (cur_buf[0] != 'd') {\r\n        Assert(false);\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INVALID_PARAMETER_VALUE),\r\n                errmsg(\"the unexpected data flag is %X, the expected data flag is 'd'.\", (unsigned int)cur_buf[0])));\r\n    }\r\n    cur_buf += 1;\r\n\r\n    errorno = memcpy_s(&ref_xlog_ptr, sizeof(XLogRecPtr), cur_buf, sizeof(XLogRecPtr));\r\n    securec_check(errorno, \"\\0\", \"\\0\");\r\n    if (XLogRecPtrIsInvalid(ref_xlog_ptr)) {\r\n        Assert(false);\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg(\"the start xlog employed for the wal data is invalid.\")));\r\n    }\r\n    cur_buf += sizeof(XLogRecPtr);\r\n\r\n    errorno = memcpy_s(&ref_xlog_ptr, sizeof(XLogRecPtr), cur_buf, sizeof(XLogRecPtr));\r\n    securec_check(errorno, \"\\0\", \"\\0\");\r\n    if (XLogRecPtrIsInvalid(ref_xlog_ptr)) {\r\n        Assert(false);\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg(\"the end xlog employed for the wal data is invalid.\")));\r\n    }\r\n\r\n    return;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"WSDataRcvCheck"
	},
	"WalDataRcvReceive":{
		"body":"static void WalDataRcvReceive(char* buf, Size nbytes, XLogRecPtr recptr)\r\n{\r\n    /* buf unit */\r\n    uint32 expected_len = 0;\r\n#ifdef DATA_DEBUG\r\n    pg_crc32 crc;\r\n#endif\r\n    Size left_len = nbytes;\r\n    char* cur_buf = buf;\r\n    errno_t errorno = EOK;\r\n\r\n    /* 'd' means the replication data, 'w' means the xlog. */\r\n    char data_flag = 0;\r\n    XLogRecPtr received_ptr = InvalidXLogRecPtr;\r\n    bool empty_streaming_body = false;\r\n\r\n    while (left_len > 0) {\r\n        errorno = memcpy_s(&expected_len, sizeof(uint32), cur_buf, sizeof(uint32));\r\n        securec_check(errorno, \"\\0\", \"\\0\");\r\n        cur_buf += sizeof(uint32);\r\n\r\n        /* skip the 'd' flag */\r\n        data_flag = cur_buf[0];\r\n        Assert(data_flag == 'd' || data_flag == 'w');\r\n        cur_buf += 1;\r\n\r\n        if (data_flag == 'd') {\r\n            if (expected_len <= (sizeof(uint32) + 1 + sizeof(XLogRecPtr) * 2)) {\r\n                Assert(false);\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_INVALID_PARAMETER_VALUE),\r\n                        errmsg(\"the received wal data is unexpected %u bytes at least more than %lu bytes\",\r\n                            expected_len,\r\n                            (sizeof(uint32) + 1 + sizeof(XLogRecPtr) * 2))));\r\n            }\r\n        } else if (data_flag == 'w') {\r\n            if (expected_len < (sizeof(uint32) + 1 + sizeof(XLogRecPtr))) {\r\n                Assert(false);\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_INVALID_PARAMETER_VALUE),\r\n                        errmsg(\"the received xlog is unexpected %u bytes at least more than %lu bytes.\",\r\n                            expected_len,\r\n                            (sizeof(uint32) + 1 + sizeof(XLogRecPtr)))));\r\n            }\r\n\r\n            errorno = memcpy_s(&received_ptr, sizeof(XLogRecPtr), cur_buf, sizeof(XLogRecPtr));\r\n            securec_check(errorno, \"\\0\", \"\\0\");\r\n\r\n            if (expected_len == (sizeof(uint32) + 1 + sizeof(XLogRecPtr))) {\r\n                ereport(DEBUG2,\r\n                    (errmsg(\"received empty streaming body at %X/%X.\",\r\n                        (uint32)(received_ptr >> 32),\r\n                        (uint32)received_ptr)));\r\n\r\n                empty_streaming_body = true;\r\n            }\r\n\r\n            if (!empty_streaming_body) {\r\n                XLByteAdvance(recptr, (uint32)(expected_len - WAL_DATA_LEN));\r\n\r\n                SpinLockAcquire(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n                t_thrd.walreceiver_cxt.walRcvCtlBlock->receivePtr = recptr;\r\n                SpinLockRelease(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n            }\r\n        } else {\r\n            Assert(false);\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_INVALID_PARAMETER_VALUE),\r\n                    errmsg(\"fail to push some wal data to the wal streaming writer queue: unexpected wal data flag %c.\",\r\n                        data_flag)));\r\n        }\r\n\r\n        if (!empty_streaming_body) {\r\n            /* skip the message header */\r\n            (void)PushToWriterQueue(cur_buf - sizeof(uint32) - 1, expected_len);\r\n            ereport(DEBUG5,\r\n                (errmsg(\"push some wal data to the wal streaming writer queue: data flag %c, %u bytes.\",\r\n                    data_flag,\r\n                    expected_len)));\r\n        } else\r\n            empty_streaming_body = false;\r\n\r\n        cur_buf += (expected_len - (sizeof(uint32) + 1));\r\n        left_len -= expected_len;\r\n\r\n        wakeupWalRcvWriter();\r\n    }\r\n    Assert(left_len == 0);\r\n\r\n    wakeupWalRcvWriter();\r\n}",
		"comment":"/*\r\n * Receive all the required replication data page.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"WalDataRcvReceive"
	},
	"WalRcvDie":{
		"body":"static void WalRcvDie(int code, Datum arg)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    ThreadId writerPid;\r\n    const int COUNTS = 2000;\r\n    int i = 1;\r\n\r\n    /*\r\n     * Shutdown WalRcvWriter thread, clear the data receive buffer.\r\n     * Ensure that all WAL records received are flushed to disk.\r\n     */\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    writerPid = walrcv->writerPid;\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    if (writerPid != 0)\r\n        (void)gs_signal_send(writerPid, SIGTERM);\r\n\r\n    ereport(LOG, (errmsg(\"waiting walrcvwriter: %lu terminate\", writerPid)));\r\n\r\n    while (writerPid) {\r\n        pg_usleep(10000L);  // sleep 0.01s\r\n\r\n        SpinLockAcquire(&walrcv->mutex);\r\n        writerPid = walrcv->writerPid;\r\n        SpinLockRelease(&walrcv->mutex);\r\n\r\n        if ((writerPid != 0) && (i % COUNTS == 0)) {\r\n            if (gs_signal_send(writerPid, SIGTERM) != 0) {\r\n                ereport(WARNING, (errmsg(\"walrcvwriter:%lu may be terminated\", writerPid)));\r\n                break;\r\n            }\r\n            i = 1;\r\n        }\r\n        i++;\r\n    }\r\n\r\n    walRcvDataCleanup();\r\n\r\n    LWLockAcquire(WALWriteLock, LW_EXCLUSIVE);\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    Assert(walrcv->walRcvState == WALRCV_RUNNING || walrcv->walRcvState == WALRCV_STOPPING);\r\n    walrcv->walRcvState = WALRCV_STOPPED;\r\n    walrcv->pid = 0;\r\n    walrcv->lwpId = 0;\r\n    walrcv->isRuning = false;\r\n    if (walrcv->walRcvCtlBlock != NULL)\r\n        walrcv->walRcvCtlBlock = NULL;\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    walRcvCtlBlockFini();\r\n    LWLockRelease(WALWriteLock);\r\n\r\n    /* Terminate the connection gracefully. */\r\n    libpqrcv_disconnect();\r\n\r\n    /* Wake up the startup process to notice promptly that we're gone */\r\n    WakeupRecovery();\r\n\r\n    if (t_thrd.libwalreceiver_cxt.recvBuf != NULL) {\r\n        PQfreemem(t_thrd.libwalreceiver_cxt.recvBuf);\r\n        t_thrd.libwalreceiver_cxt.recvBuf = NULL;\r\n    }\r\n\r\n    ereport(LOG, (errmsg(\"walreceiver thread shut down\")));\r\n}",
		"comment":"/*\r\n * Mark us as STOPPED in shared memory at exit.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"WalRcvDie"
	},
	"WalRcvIsShutdown":{
		"body":"bool WalRcvIsShutdown(void)\r\n{\r\n    return t_thrd.walreceiver_cxt.got_SIGTERM;\r\n}",
		"comment":"/* Wal receiver is shut down? */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"WalRcvIsShutdown"
	},
	"WalRcvQuickDieHandler":{
		"body":"static void WalRcvQuickDieHandler(SIGNAL_ARGS)\r\n{\r\n    gs_signal_setmask(&t_thrd.libpq_cxt.BlockSig, NULL);\r\n\r\n    /*\r\n     * We DO NOT want to run proc_exit() callbacks -- we're here because\r\n     * shared memory may be corrupted, so we don't want to try to clean up our\r\n     * transaction.  Just nail the windows shut and get out of town.  Now that\r\n     * there's an atexit callback to prevent third-party code from breaking\r\n     * things by calling exit() directly, we have to reset the callbacks\r\n     * explicitly to make this work as intended.\r\n     */\r\n    on_exit_reset();\r\n\r\n    /*\r\n     * Note we do exit(2) not exit(0).	This is to force the postmaster into a\r\n     * system reset cycle if some idiot DBA sends a manual SIGQUIT to a random\r\n     * backend.  This is necessary precisely because we don't clean up our\r\n     * shared memory state.  (The \"dead man switch\" mechanism in pmsignal.c\r\n     * should ensure the postmaster sees this as a crash, too, but no harm in\r\n     * being doubly sure.)\r\n     */\r\n    exit(2);\r\n}",
		"comment":"/*\r\n * WalRcvQuickDieHandler() occurs when signalled SIGQUIT by the postmaster.\r\n *\r\n * Some backend has bought the farm, so we need to stop what we're doing and\r\n * exit.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"WalRcvQuickDieHandler"
	},
	"WalRcvRefreshPercentCountStartLsn":{
		"body":"static void WalRcvRefreshPercentCountStartLsn(XLogRecPtr currentMaxLsn, XLogRecPtr currentDoneLsn)\r\n{\r\n    uint64 coundWindow = ((uint64)WalGetSyncCountWindow() * XLOG_SEG_SIZE);\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    XLogRecPtr baseStartLsn = InvalidXLogRecPtr;\r\n\r\n    if (!walrcv) {\r\n        return;\r\n    }\r\n\r\n    /* clear syncPercentCountStart when recevier's redo equal to sender's flush */\r\n    if (XLByteEQ(currentMaxLsn, currentDoneLsn)) {\r\n        WalRcvSetPercentCountStartLsn(InvalidXLogRecPtr);\r\n        return;\r\n    }\r\n\r\n    /* if syncPercentCountStart is valid, it means last counting cycle has not been done. */\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    baseStartLsn = walrcv->syncPercentCountStart;\r\n    SpinLockRelease(&walrcv->mutex);\r\n    if (!XLByteEQ(baseStartLsn, InvalidXLogRecPtr)) {\r\n        return;\r\n    }\r\n\r\n    /* starting a new counting cycle. */\r\n    if (XLogDiff(currentMaxLsn, currentDoneLsn) < coundWindow) {\r\n        WalRcvSetPercentCountStartLsn(InvalidXLogRecPtr);\r\n    } else {\r\n        WalRcvSetPercentCountStartLsn(currentDoneLsn);\r\n    }\r\n}",
		"comment":"/* Set start send lsn for current walsender (only called in walsender) */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"WalRcvRefreshPercentCountStartLsn"
	},
	"WalRcvSetPercentCountStartLsn":{
		"body":"void WalRcvSetPercentCountStartLsn(XLogRecPtr startLsn)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    walrcv->syncPercentCountStart = startLsn;\r\n    SpinLockRelease(&walrcv->mutex);\r\n}",
		"comment":"/* Set start send lsn for current walsender (only called in walsender) */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"WalRcvSetPercentCountStartLsn"
	},
	"WalRcvShutdownHandler":{
		"body":"static void WalRcvShutdownHandler(SIGNAL_ARGS)\r\n{\r\n    t_thrd.walreceiver_cxt.got_SIGTERM = true;\r\n}",
		"comment":"/* SIGTERM: set flag for main loop, or shutdown immediately if safe */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"WalRcvShutdownHandler"
	},
	"WalRcvSigHupHandler":{
		"body":"static void WalRcvSigHupHandler(SIGNAL_ARGS)\r\n{\r\n    t_thrd.walreceiver_cxt.got_SIGHUP = true;\r\n}",
		"comment":"/* SIGHUP: set flag to re-read config file at next convenient time */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"WalRcvSigHupHandler"
	},
	"WalRecCheckTimeOut":{
		"body":"static bool WalRecCheckTimeOut(TimestampTz nowtime, TimestampTz last_recv_timestamp, bool ping_sent)\r\n{\r\n    bool requestReply = false;\r\n    TimestampTz timeout;\r\n\r\n    /* don't bail out if we're doing something that doesn't require timeouts */\r\n    if (u_sess->attr.attr_storage.wal_receiver_timeout <= 0) {\r\n        return requestReply;\r\n    }\r\n\r\n    /*\r\n     * Use static last_reply_time to avoid call GetHeartbeatLastReplyTimestamp frequently\r\n     * when last_recv_timestamp has meet the timeout condition\r\n     * but last heartbeat time doesn't.\r\n     */\r\n    static TimestampTz last_reply_time = last_recv_timestamp;\r\n    if (timestamptz_cmp_internal(last_recv_timestamp, last_reply_time) > 0) {\r\n        last_reply_time = last_recv_timestamp;\r\n    }\r\n\r\n    timeout = CalculateTimeout(last_reply_time);\r\n    if (nowtime < timeout) {\r\n        return requestReply;\r\n    }\r\n\r\n    TimestampTz heartbeat = GetHeartbeatLastReplyTimestamp();\r\n    /* If heartbeat newer, use heartbeat to recalculate timeout. */\r\n    if (timestamptz_cmp_internal(heartbeat, last_reply_time) > 0) {\r\n        last_reply_time = heartbeat;\r\n        timeout = CalculateTimeout(last_reply_time);\r\n    }\r\n\r\n    /*\r\n     * We didn't receive anything new, for half of receiver\r\n     * replication timeout. Ping the server.\r\n     */\r\n    if (nowtime >= timeout) {\r\n        ereport(DEBUG2,\r\n            (errmsg(\"now time(%s) timeout time(%s) last recv time(%s), heartbeat time(%s), ping_sent(%d)\",\r\n                timestamptz_to_str(nowtime),\r\n                timestamptz_to_str(timeout),\r\n                timestamptz_to_str(last_recv_timestamp),\r\n                timestamptz_to_str(heartbeat),\r\n                ping_sent)));\r\n\r\n        if (!ping_sent) {\r\n            requestReply = true;\r\n        } else {\r\n            knl_g_set_is_local_redo_finish(false);\r\n            ereport(LOG, (errmsg(\"set knl_g_set_is_local_redo_finish to false in WalRecCheckTimeOut\")));\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_CONNECTION_TIMED_OUT),\r\n                    errmsg(\"terminating walreceiver due to timeout \"\r\n                           \"now time(%s) timeout time(%s) last recv time(%s) heartbeat time(%s)\",\r\n                        timestamptz_to_str(nowtime),\r\n                        timestamptz_to_str(timeout),\r\n                        timestamptz_to_str(last_recv_timestamp),\r\n                        timestamptz_to_str(heartbeat))));\r\n        }\r\n    }\r\n    return requestReply;\r\n}",
		"comment":"/*\r\n * Check if time since last receive from primary has reached the\r\n * configured limit. If we didn't receive anything new for half of receiver\r\n * replication timeout, need ping the server.\r\n *\r\n * NB: the timeout stategy is different from the sender due to ping_sent,\r\n * if pint_sent is set true,  abnormal heartbeat for (wal_receiver_timeout / 2) will cause timeout.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"WalRecCheckTimeOut"
	},
	"WalReceiverMain":{
		"body":"void WalReceiverMain(void)\r\n{\r\n    char conninfo[MAXCONNINFO];\r\n    char slotname[NAMEDATALEN];\r\n    XLogRecPtr startpoint;\r\n    TimestampTz last_recv_timestamp;\r\n    bool ping_sent = false;\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    int channel_identifier = 0;\r\n    int nRet = 0;\r\n    errno_t rc = 0;\r\n\r\n    t_thrd.walreceiver_cxt.last_sendfilereply_timestamp = GetCurrentTimestamp();\r\n    t_thrd.walreceiver_cxt.standby_config_modify_time = time(NULL);\r\n\r\n    /*\r\n     * WalRcv should be set up already (if we are a backend, we inherit this\r\n     * by fork() or EXEC_BACKEND mechanism from the postmaster).\r\n     */\r\n    Assert(walrcv != NULL);\r\n\r\n    ereport(LOG, (errmsg(\"walreceiver thread started\")));\r\n\r\n    /* Initialize walrcv buffer for walreceive optimization */\r\n    walRcvCtlBlockInit();\r\n\r\n    /*\r\n     * Mark walreceiver as running in shared memory.\r\n     *\r\n     * Do this as early as possible, so that if we fail later on, we'll set\r\n     * state to STOPPED. If we die before this, the startup process will keep\r\n     * waiting for us to start up, until it times out.\r\n     */\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    Assert(walrcv->pid == 0);\r\n    switch (walrcv->walRcvState) {\r\n        case WALRCV_STOPPING:\r\n            /* If we've already been requested to stop, don't start up. */\r\n            walrcv->walRcvState = WALRCV_STOPPED;\r\n            // lint -fallthrough\r\n        case WALRCV_STOPPED:\r\n            SpinLockRelease(&walrcv->mutex);\r\n            ereport(WARNING, (errmsg(\"walreceiver requested to stop when starting up.\")));\r\n            proc_exit(1);\r\n            break;\r\n\r\n        case WALRCV_STARTING:\r\n            /* The usual case */\r\n            break;\r\n\r\n        case WALRCV_RUNNING:\r\n            /* Shouldn't happen */\r\n            ereport(PANIC, (errmsg(\"walreceiver still running according to shared memory state\")));\r\n    }\r\n    /* Advertise our PID so that the startup process can kill us */\r\n    if (walrcv->conn_target == REPCONNTARGET_PRIMARY)\r\n        walrcv->node_state = NODESTATE_NORMAL;\r\n    walrcv->pid = t_thrd.proc_cxt.MyProcPid;\r\n#ifndef WIN32\r\n    walrcv->lwpId = syscall(SYS_gettid);\r\n#else\r\n    walrcv->lwpId = (int)t_thrd.proc_cxt.MyProcPid;\r\n#endif\r\n    walrcv->isRuning = false;\r\n    walrcv->walRcvState = WALRCV_RUNNING;\r\n\r\n    rc = memset_s(slotname, NAMEDATALEN, 0, NAMEDATALEN);\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n\r\n    rc = memset_s(conninfo, MAXCONNINFO, 0, MAXCONNINFO);\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n\r\n    /* Fetch information required to start streaming */\r\n    rc = strncpy_s(conninfo, MAXCONNINFO, (char*)walrcv->conninfo, MAXCONNINFO - 1);\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n    rc = strncpy_s(slotname, NAMEDATALEN, (char*)walrcv->slotname, NAMEDATALEN - 1);\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n\r\n    startpoint = walrcv->receiveStart;\r\n\r\n    /* Initialise to a sanish value */\r\n    walrcv->lastMsgSendTime = walrcv->lastMsgReceiptTime = walrcv->latestWalEndTime = GetCurrentTimestamp();\r\n\r\n    walrcv->walRcvCtlBlock = t_thrd.walreceiver_cxt.walRcvCtlBlock;\r\n\r\n    t_thrd.walreceiver_cxt.AmWalReceiverForFailover = (walrcv->conn_target == REPCONNTARGET_DUMMYSTANDBY ||\r\n        walrcv->conn_target == REPCONNTARGET_STANDBY) ? true : false;\r\n\r\n    t_thrd.walreceiver_cxt.AmWalReceiverForStandby = (walrcv->conn_target == REPCONNTARGET_STANDBY) ? true : false;\r\n\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    /* using localport for channel identifier */\r\n    if (!t_thrd.walreceiver_cxt.AmWalReceiverForStandby) {\r\n        volatile HaShmemData* hashmdata = t_thrd.postmaster_cxt.HaShmData;\r\n        SpinLockAcquire(&hashmdata->mutex);\r\n        int walreplindex = hashmdata->current_repl;\r\n        SpinLockRelease(&hashmdata->mutex);\r\n\r\n        if (t_thrd.postmaster_cxt.ReplConnArray[walreplindex])\r\n            channel_identifier = t_thrd.postmaster_cxt.ReplConnArray[walreplindex]->localport;\r\n    }\r\n\r\n    /* Arrange to clean up at walreceiver exit */\r\n    on_shmem_exit(WalRcvDie, 0);\r\n\r\n    /* Reset some signals that are accepted by postmaster but not here */\r\n    (void)gspqsignal(SIGHUP, WalRcvSigHupHandler); /* set flag to read config file */\r\n    (void)gspqsignal(SIGINT, SIG_IGN);\r\n    (void)gspqsignal(SIGTERM, WalRcvShutdownHandler); /* request shutdown */\r\n    (void)gspqsignal(SIGQUIT, WalRcvQuickDieHandler); /* hard crash time */\r\n    (void)gspqsignal(SIGALRM, SIG_IGN);\r\n    (void)gspqsignal(SIGPIPE, SIG_IGN);\r\n    (void)gspqsignal(SIGUSR1, sigusr1_handler);\r\n    (void)gspqsignal(SIGUSR2, SIG_IGN);\r\n\r\n    /* Reset some signals that are accepted by postmaster but not here */\r\n    (void)gspqsignal(SIGCHLD, SIG_DFL);\r\n    (void)gspqsignal(SIGTTIN, SIG_DFL);\r\n    (void)gspqsignal(SIGTTOU, SIG_DFL);\r\n    (void)gspqsignal(SIGCONT, SIG_DFL);\r\n    (void)gspqsignal(SIGWINCH, SIG_DFL);\r\n\r\n    /* We allow SIGQUIT (quickdie) at all times */\r\n    sigdelset(&t_thrd.libpq_cxt.BlockSig, SIGQUIT);\r\n\r\n    /*\r\n     * Create a resource owner to keep track of our resources (not clear that\r\n     * we need this, but may as well have one).\r\n     */\r\n    t_thrd.utils_cxt.CurrentResourceOwner = ResourceOwnerCreate(NULL, \"Wal Receiver\");\r\n\r\n    /* Unblock signals (they were blocked when the postmaster forked us) */\r\n    gs_signal_setmask(&t_thrd.libpq_cxt.UnBlockSig, NULL);\r\n    (void)gs_signal_unblock_sigusr2();\r\n\r\n    SetWalRcvDummyStandbySyncPercent(0);\r\n\r\n    /* Establish the connection to the primary for XLOG streaming */\r\n    EnableWalRcvImmediateExit();\r\n    libpqrcv_connect(conninfo, &startpoint, slotname[0] != '\\0' ? slotname : NULL, channel_identifier);\r\n    DisableWalRcvImmediateExit();\r\n\r\n    if (GetWalRcvDummyStandbySyncPercent() == SYNC_DUMMY_STANDBY_END) {\r\n        Assert(t_thrd.walreceiver_cxt.AmWalReceiverForFailover == true);\r\n        ereport(LOG, (errmsg(\"Secondary Standby has no xlog\")));\r\n    }\r\n\r\n    rc = memset_s(t_thrd.walreceiver_cxt.reply_message, sizeof(StandbyReplyMessage), 0, sizeof(StandbyReplyMessage));\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n    rc = memset_s(\r\n        t_thrd.walreceiver_cxt.feedback_message, sizeof(StandbyHSFeedbackMessage), 0, sizeof(StandbyHSFeedbackMessage));\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n    ereport(LOG, (errmsg(\"start replication at start point %X/%X\", (uint32)(startpoint >> 32), (uint32)startpoint)));\r\n\r\n    last_recv_timestamp = GetCurrentTimestamp();\r\n\r\n    if (t_thrd.proc_cxt.DataDir) {\r\n        nRet = snprintf_s(t_thrd.walreceiver_cxt.gucconf_file,\r\n            MAXPGPATH,\r\n            MAXPGPATH - 1,\r\n            \"%s/postgresql.conf\",\r\n            t_thrd.proc_cxt.DataDir);\r\n        securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n\r\n        nRet = snprintf_s(t_thrd.walreceiver_cxt.temp_guc_conf_file,\r\n            MAXPGPATH,\r\n            MAXPGPATH - 1,\r\n            \"%s/%s\",\r\n            t_thrd.proc_cxt.DataDir,\r\n            TEMP_CONF_FILE);\r\n        securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n\r\n        nRet = snprintf_s(t_thrd.walreceiver_cxt.gucconf_lock_file,\r\n            MAXPGPATH,\r\n            MAXPGPATH - 1,\r\n            \"%s/postgresql.conf.lock\",\r\n            t_thrd.proc_cxt.DataDir);\r\n        securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n    }\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    walrcv->isRuning = true;\r\n    walrcv->local_write_pos.queueid = 0;\r\n    walrcv->local_write_pos.queueoff = 0;\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    if (!dummyStandbyMode) {\r\n        SpinLockAcquire(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n        t_thrd.walreceiver_cxt.walRcvCtlBlock->receivePtr = t_thrd.walreceiver_cxt.walRcvCtlBlock->writePtr =\r\n            t_thrd.walreceiver_cxt.walRcvCtlBlock->flushPtr = GetXLogReplayRecPtr(NULL);\r\n        SpinLockRelease(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n    } else {\r\n        SpinLockAcquire(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n        t_thrd.walreceiver_cxt.walRcvCtlBlock->receivePtr = t_thrd.walreceiver_cxt.walRcvCtlBlock->writePtr =\r\n            t_thrd.walreceiver_cxt.walRcvCtlBlock->flushPtr = startpoint;\r\n        SpinLockRelease(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n    }\r\n\r\n    /*\r\n     * Synchronize standby's configure file once the HA build successfully.\r\n     *\r\n     * Note: If switchover in one hour, and there is no parameter is reloaded,\r\n     * the parameters set by client will be disabled. So we should do this.\r\n     */\r\n    firstSynchStandbyFile();\r\n\r\n    set_disable_conn_mode();\r\n    knl_g_set_is_local_redo_finish(false);\r\n    ereport(LOG, (errmsg(\"set knl_g_set_is_local_redo_finish to false when connecting to the primary\")));\r\n\r\n    /* Loop until end-of-streaming or error */\r\n    for (;;) {\r\n        unsigned char type;\r\n        char* buf = NULL;\r\n        int len;\r\n\r\n#ifdef ENABLE_DISTRIBUTE_TEST\r\n        if (TEST_STUB(DN_WALRECEIVE_MAINLOOP, stub_sleep_emit)) {\r\n            ereport(get_distribute_test_param()->elevel,\r\n                (errmsg(\"sleep_emit happen during WalReceiverMain  time:%ds, stub_name:%s\",\r\n                    get_distribute_test_param()->sleep_time,\r\n                    get_distribute_test_param()->test_stub_name)));\r\n        }\r\n#endif\r\n\r\n        /*\r\n         * Emergency bailout if postmaster has died.  This is to avoid the\r\n         * necessity for manual cleanup of all postmaster children.\r\n         */\r\n        if (!PostmasterIsAlive())\r\n            gs_thread_exit(1);\r\n\r\n        RefuseConnect();\r\n\r\n        /*\r\n         * Exit walreceiver if we're not in recovery. This should not happen,\r\n         * but cross-check the status here.\r\n         */\r\n        if (!RecoveryInProgress())\r\n            ereport(FATAL, (errmsg(\"cannot continue WAL streaming, recovery has already ended\")));\r\n\r\n        /* Process any requests or signals received recently */\r\n        ProcessWalRcvInterrupts();\r\n\r\n        if (t_thrd.walreceiver_cxt.got_SIGHUP) {\r\n            t_thrd.walreceiver_cxt.got_SIGHUP = false;\r\n            ProcessConfigFile(PGC_SIGHUP);\r\n        }\r\n\r\n        if (!WalRcvWriterInProgress())\r\n            ereport(FATAL, (errmsg(\"terminating walreceiver process due to the death of walrcvwriter\")));\r\n\r\n        if (t_thrd.walreceiver_cxt.start_switchover) {\r\n            t_thrd.walreceiver_cxt.start_switchover = false;\r\n            XLogWalRcvSendSwitchRequest();\r\n        }\r\n\r\n        /* Wait a while for data to arrive */\r\n        if (libpqrcv_receive(NAPTIME_PER_CYCLE, &type, &buf, &len)) {\r\n            last_recv_timestamp = GetCurrentTimestamp();\r\n            ping_sent = false;\r\n            /* Accept the received data, and process it */\r\n            XLogWalRcvProcessMsg(type, buf, len);\r\n\r\n            /* Receive any more data we can without sleeping */\r\n            while (libpqrcv_receive(0, &type, &buf, &len)) {\r\n                last_recv_timestamp = GetCurrentTimestamp();\r\n                XLogWalRcvProcessMsg(type, buf, len);\r\n            }\r\n\r\n            /* Let the master know that we received some data. */\r\n            XLogWalRcvSendReply(false, false);\r\n        } else {\r\n            /*\r\n             * We didn't receive anything new. If we haven't heard anything\r\n             * from the server for more than u_sess->attr.attr_storage.wal_receiver_timeout / 2,\r\n             * ping the server. Also, if it's been longer than\r\n             * u_sess->attr.attr_storage.wal_receiver_status_interval since the last update we sent,\r\n             * send a status update to the master anyway, to report any\r\n             * progress in applying WAL.\r\n             */\r\n            TimestampTz nowtime = GetCurrentTimestamp();\r\n            bool requestReply = WalRecCheckTimeOut(nowtime, last_recv_timestamp, ping_sent);\r\n            if (requestReply) {\r\n                ping_sent = true;\r\n                last_recv_timestamp = nowtime;\r\n            }\r\n\r\n            XLogWalRcvSendReply(requestReply, requestReply);\r\n            XLogWalRcvSendHSFeedback();\r\n        }\r\n        ConfigFileTimer();\r\n    }\r\n}",
		"comment":"/* Main entry point for walreceiver process */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"WalReceiverMain"
	},
	"XLogWalRcvDataPageReplication":{
		"body":"static void XLogWalRcvDataPageReplication(char* buf, Size len)\r\n{\r\n    WalDataPageMessageHeader msghdr;\r\n    Assert(true == g_instance.attr.attr_storage.enable_mix_replication);\r\n\r\n    if (!g_instance.attr.attr_storage.enable_mix_replication) {\r\n        ereport(PANIC, (errmsg(\"WAL streaming isn't employed to sync all the replication data log.\")));\r\n    }\r\n    if (len < sizeof(WalDataPageMessageHeader)) {\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_PROTOCOL_VIOLATION),\r\n                errmsg_internal(\"invalid wal data page message received from primary\")));\r\n    }\r\n\r\n    /* memcpy is required here for alignment reasons */\r\n    error_t rc = memcpy_s(&msghdr, sizeof(WalDataPageMessageHeader), buf, sizeof(WalDataPageMessageHeader));\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n\r\n    ProcessWalDataHeaderMessage(&msghdr);\r\n\r\n    buf += sizeof(WalDataPageMessageHeader);\r\n    len -= sizeof(WalDataPageMessageHeader);\r\n\r\n    if (len > WS_MAX_DATA_QUEUE_SIZE) {\r\n        Assert(false);\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_PROTOCOL_VIOLATION),\r\n                errmsg_internal(\r\n                    \"unexpected wal data size %lu bytes exceeds the max receiving data queue size %u bytes\",\r\n                    len,\r\n                    WS_MAX_DATA_QUEUE_SIZE)));\r\n    }\r\n    if (u_sess->attr.attr_storage.HaModuleDebug) {\r\n        WSDataRcvCheck(buf, len);\r\n    }\r\n    WalDataRcvReceive(buf, len, 0);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"XLogWalRcvDataPageReplication"
	},
	"XLogWalRcvProcessMsg":{
		"body":"static void XLogWalRcvProcessMsg(unsigned char type, char* buf, Size len)\r\n{\r\n    errno_t errorno = EOK;\r\n\r\n    ereport(DEBUG5, (errmsg(\"received wal message type: %c\", type)));\r\n\r\n    switch (type) {\r\n        case 'e': /* dummy standby sendxlog end. */\r\n        {\r\n            EndXLogMessage endXLogMessage;\r\n\r\n            if (len != sizeof(EndXLogMessage))\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_PROTOCOL_VIOLATION),\r\n                        errmsg_internal(\"invalid EndXLogMessage message received from Secondary Standby\")));\r\n            /* memcpy is required here for alignment reasons */\r\n            errorno = memcpy_s(&endXLogMessage, sizeof(EndXLogMessage), buf, sizeof(EndXLogMessage));\r\n            securec_check(errorno, \"\\0\", \"\\0\");\r\n            ProcessEndXLogMessage(&endXLogMessage);\r\n            break;\r\n        }\r\n        case 'w': /* WAL records */\r\n        {\r\n            WalDataMessageHeader msghdr;\r\n\r\n            if (len < sizeof(WalDataMessageHeader))\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_PROTOCOL_VIOLATION),\r\n                        errmsg_internal(\"invalid WAL message received from primary\")));\r\n            /* memcpy is required here for alignment reasons */\r\n            errorno = memcpy_s(&msghdr, sizeof(WalDataMessageHeader), buf, sizeof(WalDataMessageHeader));\r\n            securec_check(errorno, \"\\0\", \"\\0\");\r\n\r\n            ProcessWalHeaderMessage(&msghdr);\r\n\r\n            buf += sizeof(WalDataMessageHeader);\r\n            len -= sizeof(WalDataMessageHeader);\r\n            if (IsExtremeRedo()) {\r\n                XLogWalRcvReceiveInBuf(buf, len, msghdr.dataStart);\r\n            } else {\r\n                XLogWalRcvReceive(buf, len, msghdr.dataStart);\r\n            }\r\n            break;\r\n        }\r\n        case 'd': /* Data page replication for the logical xlog */\r\n        {\r\n            XLogWalRcvDataPageReplication(buf, len);\r\n            break;\r\n        }\r\n        case 'k': /* Keepalive */\r\n        {\r\n            PrimaryKeepaliveMessage keepalive;\r\n            if (len != sizeof(PrimaryKeepaliveMessage))\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_PROTOCOL_VIOLATION),\r\n                        errmsg_internal(\"invalid keepalive message received from primary\")));\r\n            /* memcpy is required here for alignment reasons */\r\n            errorno = memcpy_s(&keepalive, sizeof(PrimaryKeepaliveMessage), buf, sizeof(PrimaryKeepaliveMessage));\r\n            securec_check(errorno, \"\\0\", \"\\0\");\r\n\r\n            ProcessKeepaliveMessage(&keepalive);\r\n\r\n            /* If the primary requested a reply, send one immediately */\r\n            if (keepalive.replyRequested)\r\n                XLogWalRcvSendReply(true, false);\r\n            break;\r\n        }\r\n        case 'p': /* Promote standby */\r\n        {\r\n            PrimarySwitchResponseMessage response;\r\n\r\n            if (len != sizeof(PrimarySwitchResponseMessage))\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_PROTOCOL_VIOLATION),\r\n                        errmsg_internal(\"invalid switchover response message received from primary\")));\r\n            /* memcpy is required here for alignment reasons */\r\n            errorno =\r\n                memcpy_s(&response, sizeof(PrimarySwitchResponseMessage), buf, sizeof(PrimarySwitchResponseMessage));\r\n            securec_check(errorno, \"\\0\", \"\\0\");\r\n            ProcessWalSndrMessage(&response.walEnd, response.sendTime);\r\n\r\n            ereport(LOG, (errmsg(\"received switchover response message from primary\")));\r\n            ProcessSwitchResponse(response.switchResponse);\r\n            break;\r\n        }\r\n        case 'm': /* config file */\r\n        {\r\n            ConfigModifyTimeMessage primary_config_file;\r\n\r\n            if (len < sizeof(ConfigModifyTimeMessage))\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_PROTOCOL_VIOLATION),\r\n                        errmsg_internal(\"invalid config file message\")));\r\n            /* memcpy is required here for alignment reasons */\r\n            errorno =\r\n                memcpy_s(&primary_config_file, sizeof(ConfigModifyTimeMessage), buf, sizeof(ConfigModifyTimeMessage));\r\n            securec_check(errorno, \"\\0\", \"\\0\");\r\n            t_thrd.walreceiver_cxt.Primary_config_modify_time = primary_config_file.config_modify_time;\r\n            buf += sizeof(ConfigModifyTimeMessage);\r\n            len -= sizeof(ConfigModifyTimeMessage);\r\n            ereport(LOG, (errmsg(\"walreceiver received gaussdb config file size: %lu\", len)));\r\n            if (true != ProcessConfigFileMessage(buf, len)) {\r\n                ereport(LOG, (errmsg(\"walreceiver update config file failed\")));\r\n            }\r\n            break;\r\n        }\r\n        case 'x': /* rm xlog */\r\n        {\r\n            RmXLogMessage rmXLogMessage;\r\n\r\n            if (len != sizeof(RmXLogMessage))\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_PROTOCOL_VIOLATION),\r\n                        errmsg_internal(\"invalid RmXLog message received from primary\")));\r\n            /* memcpy is required here for alignment reasons */\r\n            errorno = memcpy_s(&rmXLogMessage, sizeof(RmXLogMessage), buf, sizeof(RmXLogMessage));\r\n            securec_check(errorno, \"\\0\", \"\\0\");\r\n            ProcessRmXLogMessage(&rmXLogMessage);\r\n            break;\r\n        }\r\n        default:\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_PROTOCOL_VIOLATION), errmsg_internal(\"invalid replication message type %c\", type)));\r\n    }\r\n}",
		"comment":"/*\r\n * Accept the message from XLOG stream, and process it.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"XLogWalRcvProcessMsg"
	},
	"XLogWalRcvReceive":{
		"body":"static void\r\nXLogWalRcvReceive(char *buf, Size nbytes, XLogRecPtr recptr)\r\n{\r\n	int			walfreeoffset;\r\n	int			walwriteoffset;\r\n	char	   *walrecvbuf = NULL;\r\n	XLogRecPtr	startptr;\r\n	int			recBufferSize = g_instance.attr.attr_storage.WalReceiverBufSize * 1024;\r\n\r\n	while (nbytes > 0)\r\n	{\r\n		int		segbytes;\r\n		int		endPoint = recBufferSize;\r\n		errno_t errorno = EOK;\r\n\r\n		SpinLockAcquire(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n		if (t_thrd.walreceiver_cxt.walRcvCtlBlock->walFreeOffset == t_thrd.walreceiver_cxt.walRcvCtlBlock->walWriteOffset)\r\n		{\r\n			// no data to be flushed\r\n			t_thrd.walreceiver_cxt.walRcvCtlBlock->walStart = recptr;\r\n		}\r\n		else if (t_thrd.walreceiver_cxt.walRcvCtlBlock->walFreeOffset == recBufferSize && \r\n			t_thrd.walreceiver_cxt.walRcvCtlBlock->walWriteOffset > 0)\r\n		{\r\n			t_thrd.walreceiver_cxt.walRcvCtlBlock->walFreeOffset = 0;\r\n		}\r\n		walfreeoffset = t_thrd.walreceiver_cxt.walRcvCtlBlock->walFreeOffset;\r\n		walwriteoffset = t_thrd.walreceiver_cxt.walRcvCtlBlock->walWriteOffset;\r\n		walrecvbuf = t_thrd.walreceiver_cxt.walRcvCtlBlock->walReceiverBuffer;\r\n		startptr = t_thrd.walreceiver_cxt.walRcvCtlBlock->walStart;\r\n		SpinLockRelease(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n\r\n		ereport(DEBUG5,\r\n				(errmsg(\"XLogWalRcvReceive: recptr(%u:%X),nbytes(%d),\"\r\n						\"walfreeoffset(%d),walwriteoffset(%d),startptr(%u:%X)\",\r\n						(uint32) (recptr >> 32), (uint32) recptr, (int)nbytes, walfreeoffset,\r\n						walwriteoffset, (uint32) (startptr >> 32), (uint32) startptr)));\r\n\r\n		XLogWalRcvSendReply(false, false);\r\n\r\n		Assert(walrecvbuf != NULL);\r\n		Assert(walfreeoffset <= recBufferSize);\r\n		Assert(walwriteoffset <= recBufferSize);\r\n\r\n		if (walfreeoffset < walwriteoffset)\r\n		{\r\n			endPoint = walwriteoffset - 1;\r\n		}\r\n\r\n		if (endPoint == walfreeoffset)\r\n		{\r\n			if (WalRcvWriterInProgress())\r\n			{\r\n				wakeupWalRcvWriter();\r\n				/* Process any requests or signals received recently */\r\n				ProcessWalRcvInterrupts();\r\n				/* Keepalived with primary when waiting flush wal data */\r\n				XLogWalRcvSendReply(false, false);\r\n				pg_usleep(1000);\r\n			}\r\n			else\r\n				walRcvDataCleanup();\r\n			continue;\r\n\r\n		}\r\n\r\n		if (walfreeoffset + (int)nbytes > endPoint)\r\n			segbytes = endPoint - walfreeoffset;\r\n		else\r\n			segbytes = nbytes;\r\n\r\n		/* Need to seek in the buffer? */\r\n		if (walfreeoffset != walwriteoffset)\r\n		{\r\n			if (walfreeoffset > walwriteoffset)\r\n			{\r\n				XLByteAdvance(startptr, (uint32)(walfreeoffset - walwriteoffset));\r\n			}\r\n			else\r\n			{\r\n				XLByteAdvance(startptr, (uint32)(recBufferSize - walwriteoffset + walfreeoffset));\r\n			}\r\n			if (!XLByteEQ(startptr, recptr))\r\n			{\r\n				/* wait for finishing flushing all wal data */\r\n				while (true)\r\n				{\r\n					SpinLockAcquire(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n					if (t_thrd.walreceiver_cxt.walRcvCtlBlock->walFreeOffset == t_thrd.walreceiver_cxt.walRcvCtlBlock->walWriteOffset)\r\n					{\r\n						t_thrd.walreceiver_cxt.walRcvCtlBlock->walStart = recptr;\r\n						SpinLockRelease(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n						break;\r\n					}\r\n					SpinLockRelease(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n\r\n					if (WalRcvWriterInProgress())\r\n					{\r\n						wakeupWalRcvWriter();\r\n						/* Process any requests or signals received recently */\r\n						ProcessWalRcvInterrupts();\r\n						/* Keepalived with primary when waiting flush wal data */\r\n						XLogWalRcvSendReply(false, false);\r\n						pg_usleep(1000);\r\n					}\r\n					else\r\n						walRcvDataCleanup();\r\n				}\r\n\r\n				ereport(FATAL,\r\n					(errmsg(\"Unexpected seek in the walreceiver buffer. \"\r\n							\"xlogrecptr is (%X:%X) but local xlogptr is (%X:%X).\",\r\n							(uint32) (recptr >> 32),\r\n							(uint32) recptr,\r\n							(uint32) (startptr >> 32),\r\n							(uint32) startptr)));\r\n			}\r\n\r\n		}\r\n\r\n		/* OK to receive the logs */\r\n		Assert(walfreeoffset + segbytes <= recBufferSize);\r\n		errorno = memcpy_s(walrecvbuf + walfreeoffset, recBufferSize - walfreeoffset, buf, segbytes);\r\n		securec_check(errorno, \"\\0\", \"\\0\");\r\n\r\n		XLByteAdvance(recptr, (uint32)segbytes);\r\n\r\n		nbytes -= segbytes;\r\n		buf += segbytes;\r\n\r\n		// update shared memory\r\n		SpinLockAcquire(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n		t_thrd.walreceiver_cxt.walRcvCtlBlock->walFreeOffset += segbytes;\r\n		if (t_thrd.walreceiver_cxt.walRcvCtlBlock->walFreeOffset == recBufferSize && \r\n			t_thrd.walreceiver_cxt.walRcvCtlBlock->walWriteOffset > 0)\r\n		{\r\n			t_thrd.walreceiver_cxt.walRcvCtlBlock->walFreeOffset = 0;\r\n		}\r\n		t_thrd.walreceiver_cxt.walRcvCtlBlock->receivePtr = recptr;\r\n		SpinLockRelease(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n\r\n	}\r\n\r\n	wakeupWalRcvWriter();\r\n}",
		"comment":"/*\r\n * Receive XLOG data into receiver buffer.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"XLogWalRcvReceive"
	},
	"XLogWalRcvReceiveInBuf":{
		"body":"static void XLogWalRcvReceiveInBuf(char* buf, Size nbytes, XLogRecPtr recptr)\r\n{\r\n    int64 walfreeoffset;\r\n    int64 walwriteoffset;\r\n    int64 walreadoffset;\r\n    char* walrecvbuf = NULL;\r\n    XLogRecPtr startptr;\r\n    int64 recBufferSize = g_instance.attr.attr_storage.WalReceiverBufSize * 1024;\r\n\r\n    while (nbytes > 0) {\r\n        int segbytes;\r\n        int endPoint = recBufferSize;\r\n        errno_t errorno = EOK;\r\n\r\n        SpinLockAcquire(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n        if (t_thrd.walreceiver_cxt.walRcvCtlBlock->walFreeOffset ==\r\n            t_thrd.walreceiver_cxt.walRcvCtlBlock->walWriteOffset) {\r\n            // no data to be flushed\r\n            t_thrd.walreceiver_cxt.walRcvCtlBlock->walStart = recptr;\r\n        } else if (t_thrd.walreceiver_cxt.walRcvCtlBlock->walFreeOffset == recBufferSize &&\r\n                   t_thrd.walreceiver_cxt.walRcvCtlBlock->walReadOffset > 0) {\r\n            t_thrd.walreceiver_cxt.walRcvCtlBlock->walFreeOffset = 0;\r\n        }\r\n        walfreeoffset = t_thrd.walreceiver_cxt.walRcvCtlBlock->walFreeOffset;\r\n        walwriteoffset = t_thrd.walreceiver_cxt.walRcvCtlBlock->walWriteOffset;\r\n        walreadoffset = t_thrd.walreceiver_cxt.walRcvCtlBlock->walReadOffset;\r\n        walrecvbuf = t_thrd.walreceiver_cxt.walRcvCtlBlock->walReceiverBuffer;\r\n        startptr = t_thrd.walreceiver_cxt.walRcvCtlBlock->walStart;\r\n        SpinLockRelease(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n\r\n        ereport(DEBUG5,\r\n            (errmsg(\"XLogWalRcvReceive: recptr(%X:%X),nbytes(%d),\"\r\n                    \"walfreeoffset(%ld),walwriteoffset(%ld),startptr(%X:%X)\",\r\n                (uint32)(recptr >> 32),\r\n                (uint32)recptr,\r\n                (int)nbytes,\r\n                walfreeoffset,\r\n                walwriteoffset,\r\n                (uint32)(startptr >> 32),\r\n                (uint32)startptr)));\r\n\r\n        XLogWalRcvSendReply(false, false);\r\n\r\n        Assert(walrecvbuf != NULL);\r\n        Assert(walfreeoffset <= recBufferSize);\r\n        Assert(walwriteoffset <= recBufferSize);\r\n        Assert(walreadoffset <= recBufferSize);\r\n\r\n        if (walfreeoffset < walreadoffset) {\r\n            endPoint = walreadoffset - 1;\r\n        }\r\n\r\n        if (endPoint == walfreeoffset) {\r\n            if (WalRcvWriterInProgress()) {\r\n                wakeupWalRcvWriter();\r\n                /* Process any requests or signals received recently */\r\n                ProcessWalRcvInterrupts();\r\n                /* Keepalived with primary when waiting flush wal data */\r\n                XLogWalRcvSendReply(false, false);\r\n                pg_usleep(1000); /* 1ms */\r\n            } else\r\n                walRcvDataCleanup();\r\n            continue;\r\n        }\r\n\r\n        if (walfreeoffset + (int)nbytes > endPoint)\r\n            segbytes = endPoint - walfreeoffset;\r\n        else\r\n            segbytes = nbytes;\r\n\r\n        /* Need to seek in the buffer? */\r\n        if (walfreeoffset != walwriteoffset) {\r\n            if (walfreeoffset > walwriteoffset) {\r\n                XLByteAdvance(startptr, (uint32)(walfreeoffset - walwriteoffset));\r\n            } else {\r\n                XLByteAdvance(startptr, (uint32)(recBufferSize - walwriteoffset + walfreeoffset));\r\n            }\r\n            if (!XLByteEQ(startptr, recptr)) {\r\n                /* wait for finishing flushing all wal data */\r\n                while (true) {\r\n                    SpinLockAcquire(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n                    if (t_thrd.walreceiver_cxt.walRcvCtlBlock->walFreeOffset ==\r\n                        t_thrd.walreceiver_cxt.walRcvCtlBlock->walReadOffset) {\r\n                        t_thrd.walreceiver_cxt.walRcvCtlBlock->walStart = recptr;\r\n                        SpinLockRelease(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n                        break;\r\n                    }\r\n                    SpinLockRelease(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n\r\n                    if (WalRcvWriterInProgress()) {\r\n                        wakeupWalRcvWriter();\r\n                        /* Process any requests or signals received recently */\r\n                        ProcessWalRcvInterrupts();\r\n                        /* Keepalived with primary when waiting flush wal data */\r\n                        XLogWalRcvSendReply(false, false);\r\n                        pg_usleep(1000); /* 1ms */\r\n                    } else\r\n                        walRcvDataCleanup();\r\n                }\r\n\r\n                ereport(FATAL,\r\n                    (errmsg(\"Unexpected seek in the walreceiver buffer. \"\r\n                            \"xlogrecptr is (%X:%X) but local xlogptr is (%X:%X).\",\r\n                        (uint32)(recptr >> 32),\r\n                        (uint32)recptr,\r\n                        (uint32)(startptr >> 32),\r\n                        (uint32)startptr)));\r\n            }\r\n        }\r\n\r\n        /* OK to receive the logs */\r\n        Assert(walfreeoffset + segbytes <= recBufferSize);\r\n        errorno = memcpy_s(walrecvbuf + walfreeoffset, recBufferSize - walfreeoffset, buf, segbytes);\r\n        securec_check(errorno, \"\\0\", \"\\0\");\r\n\r\n        XLByteAdvance(recptr, (uint32)segbytes);\r\n\r\n        nbytes -= segbytes;\r\n        buf += segbytes;\r\n\r\n        // update shared memory\r\n        SpinLockAcquire(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n        t_thrd.walreceiver_cxt.walRcvCtlBlock->walFreeOffset += segbytes;\r\n        if (t_thrd.walreceiver_cxt.walRcvCtlBlock->walFreeOffset == recBufferSize &&\r\n            t_thrd.walreceiver_cxt.walRcvCtlBlock->walReadOffset > 0) {\r\n            t_thrd.walreceiver_cxt.walRcvCtlBlock->walFreeOffset = 0;\r\n        }\r\n        t_thrd.walreceiver_cxt.walRcvCtlBlock->receivePtr = recptr;\r\n        SpinLockRelease(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n    }\r\n\r\n    wakeupWalRcvWriter();\r\n}",
		"comment":"/*\r\n * Receive XLOG data into receiver buffer.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"XLogWalRcvReceiveInBuf"
	},
	"XLogWalRcvSendHSFeedback":{
		"body":"static void XLogWalRcvSendHSFeedback(void)\r\n{\r\n    char buf[sizeof(StandbyHSFeedbackMessage) + 1];\r\n    TimestampTz now;\r\n    TransactionId xmin;\r\n    errno_t rc = 0;\r\n    /*\r\n     * If the user doesn't want status to be reported to the master, be sure\r\n     * to exit before doing anything at all.\r\n     */\r\n    if (u_sess->attr.attr_storage.wal_receiver_status_interval <= 0 || !u_sess->attr.attr_storage.hot_standby_feedback)\r\n        return;\r\n\r\n    /* Get current timestamp. */\r\n    now = GetCurrentTimestamp();\r\n    /*\r\n     * Send feedback at most once per wal_receiver_status_interval.\r\n     */\r\n    if (!TimestampDifferenceExceeds(t_thrd.walreceiver_cxt.feedback_message->sendTime, now,\r\n            u_sess->attr.attr_storage.wal_receiver_status_interval * 1000)) {\r\n        return;\r\n    }\r\n\r\n    /*\r\n     * If Hot Standby is not yet active there is nothing to send. Check this\r\n     * after the interval has expired to reduce number of calls.\r\n     */\r\n    if (!HotStandbyActive())\r\n        return;\r\n\r\n    /*\r\n     * Make the expensive call to get the oldest xmin once we are certain\r\n     * everything else has been checked.\r\n     */\r\n#ifndef ENABLE_MULTIPLE_NODES\r\n    /* Get updated RecentGlobalXmin */\r\n    GetSnapshotData(u_sess->utils_cxt.CurrentSnapshotData, true, true);\r\n#endif\r\n    xmin = GetOldestXmin(NULL);\r\n\r\n    /*\r\n     * Always send feedback message.\r\n     */\r\n    t_thrd.walreceiver_cxt.feedback_message->sendTime = now;\r\n    t_thrd.walreceiver_cxt.feedback_message->xmin = xmin;\r\n\r\n    ereport(\r\n        DEBUG2, (errmsg(\"sending hot standby feedback xmin \" XID_FMT, t_thrd.walreceiver_cxt.feedback_message->xmin)));\r\n\r\n    /* Prepend with the message type and send it. */\r\n    buf[0] = 'h';\r\n    rc = memcpy_s(&buf[1],\r\n        sizeof(StandbyHSFeedbackMessage),\r\n        t_thrd.walreceiver_cxt.feedback_message,\r\n        sizeof(StandbyHSFeedbackMessage));\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n    libpqrcv_send(buf, sizeof(StandbyHSFeedbackMessage) + 1);\r\n}",
		"comment":"/*\r\n * Send hot standby feedback message to primary, plus the current time,\r\n * in case they don't have a watch.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"XLogWalRcvSendHSFeedback"
	},
	"XLogWalRcvSendReply":{
		"body":"void XLogWalRcvSendReply(bool force, bool requestReply)\r\n{\r\n    char buf[sizeof(StandbyReplyMessage) + 1] = {0};\r\n    TimestampTz now;\r\n    XLogRecPtr receivePtr = InvalidXLogRecPtr;\r\n    XLogRecPtr writePtr = InvalidXLogRecPtr;\r\n    XLogRecPtr flushPtr = InvalidXLogRecPtr;\r\n    XLogRecPtr ReplayReadPtr = InvalidXLogRecPtr;\r\n    int rc = 0;\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    volatile HaShmemData* hashmdata = t_thrd.postmaster_cxt.HaShmData;\r\n    XLogRecPtr sndFlushPtr;\r\n\r\n    /*\r\n     * If the user doesn't want status to be reported to the master, be sure\r\n     * to exit before doing anything at all.\r\n     */\r\n    if (!force && u_sess->attr.attr_storage.wal_receiver_status_interval <= 0)\r\n        return;\r\n\r\n    SpinLockAcquire(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n    receivePtr = t_thrd.walreceiver_cxt.walRcvCtlBlock->receivePtr;\r\n    writePtr = t_thrd.walreceiver_cxt.walRcvCtlBlock->writePtr;\r\n    flushPtr = t_thrd.walreceiver_cxt.walRcvCtlBlock->flushPtr;\r\n    SpinLockRelease(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n\r\n    /* Get current timestamp. */\r\n    now = GetCurrentTimestamp();\r\n    /*\r\n     * We can compare the write and flush positions to the last message we\r\n     * sent without taking any lock, but the apply position requires a spin\r\n     * lock, so we don't check that unless something else has changed or 10\r\n     * seconds have passed.  This means that the apply log position will\r\n     * appear, from the master's point of view, to lag slightly, but since\r\n     * this is only for reporting purposes and only on idle systems, that's\r\n     * probably OK.\r\n     */\r\n    if (!force && XLByteEQ(t_thrd.walreceiver_cxt.reply_message->receive, receivePtr) &&\r\n        XLByteEQ(t_thrd.walreceiver_cxt.reply_message->write, writePtr) &&\r\n        XLByteEQ(t_thrd.walreceiver_cxt.reply_message->flush, flushPtr) &&\r\n        !(TimestampDifferenceExceeds(t_thrd.walreceiver_cxt.reply_message->sendTime, now,\r\n            u_sess->attr.attr_storage.wal_receiver_status_interval * 1000) ||\r\n        TimestampDifferenceExceeds(now, t_thrd.walreceiver_cxt.reply_message->sendTime,\r\n            u_sess->attr.attr_storage.wal_receiver_status_interval * 1000))) {\r\n        return;\r\n    }\r\n\r\n    /* Construct a new message */\r\n    t_thrd.walreceiver_cxt.reply_message->receive = receivePtr;\r\n    t_thrd.walreceiver_cxt.reply_message->write = writePtr;\r\n    t_thrd.walreceiver_cxt.reply_message->flush = flushPtr;\r\n    if (!dummyStandbyMode) {\r\n        t_thrd.walreceiver_cxt.reply_message->apply = GetXLogReplayRecPtr(NULL, &ReplayReadPtr);\r\n        t_thrd.walreceiver_cxt.reply_message->applyRead = ReplayReadPtr;\r\n    } else {\r\n        t_thrd.walreceiver_cxt.reply_message->apply = flushPtr;\r\n        t_thrd.walreceiver_cxt.reply_message->applyRead = flushPtr;\r\n    }\r\n    t_thrd.walreceiver_cxt.reply_message->sendTime = now;\r\n    t_thrd.walreceiver_cxt.reply_message->replyRequested = requestReply;\r\n\r\n    SpinLockAcquire(&hashmdata->mutex);\r\n    t_thrd.walreceiver_cxt.reply_message->peer_role = hashmdata->current_mode;\r\n    SpinLockRelease(&hashmdata->mutex);\r\n    t_thrd.walreceiver_cxt.reply_message->peer_state = get_local_dbstate();\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    walrcv->receiver_received_location = receivePtr;\r\n    walrcv->receiver_write_location = writePtr;\r\n    walrcv->receiver_flush_location = flushPtr;\r\n    walrcv->receiver_replay_location = t_thrd.walreceiver_cxt.reply_message->apply;\r\n    sndFlushPtr = walrcv->sender_flush_location;\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    if (u_sess->attr.attr_storage.HaModuleDebug) {\r\n        ereport(LOG,\r\n            (errmsg(\"HA-XLogWalRcvSendReply: sending receive %X/%X write %X/%X flush %X/%X apply %X/%X\",\r\n                (uint32)(t_thrd.walreceiver_cxt.reply_message->receive >> 32),\r\n                (uint32)t_thrd.walreceiver_cxt.reply_message->receive,\r\n                (uint32)(t_thrd.walreceiver_cxt.reply_message->write >> 32),\r\n                (uint32)t_thrd.walreceiver_cxt.reply_message->write,\r\n                (uint32)(t_thrd.walreceiver_cxt.reply_message->flush >> 32),\r\n                (uint32)t_thrd.walreceiver_cxt.reply_message->flush,\r\n                (uint32)(t_thrd.walreceiver_cxt.reply_message->apply >> 32),\r\n                (uint32)t_thrd.walreceiver_cxt.reply_message->apply)));\r\n    }\r\n\r\n    /* Prepend with the message type and send it. */\r\n    buf[0] = 'r';\r\n    rc = memcpy_s(\r\n        &buf[1], sizeof(StandbyReplyMessage), t_thrd.walreceiver_cxt.reply_message, sizeof(StandbyReplyMessage));\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n    libpqrcv_send(buf, sizeof(StandbyReplyMessage) + 1);\r\n    WalRcvRefreshPercentCountStartLsn(sndFlushPtr, flushPtr);\r\n}",
		"comment":"/*\r\n * Send reply message to primary, indicating our current XLOG positions, oldest\r\n * xmin and the current time.\r\n *\r\n * If 'force' is not true, the message is not sent unless enough time has\r\n * passed since last status update to reach wal_receiver_status_internal (or\r\n * if wal_receiver_status_interval is disabled altogether).\r\n *\r\n * If 'requestReply' is true, requests the server to reply immediately upon receiving\r\n * this message. This is used for heartbearts, when approaching wal_receiver_timeout.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"XLogWalRcvSendReply"
	},
	"XLogWalRcvSendSwitchRequest":{
		"body":"static void XLogWalRcvSendSwitchRequest(void)\r\n{\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    char buf[sizeof(StandbySwitchRequestMessage) + 1];\r\n    TimestampTz local_now;\r\n    errno_t errorno = EOK;\r\n\r\n    /* Get current timestamp. */\r\n    local_now = GetCurrentTimestamp();\r\n    t_thrd.walreceiver_cxt.request_message->sendTime = local_now;\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    t_thrd.walreceiver_cxt.request_message->demoteMode = walrcv->node_state;\r\n    walrcv->node_state = NODESTATE_STANDBY_WAITING;\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    /* Prepend with the message type and send it. */\r\n    buf[0] = 's';\r\n    errorno = memcpy_s(&buf[1],\r\n        sizeof(StandbySwitchRequestMessage),\r\n        t_thrd.walreceiver_cxt.request_message,\r\n        sizeof(StandbySwitchRequestMessage));\r\n    securec_check(errorno, \"\\0\", \"\\0\");\r\n    libpqrcv_send(buf, sizeof(StandbySwitchRequestMessage) + 1);\r\n\r\n    SendPostmasterSignal(PMSIGNAL_UPDATE_WAITING);\r\n    ereport(LOG,\r\n        (errmsg(\"send %s switchover request to primary\",\r\n            DemoteModeDesc(t_thrd.walreceiver_cxt.request_message->demoteMode))));\r\n}",
		"comment":"/*\r\n * Send switchover request message to primary, indicating the current time.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"XLogWalRcvSendSwitchRequest"
	},
	"firstSynchStandbyFile":{
		"body":"static void firstSynchStandbyFile(void)\r\n{\r\n    char bufTime[sizeof(ConfigModifyTimeMessage) + 1];\r\n    errno_t errorno = EOK;\r\n\r\n    bufTime[0] = 'A';\r\n    t_thrd.walreceiver_cxt.reply_modify_message->config_modify_time = 0;\r\n    errorno = memcpy_s(&bufTime[1],\r\n        sizeof(ConfigModifyTimeMessage),\r\n        t_thrd.walreceiver_cxt.reply_modify_message,\r\n        sizeof(ConfigModifyTimeMessage));\r\n    securec_check(errorno, \"\\0\", \"\\0\");\r\n    libpqrcv_send(bufTime, sizeof(ConfigModifyTimeMessage) + 1);\r\n}",
		"comment":"/*\r\n * firstSynchStandbyFile - Synchronise standby's configure file once the HA\r\n * build successfully.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"firstSynchStandbyFile"
	},
	"pg_stat_get_stream_replications":{
		"body":"Datum pg_stat_get_stream_replications(PG_FUNCTION_ARGS)\r\n{\r\n#define PG_STAT_GET_STREAM_REPLICATIONS_COLS 4\r\n    ReturnSetInfo* rsinfo = (ReturnSetInfo*)fcinfo->resultinfo;\r\n    TupleDesc tupdesc = NULL;\r\n    Tuplestorestate* tupstore = NULL;\r\n    MemoryContext per_query_ctx;\r\n    MemoryContext oldcontext;\r\n\r\n    Datum values[PG_STAT_GET_STREAM_REPLICATIONS_COLS];\r\n    bool nulls[PG_STAT_GET_STREAM_REPLICATIONS_COLS];\r\n\r\n    ServerMode local_role;\r\n    int static_connnections = 0;\r\n    char buildReason[MAXFNAMELEN] = {0};\r\n\r\n    volatile HaShmemData* hashmdata = t_thrd.postmaster_cxt.HaShmData;\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    bool isRunning = false;\r\n    DbState db_state = UNKNOWN_STATE;\r\n    errno_t rc = 0;\r\n\r\n    /* check to see if caller supports us returning a tuplestore */\r\n    if (rsinfo == NULL || !IsA(rsinfo, ReturnSetInfo)) {\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\r\n                errmsg(\"set-valued function called in context that cannot accept a set\")));\r\n        return (Datum)0;\r\n    }\r\n    if (!(rsinfo->allowedModes & SFRM_Materialize))\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\r\n                errmsg(\"materialize mode required, but it is not \"\r\n                       \"allowed in this context\")));\r\n\r\n    /* Build a tuple descriptor for our result type */\r\n    if (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\r\n        ereport(ERROR, (errcode(ERRCODE_DATATYPE_MISMATCH), errmsg(\"return type must be a row type\")));\r\n\r\n    per_query_ctx = rsinfo->econtext->ecxt_per_query_memory;\r\n    oldcontext = MemoryContextSwitchTo(per_query_ctx);\r\n\r\n    tupstore = tuplestore_begin_heap(true, false, u_sess->attr.attr_memory.work_mem);\r\n    rsinfo->returnMode = SFRM_Materialize;\r\n    rsinfo->setResult = tupstore;\r\n    rsinfo->setDesc = tupdesc;\r\n\r\n    (void)MemoryContextSwitchTo(oldcontext);\r\n    rc = memset_s(nulls, sizeof(nulls), 0, sizeof(nulls));\r\n    securec_check_c(rc, \"\\0\", \"\\0\");\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    isRunning = walrcv->isRuning;\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    SpinLockAcquire(&hashmdata->mutex);\r\n    local_role = hashmdata->current_mode;\r\n    static_connnections = hashmdata->repl_list_num;\r\n    SpinLockRelease(&hashmdata->mutex);\r\n\r\n    wal_get_ha_rebuild_reason(buildReason, local_role, isRunning);\r\n\r\n    if (local_role == UNKNOWN_MODE)\r\n        ereport(WARNING, (errmsg(\"server mode is unknown.\")));\r\n\r\n    /* local role */\r\n    values[0] = CStringGetTextDatum(wal_get_role_string(local_role));\r\n    /* static connections */\r\n    values[1] = Int32GetDatum(static_connnections);\r\n    /* db state */\r\n    db_state = get_local_dbstate();\r\n    values[2] = CStringGetTextDatum(wal_get_db_state_string(db_state));\r\n    /* build_reason */\r\n    values[3] = CStringGetTextDatum(buildReason);\r\n\r\n    tuplestore_putvalues(tupstore, tupdesc, values, nulls);\r\n\r\n    /* clean up and return the tuplestore */\r\n    tuplestore_donestoring(tupstore);\r\n\r\n    return (Datum)0;\r\n}",
		"comment":"/*\r\n * Returns activity of ha state, including static connections,local role,\r\n * database state and rebuild reason if database state is unnormal.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"pg_stat_get_stream_replications"
	},
	"pg_stat_get_wal_receiver":{
		"body":"Datum pg_stat_get_wal_receiver(PG_FUNCTION_ARGS)\r\n{\r\n#define PG_STAT_GET_WAL_RECEIVER_COLS 15\r\n    ReturnSetInfo* rsinfo = (ReturnSetInfo*)fcinfo->resultinfo;\r\n    TupleDesc tupdesc = NULL;\r\n    Tuplestorestate* tupstore = NULL;\r\n    MemoryContext per_query_ctx;\r\n    MemoryContext oldcontext;\r\n\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    volatile HaShmemData* hashmdata = t_thrd.postmaster_cxt.HaShmData;\r\n\r\n    char location[MAXFNAMELEN] = {0};\r\n\r\n    XLogRecPtr rcvRedo;\r\n    XLogRecPtr rcvWrite;\r\n    XLogRecPtr rcvFlush;\r\n    bool isRuning = false;\r\n\r\n    XLogRecPtr sndSent;\r\n    XLogRecPtr sndWrite;\r\n    XLogRecPtr sndFlush;\r\n    XLogRecPtr sndReplay;\r\n    XLogRecPtr rcvReceived;\r\n    XLogRecPtr syncStart;\r\n\r\n    int sync_percent = 0;\r\n    ServerMode peer_role;\r\n    DbState peer_state;\r\n    DbState local_state;\r\n    ServerMode local_role;\r\n    char localip[IP_LEN] = {0};\r\n    char remoteip[IP_LEN] = {0};\r\n    int localport = 0;\r\n    int remoteport = 0;\r\n    Datum values[PG_STAT_GET_WAL_RECEIVER_COLS];\r\n    bool nulls[PG_STAT_GET_WAL_RECEIVER_COLS];\r\n    errno_t rc = EOK;\r\n\r\n    /* check to see if caller supports us returning a tuplestore */\r\n    if (rsinfo == NULL || !IsA(rsinfo, ReturnSetInfo)) {\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\r\n                errmsg(\"set-valued function called in context that cannot accept a set\")));\r\n        return (Datum)0;\r\n    }\r\n    if (!(rsinfo->allowedModes & SFRM_Materialize))\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\r\n                errmsg(\"materialize mode required, but it is not allowed in this context\")));\r\n\r\n    /* Build a tuple descriptor for our result type */\r\n    if (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\r\n        ereport(ERROR, (errcode(ERRCODE_DATATYPE_MISMATCH), errmsg(\"return type must be a row type\")));\r\n\r\n    per_query_ctx = rsinfo->econtext->ecxt_per_query_memory;\r\n    oldcontext = MemoryContextSwitchTo(per_query_ctx);\r\n\r\n    tupstore = tuplestore_begin_heap(true, false, u_sess->attr.attr_memory.work_mem);\r\n    rsinfo->returnMode = SFRM_Materialize;\r\n    rsinfo->setResult = tupstore;\r\n    rsinfo->setDesc = tupdesc;\r\n\r\n    (void)MemoryContextSwitchTo(oldcontext);\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    isRuning = walrcv->isRuning;\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    if (walrcv->pid == 0 || !isRuning)\r\n        return (Datum)0;\r\n\r\n    SpinLockAcquire(&hashmdata->mutex);\r\n    local_role = hashmdata->current_mode;\r\n    SpinLockRelease(&hashmdata->mutex);\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    localport = walrcv->conn_channel.localport;\r\n    remoteport = walrcv->conn_channel.remoteport;\r\n    rc = strncpy_s(localip, IP_LEN, (char*)walrcv->conn_channel.localhost, IP_LEN - 1);\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n    rc = strncpy_s(remoteip, IP_LEN, (char*)walrcv->conn_channel.remotehost, IP_LEN - 1);\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n    localip[IP_LEN - 1] = '\\0';\r\n    remoteip[IP_LEN - 1] = '\\0';\r\n    peer_role = walrcv->peer_role;\r\n    peer_state = walrcv->peer_state;\r\n    local_state = get_local_dbstate();\r\n\r\n    sndSent = walrcv->sender_sent_location;\r\n    sndWrite = walrcv->sender_write_location;\r\n    sndFlush = walrcv->sender_flush_location;\r\n    sndReplay = walrcv->sender_replay_location;\r\n\r\n    rcvReceived = walrcv->receiver_received_location;\r\n    rcvRedo = walrcv->receiver_replay_location;\r\n    rcvWrite = walrcv->receiver_write_location;\r\n    rcvFlush = walrcv->receiver_flush_location;\r\n    syncStart = walrcv->syncPercentCountStart;\r\n\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    rc = memset_s(nulls, sizeof(nulls), 0, sizeof(nulls));\r\n    securec_check_c(rc, \"\\0\", \"\\0\");\r\n    values[0] = Int32GetDatum(walrcv->lwpId);\r\n\r\n    if (!superuser()) {\r\n        /*\r\n         * Only superusers can see details. Other users only get the pid\r\n         * value to know it's a receiver, but no details.\r\n         */\r\n        rc = memset_s(&nulls[1], PG_STAT_GET_WAL_RECEIVER_COLS - 1, true, PG_STAT_GET_WAL_RECEIVER_COLS - 1);\r\n        securec_check(rc, \"\\0\", \"\\0\");\r\n    } else {\r\n        /* local_role */\r\n        values[1] = CStringGetTextDatum(wal_get_role_string(local_role));\r\n        /* peer_role */\r\n        values[2] = CStringGetTextDatum(wal_get_role_string(peer_role));\r\n        /* peer_state */\r\n        values[3] = CStringGetTextDatum(wal_get_db_state_string(peer_state));\r\n        /* state */\r\n        values[4] = CStringGetTextDatum(wal_get_db_state_string(local_state));\r\n\r\n        /* sender_sent_location */\r\n        rc = snprintf_s(\r\n            location, sizeof(location), sizeof(location) - 1, \"%X/%X\", (uint32)(sndSent >> 32), (uint32)sndSent);\r\n        securec_check_ss(rc, \"\\0\", \"\\0\");\r\n        values[5] = CStringGetTextDatum(location);\r\n\r\n        /* sender_write_location */\r\n        if (sndWrite == 0)\r\n            SETXLOGLOCATION(sndWrite, sndSent)\r\n        rc = snprintf_s(\r\n            location, sizeof(location), sizeof(location) - 1, \"%X/%X\", (uint32)(sndWrite >> 32), (uint32)sndWrite);\r\n        securec_check_ss(rc, \"\\0\", \"\\0\");\r\n        values[6] = CStringGetTextDatum(location);\r\n\r\n        /* sender_flush_location */\r\n        if (sndFlush == 0)\r\n            SETXLOGLOCATION(sndFlush, sndSent)\r\n        rc = snprintf_s(\r\n            location, sizeof(location), sizeof(location) - 1, \"%X/%X\", (uint32)(sndFlush >> 32), (uint32)sndFlush);\r\n        securec_check_ss(rc, \"\\0\", \"\\0\");\r\n        values[7] = CStringGetTextDatum(location);\r\n\r\n        /* sender_replay_location */\r\n        if (sndReplay == 0)\r\n            SETXLOGLOCATION(sndReplay, sndSent)\r\n        rc = snprintf_s(\r\n            location, sizeof(location), sizeof(location) - 1, \"%X/%X\", (uint32)(sndReplay >> 32), (uint32)sndReplay);\r\n        securec_check_ss(rc, \"\\0\", \"\\0\");\r\n        values[8] = CStringGetTextDatum(location);\r\n\r\n        /* receiver_received_location */\r\n        if (rcvReceived == 0)\r\n            SETXLOGLOCATION(rcvReceived, sndSent)\r\n        rc = snprintf_s(location,\r\n            sizeof(location),\r\n            sizeof(location) - 1,\r\n            \"%X/%X\",\r\n            (uint32)(rcvReceived >> 32),\r\n            (uint32)rcvReceived);\r\n        securec_check_ss(rc, \"\\0\", \"\\0\");\r\n        values[9] = CStringGetTextDatum(location);\r\n\r\n        /* receiver_write_location */\r\n        if (rcvWrite == 0)\r\n            SETXLOGLOCATION(rcvWrite, sndSent)\r\n        rc = snprintf_s(\r\n            location, sizeof(location), sizeof(location) - 1, \"%X/%X\", (uint32)(rcvWrite >> 32), (uint32)rcvWrite);\r\n        securec_check_ss(rc, \"\\0\", \"\\0\");\r\n        values[10] = CStringGetTextDatum(location);\r\n\r\n        /* receiver_flush_location */\r\n        if (rcvFlush == 0)\r\n            SETXLOGLOCATION(rcvFlush, sndSent)\r\n        rc = snprintf_s(\r\n            location, sizeof(location), sizeof(location) - 1, \"%X/%X\", (uint32)(rcvFlush >> 32), (uint32)rcvFlush);\r\n        securec_check_ss(rc, \"\\0\", \"\\0\");\r\n        values[11] = CStringGetTextDatum(location);\r\n\r\n        /* receiver_replay_location */\r\n        if (rcvRedo == 0)\r\n            SETXLOGLOCATION(rcvRedo, sndSent)\r\n        rc = snprintf_s(\r\n            location, sizeof(location), sizeof(location) - 1, \"%X/%X\", (uint32)(rcvRedo >> 32), (uint32)rcvRedo);\r\n        securec_check_ss(rc, \"\\0\", \"\\0\");\r\n        values[12] = CStringGetTextDatum(location);\r\n\r\n        /* sync_percent */\r\n        sync_percent = GetSyncPercent(syncStart, sndFlush, rcvFlush);\r\n        rc = snprintf_s(location, sizeof(location), sizeof(location) - 1, \"%d%%\", sync_percent);\r\n        securec_check_ss(rc, \"\\0\", \"\\0\");\r\n        values[13] = CStringGetTextDatum(location);\r\n\r\n        /* channel */\r\n        rc = snprintf_s(location,\r\n            sizeof(location),\r\n            sizeof(location) - 1,\r\n            \"%s:%d<--%s:%d\",\r\n            localip,\r\n            localport,\r\n            remoteip,\r\n            remoteport);\r\n        securec_check_ss(rc, \"\\0\", \"\\0\");\r\n        values[14] = CStringGetTextDatum(location);\r\n    }\r\n    tuplestore_putvalues(tupstore, tupdesc, values, nulls);\r\n\r\n    /* clean up and return the tuplestore */\r\n    tuplestore_donestoring(tupstore);\r\n\r\n    return (Datum)0;\r\n}",
		"comment":"/*\r\n * Descriptions: Returns activity of walreveiver, including pids and xlog\r\n * locations received from primary o  cascading server.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"pg_stat_get_wal_receiver"
	},
	"sigusr1_handler":{
		"body":"static void sigusr1_handler(SIGNAL_ARGS)\r\n{\r\n    int save_errno = errno;\r\n\r\n    gs_signal_setmask(&t_thrd.libpq_cxt.BlockSig, NULL);\r\n\r\n    if (t_thrd.walreceiverfuncs_cxt.WalRcv &&\r\n        t_thrd.walreceiverfuncs_cxt.WalRcv->node_state >= NODESTATE_SMART_DEMOTE_REQUEST &&\r\n        t_thrd.walreceiverfuncs_cxt.WalRcv->node_state <= NODESTATE_FAST_DEMOTE_REQUEST) {\r\n        /* Tell walreceiver process to start switchover */\r\n        t_thrd.walreceiver_cxt.start_switchover = true;\r\n    }\r\n\r\n    gs_signal_setmask(&t_thrd.libpq_cxt.UnBlockSig, NULL);\r\n\r\n    errno = save_errno;\r\n}",
		"comment":"/*\r\n * handle signal conditions from other processes\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"sigusr1_handler"
	},
	"wakeupWalRcvWriter":{
		"body":"void wakeupWalRcvWriter()\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    if (walrcv->walrcvWriterLatch != NULL)\r\n        SetLatch(walrcv->walrcvWriterLatch);\r\n    SpinLockRelease(&walrcv->mutex);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"wakeupWalRcvWriter"
	},
	"walRcvCtlBlockFini":{
		"body":"static void walRcvCtlBlockFini()\r\n{\r\n    pfree(t_thrd.walreceiver_cxt.walRcvCtlBlock);\r\n    t_thrd.walreceiver_cxt.walRcvCtlBlock = NULL;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"walRcvCtlBlockFini"
	},
	"walRcvCtlBlockInit":{
		"body":"static void walRcvCtlBlockInit()\r\n{\r\n    char* buf = NULL;\r\n    int64 recBufferSize = g_instance.attr.attr_storage.WalReceiverBufSize * 1024;\r\n    size_t len = offsetof(WalRcvCtlBlock, walReceiverBuffer) + recBufferSize;\r\n    errno_t rc = 0;\r\n\r\n    Assert(t_thrd.walreceiver_cxt.walRcvCtlBlock == NULL);\r\n    buf = (char*)MemoryContextAlloc(t_thrd.top_mem_cxt, len);\r\n    if (buf == NULL) {\r\n        ereport(FATAL, (errcode(ERRCODE_OUT_OF_MEMORY), errmsg(\"out of memory\")));\r\n    }\r\n\r\n    rc = memset_s(buf, sizeof(WalRcvCtlBlock), 0, sizeof(WalRcvCtlBlock));\r\n    securec_check_c(rc, \"\\0\", \"\\0\");\r\n\r\n    t_thrd.walreceiver_cxt.walRcvCtlBlock = (WalRcvCtlBlock*)buf;\r\n\r\n    SpinLockInit(&t_thrd.walreceiver_cxt.walRcvCtlBlock->mutex);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"walRcvCtlBlockInit"
	},
	"walRcvCtlBlockIsEmpty":{
		"body":"bool walRcvCtlBlockIsEmpty(void)\r\n{\r\n    volatile WalRcvCtlBlock* walrcb = NULL;\r\n\r\n    LWLockAcquire(WALWriteLock, LW_EXCLUSIVE);\r\n    walrcb = getCurrentWalRcvCtlBlock();\r\n    if (walrcb == NULL) {\r\n        LWLockRelease(WALWriteLock);\r\n        return true;\r\n    }\r\n\r\n    bool retState = false;\r\n\r\n    SpinLockAcquire(&walrcb->mutex);\r\n    if (IsExtremeRedo())\r\n    {\r\n        if (walrcb->walFreeOffset == walrcb->walReadOffset)\r\n        {\r\n            retState = true;\r\n        }\r\n    } else {\r\n        if (walrcb->walFreeOffset == walrcb->walWriteOffset)\r\n        {\r\n            retState = true;\r\n        }\r\n    }\r\n\r\n    SpinLockRelease(&walrcb->mutex);\r\n    LWLockRelease(WALWriteLock);\r\n    return retState;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"walRcvCtlBlockIsEmpty"
	},
	"walRcvDataCleanup":{
		"body":"void walRcvDataCleanup()\r\n{\r\n    while (WalDataRcvWrite() > 0) {\r\n    };\r\n}",
		"comment":"/*\r\n * Clean up data in receive buffer.\r\n * This function should be called on thread exit.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"walRcvDataCleanup"
	},
	"wal_get_ha_rebuild_reason":{
		"body":"static void wal_get_ha_rebuild_reason(char* buildReason, ServerMode local_role, bool isRunning)\r\n{\r\n    if (IS_DN_DUMMY_STANDYS_MODE())\r\n        wal_get_ha_rebuild_reason_with_dummy(buildReason, local_role, isRunning);\r\n    else\r\n        wal_get_ha_rebuild_reason_with_multi(buildReason, local_role, isRunning);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"wal_get_ha_rebuild_reason"
	},
	"wal_get_ha_rebuild_reason_with_dummy":{
		"body":"static void wal_get_ha_rebuild_reason_with_dummy(char* buildReason, ServerMode local_role, bool isRunning)\r\n{\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    volatile HaShmemData* hashmdata = t_thrd.postmaster_cxt.HaShmData;\r\n    int nRet = 0;\r\n\r\n    if (local_role == NORMAL_MODE || local_role == PRIMARY_MODE) {\r\n        nRet = snprintf_s(buildReason, MAXFNAMELEN, MAXFNAMELEN - 1, \"%s\", \"Normal\");\r\n        securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n        return;\r\n    }\r\n\r\n    if (t_thrd.postmaster_cxt.ReplConnArray[1] != NULL && walrcv->conn_target == REPCONNTARGET_PRIMARY) {\r\n        if (hashmdata->repl_reason[1] == NONE_REBUILD && isRunning) {\r\n            nRet = snprintf_s(buildReason, MAXFNAMELEN, MAXFNAMELEN - 1, \"%s\", \"Normal\");\r\n            securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n        } else if (hashmdata->repl_reason[1] == NONE_REBUILD && !isRunning) {\r\n            nRet = snprintf_s(buildReason, MAXFNAMELEN, MAXFNAMELEN - 1, \"%s\", \"Connecting...\");\r\n            securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n        } else {\r\n            nRet = snprintf_s(buildReason,\r\n                MAXFNAMELEN,\r\n                MAXFNAMELEN - 1,\r\n                \"%s\",\r\n                wal_get_rebuild_reason_string(hashmdata->repl_reason[1]));\r\n            securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n        }\r\n    } else if (t_thrd.postmaster_cxt.ReplConnArray[2] != NULL && walrcv->conn_target == REPCONNTARGET_DUMMYSTANDBY) {\r\n        if (hashmdata->repl_reason[2] == NONE_REBUILD && isRunning) {\r\n            nRet = snprintf_s(buildReason, MAXFNAMELEN, MAXFNAMELEN - 1, \"%s\", \"Normal\");\r\n            securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n        } else if (hashmdata->repl_reason[2] == NONE_REBUILD && !isRunning) {\r\n            nRet = snprintf_s(buildReason, MAXFNAMELEN, MAXFNAMELEN - 1, \"%s\", \"Connecting...\");\r\n            securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n        } else {\r\n            nRet = snprintf_s(buildReason,\r\n                MAXFNAMELEN,\r\n                MAXFNAMELEN - 1,\r\n                \"%s\",\r\n                wal_get_rebuild_reason_string(hashmdata->repl_reason[2]));\r\n            securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n        }\r\n    } else {\r\n        nRet = snprintf_s(buildReason, MAXFNAMELEN, MAXFNAMELEN - 1, \"%s\", \"Disconnected\");\r\n        securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"wal_get_ha_rebuild_reason_with_dummy"
	},
	"wal_get_ha_rebuild_reason_with_multi":{
		"body":"static void wal_get_ha_rebuild_reason_with_multi(char* buildReason, ServerMode local_role, bool isRunning)\r\n{\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    volatile HaShmemData* hashmdata = t_thrd.postmaster_cxt.HaShmData;\r\n    int rcs = 0;\r\n\r\n    if (local_role == NORMAL_MODE || local_role == PRIMARY_MODE) {\r\n        rcs = snprintf_s(buildReason, MAXFNAMELEN, MAXFNAMELEN - 1, \"%s\", \"Normal\");\r\n        securec_check_ss(rcs, \"\\0\", \"\\0\");\r\n        return;\r\n    }\r\n\r\n    if (t_thrd.postmaster_cxt.ReplConnArray[hashmdata->current_repl] != NULL &&\r\n        walrcv->conn_target == REPCONNTARGET_PRIMARY) {\r\n        if (hashmdata->repl_reason[hashmdata->current_repl] == NONE_REBUILD && isRunning) {\r\n            rcs = snprintf_s(buildReason, MAXFNAMELEN, MAXFNAMELEN - 1, \"%s\", \"Normal\");\r\n            securec_check_ss(rcs, \"\\0\", \"\\0\");\r\n        } else if (hashmdata->repl_reason[hashmdata->current_repl] == NONE_REBUILD && !isRunning) {\r\n            rcs = snprintf_s(buildReason, MAXFNAMELEN, MAXFNAMELEN - 1, \"%s\", \"Connecting...\");\r\n            securec_check_ss(rcs, \"\\0\", \"\\0\");\r\n        } else {\r\n            rcs = snprintf_s(buildReason,\r\n                MAXFNAMELEN,\r\n                MAXFNAMELEN - 1,\r\n                \"%s\",\r\n                wal_get_rebuild_reason_string(hashmdata->repl_reason[hashmdata->current_repl]));\r\n            securec_check_ss(rcs, \"\\0\", \"\\0\");\r\n        }\r\n    } else {\r\n        rcs = snprintf_s(buildReason, MAXFNAMELEN, MAXFNAMELEN - 1, \"%s\", \"Disconnected\");\r\n        securec_check_ss(rcs, \"\\0\", \"\\0\");\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"wal_get_ha_rebuild_reason_with_multi"
	},
	"wal_get_rebuild_reason_string":{
		"body":"const char* wal_get_rebuild_reason_string(HaRebuildReason reason)\r\n{\r\n    switch (reason) {\r\n        case NONE_REBUILD:\r\n            return \"Normal\";\r\n        case WALSEGMENT_REBUILD:\r\n            return \"WAL segment removed\";\r\n        case CONNECT_REBUILD:\r\n            return \"Disconnected\";\r\n        case VERSION_REBUILD:\r\n            return \"Version not matched\";\r\n        case MODE_REBUILD:\r\n            return \"Mode not matched\";\r\n        case SYSTEMID_REBUILD:\r\n            return \"System id not matched\";\r\n        case TIMELINE_REBUILD:\r\n            return \"Timeline not matched\";\r\n        default:\r\n            break;\r\n    }\r\n    return \"Unknown\";\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"wal_get_rebuild_reason_string"
	},
	"wal_get_role_string":{
		"body":"const char* wal_get_role_string(ServerMode mode)\r\n{\r\n    switch (mode) {\r\n        case NORMAL_MODE:\r\n            return \"Normal\";\r\n        case PRIMARY_MODE:\r\n            return \"Primary\";\r\n        case STANDBY_MODE:\r\n            return \"Standby\";\r\n        case PENDING_MODE:\r\n            return \"Pending\";\r\n        case UNKNOWN_MODE:\r\n            return \"Unknown\";\r\n        default:\r\n            ereport(WARNING, (errmsg(\"invalid server mode:%d\", (int)mode)));\r\n            break;\r\n    }\r\n    return \"Unknown\";\r\n}",
		"comment":"/*\r\n * transfer the server mode to string.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiver.cpp",
		"name":"wal_get_role_string"
	}
}