{
	"GetRepConnArray":{
		"body":"ReplConnInfo* GetRepConnArray(int* cur_idx)\r\n{\r\n    int loop_retry = 0;\r\n\r\n    if (*cur_idx < 0 || *cur_idx > MAX_REPLNODE_NUM) {\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg(\"invalid replication node index:%d\", *cur_idx)));\r\n    }\r\n\r\n    /* do ... while  until the node is avaliable to me */\r\n    while (loop_retry++ < MAX_REPLNODE_NUM) {\r\n        if (*cur_idx == MAX_REPLNODE_NUM)\r\n            *cur_idx = 1;\r\n\r\n        if (t_thrd.postmaster_cxt.ReplConnArray[(*cur_idx)] != NULL)\r\n            break;\r\n        (*cur_idx)++;\r\n    }\r\n\r\n    return (*cur_idx < MAX_REPLNODE_NUM) ? t_thrd.postmaster_cxt.ReplConnArray[*cur_idx] : NULL;\r\n}",
		"comment":"/*\r\n * We check the conninfo one by one. We should consider the method later.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"GetRepConnArray"
	},
	"GetReplicationApplyDelay":{
		"body":"int GetReplicationApplyDelay(void)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n\r\n    XLogRecPtr receivePtr;\r\n    XLogRecPtr replayPtr;\r\n\r\n    long secs;\r\n    int usecs;\r\n    TimestampTz chunkReplayStartTime;\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    receivePtr = walrcv->receivedUpto;\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    replayPtr = GetXLogReplayRecPtr(NULL);\r\n    if (XLByteEQ(receivePtr, replayPtr))\r\n        return 0;\r\n\r\n    chunkReplayStartTime = GetCurrentChunkReplayStartTime();\r\n    if (chunkReplayStartTime == 0)\r\n        return -1;\r\n\r\n    TimestampDifference(chunkReplayStartTime, GetCurrentTimestamp(), &secs, &usecs);\r\n\r\n    return (((int)secs * 1000) + (usecs / 1000));\r\n}",
		"comment":"/*\r\n * Returns the replication apply delay in ms or -1\r\n * if the apply delay info is not available\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"GetReplicationApplyDelay"
	},
	"GetReplicationTransferLatency":{
		"body":"int GetReplicationTransferLatency(void)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n\r\n    TimestampTz lastMsgSendTime;\r\n    TimestampTz lastMsgReceiptTime;\r\n\r\n    long secs = 0;\r\n    int usecs = 0;\r\n    int ms;\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    lastMsgSendTime = walrcv->lastMsgSendTime;\r\n    lastMsgReceiptTime = walrcv->lastMsgReceiptTime;\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    TimestampDifference(lastMsgSendTime, lastMsgReceiptTime, &secs, &usecs);\r\n\r\n    ms = ((int)secs * 1000) + (usecs / 1000);\r\n\r\n    return ms;\r\n}",
		"comment":"/*\r\n * Returns the network latency in ms, note that this includes any\r\n * difference in clock settings between the servers, as well as timezone.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"GetReplicationTransferLatency"
	},
	"GetWalRcvDummyStandbySyncPercent":{
		"body":"int GetWalRcvDummyStandbySyncPercent(void)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    int percent = 0;\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    percent = walrcv->dummyStandbySyncPercent;\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    return percent;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"GetWalRcvDummyStandbySyncPercent"
	},
	"GetWalRcvWriteLsn":{
		"body":"XLogRecPtr GetWalRcvWriteLsn(XLogRecPtr* latestChunkStart)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    XLogRecPtr recptr;\r\n    errno_t rc = 0;\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    if (walrcv->walRcvCtlBlock != NULL)\r\n        recptr = walrcv->walRcvCtlBlock->walStart;\r\n    else\r\n        recptr = walrcv->receivedUpto;\r\n    if (latestChunkStart != NULL) {\r\n        /* FUTURE CASE: */\r\n        rc = strncpy_s(\r\n            (char*)latestChunkStart, sizeof(XLogRecPtr), (char*)&walrcv->latestChunkStart, sizeof(XLogRecPtr) - 1);\r\n        securec_check(rc, \"\\0\", \"\\0\");\r\n    }\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    return recptr;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"GetWalRcvWriteLsn"
	},
	"GetWalRcvWriteRecPtr":{
		"body":"XLogRecPtr GetWalRcvWriteRecPtr(XLogRecPtr* latestChunkStart)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    XLogRecPtr recptr;\r\n    errno_t rc = 0;\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    recptr = walrcv->receivedUpto;\r\n    if (latestChunkStart != NULL) {\r\n        /* FUTURE CASE: */\r\n        rc = strncpy_s(\r\n            (char*)latestChunkStart, sizeof(XLogRecPtr), (char*)&walrcv->latestChunkStart, sizeof(XLogRecPtr) - 1);\r\n        securec_check(rc, \"\\0\", \"\\0\");\r\n    }\r\n\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    return recptr;\r\n}",
		"comment":"/*\r\n * Returns the last+1 byte position that walreceiver has written.\r\n *\r\n * Optionally, returns the previous chunk start, that is the first byte\r\n * written in the most recent walreceiver flush cycle.	Callers not\r\n * interested in that value may pass NULL for latestChunkStart.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"GetWalRcvWriteRecPtr"
	},
	"RequestXLogStreaming":{
		"body":"void RequestXLogStreaming(XLogRecPtr* recptr, const char* conninfo, ReplConnTarget conn_target, const char* slotname)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    pg_time_t now = (pg_time_t)time(NULL);\r\n    XLogRecPtr Lcrecptr;\r\n    const int MAX_RETRY_TIMES = 3;\r\n    errno_t retcode = EOK;\r\n\r\n    Lcrecptr = *recptr;\r\n\r\n    knl_g_set_is_local_redo_finish(true);\r\n    ereport(LOG, (errmsg(\"knl_g_set_is_local_redo_finish true in RequestXLogStreaming\")));\r\n    /*\r\n     * We always start at the beginning of the segment. That prevents a broken\r\n     * segment (i.e., with no records in the first half of a segment) from\r\n     * being created by XLOG streaming, which might cause trouble later on if\r\n     * the segment is e.g archived.\r\n     * Prev the requested segment if request xlog from the beginning of a segment.\r\n     */\r\n    if (Lcrecptr % XLogSegSize != 0) {\r\n        Lcrecptr -= Lcrecptr % XLogSegSize;\r\n    } else if (!dummyStandbyMode) {\r\n        XLogSegNo _logSeg;\r\n        XLByteToSeg(Lcrecptr, _logSeg);\r\n        _logSeg--;\r\n        Lcrecptr = _logSeg * XLogSegSize;\r\n    }\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    if (walrcv->ntries >= MAX_RETRY_TIMES && !dummyStandbyMode) {\r\n        walrcv->isRuning = false;\r\n        SpinLockRelease(&walrcv->mutex);\r\n        return;\r\n    }\r\n\r\n    /* It better be stopped before we try to restart it */\r\n    Assert(walrcv->walRcvState == WALRCV_STOPPED);\r\n\r\n    if (conninfo != NULL) {\r\n        retcode = strncpy_s((char*)walrcv->conninfo, MAXCONNINFO, conninfo, MAXCONNINFO - 1);\r\n        securec_check(retcode, \"\\0\", \"\\0\");\r\n    } else {\r\n        SpinLockRelease(&walrcv->mutex);\r\n        SetWalRcvConninfo(conn_target);\r\n        SpinLockAcquire(&walrcv->mutex);\r\n    }\r\n\r\n    SpinLockRelease(&walrcv->mutex);\r\n    set_rcv_slot_name(slotname);\r\n    SpinLockAcquire(&walrcv->mutex);\r\n\r\n    walrcv->walRcvState = WALRCV_STARTING;\r\n    walrcv->startTime = now;\r\n\r\n    /*\r\n     * If this is the first startup of walreceiver, we initialize receivedUpto\r\n     * and latestChunkStart to receiveStart.\r\n     */\r\n    if (walrcv->receiveStart == 0) {\r\n        walrcv->receivedUpto = Lcrecptr;\r\n        walrcv->latestChunkStart = Lcrecptr;\r\n    }\r\n\r\n    walrcv->receiveStart = Lcrecptr;\r\n\r\n    walrcv->latestValidRecord = latestValidRecord;\r\n    walrcv->latestRecordCrc = t_thrd.xlog_cxt.latestRecordCrc;\r\n    SpinLockRelease(&walrcv->mutex);\r\n    WalRcvSetPercentCountStartLsn(t_thrd.xlog_cxt.latestRecordCrc);\r\n    if (XLByteLT(latestValidRecord, Lcrecptr))\r\n        ereport(LOG,\r\n            (errmsg(\"latest valid record at %X/%X, wal receiver start point at %X/%X\",\r\n                (uint32)(latestValidRecord >> 32),\r\n                (uint32)latestValidRecord,\r\n                (uint32)(Lcrecptr >> 32),\r\n                (uint32)Lcrecptr)));\r\n\r\n    SendPostmasterSignal(PMSIGNAL_START_WALRECEIVER);\r\n}",
		"comment":"/*\r\n * Request postmaster to start walreceiver.\r\n *\r\n * recptr indicates the position where streaming should begin, conninfo\r\n * is a libpq connection string to use, and slotname is, optionally, the name\r\n * of a replication slot to acquire.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"RequestXLogStreaming"
	},
	"SetFailoverFailedState":{
		"body":"static void SetFailoverFailedState(void)\r\n{\r\n    if (!t_thrd.xlog_cxt.failover_triggered)\r\n        return;\r\n\r\n    /*\r\n     * reset sync flag before switching to next channel/replication,\r\n     * in order to avoid data/xlog loss.\r\n     */\r\n    SetWalRcvDummyStandbySyncPercent(0);\r\n    SetDataRcvDummyStandbySyncPercent(0);\r\n\r\n    /* reset the dummy standby connection failed flag */\r\n    volatile WalRcvData *walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    walrcv->dummyStandbyConnectFailed = false;\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    t_thrd.xlog_cxt.failover_triggered = false;\r\n\r\n    ereport(LOG, (errmsg(\"set failover failed state.\")));\r\n    return;\r\n}",
		"comment":"/*\r\n * Reset the triggered flag, so CheckForFailoverTriggered() will return false.\r\n * And also set db_state to promoting failed.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"SetFailoverFailedState"
	},
	"SetWalRcvConninfo":{
		"body":"static void SetWalRcvConninfo(ReplConnTarget conn_target)\r\n{\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    volatile HaShmemData* hashmdata = t_thrd.postmaster_cxt.HaShmData;\r\n    ReplConnInfo* conninfo = NULL;\r\n\r\n    if (IS_DN_DUMMY_STANDYS_MODE()) {\r\n        if (conn_target == REPCONNTARGET_PRIMARY) {\r\n            ereport(LOG, (errmsg(\"wal receiver get replconninfo[1] to connect primary.\")));\r\n            t_thrd.walreceiverfuncs_cxt.WalReplIndex = REPL_IDX_PRIMARY;\r\n        } else if (walrcv->dummyStandbyConnectFailed) {\r\n            /* if have tried to connect dummy and standby, set failover failed */\r\n            if (t_thrd.walreceiverfuncs_cxt.WalReplIndex == REPL_IDX_STANDBY) {\r\n                SetFailoverFailedState();\r\n            /* else, try to connect to another standby */\r\n            } else {\r\n                conn_target = REPCONNTARGET_STANDBY;\r\n            }\r\n            ereport(LOG, (errmsg(\"wal receiver get replconninfo[%d] to failover to another instance.\",\r\n                t_thrd.walreceiverfuncs_cxt.WalReplIndex)));\r\n        } else {\r\n            /* always connect to dummy standby */\r\n            ereport(LOG, (errmsg(\"wal receiver get conninfo[2] for dummystandby.\")));\r\n            t_thrd.walreceiverfuncs_cxt.WalReplIndex = REPL_IDX_STANDBY;\r\n        }\r\n    }\r\n\r\n    conninfo = GetRepConnArray(&t_thrd.walreceiverfuncs_cxt.WalReplIndex);\r\n    if (conninfo != NULL) {\r\n        int rcs = 0;\r\n\r\n        SpinLockAcquire(&walrcv->mutex);\r\n        rcs = snprintf_s((char*)walrcv->conninfo,\r\n            MAXCONNINFO,\r\n            MAXCONNINFO - 1,\r\n            \"host=%s port=%d localhost=%s localport=%d\",\r\n            conninfo->remotehost,\r\n            conninfo->remoteport,\r\n            conninfo->localhost,\r\n            conninfo->localport);\r\n        securec_check_ss(rcs, \"\\0\", \"\\0\");\r\n        walrcv->conninfo[MAXCONNINFO - 1] = '\\0';\r\n        walrcv->conn_errno = NONE_ERROR;\r\n        walrcv->conn_target = conn_target;\r\n        walrcv->conn_channel.localservice = conninfo->localservice;\r\n        walrcv->conn_channel.remoteservice = conninfo->remoteservice;\r\n        SpinLockRelease(&walrcv->mutex);\r\n\r\n        SpinLockAcquire(&hashmdata->mutex);\r\n        hashmdata->current_repl = t_thrd.walreceiverfuncs_cxt.WalReplIndex;\r\n        hashmdata->disconnect_count[t_thrd.walreceiverfuncs_cxt.WalReplIndex] = 0;\r\n        SpinLockRelease(&hashmdata->mutex);\r\n        t_thrd.walreceiverfuncs_cxt.WalReplIndex++;\r\n    }\r\n}",
		"comment":"/*\r\n * Find next connect channel , and try to connect. According to the ReplFlag,\r\n * ReplIndex , connect error in the walrcv, find next channel, save it in\r\n * walrcv. Latter the walreceiver will use it, try to connect the primary.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"SetWalRcvConninfo"
	},
	"SetWalRcvDummyStandbySyncPercent":{
		"body":"void SetWalRcvDummyStandbySyncPercent(int percent)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    walrcv->dummyStandbySyncPercent = percent;\r\n    SpinLockRelease(&walrcv->mutex);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"SetWalRcvDummyStandbySyncPercent"
	},
	"ShutdownWalRcv":{
		"body":"void ShutdownWalRcv(void)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    ThreadId walrcvpid = 0;\r\n    int i = 1;\r\n    const int COUNTS = 2000;\r\n\r\n    /*\r\n     * Request walreceiver to stop. Walreceiver will switch to WALRCV_STOPPED\r\n     * mode once it's finished, and will also request postmaster to not\r\n     * restart itself.\r\n     */\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    switch (walrcv->walRcvState) {\r\n        case WALRCV_STOPPED:\r\n            break;\r\n        case WALRCV_STARTING:\r\n            walrcv->walRcvState = WALRCV_STOPPED;\r\n            break;\r\n\r\n        case WALRCV_RUNNING:\r\n            walrcv->walRcvState = WALRCV_STOPPING;\r\n            // lint -fallthrough\r\n        case WALRCV_STOPPING:\r\n            walrcvpid = walrcv->pid;\r\n            break;\r\n    }\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    ereport(LOG, (errmsg(\"startup shut down walreceiver.\")));\r\n    /*\r\n     * Signal walreceiver process if it was still running.\r\n     */\r\n    if (walrcvpid != 0)\r\n        (void)gs_signal_send(walrcvpid, SIGTERM);\r\n\r\n    /*\r\n     * Wait for walreceiver to acknowledge its death by setting state to\r\n     * WALRCV_STOPPED.\r\n     */\r\n    while (WalRcvInProgress()) {\r\n        /*\r\n         * This possibly-long loop needs to handle interrupts of startup\r\n         * process.\r\n         */\r\n        HandleStartupProcInterrupts();\r\n        pg_usleep(100000); /* 100ms */\r\n\r\n        SpinLockAcquire(&walrcv->mutex);\r\n        walrcvpid = walrcv->pid;\r\n        SpinLockRelease(&walrcv->mutex);\r\n\r\n        if ((walrcvpid != 0) && (i % COUNTS == 0)) {\r\n            (void)gs_signal_send(walrcvpid, SIGTERM);\r\n            i = 1;\r\n        }\r\n        i++;\r\n    }\r\n}",
		"comment":"/*\r\n * Stop walreceiver (if running) and wait for it to die.\r\n * Executed by the Startup process.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"ShutdownWalRcv"
	},
	"WalRcvAllReplayIsDone":{
		"body":"bool WalRcvAllReplayIsDone()\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    XLogRecPtr theLatestReplayedRecPtr = InvalidXLogRecPtr;\r\n    XLogRecPtr theLatestReceivedRecPtr = InvalidXLogRecPtr;\r\n\r\n    theLatestReplayedRecPtr = GetXLogReplayRecPtr(NULL, NULL);\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    theLatestReceivedRecPtr = walrcv->receiver_received_location;\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    if (XLByteLT(theLatestReplayedRecPtr, theLatestReceivedRecPtr)) {\r\n        ereport(LOG,\r\n            (errmsg(\"still waiting for the redo on the standby: the latest replayed %X/%X, the latest received %X/%X.\",\r\n                (uint32)(theLatestReplayedRecPtr >> 32),\r\n                (uint32)theLatestReplayedRecPtr,\r\n                (uint32)(theLatestReceivedRecPtr >> 32),\r\n                (uint32)theLatestReceivedRecPtr)));\r\n\r\n        return false;\r\n    }\r\n\r\n    ereport(LOG,\r\n        (errmsg(\"all redo done on the standby: the latest replayed %X/%X, the latest received %X/%X.\",\r\n            (uint32)(theLatestReplayedRecPtr >> 32),\r\n            (uint32)theLatestReplayedRecPtr,\r\n            (uint32)(theLatestReceivedRecPtr >> 32),\r\n            (uint32)theLatestReceivedRecPtr)));\r\n\r\n    return true;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"WalRcvAllReplayIsDone"
	},
	"WalRcvInProgress":{
		"body":"bool WalRcvInProgress(void)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    WalRcvState state;\r\n    pg_time_t startTime;\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n\r\n    state = walrcv->walRcvState;\r\n    startTime = walrcv->startTime;\r\n\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    /*\r\n     * If it has taken too long for walreceiver to start up, give up. Setting\r\n     * the state to STOPPED ensures that if walreceiver later does start up\r\n     * after all, it will see that it's not supposed to be running and die\r\n     * without doing anything.\r\n     */\r\n    if (state == WALRCV_STARTING) {\r\n        pg_time_t now = (pg_time_t)time(NULL);\r\n        if ((now - startTime) > WALRCV_STARTUP_TIMEOUT) {\r\n            SpinLockAcquire(&walrcv->mutex);\r\n            if (walrcv->walRcvState == WALRCV_STARTING)\r\n                state = walrcv->walRcvState = WALRCV_STOPPED;\r\n            SpinLockRelease(&walrcv->mutex);\r\n            ereport(WARNING,\r\n                (errmsg(\"shut down walreceiver due to start up timeout,\"\r\n                        \"timeout=%d,now=%ld,starttime=%ld\",\r\n                    WALRCV_STARTUP_TIMEOUT,\r\n                    now,\r\n                    startTime)));\r\n        }\r\n    }\r\n\r\n    if (state != WALRCV_STOPPED)\r\n        return true;\r\n    else\r\n        return false;\r\n}",
		"comment":"/* Is walreceiver in progress (or starting up)? */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"WalRcvInProgress"
	},
	"WalRcvIsDone":{
		"body":"bool WalRcvIsDone()\r\n{\r\n    if (g_instance.attr.attr_storage.enable_mix_replication)\r\n        return DataQueueIsEmpty(t_thrd.dataqueue_cxt.DataWriterQueue);\r\n    else\r\n        return walRcvCtlBlockIsEmpty();\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"WalRcvIsDone"
	},
	"WalRcvShmemInit":{
		"body":"void WalRcvShmemInit(void)\r\n{\r\n    bool found = false;\r\n    errno_t rc = 0;\r\n\r\n    t_thrd.walreceiverfuncs_cxt.WalRcv = (WalRcvData*)ShmemInitStruct(\"Wal Receiver Ctl\", WalRcvShmemSize(), &found);\r\n\r\n    if (!found) {\r\n        /* First time through, so initialize */\r\n        rc = memset_s(t_thrd.walreceiverfuncs_cxt.WalRcv, WalRcvShmemSize(), 0, WalRcvShmemSize());\r\n        securec_check(rc, \"\\0\", \"\\0\");\r\n        t_thrd.walreceiverfuncs_cxt.WalRcv->walRcvState = WALRCV_STOPPED;\r\n        t_thrd.walreceiverfuncs_cxt.WalRcv->node_state = NODESTATE_NORMAL;\r\n        t_thrd.walreceiverfuncs_cxt.WalRcv->conn_errno = NONE_ERROR;\r\n        t_thrd.walreceiverfuncs_cxt.WalRcv->ntries = 0;\r\n        t_thrd.walreceiverfuncs_cxt.WalRcv->dummyStandbySyncPercent = 0;\r\n        t_thrd.walreceiverfuncs_cxt.WalRcv->dummyStandbyConnectFailed = false;\r\n        SpinLockInit(&t_thrd.walreceiverfuncs_cxt.WalRcv->mutex);\r\n    }\r\n}",
		"comment":"/* Allocate and initialize walreceiver-related shared memory */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"WalRcvShmemInit"
	},
	"WalRcvShmemSize":{
		"body":"Size WalRcvShmemSize(void)\r\n{\r\n    Size size = 0;\r\n\r\n    size = add_size(size, sizeof(WalRcvData));\r\n\r\n    return size;\r\n}",
		"comment":"/* Report shared memory space needed by WalRcvShmemInit */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"WalRcvShmemSize"
	},
	"clean_failover_host_conninfo_for_dummy":{
		"body":"void clean_failover_host_conninfo_for_dummy(void)\r\n{\r\n	char	newHostPath[MAXPGPATH];\r\n	int		ret = 0;\r\n	errno_t	rc = EOK;\r\n\r\n	rc = memset_s(newHostPath, sizeof(newHostPath), 0, sizeof(newHostPath));\r\n	securec_check(rc, \"\\0\", \"\\0\");\r\n\r\n	ret = snprintf_s(newHostPath, MAXPGPATH, MAXPGPATH - 1, \"%s/%s\", t_thrd.proc_cxt.DataDir, FAILOVER_HOST_FOR_DUMMY);\r\n	securec_check_ss(ret, \"\\0\", \"\\0\");\r\n\r\n	if (unlink(newHostPath) < 0) {\r\n		ereport(LOG, (errmsg(\"remove %s failed\", newHostPath)));\r\n	} else {\r\n		ereport(LOG, (errmsg(\"remove %s success\", newHostPath)));\r\n	}\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"clean_failover_host_conninfo_for_dummy"
	},
	"connect_dn_str":{
		"body":"void connect_dn_str(char* conninfo, int replIndex)\r\n{\r\n    ReplConnInfo* replConnArray = NULL;\r\n    int rc = 0;\r\n\r\n    if (t_thrd.postmaster_cxt.ReplConnArray[1] == NULL || t_thrd.postmaster_cxt.ReplConnArray[2] == NULL) {\r\n        ereport(FATAL,\r\n            (errmsg(\"replconninfo1 or replconninfo2 not configured.\"),\r\n                errhint(\"please check your configuration in postgresql.conf.\")));\r\n    }\r\n\r\n    replConnArray = t_thrd.postmaster_cxt.ReplConnArray[replIndex];\r\n    rc = snprintf_s((char*)conninfo,\r\n        MAXCONNINFO,\r\n        MAXCONNINFO - 1,\r\n        \"host=%s port=%d localhost=%s localport=%d\",\r\n        replConnArray->remotehost,\r\n        replConnArray->remoteport,\r\n        replConnArray->localhost,\r\n        replConnArray->localport);\r\n    securec_check_ss(rc, \"\\0\", \"\\0\");\r\n}",
		"comment":"/*\r\n * reference SetWalRcvConninfo\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"connect_dn_str"
	},
	"get_failover_host_conninfo_for_dummy":{
		"body":"void get_failover_host_conninfo_for_dummy(int *repl)\r\n{\r\n    FILE *fp = NULL;\r\n    char newHostPath[MAXPGPATH];\r\n    int ret = 0;\r\n    int uselessSubIdx = 0;\r\n    errno_t rc = EOK;\r\n\r\n    if (!dummyStandbyMode || repl == NULL) {\r\n        return;\r\n    }\r\n\r\n    /* 1. init file path */\r\n    rc = memset_s(newHostPath, sizeof(newHostPath), 0, sizeof(newHostPath));\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n\r\n    /* 2. get file path */\r\n    ret = snprintf_s(newHostPath, MAXPGPATH, MAXPGPATH - 1, \"%s/%s\", t_thrd.proc_cxt.DataDir, FAILOVER_HOST_FOR_DUMMY);\r\n    securec_check_ss(ret, \"\\0\", \"\\0\");\r\n\r\n    /* 3. open file */\r\n    fp = fopen(newHostPath, \"r\");\r\n    if (fp == NULL) {\r\n        ereport(LOG, (errmsg(\"open file failed: %s\", newHostPath)));\r\n        return;\r\n    }\r\n\r\n    /* 4. get info, the second idx is useless, just for compaitble with pre version. */\r\n    ret = fscanf_s(fp, \"%d/%d\", repl, &uselessSubIdx);\r\n    if (ret < 0 && !feof(fp)) {\r\n        *repl = -1;\r\n        ereport(LOG, (errmsg(\"read conninfo failed: %s\", newHostPath)));\r\n    }\r\n\r\n    /* 5. clear the resource. */\r\n    (void)fclose(fp);\r\n    fp = NULL;\r\n    return;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"get_failover_host_conninfo_for_dummy"
	},
	"get_rcv_slot_name":{
		"body":"StringInfo get_rcv_slot_name(void)\r\n{\r\n    StringInfo slotname = makeStringInfo();\r\n\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n\r\n    /* creaet slot in dummystandby mode */\r\n    if (IS_DN_DUMMY_STANDYS_MODE()) {\r\n        SpinLockAcquire(&walrcv->mutex);\r\n        appendStringInfo(slotname, \"%s\", g_instance.attr.attr_common.PGXCNodeName);\r\n        SpinLockRelease(&walrcv->mutex);\r\n    }\r\n\r\n    return slotname;\r\n}",
		"comment":"/*\r\n * return rcv slotname\r\n *		slot_type: 0 for local 1 for remote\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"get_rcv_slot_name"
	},
	"get_repl_idx":{
		"body":"static int get_repl_idx(const char *host, int port)\r\n{\r\n	int i = 0;\r\n	int replIdx = -1;\r\n\r\n	for (i = 0; i < MAX_REPLNODE_NUM; ++i) {\r\n		if (t_thrd.postmaster_cxt.ReplConnArray[i] != NULL &&\r\n			strcmp(t_thrd.postmaster_cxt.ReplConnArray[i]->remotehost, host) == 0 &&\r\n			t_thrd.postmaster_cxt.ReplConnArray[i]->remoteport == port) {\r\n			replIdx = i;\r\n			break;\r\n		}\r\n	}\r\n\r\n	return replIdx;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"get_repl_idx"
	},
	"set_failover_host_conninfo_for_dummy":{
		"body":"void set_failover_host_conninfo_for_dummy(const char *remote_host, int remote_port)\r\n{\r\n    FILE *fp = NULL;\r\n    char newHostPath[MAXPGPATH];\r\n    int replIdx = -1;\r\n    int ret = 0;\r\n\r\n    if (!dummyStandbyMode || remote_host == NULL || remote_port == 0) {\r\n        return;\r\n    }\r\n\r\n    /* 1. get file path */\r\n    ret = snprintf_s(newHostPath, MAXPGPATH, MAXPGPATH - 1, \"%s/%s\", t_thrd.proc_cxt.DataDir, FAILOVER_HOST_FOR_DUMMY);\r\n    securec_check_ss(ret, \"\\0\", \"\\0\");\r\n\r\n    /* 2. get repl idx */\r\n    replIdx = get_repl_idx(remote_host, remote_port);\r\n    if (replIdx < 0) {\r\n        ereport(LOG, (errmsg(\"remote client is not in replconninfo: %s/%d\", remote_host, remote_port)));\r\n        return;\r\n    }\r\n\r\n    /* 3. truncate the old file. */\r\n    fp = fopen(newHostPath, \"w\");\r\n    if (fp == NULL) {\r\n        ereport(LOG, (errmsg(\"open file failed: %s\", newHostPath)));\r\n        return;\r\n    }\r\n\r\n    /*\r\n     * 4. write conninfo idx\r\n     * the second idx is useless\r\n     * just for compaitble with pre version.\r\n     */\r\n    ret = fprintf(fp, \"%d/0\", replIdx - 1);\r\n    if (ret < 0) {\r\n        ereport(LOG, (errmsg(\"write conninfo failed: %s\", newHostPath)));\r\n        (void)fclose(fp);\r\n        fp = NULL;\r\n        return;\r\n    }\r\n\r\n    /* 5. free the resource. */\r\n    (void)fflush(fp);\r\n    (void)fclose(fp);\r\n    fp = NULL;\r\n\r\n    /* 6. success */\r\n    return;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"set_failover_host_conninfo_for_dummy"
	},
	"set_rcv_slot_name":{
		"body":"static void set_rcv_slot_name(const char* slotname)\r\n{\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    volatile HaShmemData* hashmdata = t_thrd.postmaster_cxt.HaShmData;\r\n    ReplConnInfo* conninfo = NULL;\r\n    int replIdx = 0;\r\n    errno_t retcode = EOK;\r\n\r\n    /* get current repl conninfo, */\r\n    SpinLockAcquire(&hashmdata->mutex);\r\n    replIdx = hashmdata->current_repl;\r\n    SpinLockRelease(&hashmdata->mutex);\r\n\r\n    conninfo = GetRepConnArray(&replIdx);\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    if (slotname != NULL) {\r\n        retcode = strncpy_s((char*)walrcv->slotname, NAMEDATALEN, slotname, NAMEDATALEN - 1);\r\n        securec_check(retcode, \"\\0\", \"\\0\");\r\n    } else if (u_sess->attr.attr_common.application_name && strlen(u_sess->attr.attr_common.application_name) > 0) {\r\n        int rc = 0;\r\n        rc = snprintf_s(\r\n            (char*)walrcv->slotname, NAMEDATALEN, NAMEDATALEN - 1, \"%s\", u_sess->attr.attr_common.application_name);\r\n        securec_check_ss(rc, \"\\0\", \"\\0\");\r\n    } else if (g_instance.attr.attr_common.PGXCNodeName != NULL) {\r\n        int rc = 0;\r\n\r\n        if (IS_DN_DUMMY_STANDYS_MODE()) {\r\n            rc = snprintf_s(\r\n                (char*)walrcv->slotname, NAMEDATALEN, NAMEDATALEN - 1, \"%s\", g_instance.attr.attr_common.PGXCNodeName);\r\n        } else if (conninfo != NULL) {\r\n            rc = snprintf_s((char*)walrcv->slotname,\r\n                NAMEDATALEN,\r\n                NAMEDATALEN - 1,\r\n                \"%s_%s_%d\",\r\n                g_instance.attr.attr_common.PGXCNodeName,\r\n                conninfo->localhost,\r\n                conninfo->localport);\r\n        }\r\n        securec_check_ss(rc, \"\\0\", \"\\0\");\r\n    } else\r\n        walrcv->slotname[0] = '\\0';\r\n\r\n    SpinLockRelease(&walrcv->mutex);\r\n    return;\r\n}",
		"comment":"/*\r\n * Set current walrcv's slotname.\r\n *  depend on have setting the hashmdata->current_repl\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walreceiverfuncs.cpp",
		"name":"set_rcv_slot_name"
	}
}