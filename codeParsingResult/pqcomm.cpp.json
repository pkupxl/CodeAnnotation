{
	"CloseAndFreePort":{
		"body":"void CloseAndFreePort(Port* port)\r\n{\r\n    if (port != NULL) {\r\n        if (port->sock >= 0) {\r\n            close(port->sock);\r\n            port->sock = -1;\r\n        }\r\n        pfree(port);\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\heartbeat\\libpq\\pqcomm.cpp",
		"name":"CloseAndFreePort"
	},
	"SetSocketNoBlock":{
		"body":"int SetSocketNoBlock(int isocketId)\r\n{\r\n    int iFlag = 0;\r\n    int ret = 0;\r\n    uint32 uFlag = 0;\r\n\r\n    iFlag = fcntl(isocketId, F_GETFL, 0);\r\n    if (iFlag < 0) {\r\n        ereport(LOG,\r\n            (errmsg(\"Get socket info is failed(socketId = %d,errno = %d,errinfo = %s).\",\r\n                isocketId,\r\n                errno,\r\n                strerror(errno))));\r\n        return STATUS_ERROR;\r\n    }\r\n\r\n    uFlag = (uint32)iFlag;\r\n    uFlag |= O_NONBLOCK;\r\n\r\n    ret = fcntl(isocketId, F_SETFL, uFlag);\r\n    if (ret < 0) {\r\n        ereport(LOG,\r\n            (errmsg(\"Set socket block is failed(socketId = %d,errno = %d,errinfo = %s).\",\r\n                isocketId,\r\n                errno,\r\n                strerror(errno))));\r\n        return STATUS_ERROR;\r\n    }\r\n\r\n    return STATUS_OK;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\heartbeat\\libpq\\pqcomm.cpp",
		"name":"SetSocketNoBlock"
	},
	"StreamClose":{
		"body":"void StreamClose(int sock)\r\n{\r\n    close(sock);\r\n}",
		"comment":"/*\r\n * StreamClose -- close a client/backend connection\r\n *\r\n * NOTE: this is NOT used to terminate a session; it is just used to release\r\n * the file descriptor in a process that should no longer have the socket\r\n * open.  (For example, the postmaster calls this after passing ownership\r\n * of the connection to a child process.)  It is expected that someone else\r\n * still has the socket open.  So, we only want to close the descriptor,\r\n * we do NOT want to send anything to the far end.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\heartbeat\\libpq\\pqcomm.cpp",
		"name":"StreamClose"
	},
	"StreamConnection":{
		"body":"int StreamConnection(int server_fd, Port* port)\r\n{\r\n    /* accept connection and fill in the client (remote) address */\r\n    port->raddr.salen = sizeof(port->raddr.addr);\r\n    if ((port->sock = accept(server_fd, (struct sockaddr*)&port->raddr.addr, (socklen_t*)&port->raddr.salen)) < 0) {\r\n        ereport(LOG, (errmsg(\"could not accept new connection.\")));\r\n\r\n        /*\r\n         * If accept() fails then postmaster.c will still see the server\r\n         * socket as read-ready, and will immediately try again.  To avoid\r\n         * uselessly sucking lots of CPU, delay a bit before trying again.\r\n         * (The most likely reason for failure is being out of kernel file\r\n         * table slots; we can do little except hope some will get freed up.)\r\n         */\r\n        return STATUS_ERROR;\r\n    }\r\n\r\n#ifdef SCO_ACCEPT_BUG\r\n\r\n    /*\r\n     * UnixWare 7+ and OpenServer 5.0.4 are known to have this bug, but it\r\n     * shouldn't hurt to catch it for all versions of those platforms.\r\n     */\r\n    if (port->raddr.addr.ss_family == 0)\r\n        port->raddr.addr.ss_family = AF_UNIX;\r\n#endif\r\n\r\n    /* fill in the server (local) address */\r\n    port->laddr.salen = sizeof(port->laddr.addr);\r\n    if (getsockname(port->sock, (struct sockaddr*)&port->laddr.addr, (socklen_t*)&port->laddr.salen) < 0) {\r\n        ereport(LOG, (errmsg(\"getsockname() failed !\")));\r\n        return STATUS_ERROR;\r\n    }\r\n\r\n    /* select NODELAY and KEEPALIVE options if it's a TCP connection */\r\n    if (!IS_AF_UNIX(port->laddr.addr.ss_family)) {\r\n        int on;\r\n\r\n#ifdef TCP_NODELAY\r\n        on = 1;\r\n        if (setsockopt(port->sock, IPPROTO_TCP, TCP_NODELAY, (char*)&on, sizeof(on)) < 0) {\r\n            ereport(LOG, (errmsg(\"setsockopt(TCP_NODELAY) failed.\")));\r\n            return STATUS_ERROR;\r\n        }\r\n#endif\r\n        on = 1;\r\n        if (setsockopt(port->sock, SOL_SOCKET, SO_KEEPALIVE, (char*)&on, sizeof(on)) < 0) {\r\n            ereport(LOG, (errmsg(\"setsockopt(SO_KEEPALIVE) failed.\")));\r\n            return STATUS_ERROR;\r\n        }\r\n\r\n        on = SetSocketNoBlock(port->sock);\r\n        if (on != STATUS_OK) {\r\n            ereport(LOG, (errmsg(\"SetSocketNoBlock failed.\")));\r\n            return STATUS_ERROR;\r\n        }\r\n    }\r\n\r\n    return STATUS_OK;\r\n}",
		"comment":"/*\r\n * StreamConnection -- create a new connection with client using\r\n *		server port.  Set port->sock to the FD of the new connection.\r\n *\r\n * ASSUME: that this doesn't need to be non-blocking because\r\n *		the Postmaster uses select() to tell when the server master\r\n *		socket is ready for accept().\r\n *\r\n * RETURNS: STATUS_OK or STATUS_ERROR\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\heartbeat\\libpq\\pqcomm.cpp",
		"name":"StreamConnection"
	},
	"StreamServerPort":{
		"body":"int StreamServerPort(int family, char* hostName, unsigned short portNumber, int ListenSocket[], int MaxListen)\r\n{\r\n    const int PORT_STR_LEN = 32;\r\n    const int FAMILY_DESC_LEN = 64;\r\n    int fd = -1;\r\n    int err;\r\n    int maxconn;\r\n    int ret;\r\n    char portNumberStr[PORT_STR_LEN];\r\n    const char* familyDesc = NULL;\r\n    char familyDescBuf[FAMILY_DESC_LEN];\r\n    char* service = NULL;\r\n    struct addrinfo* addrs = NULL;\r\n    struct addrinfo* addr = NULL;\r\n    struct addrinfo hint;\r\n    int listen_index = 0;\r\n    int added = 0;\r\n    errno_t rc = 0;\r\n\r\n#if !defined(WIN32) || defined(IPV6_V6ONLY)\r\n    int one = 1;\r\n#endif\r\n\r\n    /* Initialize hint structure */\r\n    rc = memset_s(&hint, sizeof(hint), 0, sizeof(hint));\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n\r\n    hint.ai_family = family;\r\n    hint.ai_flags = AI_PASSIVE;\r\n    hint.ai_socktype = SOCK_STREAM;\r\n\r\n    rc = snprintf_s(portNumberStr, sizeof(portNumberStr), sizeof(portNumberStr) - 1, \"%d\", portNumber);\r\n    securec_check_ss(rc, \"\\0\", \"\\0\");\r\n    service = portNumberStr;\r\n\r\n    ret = pg_getaddrinfo_all(hostName, service, &hint, &addrs);\r\n    if (ret || (addrs == NULL)) {\r\n        if (hostName != NULL)\r\n            ereport(LOG,\r\n                (errmsg(\"could not translate host name \\\"%s\\\", service \\\"%s\\\" to address: %s\",\r\n                    hostName,\r\n                    service,\r\n                    gai_strerror(ret))));\r\n        else\r\n            ereport(LOG, (errmsg(\"could not translate service \\\"%s\\\" to address: %s\", service, gai_strerror(ret))));\r\n        if (addrs != NULL)\r\n            pg_freeaddrinfo_all(hint.ai_family, addrs);\r\n        return STATUS_ERROR;\r\n    }\r\n\r\n    for (addr = addrs; addr != NULL; addr = addr->ai_next) {\r\n        if (!IS_AF_UNIX(family) && IS_AF_UNIX(addr->ai_family)) {\r\n            /*\r\n             * Only set up a unix domain socket when they really asked for it.\r\n             * The service/port is different in that case.\r\n             */\r\n            continue;\r\n        }\r\n\r\n        /* See if there is still room to add 1 more socket. */\r\n        for (; listen_index < MaxListen; listen_index++) {\r\n            if (ListenSocket[listen_index] == PGINVALID_SOCKET)\r\n                break;\r\n        }\r\n        if (listen_index >= MaxListen) {\r\n            ereport(LOG, (errmsg(\"could not bind to all requested addresses: MAXLISTEN (%d) exceeded\", MaxListen)));\r\n            break;\r\n        }\r\n\r\n        /* set up family name for possible error messages */\r\n        switch (addr->ai_family) {\r\n            case AF_INET:\r\n                familyDesc = \"IPv4\";\r\n                break;\r\n#ifdef HAVE_IPV6\r\n            case AF_INET6:\r\n                familyDesc = \"IPv6\";\r\n                break;\r\n#endif\r\n            default:\r\n                rc = snprintf_s(familyDescBuf,\r\n                    sizeof(familyDescBuf),\r\n                    sizeof(familyDescBuf) - 1,\r\n                    \"unrecognized address family %d\",\r\n                    addr->ai_family);\r\n                securec_check_ss(rc, \"\\0\", \"\\0\");\r\n                familyDesc = familyDescBuf;\r\n                break;\r\n        }\r\n\r\n        if ((fd = socket(addr->ai_family, SOCK_STREAM, 0)) < 0) {\r\n            ereport(LOG, (errmsg(\"could not create %s socket:\", familyDesc)));\r\n            continue;\r\n        }\r\n\r\n#ifndef WIN32\r\n\r\n        /*\r\n         * Without the SO_REUSEADDR flag, a new postmaster can't be started\r\n         * right away after a stop or crash, giving \"address already in use\"\r\n         * error on TCP ports.\r\n         *\r\n         * On win32, however, this behavior only happens if the\r\n         * SO_EXLUSIVEADDRUSE is set. With SO_REUSEADDR, win32 allows multiple\r\n         * servers to listen on the same address, resulting in unpredictable\r\n         * behavior. With no flags at all, win32 behaves as Unix with\r\n         * SO_REUSEADDR.\r\n         */\r\n        if (!IS_AF_UNIX(addr->ai_family)) {\r\n            if ((setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&one, sizeof(one))) == -1) {\r\n                ereport(LOG, (errmsg(\"setsockopt(SO_REUSEADDR) failed.\")));\r\n                close(fd);\r\n                continue;\r\n            }\r\n        }\r\n#endif\r\n\r\n#ifdef IPV6_V6ONLY\r\n        if (addr->ai_family == AF_INET6) {\r\n            if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&one, sizeof(one)) == -1) {\r\n                ereport(LOG, (errmsg(\"setsockopt(IPV6_V6ONLY) failed.\")));\r\n                close(fd);\r\n                continue;\r\n            }\r\n        }\r\n#endif\r\n\r\n        /*\r\n         * Note: This might fail on some OS's, like Linux older than\r\n         * 2.4.21-pre3, that don't have the IPV6_V6ONLY socket option, and map\r\n         * ipv4 addresses to ipv6.	It will show ::ffff:ipv4 for all ipv4\r\n         * connections.\r\n         */\r\n        err = bind(fd, addr->ai_addr, addr->ai_addrlen);\r\n        if (err < 0) {\r\n            ereport(LOG,\r\n                (errmsg(\"could not bind %s socket: Is another instance already running on port %d?\"\r\n                        \" If not, wait a few seconds and retry.\",\r\n                    familyDesc,\r\n                    (int)portNumber)));\r\n\r\n            close(fd);\r\n            continue;\r\n        }\r\n\r\n        const int MAX_CONNECTIONS = 512;\r\n\r\n        /*\r\n         * Select appropriate accept-queue length limit.  PG_SOMAXCONN is only\r\n         * intended to provide a clamp on the request on platforms where an\r\n         * overly large request provokes a kernel error (are there any?).\r\n         */\r\n        maxconn = MAX_CONNECTIONS;\r\n\r\n        err = listen(fd, maxconn);\r\n        if (err < 0) {\r\n            ereport(LOG, (errmsg(\"could not listen on %s socket.\", familyDesc)));\r\n            close(fd);\r\n            continue;\r\n        }\r\n        ListenSocket[listen_index] = fd;\r\n        added++;\r\n    }\r\n\r\n    pg_freeaddrinfo_all(hint.ai_family, addrs);\r\n\r\n    if (!added)\r\n        return STATUS_ERROR;\r\n\r\n    return STATUS_OK;\r\n}",
		"comment":"/*\r\n * StreamServerPort -- open a \"listening\" port to accept connections.\r\n *\r\n * Successfully opened sockets are added to the ListenSocket[] array,\r\n * at the first position that isn't -1.\r\n *\r\n * RETURNS: STATUS_OK or STATUS_ERROR\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\heartbeat\\libpq\\pqcomm.cpp",
		"name":"StreamServerPort"
	},
	"internal_flush":{
		"body":"static int internal_flush(Port* myport)\r\n{\r\n    static THR_LOCAL int last_reported_send_errno = 0;\r\n\r\n    char* bufptr = myport->PqSendBuffer;\r\n    char* bufend = myport->PqSendBuffer + myport->PqSendPointer;\r\n\r\n    while (bufptr < bufend) {\r\n        int r;\r\n        int retry_times = 0;\r\n    resend:\r\n        errno = 0;\r\n        r = send(myport->sock, bufptr, bufend - bufptr, MSG_DONTWAIT);\r\n        myport->last_call = LastCall_SEND;\r\n        if (r <= 0) {\r\n            myport->last_errno = errno;\r\n            if (errno == EINTR)\r\n                continue; /* Ok if we were interrupted */\r\n\r\n            if (errno == EPIPE) {\r\n                return TCP_SOCKET_ERROR_EPIPE;\r\n            }\r\n\r\n            if (errno == EAGAIN || errno == EWOULDBLOCK) {\r\n                if (retry_times++ >= TCP_MAX_RETRY_TIMES) {\r\n                    return TCP_SOCKET_ERROR_NO_MESSAGE;\r\n                }\r\n                goto resend;\r\n            }\r\n\r\n            /*\r\n             * Careful: an ereport() that tries to write to the client would\r\n             * cause recursion to here, leading to stack overflow and core\r\n             * dump!  This message must go *only* to the postmaster log.\r\n             *\r\n             * If a client disconnects while we're in the midst of output, we\r\n             * might write quite a bit of data before we get to a safe query\r\n             * abort point.  So, suppress duplicate log messages.\r\n             */\r\n            if (errno != last_reported_send_errno) {\r\n                last_reported_send_errno = errno;\r\n                ereport(COMMERROR, (errmsg(\"could not send data to client.\")));\r\n            }\r\n\r\n            /*\r\n             * We drop the buffered data anyway so that processing can\r\n             * continue, even though we'll probably quit soon.\r\n             */\r\n            myport->PqSendPointer = 0;\r\n            return EOF;\r\n        } else {\r\n            myport->last_errno = 0;\r\n        }\r\n\r\n        last_reported_send_errno = 0; /* reset after any successful send */\r\n        bufptr += r;\r\n        myport->PqSendPointer = myport->PqSendPointer + r;\r\n    }\r\n\r\n    myport->PqSendPointer = 0;\r\n    return 0;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\heartbeat\\libpq\\pqcomm.cpp",
		"name":"internal_flush"
	},
	"internal_putbytes":{
		"body":"static int internal_putbytes(Port* myport, const char* s, size_t len)\r\n{\r\n    size_t amount;\r\n    int ret;\r\n    errno_t rc;\r\n\r\n    while (len > 0) {\r\n        /* If buffer is full, then flush it out */\r\n        if (myport->PqSendPointer >= PQ_BUFFER_SIZE) {\r\n            ret = internal_flush(myport);\r\n            if (ret != 0) {\r\n                return ret;\r\n            }\r\n        }\r\n        amount = PQ_BUFFER_SIZE - myport->PqSendPointer;\r\n        if (amount > len)\r\n            amount = len;\r\n        rc = memcpy_s(myport->PqSendBuffer + myport->PqSendPointer, PQ_BUFFER_SIZE - myport->PqSendPointer, s, amount);\r\n        securec_check(rc, \"\\0\", \"\\0\");\r\n        myport->PqSendPointer += amount;\r\n        s += amount;\r\n        len -= amount;\r\n    }\r\n    return 0;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\heartbeat\\libpq\\pqcomm.cpp",
		"name":"internal_putbytes"
	},
	"pq_flush":{
		"body":"int pq_flush(Port* myport)\r\n{\r\n    int res;\r\n\r\n    /* No-op if reentrant call */\r\n    res = internal_flush(myport);\r\n    return res;\r\n}",
		"comment":"/* --------------------------------\r\n *		pq_flush		- flush pending output\r\n *\r\n *		returns 0 if OK, EOF if trouble\r\n * --------------------------------\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\heartbeat\\libpq\\pqcomm.cpp",
		"name":"pq_flush"
	},
	"pq_getbyte":{
		"body":"int pq_getbyte(Port* myport)\r\n{\r\n    int ret;\r\n    while (myport->PqRecvPointer >= myport->PqRecvLength) {\r\n        ret = pq_recvbuf(myport);\r\n        if (ret == 0) {\r\n            continue;\r\n        } else {\r\n            return ret; /* Failed to recv data */\r\n        }\r\n    }\r\n    return (unsigned char)myport->PqRecvBuffer[myport->PqRecvPointer++];\r\n}",
		"comment":"/* --------------------------------\r\n *		pq_getbyte	- get a single byte from connection, or return EOF\r\n * --------------------------------\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\heartbeat\\libpq\\pqcomm.cpp",
		"name":"pq_getbyte"
	},
	"pq_getbytes":{
		"body":"int pq_getbytes(Port* myport, char* s, size_t len)\r\n{\r\n    size_t amount;\r\n    int ret;\r\n    errno_t rc;\r\n\r\n    while (len > 0) {\r\n        while (myport->PqRecvPointer >= myport->PqRecvLength) {\r\n            ret = pq_recvbuf(myport);\r\n            if (ret != 0) {\r\n                return ret; /* Failed to recv data */\r\n            }\r\n        }\r\n        amount = myport->PqRecvLength - myport->PqRecvPointer;\r\n        if (amount > len)\r\n            amount = len;\r\n        rc = memcpy_s(s, len, myport->PqRecvBuffer + myport->PqRecvPointer, amount);\r\n        securec_check(rc, \"\\0\", \"\\0\");\r\n        myport->PqRecvPointer += amount;\r\n        s += amount;\r\n        len -= amount;\r\n    }\r\n    return 0;\r\n}",
		"comment":"/* --------------------------------\r\n *		pq_getbytes		- get a known number of bytes from connection\r\n *\r\n *		returns 0 if OK, EOF if trouble\r\n * --------------------------------\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\heartbeat\\libpq\\pqcomm.cpp",
		"name":"pq_getbytes"
	},
	"pq_putbytes":{
		"body":"int pq_putbytes(Port* myport, const char* s, size_t len)\r\n{\r\n    return internal_putbytes(myport, s, len);\r\n}",
		"comment":"/* --------------------------------\r\n *      pq_putbytes     - send bytes to connection (not flushed until pq_flush)\r\n *\r\n *      returns 0 if OK, EOF if trouble\r\n * --------------------------------\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\heartbeat\\libpq\\pqcomm.cpp",
		"name":"pq_putbytes"
	},
	"pq_putmessage":{
		"body":"int pq_putmessage(Port* myport, char msgtype, const char* s, size_t len)\r\n{\r\n    uint32 n32;\r\n    int ret;\r\n    if (msgtype) {\r\n        ret = internal_putbytes(myport, &msgtype, 1);\r\n        if (ret != 0) {\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    n32 = htonl((uint32)(len + sizeof(uint32)));\r\n    ret = internal_putbytes(myport, (char*)&n32, sizeof(uint32));\r\n    if (ret != 0) {\r\n        return ret;\r\n    }\r\n\r\n    ret = internal_putbytes(myport, s, len);\r\n    if (ret != 0) {\r\n        return ret;\r\n    }\r\n\r\n    return 0;\r\n}",
		"comment":"/* --------------------------------\r\n *		pq_putmessage	- send a normal message (suppressed in COPY OUT mode)\r\n *\r\n *		If msgtype is not '\\0', it is a message type code to place before\r\n *		the message body.  If msgtype is '\\0', then the message has no type\r\n *		code (this is only valid in pre-3.0 protocols).\r\n *\r\n *		len is the length of the message body data at *s.  In protocol 3.0\r\n *		and later, a message length word (equal to len+4 because it counts\r\n *		itself too) is inserted by this routine.\r\n *\r\n *		All normal messages are suppressed while old-style COPY OUT is in\r\n *		progress.  (In practice only a few notice messages might get emitted\r\n *		then; dropping them is annoying, but at least they will still appear\r\n *		in the postmaster log.)\r\n *\r\n *		We also suppress messages generated while pqcomm.c is busy.  This\r\n *		avoids any possibility of messages being inserted within other\r\n *		messages.  The only known trouble case arises if SIGQUIT occurs\r\n *		during a pqcomm.c routine --- quickdie() will try to send a warning\r\n *		message, and the most reasonable approach seems to be to drop it.\r\n *\r\n *		returns 0 if OK, EOF if trouble\r\n * --------------------------------\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\heartbeat\\libpq\\pqcomm.cpp",
		"name":"pq_putmessage"
	},
	"pq_recvbuf":{
		"body":"static int pq_recvbuf(Port* myport)\r\n{\r\n    errno_t rc;\r\n    if (myport->PqRecvPointer > 0) {\r\n        if (myport->PqRecvLength > myport->PqRecvPointer) {\r\n            /* still some unread data, left-justify it in the buffer */\r\n            rc = memmove_s(myport->PqRecvBuffer,\r\n                myport->PqRecvLength,\r\n                myport->PqRecvBuffer + myport->PqRecvPointer,\r\n                myport->PqRecvLength - myport->PqRecvPointer);\r\n            securec_check(rc, \"\\0\", \"\\0\");\r\n            myport->PqRecvLength -= myport->PqRecvPointer;\r\n            myport->PqRecvPointer = 0;\r\n        } else\r\n            myport->PqRecvLength = myport->PqRecvPointer = 0;\r\n    }\r\n\r\n    /* Can fill buffer from myport->PqRecvLength and upwards */\r\n    for (;;) {\r\n        int r;\r\n        int retry_times = 0;\r\n\r\n    retry:\r\n        r = recv(myport->sock,\r\n            myport->PqRecvBuffer + myport->PqRecvLength,\r\n            PQ_BUFFER_SIZE - myport->PqRecvLength,\r\n            MSG_DONTWAIT);\r\n        myport->last_call = LastCall_RECV;\r\n\r\n        if (r < 0) {\r\n            myport->last_errno = errno;\r\n            if (errno == EINTR)\r\n                continue; /* Ok if interrupted */\r\n\r\n            if (errno == EPIPE) {\r\n                return TCP_SOCKET_ERROR_EPIPE;\r\n            }\r\n\r\n            /*\r\n             * The socket's file descriptor is marked O_NONBLOCK and no data is waiting to be received;\r\n             * or MSG_OOB is set and no out-of-band data is available and either the socket's file descriptor\r\n             * is marked  O_NONBLOCK or the socket does not support blocking to await out-of-band data.\r\n             */\r\n            if ((errno == EAGAIN) || (errno == EWOULDBLOCK)) {\r\n                if (retry_times++ >= TCP_MAX_RETRY_TIMES) {\r\n                    return TCP_SOCKET_ERROR_NO_MESSAGE;\r\n                }\r\n                goto retry;\r\n            }\r\n\r\n            /*\r\n             * Careful: an ereport() that tries to write to the client would\r\n             * cause recursion to here, leading to stack overflow and core\r\n             * dump!  This message must go *only* to the postmaster log.\r\n             */\r\n            ereport(COMMERROR, (errmsg(\"could not receive data from client: err=%d\", errno)));\r\n            return TCP_SOCKET_ERROR_EPIPE;\r\n        } else {\r\n            myport->last_errno = 0;\r\n        }\r\n        if (r == 0) {\r\n            /*\r\n             * EOF detected.  We used to write a log message here, but it's\r\n             * better to expect the ultimate caller to do that.\r\n             */\r\n            return EOF;\r\n        }\r\n        /* r contains number of bytes read, so just incr length */\r\n        myport->PqRecvLength += r;\r\n        return 0;\r\n    }\r\n}",
		"comment":"/* --------------------------------\r\n *		pq_recvbuf - load some bytes into the input buffer\r\n *\r\n *		returns 0 if OK, EOF if trouble\r\n * --------------------------------\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\heartbeat\\libpq\\pqcomm.cpp",
		"name":"pq_recvbuf"
	}
}