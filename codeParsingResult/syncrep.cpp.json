{
	"SyncRepCancelWait":{
		"body":"static bool SyncRepCancelWait(void)\r\n{\r\n    bool success = false;\r\n    LWLockAcquire(SyncRepLock, LW_EXCLUSIVE);\r\n    if (!t_thrd.proc->syncRepInCompleteQueue) {\r\n        if (!SHMQueueIsDetached(&(t_thrd.proc->syncRepLinks)))\r\n            SHMQueueDelete(&(t_thrd.proc->syncRepLinks));\r\n        t_thrd.proc->syncRepState = SYNC_REP_NOT_WAITING;\r\n        success = true;\r\n    }\r\n    LWLockRelease(SyncRepLock);\r\n    return success;\r\n}",
		"comment":"/*\r\n * Acquire SyncRepLock and cancel any wait currently not in completion queue.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"SyncRepCancelWait"
	},
	"SyncRepCheckSyncStandbyAlive":{
		"body":"void SyncRepCheckSyncStandbyAlive(void)\r\n{\r\n    bool sync_standby_alive = false;\r\n    int i = 0;\r\n\r\n    if (!t_thrd.walsender_cxt.WalSndCtl->sync_standbys_defined ||\r\n        !t_thrd.walsender_cxt.WalSndCtl->most_available_sync) {\r\n        t_thrd.walsender_cxt.WalSndCtl->sync_master_standalone = false;\r\n        return;\r\n    }\r\n\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n        volatile WalSnd* walsnd = &t_thrd.walsender_cxt.WalSndCtl->walsnds[i];\r\n\r\n        SpinLockAcquire(&walsnd->mutex);\r\n\r\n        /*\r\n         * Check if this synchronous standby and its pid is not zero i.e. synchronous\r\n         * standby is alive.\r\n         */\r\n        if (walsnd->pid != 0 && walsnd->sync_standby_priority > 0 &&\r\n            (walsnd->sendRole == SNDROLE_PRIMARY_DUMMYSTANDBY || walsnd->sendRole == SNDROLE_PRIMARY_STANDBY)) {\r\n            SpinLockRelease(&walsnd->mutex);\r\n            sync_standby_alive = true;\r\n            break;\r\n        }\r\n\r\n        SpinLockRelease(&walsnd->mutex);\r\n    }\r\n\r\n    if (sync_standby_alive && t_thrd.walsender_cxt.WalSndCtl->sync_master_standalone) {\r\n        ereport(LOG, (errmsg(\"standalone synchronous master now have synchronous standby\")));\r\n\r\n        t_thrd.walsender_cxt.WalSndCtl->sync_master_standalone = false;\r\n        return;\r\n    }\r\n\r\n    if (!sync_standby_alive && !t_thrd.walsender_cxt.WalSndCtl->sync_master_standalone &&\r\n        t_thrd.walsender_cxt.WalSndCtl->most_available_sync) {\r\n        ereport(LOG, (errmsg(\"synchronous master is now standalone\")));\r\n\r\n        t_thrd.walsender_cxt.WalSndCtl->sync_master_standalone = true;\r\n\r\n        /*\r\n         * If there is any waiting sender, then wake-up them as\r\n         * master has switched to standalone mode\r\n         */\r\n        for (i = 0; i < NUM_SYNC_REP_WAIT_MODE; i++)\r\n            (void)SyncRepWakeQueue(true, i);\r\n    }\r\n}",
		"comment":"/*\r\n * check to see whether synchronous standby is alive.\r\n * Loop through all sender task and check if there is any\r\n * synchronous standby is alive. If alive then master needs\r\n * to continue to wait for synchronous standby otherwise,\r\n * it does not have to and it can switch to standalone mode.\r\n * Whenever mode is changing from one to another then\r\n * log the appropriate log message, which will be used by DBA.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"SyncRepCheckSyncStandbyAlive"
	},
	"SyncRepCleanupAtProcExit":{
		"body":"void SyncRepCleanupAtProcExit(void)\r\n{\r\n    if (t_thrd.proc->syncRepLinks.prev || t_thrd.proc->syncRepLinks.next ||\r\n        t_thrd.proc->syncRepState != SYNC_REP_NOT_WAITING) {\r\n        LWLockAcquire(SyncRepLock, LW_EXCLUSIVE);\r\n        if (!t_thrd.proc->syncRepInCompleteQueue) {\r\n            if (!SHMQueueIsDetached(&(t_thrd.proc->syncRepLinks))) {\r\n                SHMQueueDelete(&(t_thrd.proc->syncRepLinks));\r\n            }\r\n            LWLockRelease(SyncRepLock);\r\n            return;\r\n        }\r\n        LWLockRelease(SyncRepLock);\r\n        SyncRepWaitCompletionQueue();\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"SyncRepCleanupAtProcExit"
	},
	"SyncRepGetNthLatestSyncRecPtr":{
		"body":"static void SyncRepGetNthLatestSyncRecPtr(\r\n    XLogRecPtr* receivePtr, XLogRecPtr* writePtr, XLogRecPtr* flushPtr, XLogRecPtr* replayPtr, List* sync_standbys, uint8 nth)\r\n{\r\n    ListCell* cell = NULL;\r\n    XLogRecPtr* receive_array = NULL;\r\n    XLogRecPtr* write_array = NULL;\r\n    XLogRecPtr* flush_array = NULL;\r\n    XLogRecPtr* apply_array = NULL;\r\n    int len;\r\n    int i = 0;\r\n\r\n    len = list_length(sync_standbys);\r\n    receive_array = (XLogRecPtr*)palloc(sizeof(XLogRecPtr) * len);\r\n    write_array = (XLogRecPtr*)palloc(sizeof(XLogRecPtr) * len);\r\n    flush_array = (XLogRecPtr*)palloc(sizeof(XLogRecPtr) * len);\r\n    apply_array = (XLogRecPtr*)palloc(sizeof(XLogRecPtr) * len);\r\n\r\n    foreach (cell, sync_standbys) {\r\n        WalSnd* walsnd = &t_thrd.walsender_cxt.WalSndCtl->walsnds[lfirst_int(cell)];\r\n\r\n        SpinLockAcquire(&walsnd->mutex);\r\n        receive_array[i] = walsnd->receive;\r\n        write_array[i] = walsnd->write;\r\n        flush_array[i] = walsnd->flush;\r\n        apply_array[i] = walsnd->apply;\r\n        SpinLockRelease(&walsnd->mutex);\r\n\r\n        i++;\r\n    }\r\n\r\n    qsort(receive_array, len, sizeof(XLogRecPtr), cmp_lsn);\r\n    qsort(write_array, len, sizeof(XLogRecPtr), cmp_lsn);\r\n    qsort(flush_array, len, sizeof(XLogRecPtr), cmp_lsn);\r\n    qsort(apply_array, len, sizeof(XLogRecPtr), cmp_lsn);\r\n\r\n    /* Get Nth latest Write, Flush, Apply positions */\r\n    *receivePtr = receive_array[nth - 1];\r\n    *writePtr = write_array[nth - 1];\r\n    *flushPtr = flush_array[nth - 1];\r\n    *replayPtr = apply_array[nth - 1];\r\n\r\n    pfree(receive_array);\r\n    receive_array = NULL;\r\n    pfree(write_array);\r\n    write_array = NULL;\r\n    pfree(flush_array);\r\n    flush_array = NULL;\r\n    pfree(apply_array);\r\n    apply_array = NULL;\r\n}",
		"comment":"/*\r\n * Calculate the Nth latest Write, Flush and Apply positions among sync\r\n * standbys.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"SyncRepGetNthLatestSyncRecPtr"
	},
	"SyncRepGetOldestSyncRecPtr":{
		"body":"static void SyncRepGetOldestSyncRecPtr(\r\n    XLogRecPtr* receivePtr, XLogRecPtr* writePtr, XLogRecPtr* flushPtr, XLogRecPtr* replayPtr, List* sync_standbys)\r\n{\r\n    ListCell* cell = NULL;\r\n\r\n    /*\r\n     * Scan through all sync standbys and calculate the oldest\r\n     * Write, Flush and Apply positions.\r\n     */\r\n    foreach (cell, sync_standbys) {\r\n        WalSnd* walsnd = &t_thrd.walsender_cxt.WalSndCtl->walsnds[lfirst_int(cell)];\r\n        XLogRecPtr receive;\r\n        XLogRecPtr write;\r\n        XLogRecPtr flush;\r\n        XLogRecPtr apply;\r\n\r\n        SpinLockAcquire(&walsnd->mutex);\r\n        receive = walsnd->receive;\r\n        write = walsnd->write;\r\n        flush = walsnd->flush;\r\n        apply = walsnd->apply;\r\n        SpinLockRelease(&walsnd->mutex);\r\n\r\n        if (XLogRecPtrIsInvalid(*writePtr) || !XLByteLE(*writePtr, write))\r\n            *writePtr = write;\r\n        if (XLogRecPtrIsInvalid(*flushPtr) || !XLByteLE(*flushPtr, flush))\r\n            *flushPtr = flush;\r\n        if (XLogRecPtrIsInvalid(*receivePtr) || !XLByteLE(*receivePtr, receive))\r\n            *receivePtr = receive;\r\n        if (XLogRecPtrIsInvalid(*replayPtr) || !XLByteLE(*replayPtr, apply))\r\n            *replayPtr = apply;\r\n    }\r\n}",
		"comment":"/*\r\n * Calculate the oldest Write, Flush and Apply positions among sync standbys.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"SyncRepGetOldestSyncRecPtr"
	},
	"SyncRepGetStandbyPriority":{
		"body":"static int SyncRepGetStandbyPriority(void)\r\n{\r\n    const char* standby_name = NULL;\r\n    int priority;\r\n    bool found = false;\r\n\r\n    /*\r\n     * Since synchronous cascade replication is not allowed, we always set the\r\n     * priority of cascading walsender to zero.\r\n     */\r\n    if (AM_WAL_STANDBY_SENDER)\r\n        return 0;\r\n\r\n    if (!SyncStandbysDefined() || t_thrd.syncrep_cxt.SyncRepConfig == NULL || !SyncRepRequested())\r\n        return 0;\r\n\r\n    standby_name = t_thrd.syncrep_cxt.SyncRepConfig->member_names;\r\n    for (priority = 1; priority <= t_thrd.syncrep_cxt.SyncRepConfig->nmembers; priority++) {\r\n        if (pg_strcasecmp(standby_name, u_sess->attr.attr_common.application_name) == 0 ||\r\n            strcmp(standby_name, \"*\") == 0) {\r\n            found = true;\r\n            break;\r\n        }\r\n        standby_name += strlen(standby_name) + 1;\r\n    }\r\n\r\n    if (!found) {\r\n        return 0;\r\n    }\r\n\r\n    /*\r\n     * In quorum-based sync replication, all the standbys in the list\r\n     * have the same priority, one.\r\n     */\r\n    return (t_thrd.syncrep_cxt.SyncRepConfig->syncrep_method == SYNC_REP_PRIORITY) ? priority : 1;\r\n}",
		"comment":"/*\r\n * Check if we are in the list of sync standbys, and if so, determine\r\n * priority sequence. Return priority if set, or zero to indicate that\r\n * we are not a potential sync standby.\r\n *\r\n * Compare the parameter SyncRepStandbyNames against the application_name\r\n * for this WALSender, or allow any name if we find a wildcard \"*\".\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"SyncRepGetStandbyPriority"
	},
	"SyncRepGetSyncRecPtr":{
		"body":"static bool SyncRepGetSyncRecPtr(XLogRecPtr* receivePtr, XLogRecPtr* writePtr, XLogRecPtr* flushPtr, XLogRecPtr* replayPtr, bool* am_sync)\r\n{\r\n    List* sync_standbys = NIL;\r\n\r\n    *receivePtr = InvalidXLogRecPtr;\r\n    *writePtr = InvalidXLogRecPtr;\r\n    *flushPtr = InvalidXLogRecPtr;\r\n    *replayPtr = InvalidXLogRecPtr;\r\n    *am_sync = false;\r\n\r\n    /* Get standbys that are considered as synchronous at this moment */\r\n    sync_standbys = SyncRepGetSyncStandbys(am_sync);\r\n    /*\r\n     * Quick exit if we are not managing a sync standby or there are not\r\n     * enough synchronous standbys.\r\n     */\r\n    if (!(*am_sync) || t_thrd.syncrep_cxt.SyncRepConfig == NULL ||\r\n        list_length(sync_standbys) < t_thrd.syncrep_cxt.SyncRepConfig->num_sync) {\r\n        list_free(sync_standbys);\r\n        return false;\r\n    }\r\n\r\n    /*\r\n     * In a priority-based sync replication, the synced positions are the\r\n     * oldest ones among sync standbys. In a quorum-based, they are the Nth\r\n     * latest ones.\r\n     *\r\n     * SyncRepGetNthLatestSyncRecPtr() also can calculate the oldest positions.\r\n     * But we use SyncRepGetOldestSyncRecPtr() for that calculation because\r\n     * it's a bit more efficient.\r\n     *\r\n     * XXX If the numbers of current and requested sync standbys are the same,\r\n     * we can use SyncRepGetOldestSyncRecPtr() to calculate the synced\r\n     * positions even in a quorum-based sync replication.\r\n     */\r\n    if (t_thrd.syncrep_cxt.SyncRepConfig->syncrep_method == SYNC_REP_PRIORITY) {\r\n        SyncRepGetOldestSyncRecPtr(receivePtr, writePtr, flushPtr, replayPtr, sync_standbys);\r\n    } else {\r\n        SyncRepGetNthLatestSyncRecPtr(\r\n            receivePtr, writePtr, flushPtr, replayPtr, sync_standbys, t_thrd.syncrep_cxt.SyncRepConfig->num_sync);\r\n    }\r\n\r\n    list_free(sync_standbys);\r\n    return true;\r\n}",
		"comment":"/*\r\n * Calculate the synced Write, Flush and Apply positions among sync standbys.\r\n *\r\n * Return false if the number of sync standbys is less than\r\n * synchronous_standby_names specifies. Otherwise return true and\r\n * store the positions into *writePtr, *flushPtr and *applyPtr.\r\n *\r\n * On return, *am_sync is set to true if this walsender is connecting to\r\n * sync standby. Otherwise it's set to false.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"SyncRepGetSyncRecPtr"
	},
	"SyncRepGetSyncStandbys":{
		"body":"List* SyncRepGetSyncStandbys(bool* am_sync)\r\n{\r\n    /* Set default result */\r\n    if (am_sync != NULL)\r\n        *am_sync = false;\r\n\r\n    /* Quick exit if sync replication is not requested */\r\n    if (t_thrd.syncrep_cxt.SyncRepConfig == NULL)\r\n        return NIL;\r\n\r\n    return (t_thrd.syncrep_cxt.SyncRepConfig->syncrep_method == SYNC_REP_PRIORITY) ?\r\n        SyncRepGetSyncStandbysPriority(am_sync) :\r\n        SyncRepGetSyncStandbysQuorum(am_sync);\r\n}",
		"comment":"/*\r\n * Return the list of sync standbys, or NIL if no sync standby is connected.\r\n *\r\n * If there are multiple standbys with the same priority,\r\n * the first one found is selected preferentially.\r\n * The caller must hold SyncRepLock.\r\n *\r\n * On return, *am_sync is set to true if this walsender is connecting to\r\n * sync standby. Otherwise it's set to false.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"SyncRepGetSyncStandbys"
	},
	"SyncRepGetSyncStandbysPriority":{
		"body":"static List* SyncRepGetSyncStandbysPriority(bool* am_sync)\r\n{\r\n    List* result = NIL;\r\n    List* pending = NIL;\r\n    int lowest_priority;\r\n    int next_highest_priority;\r\n    int this_priority;\r\n    int priority;\r\n    int i;\r\n    bool am_in_pending = false;\r\n    volatile WalSnd* walsnd = NULL; /* Use volatile pointer to prevent code rearrangement */\r\n\r\n    Assert(t_thrd.syncrep_cxt.SyncRepConfig->syncrep_method == SYNC_REP_PRIORITY);\r\n\r\n    lowest_priority = t_thrd.syncrep_cxt.SyncRepConfig->nmembers;\r\n    next_highest_priority = lowest_priority + 1;\r\n\r\n    /*\r\n     * Find the sync standbys which have the highest priority (i.e, 1). Also\r\n     * store all the other potential sync standbys into the pending list, in\r\n     * order to scan it later and find other sync standbys from it quickly.\r\n     */\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n        walsnd = &t_thrd.walsender_cxt.WalSndCtl->walsnds[i];\r\n\r\n        /* Must be active */\r\n        if (walsnd->pid == 0)\r\n            continue;\r\n\r\n        /* Must be streaming */\r\n        if (walsnd->state != WALSNDSTATE_STREAMING)\r\n            continue;\r\n\r\n        /* Must be synchronous */\r\n        this_priority = walsnd->sync_standby_priority;\r\n        if (this_priority == 0)\r\n            continue;\r\n\r\n        /* Must have a valid flush position */\r\n        if (XLogRecPtrIsInvalid(walsnd->flush))\r\n            continue;\r\n\r\n        /*\r\n         * If the priority is equal to 1, consider this standby as sync and\r\n         * append it to the result. Otherwise append this standby to the\r\n         * pending list to check if it's actually sync or not later.\r\n         */\r\n        if (this_priority == 1) {\r\n            result = lappend_int(result, i);\r\n            if (am_sync != NULL && walsnd == t_thrd.walsender_cxt.MyWalSnd)\r\n                *am_sync = true;\r\n            if (list_length(result) == t_thrd.syncrep_cxt.SyncRepConfig->num_sync) {\r\n                list_free(pending);\r\n                return result; /* Exit if got enough sync standbys */\r\n            }\r\n        } else {\r\n            pending = lappend_int(pending, i);\r\n            if (am_sync != NULL && walsnd == t_thrd.walsender_cxt.MyWalSnd)\r\n                am_in_pending = true;\r\n\r\n            /*\r\n             * Track the highest priority among the standbys in the pending\r\n             * list, in order to use it as the starting priority for later\r\n             * scan of the list. This is useful to find quickly the sync\r\n             * standbys from the pending list later because we can skip\r\n             * unnecessary scans for the unused priorities.\r\n             */\r\n            if (this_priority < next_highest_priority)\r\n                next_highest_priority = this_priority;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Consider all pending standbys as sync if the number of them plus\r\n     * already-found sync ones is lower than the configuration requests.\r\n     */\r\n    if (list_length(result) + list_length(pending) <= t_thrd.syncrep_cxt.SyncRepConfig->num_sync) {\r\n        bool needfree = (result != NIL && pending != NIL);\r\n\r\n        /*\r\n         * Set *am_sync to true if this walsender is in the pending list\r\n         * because all pending standbys are considered as sync.\r\n         */\r\n        if (am_sync != NULL && !(*am_sync))\r\n            *am_sync = am_in_pending;\r\n\r\n        result = list_concat(result, pending);\r\n        if (needfree) {\r\n            pfree(pending);\r\n            pending = NULL;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /*\r\n     * Find the sync standbys from the pending list.\r\n     */\r\n    priority = next_highest_priority;\r\n    while (priority <= lowest_priority) {\r\n        ListCell* cell = NULL;\r\n        ListCell* prev = NULL;\r\n        ListCell* next = NULL;\r\n\r\n        next_highest_priority = lowest_priority + 1;\r\n\r\n        for (cell = list_head(pending); cell != NULL; cell = next) {\r\n            i = lfirst_int(cell);\r\n            walsnd = &t_thrd.walsender_cxt.WalSndCtl->walsnds[i];\r\n\r\n            next = lnext(cell);\r\n\r\n            this_priority = walsnd->sync_standby_priority;\r\n            if (this_priority == priority) {\r\n                result = lappend_int(result, i);\r\n                if (am_sync != NULL && walsnd == t_thrd.walsender_cxt.MyWalSnd)\r\n                    *am_sync = true;\r\n\r\n                /*\r\n                 * We should always exit here after the scan of pending list\r\n                 * starts because we know that the list has enough elements to\r\n                 * reach SyncRepConfig->num_sync.\r\n                 */\r\n                if (list_length(result) == t_thrd.syncrep_cxt.SyncRepConfig->num_sync) {\r\n                    list_free(pending);\r\n                    return result; /* Exit if got enough sync standbys */\r\n                }\r\n\r\n                /*\r\n                 * Remove the entry for this sync standby from the list to\r\n                 * prevent us from looking at the same entry again.\r\n                 */\r\n                pending = list_delete_cell(pending, cell, prev);\r\n\r\n                continue;\r\n            }\r\n\r\n            if (this_priority < next_highest_priority)\r\n                next_highest_priority = this_priority;\r\n\r\n            prev = cell;\r\n        }\r\n\r\n        priority = next_highest_priority;\r\n    }\r\n\r\n    /* never reached, but keep compiler quiet */\r\n    Assert(false);\r\n    return result;\r\n}",
		"comment":"/*\r\n * Return the list of sync standbys chosen based on their priorities,\r\n * or NIL if no sync standby is connected.\r\n *\r\n * If there are multiple standbys with the same priority,\r\n * the first one found is selected preferentially.\r\n *\r\n * The caller must hold SyncRepLock. This function must be called only in\r\n * a priority-based sync replication.\r\n *\r\n * On return, *am_sync is set to true if this walsender is connecting to\r\n * sync standby. Otherwise it's set to false.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"SyncRepGetSyncStandbysPriority"
	},
	"SyncRepGetSyncStandbysQuorum":{
		"body":"static List* SyncRepGetSyncStandbysQuorum(bool* am_sync)\r\n{\r\n    List* result = NIL;\r\n    int i;\r\n    volatile WalSnd* walsnd = NULL; /* Use volatile pointer to prevent code rearrangement */\r\n\r\n    Assert(t_thrd.syncrep_cxt.SyncRepConfig->syncrep_method == SYNC_REP_QUORUM);\r\n\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n        walsnd = &t_thrd.walsender_cxt.WalSndCtl->walsnds[i];\r\n\r\n        /* Must be active */\r\n        if (walsnd->pid == 0)\r\n            continue;\r\n\r\n        /* Must be streaming */\r\n        if (walsnd->state != WALSNDSTATE_STREAMING)\r\n            continue;\r\n\r\n        /* Must be synchronous */\r\n        if (walsnd->sync_standby_priority == 0)\r\n            continue;\r\n\r\n        /* Must have a valid flush position */\r\n        if (XLogRecPtrIsInvalid(walsnd->flush))\r\n            continue;\r\n\r\n        /*\r\n         * Consider this standby as a candidate for quorum sync standbys\r\n         * and append it to the result.\r\n         */\r\n        result = lappend_int(result, i);\r\n        if (am_sync != NULL && walsnd == t_thrd.walsender_cxt.MyWalSnd)\r\n            *am_sync = true;\r\n    }\r\n\r\n    return result;\r\n}",
		"comment":"/*\r\n * Return the list of all the candidates for quorum sync standbys,\r\n * or NIL if no such standby is connected.\r\n *\r\n * The caller must hold SyncRepLock. This function must be called only in\r\n * a quorum-based sync replication.\r\n *\r\n * On return, *am_sync is set to true if this walsender is connecting to\r\n * sync standby. Otherwise it's set to false.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"SyncRepGetSyncStandbysQuorum"
	},
	"SyncRepInitConfig":{
		"body":"void SyncRepInitConfig(void)\r\n{\r\n    int priority;\r\n\r\n    /*\r\n     * Determine if we are a potential sync standby and remember the result\r\n     * for handling replies from standby.\r\n     */\r\n    priority = SyncRepGetStandbyPriority();\r\n    if (t_thrd.walsender_cxt.MyWalSnd->sync_standby_priority != priority) {\r\n        LWLockAcquire(SyncRepLock, LW_EXCLUSIVE);\r\n        t_thrd.walsender_cxt.MyWalSnd->sync_standby_priority = priority;\r\n\r\n        /*\r\n         * Synchronous standby is starting, so we should change the standalone\r\n         * sync_master_standalone, if required.\r\n         */\r\n        SyncRepCheckSyncStandbyAlive();\r\n\r\n        LWLockRelease(SyncRepLock);\r\n        ereport(DEBUG1,\r\n            (errmsg(\"standby \\\"%s\\\" now has synchronous standby priority %d\",\r\n                u_sess->attr.attr_common.application_name,\r\n                priority)));\r\n    }\r\n}",
		"comment":"/*\r\n * ===========================================================\r\n * Synchronous Replication functions for wal sender processes\r\n * ===========================================================\r\n *\r\n *\r\n * Take any action required to initialise sync rep state from config\r\n * data. Called at WALSender startup and after each SIGHUP.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"SyncRepInitConfig"
	},
	"SyncRepNotifyComplete":{
		"body":"static void SyncRepNotifyComplete()\r\n{\r\n    SHM_QUEUE *nextElement = t_thrd.proc->syncRepLinks.next;\r\n    if (nextElement) {\r\n        t_thrd.proc->syncRepLinks.next = NULL;\r\n        while (nextElement != NULL) {\r\n            PGPROC* curProc = (PGPROC*)(((char*)nextElement) - offsetof(PGPROC, syncRepLinks));\r\n            /*\r\n             * Move to next proc, so we can delete thisproc from the queue.\r\n             * curProc is valid, proc may be NULL after this.\r\n             */\r\n            nextElement = curProc->syncRepLinks.next;\r\n\r\n            /*\r\n             * Remove curProc from queue.\r\n             */\r\n            curProc->syncRepLinks.next = NULL;\r\n            curProc->syncRepLinks.prev = NULL;\r\n\r\n            /*\r\n             * SyncRepWaitForLSN() reads syncRepState without holding the lock, so\r\n             * make sure that it sees the queue link being removed before the\r\n             * syncRepState change.\r\n             */\r\n            pg_write_barrier();\r\n\r\n            curProc->syncRepState = SYNC_REP_WAIT_COMPLETE;\r\n\r\n            /*\r\n             * Wake only when we have set state and removed from queue.\r\n             */\r\n            SetLatch(&(curProc->procLatch));\r\n        }\r\n    }\r\n}",
		"comment":"/*\r\n * Leader informs following procs\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"SyncRepNotifyComplete"
	},
	"SyncRepQueueInsert":{
		"body":"static void SyncRepQueueInsert(int mode)\r\n{\r\n    PGPROC* proc = NULL;\r\n\r\n    Assert(mode >= 0 && mode < NUM_SYNC_REP_WAIT_MODE);\r\n    proc = (PGPROC*)SHMQueuePrev(&(t_thrd.walsender_cxt.WalSndCtl->SyncRepQueue[mode]),\r\n        &(t_thrd.walsender_cxt.WalSndCtl->SyncRepQueue[mode]),\r\n        offsetof(PGPROC, syncRepLinks));\r\n\r\n    while (proc != NULL) {\r\n        /*\r\n         * Stop at the queue element that we should after to ensure the queue\r\n         * is ordered by LSN. The same lsn is allowed in sync queue.\r\n         */\r\n        if (XLByteLE(proc->waitLSN, t_thrd.proc->waitLSN))\r\n            break;\r\n\r\n        proc = (PGPROC*)SHMQueuePrev(&(t_thrd.walsender_cxt.WalSndCtl->SyncRepQueue[mode]),\r\n            &(proc->syncRepLinks),\r\n            offsetof(PGPROC, syncRepLinks));\r\n    }\r\n\r\n    if (proc != NULL)\r\n        SHMQueueInsertAfter(&(proc->syncRepLinks), &(t_thrd.proc->syncRepLinks));\r\n    else\r\n        SHMQueueInsertAfter(&(t_thrd.walsender_cxt.WalSndCtl->SyncRepQueue[mode]), &(t_thrd.proc->syncRepLinks));\r\n}",
		"comment":"/*\r\n * Insert t_thrd.proc into the specified SyncRepQueue, maintaining sorted invariant.\r\n *\r\n * Usually we will go at tail of queue, though it's possible that we arrive\r\n * here out of order, so start at tail and work back to insertion point.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"SyncRepQueueInsert"
	},
	"SyncRepReleaseWaiters":{
		"body":"void SyncRepReleaseWaiters(void)\r\n{\r\n    volatile WalSndCtlData* walsndctl = t_thrd.walsender_cxt.WalSndCtl;\r\n    XLogRecPtr receivePtr;\r\n    XLogRecPtr writePtr;\r\n    XLogRecPtr flushPtr;\r\n    XLogRecPtr replayPtr;\r\n    int numreceive = 0;\r\n    int numwrite = 0;\r\n    int numflush = 0;\r\n    bool got_recptr = false;\r\n    bool am_sync = false;\r\n\r\n    /*\r\n     * If this WALSender is serving a standby that is not on the list of\r\n     * potential standbys then we have nothing to do. If we are still starting\r\n     * up, still running base backup or the current flush position is still\r\n     * invalid, then leave quickly also.\r\n     */\r\n    if (t_thrd.walsender_cxt.MyWalSnd->sync_standby_priority == 0 ||\r\n        t_thrd.walsender_cxt.MyWalSnd->state < WALSNDSTATE_STREAMING ||\r\n        XLByteEQ(t_thrd.walsender_cxt.MyWalSnd->flush, InvalidXLogRecPtr)) {\r\n        t_thrd.syncrep_cxt.announce_next_takeover = true;\r\n        return;\r\n    }\r\n\r\n    /*\r\n     * We're a potential sync standby. Release waiters if we are the highest\r\n     * priority standby. If there are multiple standbys with same priorities\r\n     * then we use the first mentioned standby. If you change this, also\r\n     * change pg_stat_get_wal_senders().\r\n     */\r\n    (void)LWLockAcquire(SyncRepLock, LW_EXCLUSIVE);\r\n\r\n    /*\r\n     * Check whether we are a sync standby or not, and calculate the synced\r\n     * positions among all sync standbys.\r\n     */\r\n    got_recptr = SyncRepGetSyncRecPtr(&receivePtr, &writePtr, &flushPtr, &replayPtr, &am_sync);\r\n\r\n    /*\r\n     * If we are managing a sync standby, though we weren't prior to this,\r\n     * then announce we are now a sync standby.\r\n     */\r\n    if (t_thrd.syncrep_cxt.announce_next_takeover && am_sync) {\r\n        t_thrd.syncrep_cxt.announce_next_takeover = false;\r\n        if (t_thrd.syncrep_cxt.SyncRepConfig->syncrep_method == SYNC_REP_PRIORITY) {\r\n            ereport(LOG,\r\n                (errmsg(\"standby \\\"%s\\\" is now a synchronous standby with priority %d\",\r\n                    u_sess->attr.attr_common.application_name,\r\n                    t_thrd.walsender_cxt.MyWalSnd->sync_standby_priority)));\r\n        } else {\r\n            ereport(LOG,\r\n                (errmsg(\"standby \\\"%s\\\" is now a candidate for quorum synchronous standby\",\r\n                    u_sess->attr.attr_common.application_name)));\r\n        }\r\n    }\r\n\r\n    /*\r\n     * If the number of sync standbys is less than requested or we aren't\r\n     * managing a sync standby then just leave.\r\n     */\r\n    if (!got_recptr || !am_sync) {\r\n        LWLockRelease(SyncRepLock);\r\n        t_thrd.syncrep_cxt.announce_next_takeover = !am_sync;\r\n        return;\r\n    }\r\n\r\n    /*\r\n     * Set the lsn first so that when we wake backends they will release up to\r\n     * this location.\r\n     */\r\n    if (XLByteLT(walsndctl->lsn[SYNC_REP_WAIT_RECEIVE], receivePtr)) {\r\n        walsndctl->lsn[SYNC_REP_WAIT_RECEIVE] = t_thrd.walsender_cxt.MyWalSnd->receive;\r\n        numreceive = SyncRepWakeQueue(false, SYNC_REP_WAIT_RECEIVE);\r\n    }\r\n    if (XLByteLT(walsndctl->lsn[SYNC_REP_WAIT_WRITE], writePtr)) {\r\n        walsndctl->lsn[SYNC_REP_WAIT_WRITE] = t_thrd.walsender_cxt.MyWalSnd->write;\r\n        numwrite = SyncRepWakeQueue(false, SYNC_REP_WAIT_WRITE);\r\n    }\r\n    if (XLByteLT(walsndctl->lsn[SYNC_REP_WAIT_FLUSH], flushPtr)) {\r\n        walsndctl->lsn[SYNC_REP_WAIT_FLUSH] = t_thrd.walsender_cxt.MyWalSnd->flush;\r\n        numflush = SyncRepWakeQueue(false, SYNC_REP_WAIT_FLUSH);\r\n    }\r\n\r\n    if (XLByteLT(walsndctl->lsn[SYNC_REP_WAIT_REPALY], replayPtr)) {\r\n        walsndctl->lsn[SYNC_REP_WAIT_REPALY] = t_thrd.walsender_cxt.MyWalSnd->apply;\r\n        numflush = SyncRepWakeQueue(false, SYNC_REP_WAIT_REPALY);\r\n    }\r\n\r\n    LWLockRelease(SyncRepLock);\r\n\r\n    ereport(DEBUG3,\r\n        (errmsg(\"released %d procs up to receive %X/%X, %d procs up to write %X/%X, %d procs up to flush %X/%X\",\r\n            numreceive,\r\n            (uint32)(receivePtr >> 32),\r\n            (uint32)receivePtr,\r\n            numwrite,\r\n            (uint32)(writePtr >> 32),\r\n            (uint32)writePtr,\r\n            numflush,\r\n            (uint32)(flushPtr >> 32),\r\n            (uint32)flushPtr)));\r\n}",
		"comment":"/*\r\n * Update the LSNs on each queue based upon our latest state. This\r\n * implements a simple policy of first-valid-standby-releases-waiter.\r\n *\r\n * Other policies are possible, which would change what we do here and what\r\n * perhaps also which information we store as well.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"SyncRepReleaseWaiters"
	},
	"SyncRepUpdateSyncStandbysDefined":{
		"body":"void SyncRepUpdateSyncStandbysDefined(void)\r\n{\r\n    bool sync_standbys_defined = SyncStandbysDefined();\r\n    if (sync_standbys_defined != t_thrd.walsender_cxt.WalSndCtl->sync_standbys_defined) {\r\n        (void)LWLockAcquire(SyncRepLock, LW_EXCLUSIVE);\r\n\r\n        /*\r\n         * If synchronous_standby_names has been reset to empty, it's futile\r\n         * for backends to continue to waiting.  Since the user no longer\r\n         * wants synchronous replication, we'd better wake them up.\r\n         */\r\n        if (!sync_standbys_defined) {\r\n            int i;\r\n\r\n            for (i = 0; i < NUM_SYNC_REP_WAIT_MODE; i++)\r\n                (void)SyncRepWakeQueue(true, i);\r\n        }\r\n\r\n        /*\r\n         * Only allow people to join the queue when there are synchronous\r\n         * standbys defined.  Without this interlock, there's a race\r\n         * condition: we might wake up all the current waiters; then, some\r\n         * backend that hasn't yet reloaded its config might go to sleep on\r\n         * the queue (and never wake up).  This prevents that.\r\n         */\r\n        t_thrd.walsender_cxt.WalSndCtl->sync_standbys_defined = sync_standbys_defined;\r\n\r\n        if (sync_standbys_defined && t_thrd.walsender_cxt.WalSndCtl->most_available_sync &&\r\n            !t_thrd.walsender_cxt.WalSndCtl->sync_master_standalone)\r\n            SyncRepCheckSyncStandbyAlive();\r\n\r\n        LWLockRelease(SyncRepLock);\r\n    }\r\n\r\n    /*\r\n     * Check if new value of parameter is same as earlier,\r\n     * if not then change in shared memory. Since here were enabling this\r\n     * parameter now only, so it may happen that there were no synchronous\r\n     * standby but master has not gone in stand-alone mode because it was\r\n     * not configured to do so.\r\n     */\r\n    if (most_available_sync != t_thrd.walsender_cxt.WalSndCtl->most_available_sync) {\r\n        LWLockAcquire(SyncRepLock, LW_EXCLUSIVE);\r\n\r\n        t_thrd.walsender_cxt.WalSndCtl->most_available_sync = most_available_sync;\r\n        (void)SyncRepCheckSyncStandbyAlive();\r\n\r\n        LWLockRelease(SyncRepLock);\r\n    }\r\n}",
		"comment":"/*\r\n * The checkpointer calls this as needed to update the shared\r\n * sync_standbys_defined flag, so that backends don't remain permanently wedged\r\n * if synchronous_standby_names is unset.  It's safe to check the current value\r\n * without the lock, because it's only ever updated by one process.  But we\r\n * must take the lock to change it.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"SyncRepUpdateSyncStandbysDefined"
	},
	"SyncRepWaitCompletionQueue":{
		"body":"static void SyncRepWaitCompletionQueue()\r\n{\r\n    /* Waiting for complete */\r\n    int i = MAX_SYNC_REP_RETRY_COUNT;\r\n    while (t_thrd.proc->syncRepState == SYNC_REP_WAITING) {\r\n        if (i-- > 0) {\r\n            pg_usleep(SYNC_REP_SLEEP_DELAY);\r\n        } else {\r\n            ereport(WARNING, (errmsg(\"Waiting for syncrep completion queue timeout.\")));\r\n            i = MAX_SYNC_REP_RETRY_COUNT;\r\n        }\r\n    }\r\n\r\n    /* Make sure that syncRepLinks is read after syncRepState */\r\n    pg_read_barrier();\r\n\r\n    /* Leader informs following procs */\r\n    if (t_thrd.proc->syncRepState == SYNC_REP_WAIT_COMPLETE && t_thrd.proc->syncRepLinks.next) {\r\n        SyncRepNotifyComplete();\r\n    }\r\n}",
		"comment":"/*\r\n * Wait for notification from completion queue. It should be finished\r\n * soon, and is irrelevant to the network. So we just wait to avoid using lock.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"SyncRepWaitCompletionQueue"
	},
	"SyncRepWaitForLSN":{
		"body":"void SyncRepWaitForLSN(XLogRecPtr XactCommitLSN)\r\n{\r\n    char* new_status = NULL;\r\n    const char* old_status = NULL;\r\n    int mode = SyncRepWaitMode;\r\n\r\n    /*\r\n     * Fast exit if user has not requested sync replication, or there are no\r\n     * sync replication standby names defined. Note that those standbys don't\r\n     * need to be connected.\r\n     */\r\n    if (!u_sess->attr.attr_storage.enable_stream_replication || !SyncRepRequested() || !SyncStandbysDefined() ||\r\n        (t_thrd.postmaster_cxt.HaShmData->current_mode == NORMAL_MODE))\r\n        return;\r\n\r\n    Assert(SHMQueueIsDetached(&(t_thrd.proc->syncRepLinks)));\r\n    Assert(t_thrd.walsender_cxt.WalSndCtl != NULL);\r\n\r\n    /* Prevent the queue cleanups to be influenced by external interruptions */\r\n    HOLD_INTERRUPTS();\r\n    \r\n    (void)LWLockAcquire(SyncRepLock, LW_EXCLUSIVE);\r\n    Assert(t_thrd.proc->syncRepState == SYNC_REP_NOT_WAITING);\r\n\r\n    /*\r\n     * We don't wait for sync rep if WalSndCtl->sync_standbys_defined is not\r\n     * set.  See SyncRepUpdateSyncStandbysDefined.\r\n     *\r\n     * Also check that the standby hasn't already replied. Unlikely race\r\n     * condition but we'll be fetching that cache line anyway so its likely to\r\n     * be a low cost check. We don't wait for sync rep if no sync standbys alive\r\n     */\r\n    if (!t_thrd.walsender_cxt.WalSndCtl->sync_standbys_defined ||\r\n        XLByteLE(XactCommitLSN, t_thrd.walsender_cxt.WalSndCtl->lsn[mode]) ||\r\n        t_thrd.walsender_cxt.WalSndCtl->sync_master_standalone) {\r\n        LWLockRelease(SyncRepLock);\r\n        RESUME_INTERRUPTS();\r\n        return;\r\n    }\r\n\r\n    /*\r\n     * Set our waitLSN so WALSender will know when to wake us, and add\r\n     * ourselves to the queue.\r\n     */\r\n    t_thrd.proc->waitLSN = XactCommitLSN;\r\n    t_thrd.proc->syncRepState = SYNC_REP_WAITING;\r\n    SyncRepQueueInsert(mode);\r\n    Assert(SyncRepQueueIsOrderedByLSN(mode));\r\n    LWLockRelease(SyncRepLock);\r\n\r\n    /* Alter ps display to show waiting for sync rep. */\r\n    if (u_sess->attr.attr_common.update_process_title) {\r\n        int len;\r\n        errno_t ret = EOK;\r\n        int rc = 0;\r\n\r\n        old_status = get_ps_display(&len);\r\n        new_status = (char*)palloc(len + 32 + 1);\r\n        ret = memcpy_s(new_status, len, old_status, len);\r\n        securec_check(ret, \"\", \"\");\r\n#define NEW_STATUS_LEN 33\r\n        rc = snprintf_s(new_status + len,\r\n            NEW_STATUS_LEN,\r\n            NEW_STATUS_LEN - 1,\r\n            \" waiting for %X/%X\",\r\n            (uint32)(XactCommitLSN >> 32),\r\n            (uint32)XactCommitLSN);\r\n        securec_check_ss(rc, \"\", \"\");\r\n\r\n        set_ps_display(new_status, false);\r\n        new_status[len] = '\\0'; /* truncate off \" waiting ...\" */\r\n    }\r\n\r\n    WaitState oldStatus = pgstat_report_waitstatus(STATE_WAIT_WALSYNC);\r\n\r\n    /*\r\n     * Wait for specified LSN to be confirmed.\r\n     *\r\n     * Each proc has its own wait latch, so we perform a normal latch\r\n     * check/wait loop here.\r\n     */\r\n    for (;;) {\r\n        /* Must reset the latch before testing state. */\r\n        ResetLatch(&t_thrd.proc->procLatch);\r\n\r\n#ifdef ENABLE_DISTRIBUTE_TEST\r\n        if (TEST_STUB(DN_STANDBY_SLEEPIN_SYNCCOMMIT, stub_sleep_emit)) {\r\n            ereport(get_distribute_test_param()->elevel,\r\n                (errmsg(\"sleep_emit happen during SyncRepWaitForLSN  time:%ds, stub_name:%s\",\r\n                    get_distribute_test_param()->sleep_time,\r\n                    get_distribute_test_param()->test_stub_name)));\r\n        }\r\n#endif\r\n\r\n        /*\r\n         * Acquiring the lock is not needed, the latch ensures proper barriers.\r\n         * If it looks like we're done, we must really be done, because once\r\n         * walsender changes the state to SYNC_REP_WAIT_COMPLETE, it will never\r\n         * update it again, so we can't be seeing a stale value in that case.\r\n         */\r\n        if (t_thrd.proc->syncRepState == SYNC_REP_WAIT_COMPLETE)\r\n            break;\r\n\r\n        /*\r\n         * If a wait for synchronous replication is pending, we can neither\r\n         * acknowledge the commit nor raise ERROR or FATAL.  The latter would\r\n         * lead the client to believe that the transaction aborted, which\r\n         * is not true: it's already committed locally. The former is no good\r\n         * either: the client has requested synchronous replication, and is\r\n         * entitled to assume that an acknowledged commit is also replicated,\r\n         * which might not be true. So in this case we issue a WARNING (which\r\n         * some clients may be able to interpret) and shut off further output.\r\n         * We do NOT reset t_thrd.int_cxt.ProcDiePending, so that the process will die after\r\n         * the commit is cleaned up.\r\n         */\r\n        if (t_thrd.int_cxt.ProcDiePending || t_thrd.proc_cxt.proc_exit_inprogress) {\r\n            ereport(WARNING,\r\n                (errcode(ERRCODE_ADMIN_SHUTDOWN),\r\n                    errmsg(\"canceling the wait for synchronous replication and terminating connection due to \"\r\n                           \"administrator command\"),\r\n                    errdetail(\"The transaction has already committed locally, but might not have been replicated to \"\r\n                              \"the standby.\")));\r\n            t_thrd.postgres_cxt.whereToSendOutput = DestNone;\r\n            if (SyncRepCancelWait()) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        /*\r\n         * It's unclear what to do if a query cancel interrupt arrives.  We\r\n         * can't actually abort at this point, but ignoring the interrupt\r\n         * altogether is not helpful, so we just terminate the wait with a\r\n         * suitable warning.\r\n         */\r\n        if (t_thrd.int_cxt.QueryCancelPending) {\r\n            /* reset query cancel signal after vacuum. */\r\n            if (!t_thrd.vacuum_cxt.in_vacuum) {\r\n                t_thrd.int_cxt.QueryCancelPending = false;\r\n            }\r\n            ereport(WARNING,\r\n                (errmsg(\"canceling wait for synchronous replication due to user request\"),\r\n                    errdetail(\"The transaction has already committed locally, but might not have been replicated to \"\r\n                              \"the standby.\")));\r\n            if (SyncRepCancelWait()) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        /*\r\n         * If the postmaster dies, we'll probably never get an\r\n         * acknowledgement, because all the wal sender processes will exit. So\r\n         * just bail out.\r\n         */\r\n        if (!PostmasterIsAlive()) {\r\n            t_thrd.int_cxt.ProcDiePending = true;\r\n            t_thrd.postgres_cxt.whereToSendOutput = DestNone;\r\n            if (SyncRepCancelWait()) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        /*\r\n         * If we  modify the syncmode dynamically, we'll stop wait\r\n         */\r\n        if (t_thrd.walsender_cxt.WalSndCtl->sync_master_standalone ||\r\n            synchronous_commit <= SYNCHRONOUS_COMMIT_LOCAL_FLUSH) {\r\n            ereport(WARNING,\r\n                (errmsg(\"canceling wait for synchronous replication due to syncmaster standalone.\"),\r\n                    errdetail(\"The transaction has already committed locally, but might not have been replicated to \"\r\n                              \"the standby.\")));\r\n            if (SyncRepCancelWait()) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        /*\r\n         * Wait on latch.  Any condition that should wake us up will set the\r\n         * latch, so no need for timeout.\r\n         */\r\n        WaitLatch(&t_thrd.proc->procLatch, WL_LATCH_SET | WL_TIMEOUT | WL_POSTMASTER_DEATH, 3000L);\r\n    }\r\n\r\n    /* Make sure that syncRepLinks is read after syncRepState */\r\n    pg_read_barrier();\r\n\r\n    /* Leader informs following procs */\r\n    if (t_thrd.proc->syncRepLinks.next) {\r\n        SyncRepNotifyComplete();\r\n    }\r\n\r\n    (void)pgstat_report_waitstatus(oldStatus);\r\n\r\n    /*\r\n     * WalSender has checked our LSN and has removed us from queue. Clean up\r\n     * state and leave.  It's OK to reset these shared memory fields without\r\n     * holding SyncRepLock, because any walsenders will ignore us anyway when\r\n     * we're not on the queue. pg_read_barrier() has been invoked after for\r\n     * loop to make sure the changes to the queue link is visible.\r\n     */\r\n    Assert(SHMQueueIsDetached(&(t_thrd.proc->syncRepLinks)));\r\n    t_thrd.proc->syncRepState = SYNC_REP_NOT_WAITING;\r\n    t_thrd.proc->syncRepInCompleteQueue = false;\r\n    t_thrd.proc->waitLSN = 0;\r\n\r\n    if (new_status != NULL) {\r\n        /* Reset ps display */\r\n        set_ps_display(new_status, false);\r\n        pfree(new_status);\r\n        new_status = NULL;\r\n    }\r\n    \r\n    RESUME_INTERRUPTS();\r\n}",
		"comment":"/*\r\n * Wait for synchronous replication, if requested by user.\r\n *\r\n * Initially backends start in state SYNC_REP_NOT_WAITING and then\r\n * change that state to SYNC_REP_WAITING before adding ourselves\r\n * to the wait queue. During SyncRepWakeQueue() a WALSender changes\r\n * the state to SYNC_REP_WAIT_COMPLETE once replication is confirmed.\r\n * This backend then resets its state to SYNC_REP_NOT_WAITING.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"SyncRepWaitForLSN"
	},
	"SyncRepWakeQueue":{
		"body":"static int SyncRepWakeQueue(bool all, int mode)\r\n{\r\n    volatile WalSndCtlData* walsndctl = t_thrd.walsender_cxt.WalSndCtl;\r\n    PGPROC* proc = NULL;\r\n    PGPROC* thisproc = NULL;\r\n    int numprocs = 0;\r\n\r\n    Assert(mode >= 0 && mode < NUM_SYNC_REP_WAIT_MODE);\r\n    Assert(SyncRepQueueIsOrderedByLSN(mode));\r\n\r\n    proc = (PGPROC*)SHMQueueNext(&(t_thrd.walsender_cxt.WalSndCtl->SyncRepQueue[mode]),\r\n        &(t_thrd.walsender_cxt.WalSndCtl->SyncRepQueue[mode]),\r\n        offsetof(PGPROC, syncRepLinks));\r\n    SHM_QUEUE* pHead = &(t_thrd.walsender_cxt.WalSndCtl->SyncRepQueue[mode]);\r\n    SHM_QUEUE* pTail = pHead;\r\n    while (proc != NULL) {\r\n        /*\r\n         * Assume the queue is ordered by LSN\r\n         */\r\n        if (!all && XLByteLT(walsndctl->lsn[mode], proc->waitLSN))\r\n            break;\r\n\r\n        /*\r\n         * Move to next proc, so we can delete thisproc from the queue.\r\n         * thisproc is valid, proc may be NULL after this.\r\n         */\r\n        thisproc = proc;\r\n        thisproc->syncRepInCompleteQueue = true;\r\n        proc = (PGPROC*)SHMQueueNext(&(t_thrd.walsender_cxt.WalSndCtl->SyncRepQueue[mode]),\r\n            &(proc->syncRepLinks),\r\n            offsetof(PGPROC, syncRepLinks));\r\n        /* Refers to the last removable node */\r\n        pTail = &(thisproc->syncRepLinks);\r\n        numprocs++;\r\n    }\r\n\r\n    /* Delete the finished segment from the list, and only notifies leader proc */\r\n    if (pTail != pHead) {\r\n        PGPROC* leaderProc = (PGPROC *) (((char *) pHead->next) - offsetof(PGPROC, syncRepLinks));\r\n        pHead->next->prev = NULL;\r\n        pHead->next = pTail->next;\r\n        pTail->next->prev = pHead;\r\n        pTail->next = NULL;\r\n        /*\r\n         * SyncRepWaitForLSN() reads syncRepState without holding the lock, so\r\n         * make sure that it sees the queue link being removed before the\r\n         * syncRepState change.\r\n         */\r\n        pg_write_barrier();\r\n        /*\r\n         * Set state to complete; see SyncRepWaitForLSN() for discussion of\r\n         * the various states.\r\n         */\r\n        leaderProc->syncRepState = SYNC_REP_WAIT_COMPLETE;\r\n        /*\r\n         * Wake only when we have set state and removed from queue.\r\n         */\r\n        SetLatch(&(leaderProc->procLatch));\r\n    }\r\n\r\n    return numprocs;\r\n}",
		"comment":"/*\r\n * Walk the specified queue from head. Set the state of any backends that\r\n * need to be woken, remove them from the queue, and then wake them.\r\n * Pass all = true to wake whole queue; otherwise, just wake up to\r\n * the walsender's LSN.\r\n *\r\n * Must hold SyncRepLock.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"SyncRepWakeQueue"
	},
	"assign_synchronous_commit":{
		"body":"void assign_synchronous_commit(int newval, void* extra)\r\n{\r\n    switch (newval) {\r\n        case SYNCHRONOUS_COMMIT_REMOTE_RECEIVE:\r\n            SyncRepWaitMode = SYNC_REP_WAIT_RECEIVE;\r\n            break;\r\n        case SYNCHRONOUS_COMMIT_REMOTE_WRITE:\r\n            SyncRepWaitMode = SYNC_REP_WAIT_WRITE;\r\n            break;\r\n        case SYNCHRONOUS_COMMIT_REMOTE_FLUSH:\r\n            SyncRepWaitMode = SYNC_REP_WAIT_FLUSH;\r\n            break;\r\n        case SYNCHRONOUS_COMMIT_REMOTE_REPLAY:\r\n            SyncRepWaitMode = SYNC_REP_WAIT_REPALY;\r\n            break;\r\n        default:\r\n            SyncRepWaitMode = SYNC_REP_NO_WAIT;\r\n            break;\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"assign_synchronous_commit"
	},
	"assign_synchronous_standby_names":{
		"body":"void assign_synchronous_standby_names(const char* newval, void* extra)\r\n{\r\n    /*\r\n     * At present, SyncRepConfig is kept at thread level, on the assumption that\r\n     * it should be safe to know the latest rep config ASAP for all sessions.\r\n     * If this assumption no longer holds, please move it to session level.\r\n     */\r\n    pfree_ext(t_thrd.syncrep_cxt.SyncRepConfig);\r\n\r\n    if (extra != NULL) {\r\n        SyncRepConfigData* pconf = (SyncRepConfigData*)extra;\r\n        errno_t rc = EOK;\r\n        t_thrd.syncrep_cxt.SyncRepConfig =\r\n            (SyncRepConfigData*)MemoryContextAlloc(t_thrd.top_mem_cxt, pconf->config_size);\r\n        rc = memcpy_s(t_thrd.syncrep_cxt.SyncRepConfig, pconf->config_size, pconf, pconf->config_size);\r\n        securec_check(rc, \"\", \"\");\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"assign_synchronous_standby_names"
	},
	"check_synchronous_standby_names":{
		"body":"bool check_synchronous_standby_names(char** newval, void** extra, GucSource source)\r\n{\r\n    errno_t rc = EOK;\r\n\r\n    if (*newval != NULL && (*newval)[0] != '\\0') {\r\n        int parse_rc;\r\n        SyncRepConfigData* pconf = NULL;\r\n        syncrep_scanner_yyscan_t yyscanner;\r\n\r\n        /* Reset communication variables to ensure a fresh start */\r\n        t_thrd.syncrepgram_cxt.syncrep_parse_result = NULL;\r\n\r\n        /* Parse the synchronous_standby_names string */\r\n        yyscanner = syncrep_scanner_init(*newval);\r\n        parse_rc = syncrep_yyparse(yyscanner);\r\n        syncrep_scanner_finish(yyscanner);\r\n\r\n        if (parse_rc != 0 || t_thrd.syncrepgram_cxt.syncrep_parse_result == NULL) {\r\n            GUC_check_errcode(ERRCODE_SYNTAX_ERROR);\r\n            GUC_check_errdetail(\"synchronous_standby_names parser failed\");\r\n            return false;\r\n        }\r\n\r\n        /* GUC extra value must be malloc'd, not palloc'd */\r\n        pconf = (SyncRepConfigData*)MemoryContextAlloc(\r\n            u_sess->top_mem_cxt, t_thrd.syncrepgram_cxt.syncrep_parse_result->config_size);\r\n        if (pconf == NULL)\r\n            return false;\r\n        rc = memcpy_s(pconf,\r\n            t_thrd.syncrepgram_cxt.syncrep_parse_result->config_size,\r\n            t_thrd.syncrepgram_cxt.syncrep_parse_result,\r\n            t_thrd.syncrepgram_cxt.syncrep_parse_result->config_size);\r\n        securec_check(rc, \"\", \"\");\r\n\r\n        *extra = (void*)pconf;\r\n        /*\r\n         * We need not explicitly clean up syncrep_parse_result.  It, and any\r\n         * other cruft generated during parsing, will be freed when the\r\n         * current memory context is deleted.  (This code is generally run in\r\n         * a short-lived context used for config file processing, so that will\r\n         * not be very long.)\r\n         */\r\n    } else\r\n        *extra = NULL;\r\n\r\n    return true;\r\n}",
		"comment":"/*\r\n * ===========================================================\r\n * Synchronous Replication functions executed by any process\r\n * ===========================================================\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"check_synchronous_standby_names"
	},
	"cmp_lsn":{
		"body":"static int cmp_lsn(const void* a, const void* b)\r\n{\r\n    XLogRecPtr lsn1 = *((const XLogRecPtr*)a);\r\n    XLogRecPtr lsn2 = *((const XLogRecPtr*)b);\r\n\r\n    if (!XLByteLE(lsn1, lsn2))\r\n        return -1;\r\n    else if (XLByteEQ(lsn1, lsn2))\r\n        return 0;\r\n    else\r\n        return 1;\r\n}",
		"comment":"/*\r\n * Compare lsn in order to sort array in descending order.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"cmp_lsn"
	},
	"syncrep_yylex":{
		"body":"int syncrep_yylex(YYSTYPE* lvalp, YYLTYPE* llocp, syncrep_scanner_yyscan_t yyscanner)\r\n{\r\n    return syncrep_scanner_yylex(&(lvalp->yy_core), llocp, yyscanner);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\syncrep.cpp",
		"name":"syncrep_yylex"
	}
}