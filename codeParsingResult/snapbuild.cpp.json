{
	"AllocateSnapshotBuilder":{
		"body":"SnapBuild* AllocateSnapshotBuilder(\r\n    ReorderBuffer* reorder, TransactionId xmin_horizon, XLogRecPtr start_lsn, bool need_full_snapshot)\r\n{\r\n    MemoryContext context;\r\n    MemoryContext oldcontext;\r\n    SnapBuild* builder = NULL;\r\n\r\n    /* allocate memory in own context, to have better accountability */\r\n    context = AllocSetContextCreate(CurrentMemoryContext,\r\n        \"snapshot builder context\",\r\n        ALLOCSET_DEFAULT_MINSIZE,\r\n        ALLOCSET_DEFAULT_INITSIZE,\r\n        ALLOCSET_DEFAULT_MAXSIZE);\r\n    oldcontext = MemoryContextSwitchTo(context);\r\n\r\n    builder = (SnapBuild*)palloc0(sizeof(SnapBuild));\r\n\r\n    builder->state = SNAPBUILD_START;\r\n    builder->context = context;\r\n    builder->reorder = reorder;\r\n    /* Other struct members initialized by zeroing via palloc0 above */\r\n    builder->committed.xcnt = 0;\r\n    builder->committed.xcnt_space = 128; /* arbitrary number */\r\n    builder->committed.xip = (TransactionId*)palloc0(builder->committed.xcnt_space * sizeof(TransactionId));\r\n    builder->committed.includes_all_transactions = true;\r\n    builder->initial_xmin_horizon = xmin_horizon;\r\n    builder->start_decoding_at = start_lsn;\r\n    builder->building_full_snapshot = need_full_snapshot;\r\n\r\n    (void)MemoryContextSwitchTo(oldcontext);\r\n\r\n    return builder;\r\n}",
		"comment":"/*\r\n * Allocate a new snapshot builder.\r\n *\r\n * xmin_horizon is the xid >=which we can be sure no catalog rows have been\r\n * removed, start_lsn is the LSN >= we want to replay commits.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"AllocateSnapshotBuilder"
	},
	"CheckPointSnapBuild":{
		"body":"void CheckPointSnapBuild(void)\r\n{\r\n    XLogRecPtr cutoff = InvalidXLogRecPtr;\r\n    XLogRecPtr redo = InvalidXLogRecPtr;\r\n    DIR* snap_dir = NULL;\r\n    struct dirent* snap_de = NULL;\r\n    char path[MAXPGPATH];\r\n    const char* basedirpath = \"pg_llog\";\r\n    const char* snsdirpath = \"pg_llog/snapshots\";\r\n    int nRet = 0;\r\n    /*\r\n     * We start of with a minimum of the last redo pointer. No new replication\r\n     * slot will start before that, so that's a safe upper bound for removal.\r\n     */\r\n    redo = GetRedoRecPtr();\r\n\r\n    /* now check for the restart ptrs from existing slots */\r\n    cutoff = ReplicationSlotsComputeLogicalRestartLSN();\r\n    /* don't start earlier than the restart lsn */\r\n    if (XLByteLT(redo, cutoff)) {\r\n        cutoff = redo;\r\n    }\r\n\r\n    snap_dir = AllocateDir(snsdirpath);\r\n    if (snap_dir == NULL && errno == ENOENT) {\r\n        /* create dir if not exist */\r\n        if (mkdir(snsdirpath, S_IRWXU) < 0) {\r\n            if (errno == ENOENT) {\r\n                /* create parent dir first if not exist */\r\n                if (mkdir(basedirpath, S_IRWXU) < 0) {\r\n                    ereport(ERROR,\r\n                        (errcode_for_file_access(), errmsg(\"could not create directory \\\"%s\\\": %m\", basedirpath)));\r\n                }\r\n                /* and then create the sub dir */\r\n                if (mkdir(snsdirpath, S_IRWXU) < 0) {\r\n                    ereport(ERROR,\r\n                        (errcode_for_file_access(), errmsg(\"could not create directory \\\"%s\\\": %m\", snsdirpath)));\r\n                }\r\n            } else {\r\n                /* Failure other than not exists */\r\n                ereport(\r\n                    ERROR, (errcode_for_file_access(), errmsg(\"could not create directory \\\"%s\\\": %m\", snsdirpath)));\r\n            }\r\n        }\r\n        snap_dir = AllocateDir(snsdirpath);\r\n    }\r\n    while ((snap_de = ReadDir(snap_dir, snsdirpath)) != NULL) {\r\n        uint32 hi;\r\n        uint32 lo;\r\n        XLogRecPtr lsn;\r\n        struct stat statbuf;\r\n\r\n        if (strcmp(snap_de->d_name, \".\") == 0 || strcmp(snap_de->d_name, \"..\") == 0) {\r\n            continue;\r\n        }\r\n\r\n        nRet = snprintf_s(path, sizeof(path), MAXPGPATH - 1, \"%s/%s\", snsdirpath, snap_de->d_name);\r\n        securec_check_ss_c(nRet, \"\", \"\");\r\n\r\n        if (lstat(path, &statbuf) == 0 && !S_ISREG(statbuf.st_mode)) {\r\n            if (!RecoveryInProgress()) {\r\n                ereport(DEBUG1, (errmsg(\"only regular files expected: %s\", path)));\r\n            }\r\n            continue;\r\n        }\r\n\r\n        /*\r\n         * temporary filenames from SnapBuildSerialize() include the LSN and\r\n         * everything but are postfixed by .$pid.tmp. We can just remove them\r\n         * the same as other files because there can be none that are currently\r\n         * being written that are older than cutoff.\r\n         *\r\n         * We just log a message if a file doesn't fit the pattern, it's\r\n         * probably some editors lock/state file or similar...\r\n         */\r\n        if (sscanf_s(snap_de->d_name, \"%X-%X.snap\", &hi, &lo) != 2) {\r\n            if (!RecoveryInProgress()) {\r\n                ereport(LOG, (errmsg(\"could not parse filename \\\"%s\\\"\", path)));\r\n            }\r\n            continue;\r\n        }\r\n\r\n        lsn = ((uint64(hi)) << 32) + lo;\r\n        /* check whether we still need it */\r\n        if (XLByteLT(lsn, cutoff) || XLByteEQ(cutoff, InvalidXLogRecPtr)) {\r\n            if (!RecoveryInProgress()) {\r\n                ereport(DEBUG1, (errmsg(\"removing snapbuild snapshot %s\", path)));\r\n            }\r\n\r\n            /*\r\n             * It's not particularly harmful, though strange, if we can't\r\n             * remove the file here. Don't prevent the checkpoint from\r\n             * completing, that'd be cure worse than the disease.\r\n             */\r\n            if (unlink(path) < 0) {\r\n                if (!RecoveryInProgress()) {\r\n                    ereport(LOG, (errcode_for_file_access(), errmsg(\"could not unlink file \\\"%s\\\": %m\", path)));\r\n                }\r\n                continue;\r\n            }\r\n        }\r\n    }\r\n    (void)FreeDir(snap_dir);\r\n}",
		"comment":"/*\r\n * Remove all serialized snapshots that are not required anymore because no\r\n * slot can need them. This doesn't actually have to run during a checkpoint,\r\n * but it's a convenient point to schedule this.\r\n *\r\n * NB: We run this during checkpoints even if logical decoding is disabled so\r\n * we cleanup old slots at some point after it got disabled.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"CheckPointSnapBuild"
	},
	"FreeSnapshotBuilder":{
		"body":"void FreeSnapshotBuilder(SnapBuild* builder)\r\n{\r\n    MemoryContext context = builder->context;\r\n\r\n    /* free snapshot explicitly, that contains some error checking */\r\n    if (builder->snapshot != NULL) {\r\n        SnapBuildSnapDecRefcount(builder->snapshot);\r\n        builder->snapshot = NULL;\r\n    }\r\n\r\n    /* other resources are deallocated via memory context reset */\r\n    MemoryContextDelete(context);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"FreeSnapshotBuilder"
	},
	"SnapBuildAddCommittedTxn":{
		"body":"static void SnapBuildAddCommittedTxn(SnapBuild* builder, TransactionId xid)\r\n{\r\n    Assert(TransactionIdIsValid(xid));\r\n\r\n    if (builder->committed.xcnt == builder->committed.xcnt_space) {\r\n        builder->committed.xcnt_space = builder->committed.xcnt_space * 2 + 1;\r\n\r\n        if (!RecoveryInProgress())\r\n            ereport(DEBUG1,\r\n                (errmsg(\"increasing space for committed transactions to %u\", (uint32)builder->committed.xcnt_space)));\r\n\r\n        builder->committed.xip =\r\n            (TransactionId*)repalloc(builder->committed.xip, builder->committed.xcnt_space * sizeof(TransactionId));\r\n    }\r\n\r\n    /*\r\n     * description: It might make sense to keep the array sorted here instead of\r\n     * doing it every time we build a new snapshot. On the other hand this\r\n     * gets called repeatedly when a transaction with subtransactions commits.\r\n     */\r\n    builder->committed.xip[builder->committed.xcnt++] = xid;\r\n}",
		"comment":"/*\r\n * Keep track of a new catalog changing transaction that has committed.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"SnapBuildAddCommittedTxn"
	},
	"SnapBuildBuildSnapshot":{
		"body":"static Snapshot SnapBuildBuildSnapshot(SnapBuild* builder, TransactionId xid)\r\n{\r\n    Snapshot snapshot;\r\n    Size ssize;\r\n    int rc = 0;\r\n    Assert(builder->state >= SNAPBUILD_FULL_SNAPSHOT);\r\n\r\n    ssize = sizeof(SnapshotData) + sizeof(TransactionId) * builder->committed.xcnt +\r\n            sizeof(TransactionId) * 1 /* toplevel xid */;\r\n\r\n    snapshot = (Snapshot)MemoryContextAllocZero(builder->context, ssize);\r\n\r\n    snapshot->satisfies = HeapTupleSatisfiesHistoricMVCC;\r\n\r\n    /*\r\n     * We misuse the original meaning of SnapshotData's xip and subxip fields\r\n     * to make the more fitting for our needs.\r\n     *\r\n     * In the 'xip' array we store transactions that have to be treated as\r\n     * committed. Since we will only ever look at tuples from transactions\r\n     * that have modified the catalog its more efficient to store those few\r\n     * that exist between xmin and xmax (frequently there are none).\r\n     *\r\n     * Snapshots that are used in transactions that have modified the catalog\r\n     * also use the 'subxip' array to store their toplevel xid and all the\r\n     * subtransaction xids so we can recognize when we need to treat rows as\r\n     * visible that are not in xip but still need to be visible. Subxip only\r\n     * gets filled when the transaction is copied into the context of a\r\n     * catalog modifying transaction since we otherwise share a snapshot\r\n     * between transactions. As long as a txn hasn't modified the catalog it\r\n     * doesn't need to treat any uncommitted rows as visible, so there is no\r\n     * need for those xids.\r\n     *\r\n     * Both arrays are qsort'ed so that we can use bsearch() on them.\r\n     */\r\n    Assert(TransactionIdIsNormal(builder->xmin));\r\n    Assert(TransactionIdIsNormal(builder->xmax));\r\n\r\n    snapshot->xmin = builder->xmin;\r\n    snapshot->xmax = builder->xmax;\r\n\r\n    /* store all transactions to be treated as committed by this snapshot */\r\n    snapshot->xip = (TransactionId*)((char*)snapshot + sizeof(SnapshotData));\r\n    snapshot->xcnt = (uint32)(builder->committed.xcnt);\r\n    if (builder->committed.xcnt != 0) {\r\n        rc = memcpy_s(snapshot->xip,\r\n            builder->committed.xcnt * sizeof(TransactionId),\r\n            builder->committed.xip,\r\n            builder->committed.xcnt * sizeof(TransactionId));\r\n        securec_check(rc, \"\", \"\");\r\n    }\r\n    /* sort so we can bsearch() */\r\n    qsort(snapshot->xip, snapshot->xcnt, sizeof(TransactionId), xidComparator);\r\n\r\n    /*\r\n     * Initially, subxip is empty, i.e. it's a snapshot to be used by\r\n     * transactions that don't modify the catalog. Will be filled by\r\n     * ReorderBufferCopySnap() if necessary.\r\n     */\r\n    snapshot->subxcnt = 0;\r\n    snapshot->subxip = NULL;\r\n\r\n    snapshot->suboverflowed = false;\r\n    snapshot->takenDuringRecovery = false;\r\n    snapshot->copied = false;\r\n    snapshot->curcid = FirstCommandId;\r\n    snapshot->active_count = 0;\r\n    snapshot->regd_count = 0; /* mark as registered so nobody frees it */\r\n\r\n    return snapshot;\r\n}",
		"comment":"/*\r\n * Build a new snapshot, based on currently committed catalog-modifying\r\n * transactions.\r\n *\r\n * In-progress transactions with catalog access are *not* allowed to modify\r\n * these snapshots; they have to copy them and fill in appropriate ->curcid\r\n * and ->subxip/subxcnt values.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"SnapBuildBuildSnapshot"
	},
	"SnapBuildClearExportedSnapshot":{
		"body":"void SnapBuildClearExportedSnapshot()\r\n{\r\n    /* nothing exported, thats the usual case */\r\n    if (!t_thrd.logical_cxt.ExportInProgress)\r\n        return;\r\n\r\n    if (!IsTransactionState())\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"clearing exported snapshot in wrong transaction state\")));\r\n\r\n    /* make sure nothing  could have ever happened */\r\n    AbortCurrentTransaction();\r\n\r\n    t_thrd.utils_cxt.CurrentResourceOwner = t_thrd.logical_cxt.SavedResourceOwnerDuringExport;\r\n    t_thrd.logical_cxt.SavedResourceOwnerDuringExport = NULL;\r\n    t_thrd.logical_cxt.ExportInProgress = false;\r\n}",
		"comment":"/*\r\n * Reset a previously SnapBuildExportSnapshot()'ed snapshot if there is\r\n * any. Aborts the previously started transaction and resets the resource\r\n * owner back to it's original value.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"SnapBuildClearExportedSnapshot"
	},
	"SnapBuildCommitTxn":{
		"body":"void SnapBuildCommitTxn(SnapBuild* builder, XLogRecPtr lsn, TransactionId xid, int nsubxacts, TransactionId* subxacts)\r\n{\r\n    int nxact;\r\n\r\n    bool forced_timetravel = false;\r\n    bool sub_needs_timetravel = false;\r\n    bool top_needs_timetravel = false;\r\n\r\n    TransactionId xmax = xid;\r\n\r\n    /*\r\n     * If we couldn't observe every change of a transaction because it was\r\n     * already running at the point we started to observe we have to assume it\r\n     * made catalog changes.\r\n     *\r\n     * This has the positive benefit that we afterwards have enough\r\n     * information to build an exportable snapshot that's usable by pg_dump et\r\n     * al.\r\n     */\r\n    if (builder->state < SNAPBUILD_CONSISTENT) {\r\n        /* ensure that only commits after this are getting replayed */\r\n        if (XLByteLE(builder->start_decoding_at, lsn)) {\r\n            XLByteAdvance(lsn, 1);\r\n            builder->start_decoding_at = lsn;\r\n        }\r\n\r\n        /*\r\n         * We could avoid treating !SnapBuildTxnIsRunning transactions as\r\n         * timetravel ones, but we want to be able to export a snapshot when\r\n         * we reached consistency.\r\n         */\r\n        forced_timetravel = true;\r\n        if (!RecoveryInProgress())\r\n            ereport(\r\n                DEBUG1, (errmsg(\"forced to assume catalog changes for xid %lu because it was running to early\", xid)));\r\n    }\r\n\r\n    for (nxact = 0; nxact < nsubxacts; nxact++) {\r\n        TransactionId subxid = subxacts[nxact];\r\n\r\n        // If we're forcing time-travel we also need visibility information\r\n        // about sub-transaction, so keep track of sub-transaction's state.\r\n        if (forced_timetravel) {\r\n            SnapBuildAddCommittedTxn(builder, subxid);\r\n            if (NormalTransactionIdFollows(subxid, xmax)) {\r\n                xmax = subxid;\r\n            }\r\n        } else if (ReorderBufferXidHasCatalogChanges(builder->reorder, subxid)) {\r\n            // Add sub-transaction to base snapshot if it DDL, we don't distinguish\r\n            // to top-level transactions there.\r\n            sub_needs_timetravel = true;\r\n            if (!RecoveryInProgress()) {\r\n                ereport(DEBUG2, (errmsg(\"found subtransaction %lu:%lu with catalog changes.\", xid, subxid)));\r\n            }\r\n            SnapBuildAddCommittedTxn(builder, subxid);\r\n            if (NormalTransactionIdFollows(subxid, xmax)) {\r\n                xmax = subxid;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (forced_timetravel) {\r\n        if (!RecoveryInProgress()) {\r\n            ereport(DEBUG1, (errmsg(\"forced transaction %lu to do timetravel.\", xid)));\r\n        }\r\n        SnapBuildAddCommittedTxn(builder, xid);\r\n    } else if (ReorderBufferXidHasCatalogChanges(builder->reorder, xid)) {\r\n        /* add toplevel transaction to base snapshot */\r\n        if (!RecoveryInProgress()) {\r\n            ereport(DEBUG2, (errmsg(\"found top level transaction %lu, with catalog changes!\", xid)));\r\n        }\r\n        top_needs_timetravel = true;\r\n        SnapBuildAddCommittedTxn(builder, xid);\r\n    } else if (sub_needs_timetravel) {\r\n        /* mark toplevel txn as timetravel as well */\r\n        SnapBuildAddCommittedTxn(builder, xid);\r\n    }\r\n\r\n    /* if there's any reason to build a historic snapshot, to so now */\r\n    if (forced_timetravel || top_needs_timetravel || sub_needs_timetravel) {\r\n        /*\r\n         * Adjust xmax of the snapshot builder, we only do that for committed,\r\n         * catalog modifying, transactions, everything else isn't interesting\r\n         * for us since we'll never look at the respective rows.\r\n         */\r\n        if (!TransactionIdIsValid(builder->xmax) || TransactionIdFollowsOrEquals(xmax, builder->xmax)) {\r\n            builder->xmax = xmax;\r\n            TransactionIdAdvance(builder->xmax);\r\n        }\r\n\r\n        /*\r\n         * If we haven't built a complete snapshot yet there's no need to hand\r\n         * it out, it wouldn't (and couldn't) be used anyway.\r\n         */\r\n        if (builder->state < SNAPBUILD_FULL_SNAPSHOT) {\r\n            return;\r\n        }\r\n\r\n        /*\r\n         * Decrease the snapshot builder's refcount of the old snapshot, note\r\n         * that it still will be used if it has been handed out to the\r\n         * reorderbuffer earlier.\r\n         */\r\n        if (builder->snapshot != NULL) {\r\n            SnapBuildSnapDecRefcount(builder->snapshot);\r\n        }\r\n        builder->snapshot = SnapBuildBuildSnapshot(builder, xid);\r\n\r\n        /* we might need to execute invalidations, add snapshot */\r\n        if (!ReorderBufferXidHasBaseSnapshot(builder->reorder, xid)) {\r\n            SnapBuildSnapIncRefcount(builder->snapshot);\r\n            ReorderBufferSetBaseSnapshot(builder->reorder, xid, lsn, builder->snapshot);\r\n        }\r\n\r\n        /* refcount of the snapshot builder for the new snapshot */\r\n        SnapBuildSnapIncRefcount(builder->snapshot);\r\n\r\n        /* add a new SnapshotNow to all currently running transactions */\r\n        SnapBuildDistributeNewCatalogSnapshot(builder, lsn);\r\n    } else {\r\n        /* record that we cannot export a general snapshot anymore */\r\n        builder->committed.includes_all_transactions = false;\r\n    }\r\n}",
		"comment":"/*\r\n * Handle everything that needs to be done when a transaction commits\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"SnapBuildCommitTxn"
	},
	"SnapBuildCurrentState":{
		"body":"SnapBuildState SnapBuildCurrentState(SnapBuild* builder)\r\n{\r\n    return builder->state;\r\n}",
		"comment":"/*\r\n * In which state of snapshot building are we?\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"SnapBuildCurrentState"
	},
	"SnapBuildDistributeNewCatalogSnapshot":{
		"body":"static void SnapBuildDistributeNewCatalogSnapshot(SnapBuild* builder, XLogRecPtr lsn)\r\n{\r\n    dlist_iter txn_i;\r\n    ReorderBufferTXN* txn = NULL;\r\n\r\n    /*\r\n     * Iterate through all toplevel transactions. This can include\r\n     * subtransactions which we just don't yet know to be that, but that's\r\n     * fine, they will just get an unneccesary snapshot queued.\r\n     */\r\n    dlist_foreach(txn_i, &builder->reorder->toplevel_by_lsn)\r\n    {\r\n        txn = dlist_container(ReorderBufferTXN, node, txn_i.cur);\r\n\r\n        Assert(TransactionIdIsValid(txn->xid));\r\n\r\n        /*\r\n         * If we don't have a base snapshot yet, there are no changes in this\r\n         * transaction which in turn implies we don't yet need a snapshot at\r\n         * all. We'll add add a snapshot when the first change gets queued.\r\n         *\r\n         * NB: This works correctly even for subtransactions because\r\n         * ReorderBufferAssignChild() takes care to transfer the base snapshot\r\n         * to the top-level transaction, and while iterating the changequeue\r\n         * we'll get the change from the subtxn.\r\n         */\r\n        if (!ReorderBufferXidHasBaseSnapshot(builder->reorder, txn->xid))\r\n            continue;\r\n\r\n        if (!RecoveryInProgress())\r\n            ereport(\r\n                DEBUG2, (errmsg(\"adding a new snapshot to %lu at %X/%X\", txn->xid, (uint32)(lsn >> 32), (uint32)lsn)));\r\n\r\n        /*\r\n         * increase the snapshot's refcount for the transaction we are handing\r\n         * it out to\r\n         */\r\n        SnapBuildSnapIncRefcount(builder->snapshot);\r\n        ReorderBufferAddSnapshot(builder->reorder, txn->xid, lsn, builder->snapshot);\r\n    }\r\n}",
		"comment":"/*\r\n * Add a new Snapshot to all transactions we're decoding that currently are\r\n * in-progress so they can see new catalog contents made by the transaction\r\n * that just committed. This is necessary because those in-progress\r\n * transactions will use the new catalog's contents from here on (at the very\r\n * least everything they do needs to be compatible with newer catalog\r\n * contents).\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"SnapBuildDistributeNewCatalogSnapshot"
	},
	"SnapBuildExportSnapshot":{
		"body":"const char* SnapBuildExportSnapshot(SnapBuild* builder)\r\n{\r\n    Snapshot snap = NULL;\r\n    char* snapname = NULL;\r\n    TransactionId* newxip = NULL;\r\n    const int newxcnt = 0;\r\n    int maxcnt = GetMaxSnapshotXidCount();\r\n\r\n    if (u_sess->utils_cxt.FirstSnapshotSet) {\r\n        return NULL;\r\n    }\r\n    if (builder->state != SNAPBUILD_CONSISTENT)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\r\n                errmsg(\"cannot export a snapshot before reaching a consistent state\")));\r\n\r\n    if (!builder->committed.includes_all_transactions)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\r\n                errmsg(\"cannot export a snapshot, not all transactions are monitored anymore\")));\r\n\r\n    /* so we don't overwrite the existing value */\r\n    if (TransactionIdIsValid(t_thrd.pgxact->xmin))\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\r\n                errmsg(\"cannot export a snapshot when MyPgXact->xmin already is valid\")));\r\n    if (IsTransactionOrTransactionBlock())\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"cannot export a snapshot from within a transaction\")));\r\n\r\n    if (t_thrd.logical_cxt.SavedResourceOwnerDuringExport)\r\n        ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"can only export one snapshot at a time\")));\r\n\r\n    t_thrd.logical_cxt.SavedResourceOwnerDuringExport = t_thrd.utils_cxt.CurrentResourceOwner;\r\n    t_thrd.logical_cxt.ExportInProgress = true;\r\n\r\n    StartTransactionCommand();\r\n\r\n    Assert(!u_sess->utils_cxt.FirstSnapshotSet);\r\n\r\n    /* There doesn't seem to a nice API to set these */\r\n    u_sess->utils_cxt.XactIsoLevel = XACT_REPEATABLE_READ;\r\n    u_sess->attr.attr_common.XactReadOnly = true;\r\n\r\n    snap = SnapBuildBuildSnapshot(builder, GetTopTransactionId());\r\n\r\n    /*\r\n     * We know that snap->xmin is alive, enforced by the logical xmin\r\n     * mechanism. Due to that we can do this without locks, we're only\r\n     * changing our own value.\r\n     */\r\n    t_thrd.pgxact->xmin = snap->xmin;\r\n\r\n    if (snap->xcnt > (uint32)maxcnt)\r\n        maxcnt = snap->xcnt;\r\n\r\n    /* allocate in transaction context */\r\n    newxip = (TransactionId*)palloc(sizeof(TransactionId) * maxcnt);\r\n\r\n    /*\r\n     * snapbuild.c builds transactions in an \"inverted\" manner, which means it\r\n     * stores committed transactions in ->xip, not ones in progress. Build a\r\n     * classical snapshot by marking all non-committed transactions as\r\n     * in-progress. This can be expensive.\r\n     */\r\n    snap->xcnt = newxcnt;\r\n    snap->xip = newxip;\r\n\r\n    /*\r\n     * now that we've built a plain snapshot, use the normal mechanisms for\r\n     * exporting it\r\n     */\r\n    snapname = ExportSnapshot(snap, NULL);\r\n    if (!RecoveryInProgress())\r\n        ereport(LOG, (errmsg(\"exported logical decoding snapshot: \\\"%s\\\" with %u xids\", snapname, snap->xcnt)));\r\n    return snapname;\r\n}",
		"comment":"/*\r\n * Export a snapshot so it can be set in another session with SET TRANSACTION\r\n * SNAPSHOT.\r\n *\r\n * For that we need to start a transaction in the current backend as the\r\n * importing side checks whether the source transaction is still open to make\r\n * sure the xmin horizon hasn't advanced since then.\r\n *\r\n * After that we convert a locally built snapshot into the normal variant\r\n * understood by HeapTupleSatisfiesMVCC et al.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"SnapBuildExportSnapshot"
	},
	"SnapBuildFindSnapshot":{
		"body":"static bool SnapBuildFindSnapshot(SnapBuild* builder, XLogRecPtr lsn, xl_running_xacts* running)\r\n{\r\n    /* ---\r\n     * Build catalog decoding snapshot incrementally using information about\r\n     * the currently running transactions. There are several ways to do that:\r\n     *\r\n     * a) There were no running transactions when the xl_running_xacts record\r\n     *	  was inserted, jump to CONSISTENT immediately. We might find such a\r\n     *	  state while waiting on c)'s sub-states.\r\n     *\r\n     * b) This (in a previous run) or another decoding slot serialized a\r\n     *	  snapshot to disk that we can use.  Can't use this method for the\r\n     *	  initial snapshot when slot is being created and needs full snapshot\r\n     *	  for export or direct use, as that snapshot will only contain catalog\r\n     *	  modifying transactions.\r\n     *\r\n     * c) First incrementally build a snapshot for catalog tuples\r\n     *	  (BUILDING_SNAPSHOT), that requires all, already in-progress,\r\n     *	  transactions to finish.  Every transaction starting after that\r\n     *	  (FULL_SNAPSHOT state), has enough information to be decoded.  But\r\n     *	  for older running transactions no viable snapshot exists yet, so\r\n     *	  CONSISTENT will only be reached once all of those have finished.\r\n     * ---\r\n     *\r\n     *\r\n     * xl_running_xact record is older than what we can use, we might not have\r\n     * all necessary catalog rows anymore.\r\n     */\r\n    if (TransactionIdIsNormal(builder->initial_xmin_horizon) &&\r\n        NormalTransactionIdPrecedes(running->oldestRunningXid, builder->initial_xmin_horizon)) {\r\n        if (!RecoveryInProgress()) {\r\n            ereport(DEBUG1,\r\n                (errmsg(\"skipping snapshot at %X/%X while building logical decoding snapshot, xmin horizon too low\",\r\n                    (uint32)(lsn >> 32), (uint32)lsn),\r\n                    errdetail(\"initial xmin horizon of %lu vs the snapshot's %lu\", builder->initial_xmin_horizon,\r\n                        running->oldestRunningXid)));\r\n        }\r\n        SnapBuildWaitSnapshot(running, builder->initial_xmin_horizon);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * a) No transaction were running or persistency is RS_PERSISTENT,\r\n     * This is not affected by races around xl_running_xacts, because we can\r\n     * miss transaction commits, but currently not transactions starting.\r\n     *\r\n     * NB: We might have already started to incrementally assemble a snapshot,\r\n     * so we need to be careful to deal with that.\r\n     * Persistency is RS_PERSISTENT means that we create logical slot success.\r\n     * So wen can set snapbuild state to SNAPBUILD_CONSISTENT.\r\n     */\r\n    if (running->oldestRunningXid == running->nextXid ||\r\n        t_thrd.slot_cxt.MyReplicationSlot->data.persistency == RS_PERSISTENT) {\r\n        if (XLByteEQ(builder->start_decoding_at, InvalidXLogRecPtr) || XLByteLE(builder->start_decoding_at, lsn)) {\r\n            /* can decode everything after this */\r\n            XLByteAdvance(lsn, 1);\r\n            builder->start_decoding_at = lsn;\r\n        }\r\n\r\n        /* As no transactions were running xmin/xmax can be trivially set. */\r\n        builder->xmin = running->nextXid; /* < are finished */\r\n        builder->xmax = running->nextXid; /* >= are running */\r\n\r\n        /* so we can safely use the faster comparisons */\r\n        Assert(TransactionIdIsNormal(builder->xmin));\r\n        Assert(TransactionIdIsNormal(builder->xmax));\r\n\r\n        builder->state = SNAPBUILD_CONSISTENT;\r\n        SnapBuildStartNextPhaseAt(builder, InvalidTransactionId);\r\n        if (!RecoveryInProgress()) {\r\n            ereport(LOG,\r\n                (errmsg(\"logical decoding found consistent point at %X/%X\", (uint32)(lsn >> 32), (uint32)lsn),\r\n                    errdetail(\"running xacts with xcnt == 0\")));\r\n        }\r\n\r\n        return false;\r\n    } else if (!builder->building_full_snapshot && SnapBuildRestore(builder, lsn)) {\r\n        /* b) valid on disk state and not building full snapshot\r\n         *\r\n         * there won't be any state to cleanup\r\n         */\r\n        return false;\r\n    } else if (builder->state == SNAPBUILD_START) {\r\n        /*\r\n         * c) transition from START to BUILDING_SNAPSHOT.\r\n         *\r\n         * In START state, and a xl_running_xacts record with running xacts is\r\n         * encountered.  In that case, switch to BUILDING_SNAPSHOT state, and\r\n         * record xl_running_xacts->nextXid.  Once all running xacts have finished\r\n         * (i.e. they're all >= nextXid), we have a complete catalog snapshot.  It\r\n         * might look that we could use xl_running_xact's ->xids information to\r\n         * get there quicker, but that is problematic because transactions marked\r\n         * as running, might already have inserted their commit record - it's\r\n         * infeasible to change that with locking.\r\n         */\r\n        builder->state = SNAPBUILD_BUILDING_SNAPSHOT;\r\n        SnapBuildStartNextPhaseAt(builder, running->nextXid);\r\n\r\n        /*\r\n         * Start with an xmin/xmax that's correct for future, when all the\r\n         * currently running transactions have finished. We'll update both\r\n         * while waiting for the pending transactions to finish.\r\n         */\r\n        builder->xmin = running->nextXid; /* < are finished */\r\n        builder->xmax = running->nextXid; /* >= are running */\r\n\r\n        /* so we can safely use the faster comparisons */\r\n        Assert(TransactionIdIsNormal(builder->xmin));\r\n        Assert(TransactionIdIsNormal(builder->xmax));\r\n\r\n        if (!RecoveryInProgress()) {\r\n            ereport(LOG,\r\n                (errmsg(\"logical decoding found initial starting point at %X/%X\", (uint32)(lsn >> 32), (uint32)lsn),\r\n                errdetail(\"Waiting for transactions (approximately %d) older than %lu to end.\", running->xcnt,\r\n                    running->nextXid)));\r\n        }\r\n        SnapBuildWaitSnapshot(running, running->nextXid);\r\n    } else if (builder->state == SNAPBUILD_BUILDING_SNAPSHOT &&\r\n        TransactionIdPrecedesOrEquals(SnapBuildNextPhaseAt(builder), running->oldestRunningXid)) {\r\n        /*\r\n         * c) transition from BUILDING_SNAPSHOT to FULL_SNAPSHOT.\r\n         *\r\n         * In BUILDING_SNAPSHOT state, and this xl_running_xacts' oldestRunningXid\r\n         * is >= than nextXid from when we switched to BUILDING_SNAPSHOT.  This\r\n         * means all transactions starting afterwards have enough information to\r\n         * be decoded.  Switch to FULL_SNAPSHOT.\r\n         */\r\n        builder->state = SNAPBUILD_FULL_SNAPSHOT;\r\n        SnapBuildStartNextPhaseAt(builder, running->nextXid);\r\n        ereport(LOG,\r\n            (errmsg(\"logical decoding found initial consistent point at %X/%X\", (uint32)(lsn >> 32), (uint32)lsn),\r\n            errdetail(\"Waiting for transactions (approximately %d) older than %lu to end.\", running->xcnt,\r\n                running->nextXid)));\r\n\r\n        SnapBuildWaitSnapshot(running, running->nextXid);\r\n    } else if (builder->state == SNAPBUILD_FULL_SNAPSHOT &&\r\n        TransactionIdPrecedesOrEquals(SnapBuildNextPhaseAt(builder), running->oldestRunningXid)) {\r\n        /*\r\n         * c) transition from FULL_SNAPSHOT to CONSISTENT.\r\n         *\r\n         * In FULL_SNAPSHOT state (see d) ), and this xl_running_xacts'\r\n         * oldestRunningXid is >= than nextXid from when we switched to\r\n         * FULL_SNAPSHOT.  This means all transactions that are currently in\r\n         * progress have a catalog snapshot, and all their changes have been\r\n         * collected.  Switch to CONSISTENT.\r\n         */\r\n        builder->state = SNAPBUILD_CONSISTENT;\r\n        SnapBuildStartNextPhaseAt(builder, InvalidTransactionId);\r\n\r\n        ereport(LOG, (errmsg(\"logical decoding found consistent point at %X/%X\", (uint32)(lsn >> 32), (uint32)lsn),\r\n            errdetail(\"There are no old transactions anymore.\")));\r\n    }\r\n\r\n    /*\r\n     * We already started to track running xacts and need to wait for all\r\n     * in-progress ones to finish. We fall through to the normal processing of\r\n     * records so incremental cleanup can be performed.\r\n     */\r\n    return true;\r\n}",
		"comment":"/*\r\n * Build the start of a snapshot that's capable of decoding the catalog.\r\n *\r\n * Helper function for SnapBuildProcessRunningXacts() while we're not yet\r\n * consistent.\r\n *\r\n * Returns true if there is a point in performing internal maintenance/cleanup\r\n * using the xl_running_xacts record.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"SnapBuildFindSnapshot"
	},
	"SnapBuildFreeSnapshot":{
		"body":"static void SnapBuildFreeSnapshot(Snapshot snap)\r\n{\r\n    /* make sure we don't get passed an external snapshot */\r\n    Assert(snap->satisfies == HeapTupleSatisfiesHistoricMVCC);\r\n\r\n    /* make sure nobody modified our snapshot */\r\n    Assert(snap->curcid == FirstCommandId);\r\n    Assert(!snap->suboverflowed);\r\n    Assert(!snap->takenDuringRecovery);\r\n    Assert(snap->regd_count == 0);\r\n\r\n    /* slightly more likely, so it's checked even without c-asserts */\r\n    if (snap->copied)\r\n        ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"cannot free a copied snapshot\")));\r\n\r\n    if (snap->active_count)\r\n        ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"cannot free an active snapshot\")));\r\n\r\n    if (GTM_LITE_MODE && (snap->prepared_array != NULL))\r\n        pfree_ext(snap->prepared_array);\r\n\r\n    pfree(snap);\r\n    snap = NULL;\r\n}",
		"comment":"/*\r\n * Free an unreferenced snapshot that has previously been built by us.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"SnapBuildFreeSnapshot"
	},
	"SnapBuildNextPhaseAt":{
		"body":"static inline TransactionId SnapBuildNextPhaseAt(SnapBuild* builder)\r\n{\r\n    /*\r\n     * For backward compatibility reasons this has to be stored in the wrongly\r\n     * named field.  Will be fixed in next major version.\r\n     */\r\n    return builder->was_running.was_xmax;\r\n}",
		"comment":"/*\r\n * Return TransactionId after which the next phase of initial snapshot\r\n * building will happen.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"SnapBuildNextPhaseAt"
	},
	"SnapBuildProcessChange":{
		"body":"bool SnapBuildProcessChange(SnapBuild* builder, TransactionId xid, XLogRecPtr lsn)\r\n{\r\n    /*\r\n     * We can't handle data in transactions if we haven't built a snapshot\r\n     * yet, so don't store them.\r\n     */\r\n    if (builder->state < SNAPBUILD_FULL_SNAPSHOT)\r\n        return false;\r\n\r\n    /*\r\n     * No point in keeping track of changes in transactions that we don't have\r\n     * enough information about to decode. This means that they started before\r\n     * we got into the SNAPBUILD_FULL_SNAPSHOT state.\r\n     */\r\n    if (builder->state < SNAPBUILD_CONSISTENT && TransactionIdPrecedes(xid, SnapBuildNextPhaseAt(builder)))\r\n        return false;\r\n\r\n    /*\r\n     * If the reorderbuffer doesn't yet have a snapshot, add one now, it will\r\n     * be needed to decode the change we're currently processing.\r\n     */\r\n    if (!ReorderBufferXidHasBaseSnapshot(builder->reorder, xid)) {\r\n        /* only build a new snapshot if we don't have a prebuilt one */\r\n        if (builder->snapshot == NULL) {\r\n            builder->snapshot = SnapBuildBuildSnapshot(builder, xid);\r\n            /* inrease refcount for the snapshot builder */\r\n            SnapBuildSnapIncRefcount(builder->snapshot);\r\n        }\r\n\r\n        /*\r\n         * Increase refcount for the transaction we're handing the snapshot\r\n         * out to.\r\n         */\r\n        SnapBuildSnapIncRefcount(builder->snapshot);\r\n        ReorderBufferSetBaseSnapshot(builder->reorder, xid, lsn, builder->snapshot);\r\n    }\r\n\r\n    return true;\r\n}",
		"comment":"/*\r\n * Handle the effects of a single heap change, appropriate to the current state\r\n * of the snapshot builder and returns whether changes made at (xid, lsn) can\r\n * be decoded.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"SnapBuildProcessChange"
	},
	"SnapBuildProcessNewCid":{
		"body":"void SnapBuildProcessNewCid(SnapBuild* builder, TransactionId xid, XLogRecPtr lsn, xl_heap_new_cid* xlrec,\r\n    int bucket_id)\r\n{\r\n    CommandId cid;\r\n\r\n    RelFileNode tmp_node;\r\n    RelFileNodeCopy(tmp_node, xlrec->target_node, bucket_id);\r\n\r\n    /*\r\n     * we only log new_cid's if a catalog tuple was modified, so mark\r\n     * the transaction as containing catalog modifications\r\n     */\r\n    ReorderBufferXidSetCatalogChanges(builder->reorder, xid, lsn);\r\n\r\n    ReorderBufferAddNewTupleCids(builder->reorder,\r\n        xlrec->top_xid,\r\n        lsn,\r\n        tmp_node,\r\n        xlrec->target_tid,\r\n        xlrec->cmin,\r\n        xlrec->cmax,\r\n        xlrec->combocid);\r\n\r\n    /* figure out new command id */\r\n    if (xlrec->cmin != InvalidCommandId && xlrec->cmax != InvalidCommandId)\r\n        cid = Max(xlrec->cmin, xlrec->cmax);\r\n    else if (xlrec->cmax != InvalidCommandId)\r\n        cid = xlrec->cmax;\r\n    else if (xlrec->cmin != InvalidCommandId)\r\n        cid = xlrec->cmin;\r\n    else {\r\n        cid = InvalidCommandId; /* silence compiler */\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"xl_heap_new_cid record without a valid CommandId\")));\r\n    }\r\n\r\n    ReorderBufferAddNewCommandId(builder->reorder, xid, lsn, cid + 1);\r\n}",
		"comment":"/*\r\n * Do CommandId/ComboCid handling after reading a xl_heap_new_cid record. This\r\n * implies that a transaction has done some form of write to system catalogs.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"SnapBuildProcessNewCid"
	},
	"SnapBuildProcessRunningXacts":{
		"body":"void SnapBuildProcessRunningXacts(SnapBuild* builder, XLogRecPtr lsn, xl_running_xacts* running)\r\n{\r\n    ReorderBufferTXN* txn = NULL;\r\n    TransactionId xmin;\r\n\r\n    /*\r\n     * If we're not consistent yet, inspect the record to see whether it\r\n     * allows to get closer to being consistent. If we are consistent, dump\r\n     * our snapshot so others or we, after a restart, can use it.\r\n     */\r\n    if (builder->state < SNAPBUILD_CONSISTENT) {\r\n        /* returns false if there's no point in performing cleanup just yet */\r\n        if (!SnapBuildFindSnapshot(builder, lsn, running)) {\r\n            return;\r\n        }\r\n    } else {\r\n        SnapBuildSerialize(builder, lsn);\r\n    }\r\n\r\n    /*\r\n     * Update range of interesting xids base don the running xacts\r\n     * information. We don't increase ->xmax using it, because once we are in\r\n     * a consistent state we can do that ourselves and much more efficiently\r\n     * so, because we only need to do it for catalog transactions since we\r\n     * only ever look at those.\r\n     *\r\n     * NB: Because of that xmax can be lower than xmin, because we only\r\n     * increase xmax when a catalog modifying transaction commits. While odd\r\n     * looking, its correct and actually more efficient this way since we hit\r\n     * fast paths in tqual.c.\r\n     */\r\n    builder->xmin = running->oldestRunningXid;\r\n\r\n    /* Remove transactions we don't need to keep track off anymore */\r\n    SnapBuildPurgeCommittedTxn(builder);\r\n\r\n    /*\r\n     * Advance the xmin limit for the current replication slot, to allow\r\n     * vacuum to clean up the tuples this slot has been protecting.\r\n     *\r\n     * The reorderbuffer might have an xmin among the currently running\r\n     * snapshots; use it if so.  If not, we need only consider the snapshots\r\n     * we'll produce later, which can't be less than the oldest running xid in\r\n     * the record we're reading now.\r\n     */\r\n    xmin = ReorderBufferGetOldestXmin(builder->reorder);\r\n    if (xmin == InvalidTransactionId) {\r\n        xmin = running->oldestRunningXid;\r\n    }\r\n    ereport(DEBUG3,\r\n        (errmsg(\"xmin: %lu, xmax: %lu, oldest running: %lu, oldest xmin: %lu\",\r\n            builder->xmin, builder->xmax,\r\n            running->oldestRunningXid, xmin)));\r\n    LogicalIncreaseXminForSlot(lsn, xmin);\r\n\r\n    /*\r\n     * Also tell the slot where we can restart decoding from. We don't want to\r\n     * do that after every commit because changing that implies an fsync of\r\n     * the logical slot's state file, so we only do it every time we see a\r\n     * running xacts record.\r\n     *\r\n     * Do so by looking for the oldest in progress transaction (determined by\r\n     * the first LSN of any of its relevant records). Every transaction\r\n     * remembers the last location we stored the snapshot to disk before its\r\n     * beginning. That point is where we can restart from.\r\n     *\r\n     *\r\n     * Can't know about a serialized snapshot's location if we're not\r\n     * consistent.\r\n     */\r\n    if (builder->state < SNAPBUILD_CONSISTENT) {\r\n        return;\r\n    }\r\n\r\n    txn = ReorderBufferGetOldestTXN(builder->reorder);\r\n    /*\r\n     * oldest ongoing txn might have started when we didn't yet serialize\r\n     * anything because we hadn't reached a consistent state yet.\r\n     */\r\n    if (txn != NULL && !XLByteEQ(txn->restart_decoding_lsn, InvalidXLogRecPtr)) {\r\n        LogicalIncreaseRestartDecodingForSlot(lsn, txn->restart_decoding_lsn);\r\n    } else if (txn == NULL && !XLByteEQ(builder->reorder->current_restart_decoding_lsn, InvalidXLogRecPtr)\r\n               && !XLByteEQ(builder->last_serialized_snapshot, InvalidXLogRecPtr)) {\r\n        // No in-progress transaction, can reuse the last serialized snapshot if we have one.\r\n        LogicalIncreaseRestartDecodingForSlot(lsn, builder->last_serialized_snapshot);\r\n    }\r\n}",
		"comment":"/* -----------------------------------\r\n * Snapshot building functions dealing with xlog records\r\n * -----------------------------------\r\n *\r\n * Process a running xacts record, and use it's information to first build a\r\n * historic snapshot and later to release resources that aren't needed\r\n * anymore.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"SnapBuildProcessRunningXacts"
	},
	"SnapBuildPurgeCommittedTxn":{
		"body":"static void SnapBuildPurgeCommittedTxn(SnapBuild* builder)\r\n{\r\n    size_t off = 0;\r\n    TransactionId* workspace = NULL;\r\n    uint32 surviving_xids = 0;\r\n    int rc = 0;\r\n    /* not ready yet */\r\n    if (!TransactionIdIsNormal(builder->xmin))\r\n        return;\r\n\r\n    /* description: Neater algorithm than just copying and iterating? */\r\n    workspace = (TransactionId*)MemoryContextAlloc(builder->context, builder->committed.xcnt * sizeof(TransactionId));\r\n\r\n    /* copy xids that still are interesting to workspace */\r\n    for (off = 0; off < builder->committed.xcnt; off++) {\r\n        if (NormalTransactionIdPrecedes(builder->committed.xip[off], builder->xmin))\r\n            ; /* remove */\r\n        else\r\n            workspace[surviving_xids++] = builder->committed.xip[off];\r\n    }\r\n    if (surviving_xids) {\r\n        /* copy workspace back to persistent state */\r\n        rc = memcpy_s(builder->committed.xip,\r\n            surviving_xids * sizeof(TransactionId),\r\n            workspace,\r\n            surviving_xids * sizeof(TransactionId));\r\n        securec_check(rc, \"\", \"\");\r\n    }\r\n    if (!RecoveryInProgress())\r\n        ereport(DEBUG3,\r\n            (errmsg(\"purged committed transactions from %lu to %u, xmin: %lu, xmax: %lu\",\r\n                builder->committed.xcnt,\r\n                surviving_xids,\r\n                builder->xmin,\r\n                builder->xmax)));\r\n    builder->committed.xcnt = surviving_xids;\r\n\r\n    pfree(workspace);\r\n    workspace = NULL;\r\n}",
		"comment":"/*\r\n * Remove knowledge about transactions we treat as committed that are smaller\r\n * than ->xmin. Those won't ever get checked via the ->commited array but via\r\n * the clog machinery, so we don't need to waste memory on them.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"SnapBuildPurgeCommittedTxn"
	},
	"SnapBuildRestore":{
		"body":"static bool SnapBuildRestore(SnapBuild* builder, XLogRecPtr lsn)\r\n{\r\n    SnapBuildOnDisk ondisk;\r\n    int fd;\r\n    char path[MAXPGPATH];\r\n    Size sz;\r\n    Size readBytes;\r\n    pg_crc32 checksum;\r\n    int nRet = 0;\r\n    /* no point in loading a snapshot if we're already there */\r\n    if (builder->state == SNAPBUILD_CONSISTENT)\r\n        return false;\r\n\r\n    nRet = sprintf_s(path, sizeof(path), \"pg_llog/snapshots/%X-%X.snap\", (uint32)(lsn >> 32), (uint32)lsn);\r\n    securec_check_ss(nRet, \"\", \"\");\r\n\r\n    fd = OpenTransientFile(path, O_RDONLY | PG_BINARY, 0);\r\n    if (fd < 0 && errno == ENOENT) {\r\n        return false;\r\n    } else if (fd < 0) {\r\n        ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not open file \\\"%s\\\": %m\", path)));\r\n    }\r\n\r\n    /* ----\r\n     * Make sure the snapshot had been stored safely to disk, that's normally\r\n     * cheap.\r\n     * Note that we do not need PANIC here, nobody will be able to use the\r\n     * slot without fsyncing, and saving it won't suceed without an fsync()\r\n     * either...\r\n     * ----\r\n     */\r\n    fsync_fname(path, false);\r\n    fsync_fname(\"pg_llog/snapshots\", true);\r\n\r\n    /* read statically sized portion of snapshot */\r\n    readBytes = (Size)read(fd, &ondisk, SnapBuildOnDiskConstantSize);\r\n    if (readBytes != SnapBuildOnDiskConstantSize) {\r\n        (void)CloseTransientFile(fd);\r\n        ereport(ERROR,\r\n            (errcode_for_file_access(),\r\n                errmsg(\r\n                    \"could not read file \\\"%s\\\", read %lu of %lu: %m\", path, readBytes, SnapBuildOnDiskConstantSize)));\r\n    }\r\n\r\n    if (ondisk.magic != SNAPBUILD_MAGIC) {\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_LOGICAL_DECODE_ERROR),\r\n                errmsg(\"snapbuild state file \\\"%s\\\" has wrong magic %u instead of %d\",\r\n                    path, ondisk.magic, SNAPBUILD_MAGIC)));\r\n    }\r\n\r\n    if (ondisk.version != SNAPBUILD_VERSION) {\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_LOGICAL_DECODE_ERROR),\r\n             errmsg(\"snapbuild state file \\\"%s\\\" has unsupported version %u instead of %d\",\r\n                    path, ondisk.version, SNAPBUILD_VERSION)));\r\n    }\r\n\r\n    INIT_CRC32(checksum);\r\n    COMP_CRC32(checksum,\r\n        ((char*)&ondisk) + SnapBuildOnDiskNotChecksummedSize,\r\n        SnapBuildOnDiskConstantSize - SnapBuildOnDiskNotChecksummedSize);\r\n\r\n    /* read SnapBuild */\r\n    readBytes = (Size)read(fd, &ondisk.builder, sizeof(SnapBuild));\r\n    if (readBytes != sizeof(SnapBuild)) {\r\n        (void)CloseTransientFile(fd);\r\n        ereport(ERROR,\r\n            (errcode_for_file_access(),\r\n                errmsg(\"could not read file \\\"%s\\\", read %lu of %lu: %m\", path, readBytes, sizeof(SnapBuild))));\r\n    }\r\n    COMP_CRC32(checksum, &ondisk.builder, sizeof(SnapBuild));\r\n\r\n    /* restore running xacts (dead, but kept for backward compat) */\r\n    if (MAX_SIZE_T_NUM / sizeof(TransactionId) < ondisk.builder.was_running.was_xcnt_space) {\r\n        (void)CloseTransientFile(fd);\r\n        ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not read file \\\"%s\\\", size overflow\", path)));\r\n    }\r\n    /* restore running xacts (dead, but kept for backward compat) */\r\n    sz = sizeof(TransactionId) * ondisk.builder.was_running.was_xcnt_space;\r\n    ondisk.builder.was_running.was_xip = (TransactionId*)MemoryContextAllocZero(builder->context, sz);\r\n    readBytes = read(fd, ondisk.builder.was_running.was_xip, sz);\r\n    if (readBytes != sz) {\r\n        (void)CloseTransientFile(fd);\r\n        ereport(ERROR,\r\n            (errcode_for_file_access(),\r\n                errmsg(\"could not read file \\\"%s\\\", read %lu of %lu: %m\", path, readBytes, (long unsigned int)sz)));\r\n    }\r\n    COMP_CRC32(checksum, ondisk.builder.was_running.was_xip, sz);\r\n\r\n    /* restore committed xacts information */\r\n    if (MAX_SIZE_T_NUM / sizeof(TransactionId) < ondisk.builder.committed.xcnt_space) {\r\n        (void)CloseTransientFile(fd);\r\n        ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not read file \\\"%s\\\", size overflow\", path)));\r\n    }\r\n    sz = sizeof(TransactionId) * ondisk.builder.committed.xcnt;\r\n    if (sz > 0) {\r\n        ondisk.builder.committed.xip = (TransactionId*)MemoryContextAllocZero(builder->context, sz);\r\n        readBytes = read(fd, ondisk.builder.committed.xip, sz);\r\n        if (readBytes != sz) {\r\n            (void)CloseTransientFile(fd);\r\n            ereport(ERROR,\r\n                (errcode_for_file_access(),\r\n                    errmsg(\"could not read file \\\"%s\\\", read %lu of %lu: %m\", path, readBytes, sz)));\r\n        }\r\n        COMP_CRC32(checksum, ondisk.builder.committed.xip, sz);\r\n    }\r\n    (void)CloseTransientFile(fd);\r\n\r\n    /* verify checksum of what we've read */\r\n    if (!EQ_CRC32(checksum, ondisk.checksum)) {\r\n        ereport(ERROR,\r\n            (errcode_for_file_access(),\r\n                errmsg(\"snapbuild state file %s: checksum mismatch, is %u, should be %u\",\r\n                    path, checksum, ondisk.checksum)));\r\n    }\r\n\r\n    /*\r\n     * ok, we now have a sensible snapshot here, figure out if it has more\r\n     * information than we have.\r\n     *\r\n     *\r\n     * We are only interested in consistent snapshots for now, comparing\r\n     * whether one imcomplete snapshot is more \"advanced\" seems to be\r\n     * unnecessarily complex.\r\n     */\r\n    if (ondisk.builder.state < SNAPBUILD_CONSISTENT) {\r\n        goto snapshot_not_interesting;\r\n    }\r\n\r\n    /*\r\n     * Don't use a snapshot that requires an xmin that we cannot guarantee to\r\n     * be available.\r\n     */\r\n    if (TransactionIdPrecedes(ondisk.builder.xmin, builder->initial_xmin_horizon)) {\r\n        goto snapshot_not_interesting;\r\n    }\r\n\r\n    /* ok, we think the snapshot is sensible, copy over everything important */\r\n    builder->xmin = ondisk.builder.xmin;\r\n    builder->xmax = ondisk.builder.xmax;\r\n    builder->state = ondisk.builder.state;\r\n\r\n    builder->committed.xcnt = ondisk.builder.committed.xcnt;\r\n    /* \r\n     * We only allocated/stored xcnt, not xcnt_space xids !\r\n     * don't overwrite preallocated xip, if we don't have anything here \r\n     */\r\n    if (builder->committed.xcnt > 0) {\r\n        pfree(builder->committed.xip);\r\n        builder->committed.xip = NULL;\r\n        builder->committed.xcnt_space = ondisk.builder.committed.xcnt;\r\n        builder->committed.xip = ondisk.builder.committed.xip;\r\n    }\r\n    ondisk.builder.committed.xip = NULL;\r\n\r\n    /* our snapshot is not interesting anymore, build a new one */\r\n    if (builder->snapshot != NULL) {\r\n        SnapBuildSnapDecRefcount(builder->snapshot);\r\n    }\r\n    builder->snapshot = SnapBuildBuildSnapshot(builder, InvalidTransactionId);\r\n    SnapBuildSnapIncRefcount(builder->snapshot);\r\n\r\n    ReorderBufferSetRestartPoint(builder->reorder, lsn);\r\n\r\n    Assert(builder->state == SNAPBUILD_CONSISTENT);\r\n\r\n    if (!RecoveryInProgress()) {\r\n        ereport(LOG,\r\n            (errmsg(\"logical decoding found consistent point at %X/%X\", (uint32)(lsn >> 32), (uint32)lsn),\r\n                errdetail(\"found initial snapshot in snapbuild file\")));\r\n    }\r\n    return true;\r\n\r\nsnapshot_not_interesting:\r\n    if (ondisk.builder.committed.xip != NULL) {\r\n        pfree(ondisk.builder.committed.xip);\r\n        ondisk.builder.committed.xip = NULL;\r\n    }\r\n    return false;\r\n}",
		"comment":"/*\r\n * Restore a snapshot into 'builder' if previously one has been stored at the\r\n * location indicated by 'lsn'. Returns true if successful, false otherwise.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"SnapBuildRestore"
	},
	"SnapBuildSerializationPoint":{
		"body":"void SnapBuildSerializationPoint(SnapBuild* builder, XLogRecPtr lsn)\r\n{\r\n    if (builder->state < SNAPBUILD_CONSISTENT) {\r\n        (void)SnapBuildRestore(builder, lsn);\r\n    } else {\r\n        (void)SnapBuildSerialize(builder, lsn);\r\n    }\r\n}",
		"comment":"/*\r\n * Store/Load a snapshot from disk, depending on the snapshot builder's state.\r\n *\r\n * Supposed to be used by external (i.e. not snapbuild.c) code that just reada\r\n * record that's a potential location for a serialized snapshot.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"SnapBuildSerializationPoint"
	},
	"SnapBuildSerialize":{
		"body":"static void SnapBuildSerialize(SnapBuild* builder, XLogRecPtr lsn)\r\n{\r\n    Size needed_length = 0;\r\n    SnapBuildOnDisk* ondisk = NULL;\r\n    char* ondisk_c = NULL;\r\n    int rc = 0;\r\n    int fd = 0;\r\n    char tmppath[MAXPGPATH];\r\n    char path[MAXPGPATH];\r\n    int ret = 0;\r\n    struct stat stat_buf;\r\n    uint32 sz = 0;\r\n    int nRet = 0;\r\n    Assert(!XLByteEQ(lsn, InvalidXLogRecPtr));\r\n    Assert(XLByteEQ(builder->last_serialized_snapshot, InvalidXLogRecPtr) ||\r\n           XLByteLE(builder->last_serialized_snapshot, lsn));\r\n\r\n    /*\r\n     * no point in serializing if we cannot continue to work immediately after\r\n     * restoring the snapshot\r\n     */\r\n    if (builder->state < SNAPBUILD_CONSISTENT) {\r\n        return;\r\n    }\r\n\r\n    /*\r\n     * We identify snapshots by the LSN they are valid for. We don't need to\r\n     * include timelines in the name as each LSN maps to exactly one timeline\r\n     * unless the user used pg_resetxlog or similar. If a user did so, there's\r\n     * no hope continuing to decode anyway.\r\n     */\r\n    nRet = sprintf_s(path, MAXPGPATH, \"pg_llog/snapshots/%X-%X.snap\", (uint32)(lsn >> 32), (uint32)lsn);\r\n    securec_check_ss(nRet, \"\", \"\");\r\n    /*\r\n     * first check whether some other backend already has written the snapshot\r\n     * for this LSN. It's perfectly fine if there's none, so we accept ENOENT\r\n     * as a valid state. Everything else is an unexpected error.\r\n     */\r\n    ret = stat(path, &stat_buf);\r\n    if (ret != 0 && errno != ENOENT) {\r\n        ereport(ERROR, (errcode(ERRCODE_LOGICAL_DECODE_ERROR), errmsg(\"could not stat file \\\"%s\\\": %m\", path)));\r\n    } else if (ret == 0) {\r\n        /*\r\n         * somebody else has already serialized to this point, don't overwrite\r\n         * but remember location, so we don't need to read old data again.\r\n         *\r\n         * To be sure it has been synced to disk after the rename() from the\r\n         * tempfile filename to the real filename, we just repeat the\r\n         * fsync. That ought to be cheap because in most scenarios it should\r\n         * already be safely on disk.\r\n         */\r\n        fsync_fname(path, false);\r\n        fsync_fname(\"pg_llog/snapshots\", true);\r\n\r\n        builder->last_serialized_snapshot = lsn;\r\n        goto out;\r\n    }\r\n\r\n    /*\r\n     * there is an obvious race condition here between the time we stat(2) the\r\n     * file and us writing the file. But we rename the file into place\r\n     * atomically and all files created need to contain the same data anyway,\r\n     * so this is perfectly fine, although a bit of a resource waste. Locking\r\n     * seems like pointless complication.\r\n     */\r\n    if (!RecoveryInProgress()) {\r\n        ereport(DEBUG1, (errmsg(\"serializing snapshot to %s\", path)));\r\n    }\r\n\r\n    /* to make sure only we will write to this tempfile, include pid */\r\n    rc = sprintf_s(tmppath, sizeof(tmppath),\r\n        \"pg_llog/snapshots/%X-%X.snap.%u.tmp\",\r\n        (uint32)(lsn >> 32), (uint32)lsn, (uint32)t_thrd.proc_cxt.MyProcPid);\r\n    securec_check_ss(rc, \"\", \"\");\r\n\r\n    /*\r\n     * Unlink temporary file if it already exists, needs to have been before a\r\n     * crash/error since we won't enter this function twice from within a\r\n     * single decoding slot/backend and the temporary file contains the pid of\r\n     * the current process.\r\n     */\r\n    if (unlink(tmppath) != 0 && errno != ENOENT) {\r\n        ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not unlink file \\\"%s\\\": %m\", path)));\r\n    }\r\n\r\n    needed_length = sizeof(SnapBuildOnDisk) + sizeof(TransactionId) * builder->committed.xcnt;\r\n\r\n    ondisk_c = (char*)MemoryContextAllocZero(builder->context, needed_length);\r\n    ondisk = (SnapBuildOnDisk*)ondisk_c;\r\n    ondisk->magic = SNAPBUILD_MAGIC;\r\n    ondisk->version = SNAPBUILD_VERSION;\r\n    ondisk->length = needed_length;\r\n    INIT_CRC32(ondisk->checksum);\r\n    COMP_CRC32(ondisk->checksum,\r\n        ((char*)ondisk) + SnapBuildOnDiskNotChecksummedSize,\r\n        SnapBuildOnDiskConstantSize - SnapBuildOnDiskNotChecksummedSize);\r\n    ondisk_c += sizeof(SnapBuildOnDisk);\r\n\r\n    nRet = memcpy_s(&ondisk->builder, sizeof(SnapBuild), builder, sizeof(SnapBuild));\r\n    securec_check(nRet, \"\", \"\");\r\n    /* NULL-ify memory-only data */\r\n    ondisk->builder.context = NULL;\r\n    ondisk->builder.snapshot = NULL;\r\n    ondisk->builder.reorder = NULL;\r\n    ondisk->builder.committed.xip = NULL;\r\n\r\n    COMP_CRC32(ondisk->checksum, &ondisk->builder, sizeof(SnapBuild));\r\n\r\n    /* there shouldn't be any running xacts */\r\n    Assert(builder->was_running.was_xcnt == 0);\r\n\r\n    /* copy committed xacts */\r\n    sz = sizeof(TransactionId) * builder->committed.xcnt;\r\n    if (builder->committed.xcnt) {\r\n        nRet = memcpy_s(ondisk_c, sz, builder->committed.xip, sz);\r\n        securec_check(nRet, \"\", \"\");\r\n    }\r\n    COMP_CRC32(ondisk->checksum, ondisk_c, sz);\r\n    ondisk_c += sz;\r\n\r\n    /* we have valid data now, open tempfile and write it there */\r\n    fd = OpenTransientFile(tmppath, O_CREAT | O_EXCL | O_WRONLY | PG_BINARY, S_IRUSR | S_IWUSR);\r\n    if (fd < 0) {\r\n        ereport(ERROR, (errcode(ERRCODE_LOGICAL_DECODE_ERROR), errmsg(\"could not open file \\\"%s\\\": %m\", path)));\r\n    }\r\n\r\n    if (Size(write(fd, ondisk, needed_length)) != needed_length) {\r\n        (void)CloseTransientFile(fd);\r\n        ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not write to file \\\"%s\\\": %m\", tmppath)));\r\n    }\r\n\r\n    /*\r\n     * fsync the file before renaming so that even if we crash after this we\r\n     * have either a fully valid file or nothing.\r\n     *\r\n     * It's safe to just ERROR on fsync() here because we'll retry the whole\r\n     * operation including the writes.\r\n     *\r\n     * description: Do the fsync() via checkpoints/restartpoints, doing it here has\r\n     * some noticeable overhead since it's performed synchronously during\r\n     * decoding?\r\n     */\r\n    if (pg_fsync(fd) != 0) {\r\n        (void)CloseTransientFile(fd);\r\n        ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not fsync file \\\"%s\\\": %m\", tmppath)));\r\n    }\r\n    (void)CloseTransientFile(fd);\r\n\r\n    fsync_fname(\"pg_llog/snapshots\", true);\r\n\r\n    /*\r\n     * We may overwrite the work from some other backend, but that's ok, our\r\n     * snapshot is valid as well, we'll just have done some superflous work.\r\n     */\r\n    if (rename(tmppath, path) != 0) {\r\n        ereport(ERROR,\r\n            (errcode_for_file_access(), errmsg(\"could not rename file \\\"%s\\\" to \\\"%s\\\": %m\", tmppath, path)));\r\n    }\r\n\r\n    /* make sure we persist */\r\n    fsync_fname(path, false);\r\n    fsync_fname(\"pg_llog/snapshots\", true);\r\n\r\n    /*\r\n     * Now there's no way we can loose the dumped state anymore, remember\r\n     * this as a serialization point.\r\n     */\r\n    builder->last_serialized_snapshot = lsn;\r\n\r\nout:\r\n    ReorderBufferSetRestartPoint(builder->reorder, builder->last_serialized_snapshot);\r\n}",
		"comment":"/*\r\n * Serialize the snapshot 'builder' at the location 'lsn' if it hasn't already\r\n * been done by another decoding process.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"SnapBuildSerialize"
	},
	"SnapBuildSnapDecRefcount":{
		"body":"void SnapBuildSnapDecRefcount(Snapshot snap)\r\n{\r\n    /* make sure we don't get passed an external snapshot */\r\n    Assert(snap->satisfies == HeapTupleSatisfiesHistoricMVCC);\r\n\r\n    /* make sure nobody modified our snapshot */\r\n    Assert(snap->curcid == FirstCommandId);\r\n    Assert(!snap->suboverflowed);\r\n    Assert(!snap->takenDuringRecovery);\r\n\r\n    Assert(snap->regd_count == 0);\r\n\r\n    Assert(snap->active_count > 0);\r\n\r\n    /* slightly more likely, so its checked even without casserts */\r\n    if (snap->copied)\r\n        ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"cannot free a copied snapshot\")));\r\n\r\n    snap->active_count--;\r\n    if (snap->active_count == 0)\r\n        SnapBuildFreeSnapshot(snap);\r\n}",
		"comment":"/*\r\n * Decrease refcount of a snapshot and free if the refcount reaches zero.\r\n *\r\n * Externally visible, so that external resources that have been handed an\r\n * IncRef'ed Snapshot can adjust its refcount easily.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"SnapBuildSnapDecRefcount"
	},
	"SnapBuildSnapIncRefcount":{
		"body":"static void SnapBuildSnapIncRefcount(Snapshot snap)\r\n{\r\n    snap->active_count++;\r\n}",
		"comment":"/*\r\n * Increase refcount of a snapshot.\r\n *\r\n * This is used when handing out a snapshot to some external resource or when\r\n * adding a Snapshot as builder->snapshot.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"SnapBuildSnapIncRefcount"
	},
	"SnapBuildStartNextPhaseAt":{
		"body":"static inline void SnapBuildStartNextPhaseAt(SnapBuild* builder, TransactionId at)\r\n{\r\n    /*\r\n     * For backward compatibility reasons this has to be stored in the wrongly\r\n     * named field.  Will be fixed in next major version.\r\n     */\r\n    builder->was_running.was_xmax = at;\r\n}",
		"comment":"/*\r\n * Set TransactionId after which the next phase of initial snapshot building\r\n * will happen.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"SnapBuildStartNextPhaseAt"
	},
	"SnapBuildWaitSnapshot":{
		"body":"static void SnapBuildWaitSnapshot(xl_running_xacts* running, TransactionId cutoff)\r\n{\r\n    for (int off = 0; off < running->xcnt; off++) {\r\n        TransactionId xid = running->xids[off];\r\n\r\n        /*\r\n         * Upper layers should prevent that we ever need to wait on\r\n         * ourselves. Check anyway, since failing to do so would either\r\n         * result in an endless wait or an Assert() failure.\r\n         */\r\n        if (TransactionIdIsCurrentTransactionId(xid)) {\r\n            ereport(ERROR, (errcode(ERRCODE_LOGICAL_DECODE_ERROR), errmsg(\"waiting for ourselves\")));\r\n        }\r\n\r\n        if (TransactionIdFollows(xid, cutoff)) {\r\n            continue;\r\n        }\r\n\r\n        XactLockTableWait(xid);\r\n    }\r\n\r\n    /*\r\n     * All transactions we needed to finish finished - try to ensure there is\r\n     * another xl_running_xacts record in a timely manner, without having to\r\n     * write for bgwriter or checkpointer to log one.  During recovery we\r\n     * can't enforce that, so we'll have to wait.\r\n     */\r\n    if (!RecoveryInProgress()) {\r\n        (void)LogStandbySnapshot();\r\n    }\r\n}",
		"comment":"/* ---\r\n * Iterate through xids in record, wait for all older than the cutoff to\r\n * finish.  Then, if possible, log a new xl_running_xacts record.\r\n *\r\n * This isn't required for the correctness of decoding, but to:\r\n * a) allow isolationtester to notice that we're currently waiting for\r\n *	something.\r\n * b) log a new xl_running_xacts record where it'd be helpful, without having\r\n *	to write for bgwriter or checkpointer.\r\n * ---\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"SnapBuildWaitSnapshot"
	},
	"SnapBuildXactNeedsSkip":{
		"body":"bool SnapBuildXactNeedsSkip(SnapBuild* builder, XLogRecPtr ptr)\r\n{\r\n    return XLByteLT(ptr, builder->start_decoding_at);\r\n}",
		"comment":"/*\r\n * Should the contents of transaction ending at 'ptr' be decoded?\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\snapbuild.cpp",
		"name":"SnapBuildXactNeedsSkip"
	}
}