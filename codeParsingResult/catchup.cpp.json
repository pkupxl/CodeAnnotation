{
	"CatchupKill":{
		"body":"static void CatchupKill(int code, Datum arg)\r\n{\r\n    ReplaceOrFreeBcmFileListBuffer(NULL, 0);\r\n    ereport(LOG, (errmsg(\"catchup process shutdown.\")));\r\n    catchupState = CATCHUP_NONE;\r\n    catchup_online = false;\r\n}",
		"comment":"/* Destroy the catchup data structure for catchup process */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\catchup.cpp",
		"name":"CatchupKill"
	},
	"CatchupMain":{
		"body":"void CatchupMain()\r\n{\r\n    sigjmp_buf local_sigjmp_buf;\r\n    MemoryContext catchupContext;\r\n\r\n    /* we are a postmaster subprocess now */\r\n    IsUnderPostmaster = true;\r\n\r\n    t_thrd.role = CATCHUP;\r\n\r\n    catchup_online = true;\r\n\r\n    /* tell datasender we update the values. */\r\n    pg_memory_barrier();\r\n\r\n    /* reset t_thrd.proc_cxt.MyProcPid */\r\n    t_thrd.proc_cxt.MyProcPid = gs_thread_self();\r\n\r\n    /* record Start Time for logging */\r\n    t_thrd.proc_cxt.MyStartTime = time(NULL);\r\n\r\n    t_thrd.proc_cxt.MyProgName = \"Catchup\";\r\n\r\n    /* Identify myself via ps */\r\n    init_ps_display(\"catchup process\", \"\", \"\", \"\");\r\n\r\n    SetProcessingMode(InitProcessing);\r\n\r\n    /*\r\n     * Set up signal handlers.\r\n     */\r\n    on_shmem_exit(CatchupKill, 0);\r\n    (void)gspqsignal(SIGINT, SIG_IGN);\r\n    (void)gspqsignal(SIGUSR1, procsignal_sigusr1_handler);\r\n    (void)gspqsignal(SIGPIPE, SIG_IGN);\r\n\r\n    (void)gspqsignal(SIGTERM, CatchupShutdownHandler);\r\n    (void)gspqsignal(SIGQUIT, quickdie);\r\n    (void)gspqsignal(SIGALRM, handle_sig_alarm);\r\n    (void)gspqsignal(SIGUSR2, SIG_IGN);\r\n    (void)gspqsignal(SIGFPE, SIG_IGN);\r\n    (void)gspqsignal(SIGCHLD, SIG_DFL);\r\n    (void)gspqsignal(SIGHUP, SIG_IGN);\r\n\r\n    /* We allow SIGQUIT (quickdie) at all times */\r\n    (void)sigdelset(&t_thrd.libpq_cxt.BlockSig, SIGQUIT);\r\n\r\n    /* Early initialization */\r\n    BaseInit();\r\n\r\n    /*\r\n     * Create a per-backend PGPROC struct in shared memory, except in the\r\n     * EXEC_BACKEND case where this was done in SubPostmasterMain. We must do\r\n     * this before we can use LWLocks (and in the EXEC_BACKEND case we already\r\n     * had to do some stuff with LWLocks).\r\n     */\r\n#ifndef EXEC_BACKEND\r\n    InitProcess();\r\n#endif\r\n\r\n    t_thrd.proc_cxt.PostInit->SetDatabaseAndUser(NULL, InvalidOid, NULL);\r\n    t_thrd.proc_cxt.PostInit->InitCatchupWorker();\r\n\r\n    SetProcessingMode(NormalProcessing);\r\n\r\n    /*\r\n     * Create a resource owner to keep track of our resources (currently only\r\n     * buffer pins).\r\n     */\r\n    t_thrd.utils_cxt.CurrentResourceOwner = ResourceOwnerCreate(NULL, \"Catchup\");\r\n\r\n    /*\r\n     * Create a memory context that we will do all our work in.  We do this so\r\n     * that we can reset the context during error bcm read or send and thereby\r\n     * avoid possible memory leaks.  Formerly this code just ran in\r\n     * t_thrd.top_mem_cxt, but resetting that would be a really bad idea.\r\n     */\r\n    catchupContext = AllocSetContextCreate(\r\n        t_thrd.top_mem_cxt, \"Catchup\", ALLOCSET_DEFAULT_MINSIZE, ALLOCSET_DEFAULT_INITSIZE, ALLOCSET_DEFAULT_MAXSIZE);\r\n    (void)MemoryContextSwitchTo(catchupContext);\r\n\r\n    /* report this backend in the PgBackendStatus array */\r\n    pgstat_bestart();\r\n    pgstat_report_appname(\"Catchup\");\r\n    pgstat_report_activity(STATE_IDLE, NULL);\r\n\r\n    /*\r\n     * If an exception is encountered, processing resumes here.\r\n     *\r\n     * See notes in postgres.c about the design of this coding.\r\n     */\r\n    int curTryCounter = 0;\r\n    int *oldTryCounter = NULL;\r\n    if (sigsetjmp(local_sigjmp_buf, 1) != 0) {\r\n        gstrace_tryblock_exit(true, oldTryCounter);\r\n\r\n        /* Since not using PG_TRY, must reset error stack by hand */\r\n        t_thrd.log_cxt.error_context_stack = NULL;\r\n\r\n        /* Prevent interrupts while cleaning up */\r\n        HOLD_INTERRUPTS();\r\n\r\n        /* Forget any pending QueryCancel request */\r\n        t_thrd.int_cxt.QueryCancelPending = false;\r\n        (void)disable_sig_alarm(true);\r\n        t_thrd.int_cxt.QueryCancelPending = false; /* again in case timeout occurred */\r\n\r\n        /* Report the error to the server log */\r\n        EmitErrorReport();\r\n\r\n        /*\r\n         * when clearing the BCM encounter ERROR, we should ResetBCMArray, or it\r\n         * will enter ClearBCMArray infinite loop, then coredump.\r\n         */\r\n        ResetBCMArray();\r\n\r\n        /* Abort the current transaction in order to recover */\r\n        AbortCurrentTransaction();\r\n\r\n        /*\r\n         * Now return to normal top-level context and clear ErrorContext for\r\n         * next time.\r\n         */\r\n        (void)MemoryContextSwitchTo(catchupContext);\r\n        FlushErrorState();\r\n\r\n        /* Flush any leaked data in the top-level context */\r\n        MemoryContextResetAndDeleteChildren(catchupContext);\r\n\r\n        /* Now we can allow interrupts again */\r\n        RESUME_INTERRUPTS();\r\n\r\n        /*\r\n         * Sleep at least 1 second after any error.  A write error is likely\r\n         * to be repeated, and we don't want to be filling the error logs as\r\n         * fast as we can.\r\n         */\r\n        pg_usleep(1000000L);\r\n\r\n        /*\r\n         * Close all open files after any error.  This is helpful on Windows,\r\n         * where holding deleted files open causes various strange errors.\r\n         * It's not clear we need it elsewhere, but shouldn't hurt.\r\n         */\r\n        smgrcloseall();\r\n\r\n        CatchupShutdownIfNoDataSender();\r\n    }\r\n    oldTryCounter = gstrace_tryblock_entry(&curTryCounter);\r\n\r\n    catchupState = CATCHUP_NONE;\r\n    /* We can now handle ereport(ERROR) */\r\n    t_thrd.log_cxt.PG_exception_stack = &local_sigjmp_buf;\r\n\r\n    gs_signal_setmask(&t_thrd.libpq_cxt.UnBlockSig, NULL);\r\n    (void)gs_signal_unblock_sigusr2();\r\n\r\n#ifdef ENABLE_MULTIPLE_NODES\r\n    /*\r\n     * When primary receive switchover, it will SIGTERM all Backend thread,\r\n     * include catchup thread, if getBcmFileList get ERROR, it will longjump\r\n     * and enter CatchupShutdown, then datasnd will exit, primary will domote\r\n     * to standby, but some unsync data in bcm file will lost. So we can not\r\n     * respond the SIGTERM signal.\r\n     */\r\n    if (IS_DN_DUMMY_STANDYS_MODE()) {\r\n        bool fullCatchup = false;\r\n\r\n        /* If incremental catchup switch is off, we use full catchup. */\r\n        if (!u_sess->attr.attr_storage.enable_incremental_catchup) {\r\n            fullCatchup = true;\r\n        } else {\r\n            fullCatchup = WaitDummyStarts();\r\n            /* Tell the sender who is connecting with dummy standby,\r\n             * to scan local data and get BCM file lists.\r\n             */\r\n            if (!fullCatchup) {\r\n                catchupState = CATCHUP_STARTING;\r\n                fullCatchup = WaitBcmFileList();\r\n            }\r\n        }\r\n        StartTransactionCommand();\r\n        if (!fullCatchup) {\r\n            GetIncrementalBcmFileList();\r\n        } else {\r\n            GetBcmFileList(false);\r\n        }\r\n        CommitTransactionCommand();\r\n    }\r\n#endif\r\n\r\n    catchupDone = true;\r\n    catchup_online = false;\r\n    catchupState = CATCHUP_NONE;\r\n\r\n    pg_memory_barrier();\r\n\r\n    /* All done, go away */\r\n    proc_exit(0);\r\n}",
		"comment":"/*\r\n * CatchupMain\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\catchup.cpp",
		"name":"CatchupMain"
	},
	"CatchupShutdown":{
		"body":"static void CatchupShutdown(void)\r\n{\r\n    ereport(LOG, (errmsg(\"catchup process shutdown.\")));\r\n    catchup_online = false;\r\n    proc_exit(0);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\catchup.cpp",
		"name":"CatchupShutdown"
	},
	"CatchupShutdownHandler":{
		"body":"static void CatchupShutdownHandler(SIGNAL_ARGS)\r\n{\r\n    t_thrd.catchup_cxt.catchup_shutdown_requested = true;\r\n}",
		"comment":"/* SIGTERM: set flag to shut down */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\catchup.cpp",
		"name":"CatchupShutdownHandler"
	},
	"CatchupShutdownIfNoDataSender":{
		"body":"void CatchupShutdownIfNoDataSender(void)\r\n{\r\n    if (t_thrd.role == CATCHUP) {\r\n        if (!DataSndInProgress(SNDROLE_PRIMARY_STANDBY) || !u_sess->attr.attr_storage.enable_stream_replication)\r\n            CatchupShutdown();\r\n    }\r\n}",
		"comment":"/*\r\n * Catchup is designed for Standby Catchup Primary, when DataSend that transfer\r\n * data from primary to standby shutdown, Catchup should shutdown, otherwise,\r\n * data for Catchup will be sent to Secordary, this will cause data loss:\r\n *  1. Standby Catchup Primary;\r\n *	2. DataSender between Primary and Standby exit because of timeout;\r\n *	3. data(`table1') to Catcup will sent to Secondary;\r\n *	4. Standby connect Primary again and continue Catchup;\r\n *	5. finary, Standby Catchup all other data, at this time, we mistakenly believe\r\n *	   Standby Catchup Primary, and Secordary can delete all data;\r\n *	6. Then, Primary down, and Standby failover, the `table1' data will loss;\r\n *\r\n *	So, when DataSend between Primary and Standby shutdown because of timeout,\r\n *	Catchup should shutdown.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\catchup.cpp",
		"name":"CatchupShutdownIfNoDataSender"
	},
	"IsCatchupProcess":{
		"body":"bool IsCatchupProcess(void)\r\n{\r\n    return t_thrd.role == CATCHUP;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\catchup.cpp",
		"name":"IsCatchupProcess"
	}
}