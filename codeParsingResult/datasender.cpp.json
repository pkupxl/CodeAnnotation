{
	"DataSend":{
		"body":"static void DataSend(bool* caughtup)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile DataSnd* datasnd = t_thrd.datasender_cxt.MyDataSnd;\r\n    char* datasndbuf = NULL;\r\n    DataPageMessageHeader msghdr;\r\n    DataQueuePtr startptr;\r\n    DataQueuePtr endptr;\r\n    uint32 sendsize;\r\n    errno_t rc = 0;\r\n\r\n    /* Need interface to check if we need to send some data this time  */\r\n    SpinLockAcquire(&datasnd->mutex);\r\n    startptr.queueid = datasnd->sendPosition.queueid;\r\n    startptr.queueoff = datasnd->sendPosition.queueoff;\r\n    endptr.queueid = datasnd->sendPosition.queueid;\r\n    endptr.queueoff = datasnd->sendPosition.queueoff;\r\n    SpinLockRelease(&datasnd->mutex);\r\n\r\n    t_thrd.datasender_cxt.output_message[0] = 'd';\r\n\r\n    datasndbuf = t_thrd.datasender_cxt.output_message + 1 + sizeof(DataPageMessageHeader);\r\n\r\n    if (AmDataSenderOnDummyStandby()) {\r\n        sendsize = DataSendReadData(datasndbuf, g_instance.attr.attr_storage.MaxSendSize * 1024);\r\n        ereport(DEBUG5, (errmsg(\"AmDataSenderOnDummyStandby is true: sendsize=%u\", sendsize)));\r\n    } else {\r\n        sendsize = GetFromDataQueue(datasndbuf,\r\n            g_instance.attr.attr_storage.MaxSendSize * 1024,\r\n            startptr,\r\n            endptr,\r\n            false,\r\n            t_thrd.dataqueue_cxt.DataSenderQueue);\r\n        ereport(DEBUG5,\r\n            (errmsg(\"AmDataSenderOnDummyStandby is false: sendsize=%u startpos=%u/%u endpos=%u/%u\",\r\n                sendsize,\r\n                startptr.queueid,\r\n                startptr.queueoff,\r\n                endptr.queueid,\r\n                endptr.queueoff)));\r\n    }\r\n\r\n    if (!u_sess->attr.attr_storage.enable_stream_replication || (sendsize == 0)) {\r\n        /* update current sendPosition to correction position. */\r\n        SpinLockAcquire(&datasnd->mutex);\r\n        datasnd->sendPosition.queueid = startptr.queueid;\r\n        datasnd->sendPosition.queueoff = startptr.queueoff;\r\n        SpinLockRelease(&datasnd->mutex);\r\n        *caughtup = true;\r\n        ereport(DEBUG5, (errmsg(\"caughtup is true\")));\r\n        return;\r\n    }\r\n\r\n    /*\r\n     * Fill the message header last so that the send timestamp is taken as late as possible.\r\n     */\r\n    msghdr.dataStart = startptr;\r\n    msghdr.dataEnd = endptr;\r\n    msghdr.sendTime = GetCurrentTimestamp();\r\n    msghdr.catchup = (t_thrd.datasender_cxt.MyDataSnd->state == DATASNDSTATE_CATCHUP);\r\n    rc = memcpy_s(t_thrd.datasender_cxt.output_message + 1,\r\n        sizeof(DataPageMessageHeader),\r\n        &msghdr,\r\n        sizeof(DataPageMessageHeader));\r\n    securec_check(rc, \"\", \"\");\r\n\r\n    pq_putmessage_noblock('d', t_thrd.datasender_cxt.output_message, 1 + sizeof(DataPageMessageHeader) + sendsize);\r\n\r\n    SpinLockAcquire(&datasnd->mutex);\r\n    datasnd->sendPosition.queueid = endptr.queueid;\r\n    datasnd->sendPosition.queueoff = endptr.queueoff;\r\n    SpinLockRelease(&datasnd->mutex);\r\n\r\n    Assert(sendsize > 0);\r\n    *caughtup = false;\r\n\r\n    if (u_sess->attr.attr_storage.HaModuleDebug) {\r\n        ereport(LOG,\r\n            (errmsg(\"HA-DataSend done: send data from %u/%u to %u/%u, size %u\",\r\n                startptr.queueid,\r\n                startptr.queueoff,\r\n                endptr.queueid,\r\n                endptr.queueoff,\r\n                sendsize)));\r\n    }\r\n\r\n    return;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSend"
	},
	"DataSendReadData":{
		"body":"static uint32 DataSendReadData(char* buf, uint32 bufsize)\r\n{\r\n    uint32 bytesread = 0;\r\n    char path[MAXPGPATH] = {0};\r\n    uint32 nbytes = 0;\r\n    uint32 total_len = 0;\r\n    errno_t rc = EOK;\r\n    int nRet = 0;\r\n\r\n    rc = memset_s(buf, bufsize, 0, bufsize);\r\n    securec_check(rc, \"\", \"\");\r\n\r\nretry:\r\n    /* open the file */\r\n    while (t_thrd.datasender_cxt.dummy_data_read_file_fd == NULL) {\r\n        /* if dummy standby have no data to send , return 0 */\r\n        if (t_thrd.datasender_cxt.dummy_data_read_file_num > t_thrd.datarcvwriter_cxt.dummy_data_writer_file_num) {\r\n            ereport(DEBUG5,\r\n                (errmsg(\r\n                    \"no data to send.dummy_data_read_file_num=%u\", t_thrd.datasender_cxt.dummy_data_read_file_num)));\r\n\r\n            if (total_len > bufsize)\r\n                ereport(PANIC,\r\n                    (errmsg(\"Secondery standby finish read data error, total len %u, bufsize %u\", total_len, bufsize)));\r\n            return total_len;\r\n        }\r\n        /* get the file path */\r\n        nRet = snprintf_s(\r\n            path, sizeof(path), MAXPGPATH - 1, \"base/dummy_standby/%u\", t_thrd.datasender_cxt.dummy_data_read_file_num);\r\n        securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n\r\n        ereport(DEBUG5, (errmsg(\"DataSendReadData path=%s\", path)));\r\n\r\n        /* open the file */\r\n        t_thrd.datasender_cxt.dummy_data_read_file_fd = fopen(path, \"rb\");\r\n        if (t_thrd.datasender_cxt.dummy_data_read_file_fd == NULL) {\r\n            ereport(WARNING, (errcode_for_file_access(), errmsg(\"could not open data file \\\"%s\\\": %m\", path)));\r\n            t_thrd.datasender_cxt.dummy_data_read_file_num++;\r\n        }\r\n    }\r\n\r\n    /* get many pages to bufsize */\r\n    for (;;) {\r\n        /*\r\n         * OK to read the data:\r\n         * 1. first to read the nbytes num;\r\n         */\r\n        bytesread = fread(&nbytes, 1, sizeof(nbytes), t_thrd.datasender_cxt.dummy_data_read_file_fd);\r\n        if (bytesread != sizeof(nbytes)) {\r\n            if (ferror(t_thrd.datasender_cxt.dummy_data_read_file_fd)) {\r\n                ereport(PANIC,\r\n                    (errcode_for_file_access(),\r\n                        errmsg(\"could not read to data file %s length %u: %m\", path, nbytes)));\r\n            }\r\n            if (feof(t_thrd.datasender_cxt.dummy_data_read_file_fd)) {\r\n                ereport(LOG,\r\n                    (errmsg(\"step1: data file num %u, read file fd %d\",\r\n                        t_thrd.datasender_cxt.dummy_data_read_file_num,\r\n                        t_thrd.datasender_cxt.dummy_data_read_file_fd->_fileno)));\r\n                t_thrd.datasender_cxt.dummy_data_read_file_num++;\r\n                fclose(t_thrd.datasender_cxt.dummy_data_read_file_fd);\r\n                t_thrd.datasender_cxt.dummy_data_read_file_fd = NULL;\r\n\r\n                /*\r\n                 * if we receive the eof when read the nbytes num, the file maybe\r\n                 * interruption when writting. So we goto retry to read the next file.\r\n                 */\r\n                goto retry;\r\n            }\r\n        }\r\n\r\n        /* if the bufsize is full, then we send it. */\r\n        if (total_len + nbytes > bufsize) {\r\n            if (fseek(t_thrd.datasender_cxt.dummy_data_read_file_fd, -(long)sizeof(nbytes), SEEK_CUR))\r\n                ereport(\r\n                    PANIC, (errmsg(\"fseek data file num %u error\", t_thrd.datasender_cxt.dummy_data_read_file_num)));\r\n            break;\r\n        }\r\n\r\n        /*\r\n         * 2. then to read the data with the nbytes;\r\n         */\r\n        bytesread = fread(buf + total_len, 1, nbytes, t_thrd.datasender_cxt.dummy_data_read_file_fd);\r\n        if (bytesread != nbytes) {\r\n            if (ferror(t_thrd.datasender_cxt.dummy_data_read_file_fd)) {\r\n                ereport(PANIC,\r\n                    (errcode_for_file_access(),\r\n                        errmsg(\"could not read to data file %s length %u: %m\", path, nbytes)));\r\n            }\r\n            if (feof(t_thrd.datasender_cxt.dummy_data_read_file_fd)) {\r\n                ereport(LOG,\r\n                    (errmsg(\"step2: data file num %u, read file fd %d\",\r\n                        t_thrd.datasender_cxt.dummy_data_read_file_num,\r\n                        t_thrd.datasender_cxt.dummy_data_read_file_fd->_fileno)));\r\n                t_thrd.datasender_cxt.dummy_data_read_file_num++;\r\n                fclose(t_thrd.datasender_cxt.dummy_data_read_file_fd);\r\n                t_thrd.datasender_cxt.dummy_data_read_file_fd = NULL;\r\n\r\n                /*\r\n                 * if we receive the eof when read the data, the file maybe\r\n                 * interruption when writting. So we goto retry to read the next file.\r\n                 */\r\n                goto retry;\r\n            }\r\n        }\r\n        total_len += nbytes;\r\n    }\r\n\r\n    if (total_len > bufsize)\r\n        ereport(PANIC, (errmsg(\"Secondery standby read data error, total len %u, bufsize %u\", total_len, bufsize)));\r\n\r\n    return total_len;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSendReadData"
	},
	"DataSenderMain":{
		"body":"int DataSenderMain(void)\r\n{\r\n    MemoryContext datasnd_context;\r\n\r\n    t_thrd.proc_cxt.MyProgName = \"DataSender\";\r\n\r\n    /* Create a per-datasender data structure in shared memory */\r\n    InitDataSnd();\r\n    catchupDone = false;\r\n\r\n    ereport(LOG, (errmsg(\"datasender thread started\")));\r\n    /*\r\n     * Create a memory context that we will do all our work in.  We do this so\r\n     * that we can reset the context during error recovery and thereby avoid\r\n     * possible memory leaks.  Formerly this code just ran in\r\n     * t_thrd.top_mem_cxt, but resetting that would be a really bad idea.\r\n     *\r\n     * XXX: we don't actually attempt error recovery in datasender, we just\r\n     * close the connection and exit.\r\n     */\r\n    datasnd_context = AllocSetContextCreate(t_thrd.top_mem_cxt,\r\n        \"Data Sender\",\r\n        ALLOCSET_DEFAULT_MINSIZE,\r\n        ALLOCSET_DEFAULT_INITSIZE,\r\n        ALLOCSET_DEFAULT_MAXSIZE);\r\n    MemoryContextSwitchTo(datasnd_context);\r\n\r\n    /* Set up resource owner */\r\n    t_thrd.utils_cxt.CurrentResourceOwner = ResourceOwnerCreate(NULL, \"datasender top-level resource owner\");\r\n\r\n    /*\r\n     * Let postmaster know that we're streaming. Once we've declared us as a\r\n     * Data sender process, postmaster will let us outlive the postgres and\r\n     * kill us last in the shutdown sequence, so we get a chance to stream all\r\n     * remaining data at shutdown.\r\n     */\r\n    MarkPostmasterChildDataSender();\r\n    SendPostmasterSignal(PMSIGNAL_ADVANCE_STATE_MACHINE);\r\n\r\n    /* Unblock signals (they were blocked when the postmaster forked us) */\r\n    gs_signal_setmask(&t_thrd.libpq_cxt.UnBlockSig, NULL);\r\n\r\n    if (dummyStandbyMode) {\r\n        ShutdownDataRcv();\r\n        t_thrd.xlog_cxt.ThisTimeLineID = GetRecoveryTargetTLI();\r\n        ereport(LOG, (errmsg(\"ThisTimeLineID: %u\", t_thrd.xlog_cxt.ThisTimeLineID)));\r\n    }\r\n\r\n    /* Tell the standby that datasender is ready for receiving commands */\r\n    ReadyForQuery_noblock(DestRemote, u_sess->attr.attr_storage.wal_sender_timeout);\r\n\r\n    /* Handle handshake messages before streaming */\r\n    DataSndHandshake();\r\n\r\n    /* Initialize shared memory status */\r\n    {\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile DataSnd* datasnd = t_thrd.datasender_cxt.MyDataSnd;\r\n\r\n        SpinLockAcquire(&datasnd->mutex);\r\n        datasnd->pid = t_thrd.proc_cxt.MyProcPid;\r\n#ifndef WIN32\r\n        datasnd->lwpId = syscall(SYS_gettid);\r\n#else\r\n        datasnd->lwpId = (int)t_thrd.proc_cxt.MyProcPid;\r\n#endif\r\n        SpinLockRelease(&datasnd->mutex);\r\n\r\n        if (datasnd->sendRole == SNDROLE_PRIMARY_DUMMYSTANDBY) {\r\n            pgstat_report_appname(\"DataSender to Secondary\");\r\n        } else if (datasnd->sendRole == SNDROLE_PRIMARY_BUILDSTANDBY) {\r\n            pgstat_report_appname(\"DataSender to Build\");\r\n        } else if (datasnd->sendRole == SNDROLE_PRIMARY_STANDBY) {\r\n            pgstat_report_appname(\"DataSender to Standby\");\r\n        }\r\n    }\r\n\r\n    /* init the dummy standby data num to write */\r\n    if (dummyStandbyMode) {\r\n        /* Init */\r\n        dummySearching = false;\r\n        InitDummyDataNum();\r\n    }\r\n\r\n    /* Main loop of datasender */\r\n    return DataSndLoop();\r\n}",
		"comment":"/* Main entry point for datasender process */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSenderMain"
	},
	"DataSndCaughtup":{
		"body":"static bool DataSndCaughtup(void)\r\n{\r\n    int i;\r\n\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile DataSnd* datasnd = &t_thrd.datasender_cxt.DataSndCtl->datasnds[i];\r\n\r\n        SpinLockAcquire(&datasnd->mutex);\r\n\r\n        if (datasnd->pid != 0 && datasnd->sendRole == SNDROLE_PRIMARY_STANDBY &&\r\n            datasnd->state == DATASNDSTATE_STREAMING) {\r\n            SpinLockRelease(&datasnd->mutex);\r\n\r\n            return true;\r\n        }\r\n\r\n        SpinLockRelease(&datasnd->mutex);\r\n    }\r\n\r\n    return false;\r\n}",
		"comment":"/* return true if any standby(except dummy standby) caught up */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndCaughtup"
	},
	"DataSndCheckTimeOut":{
		"body":"static void DataSndCheckTimeOut(TimestampTz now)\r\n{\r\n    TimestampTz timeout;\r\n\r\n    /* don't bail out if we're doing something that doesn't require timeouts */\r\n    if (t_thrd.datasender_cxt.last_reply_timestamp <= 0)\r\n        return;\r\n\r\n    timeout = TimestampTzPlusMilliseconds(\r\n        t_thrd.datasender_cxt.last_reply_timestamp, u_sess->attr.attr_storage.wal_sender_timeout);\r\n    if (u_sess->attr.attr_storage.wal_sender_timeout > 0 && now >= timeout) {\r\n        /*\r\n         * Since typically expiration of replication timeout means\r\n         * communication problem, we don't send the error message to the\r\n         * standby.\r\n         */\r\n        ereport(COMMERROR, (errmsg(\"terminating Datasender process due to replication timeout\")));\r\n        DataSndShutdown();\r\n    }\r\n}",
		"comment":"/*\r\n * Check if time since last receive from standby has reached the\r\n * configured limit.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndCheckTimeOut"
	},
	"DataSndComputeSleeptime":{
		"body":"static long DataSndComputeSleeptime(TimestampTz now)\r\n{\r\n    long sleeptime = 10000; /* 10 s */\r\n\r\n    if (u_sess->attr.attr_storage.wal_sender_timeout > 0 && t_thrd.datasender_cxt.last_reply_timestamp > 0) {\r\n        TimestampTz wakeup_time;\r\n        long sec_to_timeout;\r\n        int microsec_to_timeout;\r\n\r\n        /*\r\n         * At the latest stop sleeping once wal_sender_timeout has been\r\n         * reached.\r\n         */\r\n        wakeup_time = TimestampTzPlusMilliseconds(\r\n            t_thrd.datasender_cxt.last_reply_timestamp, u_sess->attr.attr_storage.wal_sender_timeout);\r\n\r\n        /*\r\n         * If no ping has been sent yet, wakeup when it's time to do so.\r\n         * DataSndKeepaliveIfNecessary() wants to send a keepalive once half of\r\n         * the timeout passed without a response.\r\n         */\r\n        if (!t_thrd.datasender_cxt.ping_sent)\r\n            wakeup_time = TimestampTzPlusMilliseconds(\r\n                t_thrd.datasender_cxt.last_reply_timestamp, u_sess->attr.attr_storage.wal_sender_timeout / 2);\r\n\r\n        /* Compute relative time until wakeup. */\r\n        TimestampDifference(now, wakeup_time, &sec_to_timeout, &microsec_to_timeout);\r\n\r\n        sleeptime = sec_to_timeout * 1000 + microsec_to_timeout / 1000;\r\n    }\r\n\r\n    return sleeptime;\r\n}",
		"comment":"/*\r\n * Compute how long send/receive loops should sleep.\r\n *\r\n * If wal_sender_timeout is enabled we want to wake up in time to send\r\n * keepalives and to abort the connection if wal_sender_timeout has been\r\n * reached.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndComputeSleeptime"
	},
	"DataSndGetStateString":{
		"body":"static const char* DataSndGetStateString(DataSndState state)\r\n{\r\n    switch (state) {\r\n        case DATASNDSTATE_STARTUP:\r\n            return \"Startup\";\r\n        case DATASNDSTATE_CATCHUP:\r\n            return \"Catchup\";\r\n        case DATASNDSTATE_STREAMING:\r\n            return \"Streaming\";\r\n    }\r\n    return \"Unknown\";\r\n}",
		"comment":"/*\r\n * return datasender state string.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndGetStateString"
	},
	"DataSndHandshake":{
		"body":"static void DataSndHandshake(void)\r\n{\r\n    StringInfoData input_message;\r\n    bool replication_started = false;\r\n    int sleep_time = 0;\r\n\r\n    initStringInfo(&input_message);\r\n\r\n    while (!replication_started) {\r\n        int first_char;\r\n\r\n        DataSndSetState(DATASNDSTATE_STARTUP);\r\n        set_ps_display(\"idle\", false);\r\n\r\n        /* Wait for some data to arrive */\r\n        if (!pq_select(NAPTIME_PER_CYCLE)) {\r\n            sleep_time += NAPTIME_PER_CYCLE;\r\n\r\n            /*\r\n             * not yet data available without blocking,\r\n             * check if it is under maximum timeout\r\n             * period\r\n             */\r\n            if (u_sess->attr.attr_storage.wal_sender_timeout > 0 &&\r\n                sleep_time >= u_sess->attr.attr_storage.wal_sender_timeout) {\r\n                ereport(COMMERROR,\r\n                    (errcode(ERRCODE_PROTOCOL_VIOLATION), errmsg(\"no message received from standby for maximum time\")));\r\n                proc_exit(0);\r\n            }\r\n            continue;\r\n        }\r\n\r\n        sleep_time = 0;\r\n\r\n        /*\r\n         * Since select has indicated that data is available to read,\r\n         * then we can call blocking function itself, as there must be\r\n         * some data to get.\r\n         */\r\n        first_char = pq_getbyte();\r\n\r\n        /*\r\n         * Emergency bailout if postmaster has died.  This is to avoid the\r\n         * necessity for manual cleanup of all postmaster children.\r\n         */\r\n        if (!PostmasterIsAlive()) {\r\n            gs_thread_exit(1);\r\n        }\r\n\r\n        /*\r\n         * Check for any other interesting events that happened while we\r\n         * slept.\r\n         */\r\n        if (t_thrd.datasender_cxt.got_SIGHUP) {\r\n            t_thrd.datasender_cxt.got_SIGHUP = false;\r\n            ProcessConfigFile(PGC_SIGHUP);\r\n        }\r\n\r\n        if (first_char != EOF) {\r\n            /*\r\n             * Read the message contents. This is expected to be done without\r\n             * blocking because we've been able to get message type code.\r\n             */\r\n            if (pq_getmessage(&input_message, 0)) {\r\n                first_char = EOF; /* suitable message already logged */\r\n            }\r\n        }\r\n\r\n        /* Handle the very limited subset of commands expected in this phase */\r\n        switch (first_char) {\r\n            case 'Q': /* Query message */\r\n            {\r\n                const char* query_string = NULL;\r\n\r\n                query_string = pq_getmsgstring(&input_message);\r\n                pq_getmsgend(&input_message);\r\n\r\n                if (HandleDataReplicationCommand(query_string)) {\r\n                    replication_started = true;\r\n                }\r\n            } break;\r\n\r\n            case 'X':\r\n                /* standby is closing the connection */\r\n                proc_exit(0);\r\n                break;\r\n            case EOF:\r\n                /* standby disconnected unexpectedly */\r\n                ereport(\r\n                    COMMERROR, (errcode(ERRCODE_PROTOCOL_VIOLATION), errmsg(\"unexpected EOF on standby connection\")));\r\n                proc_exit(0);\r\n                break;\r\n            default:\r\n                ereport(FATAL,\r\n                    (errcode(ERRCODE_PROTOCOL_VIOLATION),\r\n                        errmsg(\"invalid standby handshake message type %d\", first_char)));\r\n        }\r\n    }\r\n}",
		"comment":"/*\r\n * Execute commands from datareceiver, until we enter streaming mode.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndHandshake"
	},
	"DataSndInProgress":{
		"body":"bool DataSndInProgress(int type)\r\n{\r\n    int i;\r\n\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile DataSnd* datasnd = &t_thrd.datasender_cxt.DataSndCtl->datasnds[i];\r\n\r\n        SpinLockAcquire(&datasnd->mutex);\r\n\r\n        if (datasnd->pid != 0 && ((datasnd->sendRole & type) == datasnd->sendRole)) {\r\n            SpinLockRelease(&datasnd->mutex);\r\n            return true;\r\n        }\r\n\r\n        SpinLockRelease(&datasnd->mutex);\r\n    }\r\n\r\n    return false;\r\n}",
		"comment":"/* check if there is any data sender alive. */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndInProgress"
	},
	"DataSndInSearching":{
		"body":"bool DataSndInSearching(void)\r\n{\r\n    return dummySearching;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndInSearching"
	},
	"DataSndKeepalive":{
		"body":"static void DataSndKeepalive(bool requestReply)\r\n{\r\n    volatile DataSnd* datasnd = t_thrd.datasender_cxt.MyDataSnd;\r\n    DataSndKeepaliveMessage keepalive_message;\r\n    errno_t errorno = EOK;\r\n\r\n    SpinLockAcquire(&datasnd->mutex);\r\n    keepalive_message.sendPosition.queueid = datasnd->sendPosition.queueid;\r\n    keepalive_message.sendPosition.queueoff = datasnd->sendPosition.queueoff;\r\n    SpinLockRelease(&datasnd->mutex);\r\n    keepalive_message.sendTime = GetCurrentTimestamp();\r\n    keepalive_message.replyRequested = requestReply;\r\n    keepalive_message.catchup = (t_thrd.datasender_cxt.MyDataSnd->state == DATASNDSTATE_CATCHUP);\r\n\r\n    ereport(DEBUG2, (errmsg(\"sending data replication keepalive\")));\r\n\r\n    /* Prepend with the message type and send it. */\r\n    t_thrd.datasender_cxt.output_message[0] = 'k';\r\n    errorno = memcpy_s(t_thrd.datasender_cxt.output_message + 1,\r\n        sizeof(DataPageMessageHeader) + g_instance.attr.attr_storage.MaxSendSize * 1024,\r\n        &keepalive_message,\r\n        sizeof(DataSndKeepaliveMessage));\r\n    securec_check(errorno, \"\", \"\");\r\n    (void)pq_putmessage_noblock('d', t_thrd.datasender_cxt.output_message, sizeof(DataSndKeepaliveMessage) + 1);\r\n\r\n    /* Flush the keepalive message to standby immediately. */\r\n    if (pq_flush_if_writable() != 0)\r\n        DataSndShutdown();\r\n}",
		"comment":"/*\r\n * This function is used to send keepalive message to standby.\r\n * If requestReply is set, sets a flag in the message requesting the standby\r\n * to send a message back to us, for heartbeat purposes.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndKeepalive"
	},
	"DataSndKeepaliveIfNecessary":{
		"body":"static void DataSndKeepaliveIfNecessary(TimestampTz now)\r\n{\r\n    TimestampTz ping_time;\r\n\r\n    /*\r\n     * Don't send keepalive messages if timeouts are globally disabled or\r\n     * we're doing something not partaking in timeouts.\r\n     */\r\n    if (u_sess->attr.attr_storage.wal_sender_timeout <= 0 || t_thrd.datasender_cxt.last_reply_timestamp <= 0)\r\n        return;\r\n\r\n    if (t_thrd.datasender_cxt.ping_sent)\r\n        return;\r\n\r\n    /*\r\n     * If half of wal_sender_timeout has lapsed without receiving any reply\r\n     * from the standby, send a keep-alive message to the standby requesting\r\n     * an immediate reply.\r\n     */\r\n    ping_time = TimestampTzPlusMilliseconds(\r\n        t_thrd.datasender_cxt.last_reply_timestamp, u_sess->attr.attr_storage.wal_sender_timeout / 2);\r\n    if (now >= ping_time) {\r\n        DataSndKeepalive(true);\r\n        t_thrd.datasender_cxt.ping_sent = true;\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndKeepaliveIfNecessary"
	},
	"DataSndKill":{
		"body":"static void DataSndKill(int code, Datum arg)\r\n{\r\n    DataSnd* datasnd = t_thrd.datasender_cxt.MyDataSnd;\r\n\r\n    Assert(t_thrd.datasender_cxt.MyDataSnd != NULL);\r\n\r\n    /* DataSnd struct isn't mine anymore */\r\n    t_thrd.datasender_cxt.MyDataSnd = NULL;\r\n\r\n    DisownLatch(&datasnd->latch);\r\n\r\n    if (code > 0) {\r\n        /* * Sleep at least 0.1 second to wait for reporting the error to the client */\r\n        pg_usleep(100000L);\r\n    }\r\n\r\n    /* Mark DataSnd struct no longer in use. */\r\n    SpinLockAcquire(&datasnd->mutex);\r\n    datasnd->pid = 0;\r\n    SpinLockRelease(&datasnd->mutex);\r\n    dummySearching = false;\r\n\r\n    ereport(LOG, (errmsg(\"datasender thread shut down\")));\r\n}",
		"comment":"/* Destroy the per-datasender data structure for this datasender process */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndKill"
	},
	"DataSndLastCycleHandler":{
		"body":"static void DataSndLastCycleHandler(SIGNAL_ARGS)\r\n{\r\n    int save_errno = errno;\r\n\r\n    t_thrd.datasender_cxt.datasender_ready_to_stop = true;\r\n    if (t_thrd.datasender_cxt.MyDataSnd)\r\n        SetLatch(&t_thrd.datasender_cxt.MyDataSnd->latch);\r\n\r\n    errno = save_errno;\r\n}",
		"comment":"/* SIGUSR2: set flag to do a last cycle and shut down afterwards */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndLastCycleHandler"
	},
	"DataSndLoop":{
		"body":"static int DataSndLoop(void)\r\n{\r\n    bool caughtup = false;\r\n    bool first_startup = true;\r\n    bool rm_dummy_data_log = true;\r\n    bool marked_stream_replication = true;\r\n    TimestampTz last_send_catchup_timestamp;\r\n\r\n    /*\r\n     * Allocate buffer that will be used for each output message.  We do this\r\n     * just once to reduce palloc overhead.  The buffer must be made large\r\n     * enough for maximum-sized messages.\r\n     */\r\n    t_thrd.datasender_cxt.output_message =\r\n        (char*)palloc(1 + sizeof(DataPageMessageHeader) + g_instance.attr.attr_storage.MaxSendSize * 1024);\r\n\r\n    /*\r\n     * Allocate buffer that will be used for processing reply messages.  As\r\n     * above, do this just once to reduce palloc overhead.\r\n     */\r\n    initStringInfo(t_thrd.datasender_cxt.reply_message);\r\n    last_send_catchup_timestamp = GetCurrentTimestamp();\r\n\r\n    /* Initialize the last reply timestamp */\r\n    t_thrd.datasender_cxt.last_reply_timestamp = GetCurrentTimestamp();\r\n    t_thrd.datasender_cxt.ping_sent = false;\r\n\r\n    /* Loop forever, unless we get an error */\r\n    for (;;) {\r\n        TimestampTz now;\r\n\r\n        /* Clear any already-pending wakeups */\r\n        ResetLatch(&t_thrd.datasender_cxt.MyDataSnd->latch);\r\n\r\n        pgstat_report_activity(STATE_RUNNING, NULL);\r\n\r\n        /*\r\n         * Emergency bailout if postmaster has died.  This is to avoid the\r\n         * necessity for manual cleanup of all postmaster children.\r\n         */\r\n        if (!PostmasterIsAlive())\r\n            gs_thread_exit(1);\r\n\r\n        /* Process any requests or signals received recently */\r\n        if (t_thrd.datasender_cxt.got_SIGHUP) {\r\n            t_thrd.datasender_cxt.got_SIGHUP = false;\r\n            marked_stream_replication = u_sess->attr.attr_storage.enable_stream_replication;\r\n            ProcessConfigFile(PGC_SIGHUP);\r\n        }\r\n\r\n        /* Normal exit from the datasender is here */\r\n        if (t_thrd.datasender_cxt.datasender_shutdown_requested) {\r\n            /* Inform the standby that DATA streaming is done */\r\n            pq_puttextmessage('C', \"COPY 0\");\r\n            (void)pq_flush();\r\n\r\n            ereport(LOG, (errmsg(\"data replication caughtup, ready to stop.\")));\r\n\r\n            proc_exit(0);\r\n        }\r\n\r\n        /* If changed to stream replication, request for catchup. */\r\n        if (u_sess->attr.attr_storage.enable_stream_replication && !marked_stream_replication) {\r\n            marked_stream_replication = u_sess->attr.attr_storage.enable_stream_replication;\r\n            DataSndSetState(DATASNDSTATE_CATCHUP);\r\n            if (!AmDataSenderToDummyStandby() && !dummyStandbyMode) {\r\n                pg_memory_barrier();\r\n\r\n                if (catchup_online)\r\n                    ereport(\r\n                        ERROR, (errcode(ERRCODE_INVALID_STATUS), errmsg(\"catchup thread is online, wait it shutdown\")));\r\n\r\n                SendPostmasterSignal(PMSIGNAL_START_CATCHUP);\r\n            }\r\n        }\r\n\r\n        /* Check for input from the client */\r\n        ProcessRepliesIfAny();\r\n\r\n        if (AmDataSenderToDummyStandby()) {\r\n            /*\r\n             * During the loop, if we got signal from sender which corresponding standby receiver,\r\n             * We notify Dummy_standby to scan incremental files which used for catchup immediately.\r\n             */\r\n            if (catchupState == CATCHUP_STARTING) {\r\n                dummySearching = true;\r\n                pg_memory_barrier();\r\n                catchupState = CATCHUP_SEARCHING;\r\n                ereport(LOG, (errmsg(\"Send message to dummy to start searching incremental bcm file list.\")));\r\n                DataSndNotifyCatchup();\r\n            }\r\n\r\n            /*\r\n             * If I am sender to Dummy standby and standby caught up primary,\r\n             * do not need to send data to xlog Dummy standby;\r\n             */\r\n            if (DataSndInProgress(SNDROLE_PRIMARY_STANDBY)) {\r\n                caughtup = true;\r\n\r\n                SpinLockAcquire(&t_thrd.datasender_cxt.MyDataSnd->mutex);\r\n                t_thrd.datasender_cxt.MyDataSnd->sending = false;\r\n                t_thrd.datasender_cxt.MyDataSnd->sendPosition.queueid = 0;\r\n                t_thrd.datasender_cxt.MyDataSnd->sendPosition.queueoff = 0;\r\n                SpinLockRelease(&t_thrd.datasender_cxt.MyDataSnd->mutex);\r\n\r\n                if (DataSndCaughtup()) {\r\n                    /* Send rm_data command to Dummy Standby, false means not need response. */\r\n                    DataSndRmData(false);\r\n\r\n                    /*\r\n                     * The primary send dummystandby rm data message at the first time, we will\r\n                     * print a log.\r\n                     */\r\n                    if (rm_dummy_data_log) {\r\n                        ereport(LOG, (errmsg(\"sending dummystandby rm data message.\")));\r\n                        rm_dummy_data_log = false;\r\n                    }\r\n                }\r\n            } else {\r\n                SpinLockAcquire(&t_thrd.datasender_cxt.MyDataSnd->mutex);\r\n                t_thrd.datasender_cxt.MyDataSnd->sending = true;\r\n                SpinLockRelease(&t_thrd.datasender_cxt.MyDataSnd->mutex);\r\n\r\n                if (!pq_is_send_pending()) {\r\n                    DataSend(&caughtup);\r\n                    send_dummy_count++;\r\n                    pg_memory_barrier();\r\n                    rm_dummy_data_log = true;\r\n                } else\r\n                    caughtup = false;\r\n            }\r\n        } else {\r\n            /*\r\n             * If we don't have any pending data in the output buffer, try to send\r\n             * some more.  If there is some, we don't bother to call XLogSend\r\n             * again until we've flushed it ... but we'd better assume we are not\r\n             * caught up.\r\n             */\r\n            if (!pq_is_send_pending())\r\n                DataSend(&caughtup);\r\n            else\r\n                caughtup = false;\r\n\r\n            if (caughtup && dummyStandbyMode) {\r\n                ereport(LOG,\r\n                    (errmsg(\"standby \\\"%s\\\" has now caught up with dummystandby\",\r\n                        u_sess->attr.attr_common.application_name)));\r\n\r\n                if (!pq_is_send_pending()) {\r\n                    DataSndSyncStandbyDone(false);\r\n                    (void)pq_flush();\r\n                    ereport(LOG, (errmsg(\"dummystandby data replication caughtup, ready to stop\")));\r\n                } else\r\n                    ereport(DEBUG5,\r\n                        (errmsg(\"standby \\\"%s\\\" has now caught up with dummystandby, but pend on sending\",\r\n                            u_sess->attr.attr_common.application_name)));\r\n            }\r\n\r\n            if (!dummyStandbyMode && !catchupDone && !catchup_online) {\r\n                TimestampTz current;\r\n                current = GetCurrentTimestamp();\r\n                if (TimestampDifferenceExceeds(last_send_catchup_timestamp, current, 1000)) {\r\n                    ereport(LOG, (errmsg(\"catchup thread create failed, try again\")));\r\n                    SendPostmasterSignal(PMSIGNAL_START_CATCHUP);\r\n                    last_send_catchup_timestamp = current;\r\n                }\r\n            }\r\n        }\r\n\r\n        /* Try to flush pending output to the client */\r\n        if (pq_flush_if_writable() != 0)\r\n            break;\r\n\r\n        /* If nothing remains to be sent right now ... */\r\n        if (caughtup && !pq_is_send_pending() && !catchup_online) {\r\n            /*\r\n             * If we're in catchup state, move to streaming.  This is an\r\n             * important state change for users to know about, since before\r\n             * this point data loss might occur if the primary dies and we\r\n             * need to failover to the standby. The state change is also\r\n             * important for synchronous replication, since commits that\r\n             * started to wait at that point might wait for some time.\r\n             */\r\n            if (t_thrd.datasender_cxt.MyDataSnd->state == DATASNDSTATE_CATCHUP) {\r\n                ereport(DEBUG1,\r\n                    (errmsg(\r\n                        \"standby \\\"%s\\\" has now caught up with primary\", u_sess->attr.attr_common.application_name)));\r\n\r\n                /* sender to standby on primary */\r\n                if (t_thrd.datasender_cxt.MyDataSnd->sendRole == SNDROLE_PRIMARY_STANDBY) {\r\n                    /*\r\n                     * When standby connect to primary, primary will create\r\n                     * catchup thread to sync data, after catchup thread exit,\r\n                     * and caughtup is true , datasnd will change its state.\r\n                     * But when caughtup is true, the catchup thread is creating,\r\n                     * we can't change it.\r\n                     */\r\n                    if (catchupDone)\r\n                        DataSndSetState(DATASNDSTATE_STREAMING);\r\n                } else\r\n                    DataSndSetState(DATASNDSTATE_STREAMING);\r\n                /* Refresh new state to peer */\r\n                DataSndKeepalive(true);\r\n            }\r\n\r\n            /*\r\n             * When SIGUSR2 arrives, we send any outstanding logs up to the\r\n             * shutdown checkpoint record (i.e., the latest record) and exit.\r\n             * This may be a normal termination at shutdown, or a promotion,\r\n             * the walsender is not sure which.\r\n             */\r\n            if (t_thrd.datasender_cxt.datasender_ready_to_stop) {\r\n                /*\r\n                 * Let's just be real sure we're caught up. For dummy sender,\r\n                 * during shutting down, if the sender to standby is in progress,\r\n                 * skip to send outstanding logs.\r\n                 */\r\n                if (AmDataSenderToDummyStandby() && DataSndInProgress(SNDROLE_PRIMARY_STANDBY))\r\n                    ; /* nothing to do */\r\n                else\r\n                    DataSend(&caughtup);\r\n                if (caughtup && !pq_is_send_pending()) {\r\n                    t_thrd.datasender_cxt.datasender_shutdown_requested = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        now = GetCurrentTimestamp();\r\n\r\n        /* Check for replication timeout. */\r\n        DataSndCheckTimeOut(now);\r\n\r\n        /* Send keepalive if the time has come. */\r\n        DataSndKeepaliveIfNecessary(now);\r\n\r\n        /*\r\n         * We don't block if not caught up, unless there is unsent data\r\n         * pending in which case we'd better block until the socket is\r\n         * write-ready.  This test is only needed for the case where XLogSend\r\n         * loaded a subset of the available data but then pq_flush_if_writable\r\n         * flushed it all --- we should immediately try to send more.\r\n         */\r\n        if (caughtup || pq_is_send_pending()) {\r\n            long sleeptime = 10000; /* 10 s */\r\n            int wakeEvents;\r\n\r\n            wakeEvents = WL_LATCH_SET | WL_POSTMASTER_DEATH | WL_SOCKET_READABLE | WL_TIMEOUT;\r\n\r\n            sleeptime = DataSndComputeSleeptime(now);\r\n\r\n            if (pq_is_send_pending())\r\n                wakeEvents |= WL_SOCKET_WRITEABLE;\r\n            else if (first_startup) {\r\n                /* Datasender first startup, send a keepalive to standby, no need reply. */\r\n                DataSndKeepalive(false);\r\n                first_startup = false;\r\n            }\r\n\r\n            /* Sleep until something happens or we time out */\r\n            pgstat_report_activity(STATE_IDLE, NULL);\r\n            t_thrd.int_cxt.ImmediateInterruptOK = true;\r\n            CHECK_FOR_INTERRUPTS();\r\n            WaitLatchOrSocket(\r\n                &t_thrd.datasender_cxt.MyDataSnd->latch, wakeEvents, u_sess->proc_cxt.MyProcPort->sock, sleeptime);\r\n            t_thrd.int_cxt.ImmediateInterruptOK = false;\r\n        }\r\n    }\r\n\r\n    DataSndShutdown();\r\n    return 1; /* keep the compiler quiet */\r\n}",
		"comment":"/* Main loop of datasender process */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndLoop"
	},
	"DataSndNotifyCatchup":{
		"body":"static void DataSndNotifyCatchup()\r\n{\r\n    NotifyDummyCatchupMessage dummyCatchupMessage;\r\n    errno_t errorno = EOK;\r\n\r\n    dummyCatchupMessage.sendTime = GetCurrentTimestamp();\r\n    ereport(LOG, (errmsg(\"primary catchup process notify dummy to start searching incremental files.\")));\r\n\r\n    /* Prepend with the message type and send it. */\r\n    t_thrd.datasender_cxt.output_message[0] = 'b';\r\n    errorno = memcpy_s(t_thrd.datasender_cxt.output_message + 1,\r\n        sizeof(DataPageMessageHeader) + g_instance.attr.attr_storage.MaxSendSize * 1024,\r\n        &dummyCatchupMessage,\r\n        sizeof(NotifyDummyCatchupMessage));\r\n    securec_check(errorno, \"\", \"\");\r\n    (void)pq_putmessage_noblock('d', t_thrd.datasender_cxt.output_message, sizeof(NotifyDummyCatchupMessage) + 1);\r\n}",
		"comment":"/*\r\n * This function is used to send notify message to dummystandby to search incremental files which used for catchup.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndNotifyCatchup"
	},
	"DataSndQuickDieHandler":{
		"body":"static void DataSndQuickDieHandler(SIGNAL_ARGS)\r\n{\r\n    gs_signal_setmask(&t_thrd.libpq_cxt.BlockSig, NULL);\r\n\r\n    /*\r\n     * We DO NOT want to run proc_exit() callbacks -- we're here because\r\n     * shared memory may be corrupted, so we don't want to try to clean up our\r\n     * transaction.  Just nail the windows shut and get out of town.  Now that\r\n     * there's an atexit callback to prevent third-party code from breaking\r\n     * things by calling exit() directly, we have to reset the callbacks\r\n     * explicitly to make this work as intended.\r\n     */\r\n    on_exit_reset();\r\n\r\n    /*\r\n     * Note we do exit(2) not exit(0).	This is to force the postmaster into a\r\n     * system reset cycle if some idiot DBA sends a manual SIGQUIT to a random\r\n     * backend.  This is necessary precisely because we don't clean up our\r\n     * shared memory state.  (The \"dead man switch\" mechanism in pmsignal.c\r\n     * should ensure the postmaster sees this as a crash, too, but no harm in\r\n     * being doubly sure.)\r\n     */\r\n    exit(2);\r\n}",
		"comment":"/*\r\n * DataSndQuickDieHandler() occurs when signalled SIGQUIT by the postmaster.\r\n *\r\n * Some backend has bought the farm,\r\n * so we need to stop what we're doing and exit.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndQuickDieHandler"
	},
	"DataSndRmData":{
		"body":"static void DataSndRmData(bool requestReply)\r\n{\r\n    RmDataMessage rmDataMessage;\r\n    volatile HaShmemData* hashmdata = t_thrd.postmaster_cxt.HaShmData;\r\n    errno_t errorno = EOK;\r\n\r\n    /* Construct a new message */\r\n    SpinLockAcquire(&hashmdata->mutex);\r\n    rmDataMessage.peer_role = hashmdata->current_mode;\r\n    SpinLockRelease(&hashmdata->mutex);\r\n    rmDataMessage.peer_state = get_local_dbstate();\r\n    rmDataMessage.sendTime = GetCurrentTimestamp();\r\n    rmDataMessage.replyRequested = requestReply;\r\n\r\n    /* Prepend with the message type and send it. */\r\n    t_thrd.datasender_cxt.output_message[0] = 'x';\r\n    errorno = memcpy_s(t_thrd.datasender_cxt.output_message + 1,\r\n        sizeof(DataPageMessageHeader) + g_instance.attr.attr_storage.MaxSendSize * 1024,\r\n        &rmDataMessage,\r\n        sizeof(RmDataMessage));\r\n    securec_check(errorno, \"\", \"\");\r\n    (void)pq_putmessage_noblock('d', t_thrd.datasender_cxt.output_message, sizeof(RmDataMessage) + 1);\r\n}",
		"comment":"/*\r\n * This function is used to send rm_data message to  dummystandby.\r\n * If requestReply is set, sets a flag in the message requesting the standby\r\n * to send a message back to us, for heartbeat purposes.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndRmData"
	},
	"DataSndSetState":{
		"body":"void DataSndSetState(DataSndState state)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile DataSnd* datasnd = t_thrd.datasender_cxt.MyDataSnd;\r\n\r\n    Assert(t_thrd.datasender_cxt.am_datasender);\r\n\r\n    if (datasnd->state == state)\r\n        return;\r\n\r\n    SpinLockAcquire(&datasnd->mutex);\r\n    datasnd->state = state;\r\n    if (state == DATASNDSTATE_CATCHUP)\r\n        datasnd->catchupTime[0] = GetCurrentTimestamp();\r\n    else if (state == DATASNDSTATE_STREAMING)\r\n        datasnd->catchupTime[1] = GetCurrentTimestamp();\r\n    SpinLockRelease(&datasnd->mutex);\r\n}",
		"comment":"/* Set state for current datasender (only called in datasender) */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndSetState"
	},
	"DataSndShmemInit":{
		"body":"void DataSndShmemInit(void)\r\n{\r\n    bool found = false;\r\n    int i;\r\n    errno_t rc = 0;\r\n\r\n    t_thrd.datasender_cxt.DataSndCtl = (DataSndCtlData*)ShmemInitStruct(\"Data Sender Ctl\", DataSndShmemSize(), &found);\r\n\r\n    if (!found) {\r\n        /* First time through, so initialize */\r\n        rc = memset_s(t_thrd.datasender_cxt.DataSndCtl, DataSndShmemSize(), 0, DataSndShmemSize());\r\n        securec_check(rc, \"\", \"\");\r\n        SHMQueueInit(&(t_thrd.datasender_cxt.DataSndCtl->SyncRepQueue));\r\n\r\n        for (i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n            DataSnd* datasnd = &t_thrd.datasender_cxt.DataSndCtl->datasnds[i];\r\n\r\n            rc = memset_s(datasnd, sizeof(DataSnd), 0, sizeof(DataSnd));\r\n            securec_check(rc, \"\", \"\");\r\n            datasnd->sendKeepalive = true;\r\n            SpinLockInit(&datasnd->mutex);\r\n            InitSharedLatch(&datasnd->latch);\r\n        }\r\n        SpinLockInit(&t_thrd.datasender_cxt.DataSndCtl->mutex);\r\n    }\r\n}",
		"comment":"/* Allocate and initialize datasender-related shared memory */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndShmemInit"
	},
	"DataSndShmemSize":{
		"body":"Size DataSndShmemSize(void)\r\n{\r\n    Size size = 0;\r\n\r\n    size = offsetof(DataSndCtlData, datasnds);\r\n    size = add_size(size, mul_size(g_instance.attr.attr_storage.max_wal_senders, sizeof(DataSnd)));\r\n\r\n    return size;\r\n}",
		"comment":"/* Report shared-memory space needed by DataSndShmemInit */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndShmemSize"
	},
	"DataSndShutdown":{
		"body":"static void DataSndShutdown(void)\r\n{\r\n    /*\r\n     * Reset whereToSendOutput to prevent ereport from attempting to send any\r\n     * more messages to the standby.\r\n     */\r\n    if (t_thrd.postgres_cxt.whereToSendOutput == DestRemote)\r\n        t_thrd.postgres_cxt.whereToSendOutput = DestNone;\r\n\r\n    proc_exit(0);\r\n    abort(); /* keep the compiler quiet */\r\n}",
		"comment":"/*\r\n * Handle a client's connection abort in an orderly manner.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndShutdown"
	},
	"DataSndShutdownHandler":{
		"body":"static void DataSndShutdownHandler(SIGNAL_ARGS)\r\n{\r\n    int save_errno = errno;\r\n\r\n    t_thrd.datasender_cxt.datasender_shutdown_requested = true;\r\n    if (t_thrd.datasender_cxt.MyDataSnd)\r\n        SetLatch(&t_thrd.datasender_cxt.MyDataSnd->latch);\r\n\r\n    /*\r\n     * Set the standard (non-datasender) state as well, so that we can abort\r\n     * things like do_pg_stop_backup().\r\n     */\r\n    InterruptPending = true;\r\n    t_thrd.int_cxt.ProcDiePending = true;\r\n\r\n    errno = save_errno;\r\n}",
		"comment":"/* SIGTERM: set flag to shut down */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndShutdownHandler"
	},
	"DataSndSigHupHandler":{
		"body":"static void DataSndSigHupHandler(SIGNAL_ARGS)\r\n{\r\n    int save_errno = errno;\r\n\r\n    t_thrd.datasender_cxt.got_SIGHUP = true;\r\n    if (t_thrd.datasender_cxt.MyDataSnd)\r\n        SetLatch(&t_thrd.datasender_cxt.MyDataSnd->latch);\r\n\r\n    errno = save_errno;\r\n}",
		"comment":"/* SIGHUP: set flag to re-read config file at next convenient time */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndSigHupHandler"
	},
	"DataSndSignals":{
		"body":"void DataSndSignals(void)\r\n{\r\n    /* Set up signal handlers */\r\n    (void)gspqsignal(SIGHUP, DataSndSigHupHandler);    /* set flag to read config\r\n                                                        * file */\r\n    (void)gspqsignal(SIGINT, SIG_IGN);                 /* not used */\r\n    (void)gspqsignal(SIGTERM, DataSndShutdownHandler); /* request shutdown */\r\n    (void)gspqsignal(SIGQUIT, DataSndQuickDieHandler); /* hard crash time */\r\n    (void)gspqsignal(SIGALRM, handle_sig_alarm);\r\n    (void)gspqsignal(SIGPIPE, SIG_IGN);\r\n    (void)gspqsignal(SIGUSR1, DataSndXLogSendHandler);  /* request DATA sending */\r\n    (void)gspqsignal(SIGUSR2, DataSndLastCycleHandler); /* request a last cycle and shutdown */\r\n\r\n    /* Reset some signals that are accepted by postmaster but not here */\r\n    (void)gspqsignal(SIGCHLD, SIG_DFL);\r\n    (void)gspqsignal(SIGTTIN, SIG_DFL);\r\n    (void)gspqsignal(SIGTTOU, SIG_DFL);\r\n    (void)gspqsignal(SIGCONT, SIG_DFL);\r\n    (void)gspqsignal(SIGWINCH, SIG_DFL);\r\n}",
		"comment":"/* Set up signal handlers */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndSignals"
	},
	"DataSndSyncStandbyDone":{
		"body":"static void DataSndSyncStandbyDone(bool requestReply)\r\n{\r\n    EndDataMessage endDataMessage;\r\n    volatile HaShmemData* hashmdata = t_thrd.postmaster_cxt.HaShmData;\r\n    errno_t errorno = EOK;\r\n\r\n    /* Construct a new message */\r\n    SpinLockAcquire(&hashmdata->mutex);\r\n    endDataMessage.peer_role = hashmdata->current_mode;\r\n    SpinLockRelease(&hashmdata->mutex);\r\n    endDataMessage.peer_state = get_local_dbstate();\r\n    endDataMessage.sendTime = GetCurrentTimestamp();\r\n    endDataMessage.percent = SYNC_DUMMY_STANDBY_END;\r\n\r\n    ereport(dummyStandbyMode ? LOG : DEBUG2, (errmsg(\"sending standby end data message\")));\r\n\r\n    /* Prepend with the message type and send it. */\r\n    t_thrd.datasender_cxt.output_message[0] = 'e';\r\n    errorno = memcpy_s(t_thrd.datasender_cxt.output_message + 1,\r\n        sizeof(DataPageMessageHeader) + g_instance.attr.attr_storage.MaxSendSize * 1024,\r\n        &endDataMessage,\r\n        sizeof(EndDataMessage));\r\n    securec_check(errorno, \"\", \"\");\r\n    (void)pq_putmessage_noblock('d', t_thrd.datasender_cxt.output_message, sizeof(EndDataMessage) + 1);\r\n}",
		"comment":"/*\r\n * This function is used to send end data message to  standby.\r\n * If requestReply is set, sets a flag in the message requesting the standby\r\n * to send a message back to us, for heartbeat purposes.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndSyncStandbyDone"
	},
	"DataSndWakeup":{
		"body":"void DataSndWakeup(void)\r\n{\r\n    int i;\r\n\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++)\r\n        SetLatch(&t_thrd.datasender_cxt.DataSndCtl->datasnds[i].latch);\r\n}",
		"comment":"/* Wake up all datasenders */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndWakeup"
	},
	"DataSndXLogSendHandler":{
		"body":"static void DataSndXLogSendHandler(SIGNAL_ARGS)\r\n{\r\n    int save_errno = errno;\r\n\r\n    latch_sigusr1_handler();\r\n\r\n    errno = save_errno;\r\n}",
		"comment":"/* SIGUSR1: set flag to send WAL records */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"DataSndXLogSendHandler"
	},
	"HandleDataReplicationCommand":{
		"body":"static bool HandleDataReplicationCommand(const char* cmd_string)\r\n{\r\n    bool replication_started = false;\r\n    int parse_rc;\r\n    Node* cmd_node = NULL;\r\n    MemoryContext cmd_context;\r\n    MemoryContext old_context;\r\n    replication_scanner_yyscan_t yyscanner = NULL;\r\n\r\n    ereport(LOG, (errmsg(\"received data replication command: %s\", cmd_string)));\r\n\r\n    cmd_context = AllocSetContextCreate(CurrentMemoryContext,\r\n        \"Replication command context\",\r\n        ALLOCSET_DEFAULT_MINSIZE,\r\n        ALLOCSET_DEFAULT_INITSIZE,\r\n        ALLOCSET_DEFAULT_MAXSIZE);\r\n\r\n    yyscanner = replication_scanner_init(cmd_string);\r\n    parse_rc = replication_yyparse(yyscanner);\r\n    replication_scanner_finish(yyscanner);\r\n\r\n    if (parse_rc != 0) {\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_SYNTAX_ERROR), (errmsg_internal(\"replication command parser returned %d\", parse_rc))));\r\n    }\r\n\r\n    old_context = MemoryContextSwitchTo(cmd_context);\r\n\r\n    cmd_node = t_thrd.replgram_cxt.replication_parse_result;\r\n\r\n    switch (cmd_node->type) {\r\n        case T_IdentifySystemCmd:\r\n            IdentifySystem();\r\n            break;\r\n\r\n        case T_IdentifyModeCmd:\r\n            IdentifyMode();\r\n            break;\r\n\r\n        case T_StartDataReplicationCmd:\r\n            StartDataReplication((StartDataReplicationCmd*)cmd_node);\r\n            /* break out of the loop */\r\n            replication_started = true;\r\n            break;\r\n\r\n        default:\r\n            ereport(\r\n                FATAL, (errcode(ERRCODE_PROTOCOL_VIOLATION), errmsg(\"invalid standby query string: %s\", cmd_string)));\r\n    }\r\n\r\n    /* done */\r\n    MemoryContextSwitchTo(old_context);\r\n    MemoryContextDelete(cmd_context);\r\n\r\n    return replication_started;\r\n}",
		"comment":"/*\r\n * Execute an incoming replication command.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"HandleDataReplicationCommand"
	},
	"IdentifySystem":{
		"body":"static void IdentifySystem(void)\r\n{\r\n    StringInfoData buf;\r\n    char sysid[32];\r\n    char tli[11];\r\n    int rc = EOK;\r\n\r\n    /*\r\n     * Reply with a result set with one row, three columns. First col is\r\n     * system ID, second is timeline ID.\r\n     */\r\n    rc = snprintf_s(sysid, sizeof(sysid), sizeof(sysid) - 1, UINT64_FORMAT, GetSystemIdentifier());\r\n    securec_check_ss(rc, \"\", \"\");\r\n    rc = snprintf_s(tli, sizeof(tli), sizeof(tli) - 1, \"%u\", t_thrd.xlog_cxt.ThisTimeLineID);\r\n    securec_check_ss(rc, \"\", \"\");\r\n\r\n    /* Send a RowDescription message */\r\n    pq_beginmessage(&buf, 'T');\r\n    pq_sendint16(&buf, 2); /* 2 fields */\r\n\r\n    /* first field */\r\n    pq_sendstring(&buf, \"systemid\"); /* col name */\r\n    pq_sendint32(&buf, 0);           /* table oid */\r\n    pq_sendint16(&buf, 0);           /* attnum */\r\n    pq_sendint32(&buf, TEXTOID);     /* type oid */\r\n    pq_sendint16(&buf, UINT16_MAX);  /* typlen */\r\n    pq_sendint32(&buf, 0);           /* typmod */\r\n    pq_sendint16(&buf, 0);           /* format code */\r\n\r\n    /* second field */\r\n    pq_sendstring(&buf, \"timeline\"); /* col name */\r\n    pq_sendint32(&buf, 0);           /* table oid */\r\n    pq_sendint16(&buf, 0);           /* attnum */\r\n    pq_sendint32(&buf, INT4OID);     /* type oid */\r\n    pq_sendint16(&buf, 4);           /* typlen */\r\n    pq_sendint32(&buf, 0);           /* typmod */\r\n    pq_sendint16(&buf, 0);           /* format code */\r\n    pq_endmessage_noblock(&buf);\r\n\r\n    /* Send a DataRow message */\r\n    pq_beginmessage(&buf, 'D');\r\n    pq_sendint16(&buf, 2);             /* # of columns */\r\n    pq_sendint32(&buf, strlen(sysid)); /* col1 len */\r\n    pq_sendbytes(&buf, (char*)sysid, strlen(sysid));\r\n    pq_sendint32(&buf, strlen(tli)); /* col2 len */\r\n    pq_sendbytes(&buf, (char*)tli, strlen(tli));\r\n    pq_endmessage_noblock(&buf);\r\n\r\n    /* Send CommandComplete and ReadyForQuery messages */\r\n    EndCommand_noblock(\"SELECT\", DestRemote);\r\n    ReadyForQuery_noblock(DestRemote, u_sess->attr.attr_storage.wal_sender_timeout);\r\n    /* ReadyForQuery did pq_flush_if_available for us */\r\n}",
		"comment":"/*\r\n * IDENTIFY_SYSTEM\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"IdentifySystem"
	},
	"InitDataSnd":{
		"body":"static void InitDataSnd(void)\r\n{\r\n    int i;\r\n\r\n    /*\r\n     * WalSndCtl should be set up already (we inherit this by fork() or\r\n     * EXEC_BACKEND mechanism from the postmaster).\r\n     */\r\n    AssertEreport(t_thrd.datasender_cxt.DataSndCtl != nullptr, MOD_FUNCTION, \"DataSndCtl should not be null\");\r\n    AssertEreport(t_thrd.datasender_cxt.MyDataSnd == nullptr, MOD_FUNCTION, \"MyDataSnd should be null\");\r\n\r\n    /*\r\n     * Find a free walsender slot and reserve it. If this fails, we must be\r\n     * out of WalSnd structures.\r\n     */\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile DataSnd* datasnd = &t_thrd.datasender_cxt.DataSndCtl->datasnds[i];\r\n\r\n        SpinLockAcquire(&datasnd->mutex);\r\n\r\n        if (datasnd->pid != 0) {\r\n            SpinLockRelease(&datasnd->mutex);\r\n            continue;\r\n        } else {\r\n            /*\r\n             * Found a free slot. Reserve it for us.\r\n             */\r\n            datasnd->pid = t_thrd.proc_cxt.MyProcPid;\r\n            datasnd->state = DATASNDSTATE_STARTUP;\r\n            datasnd->sendKeepalive = true;\r\n            datasnd->sending = true;\r\n\r\n            if (dummyStandbyMode) {\r\n                datasnd->sendRole = SNDROLE_DUMMYSTANDBY_STANDBY;\r\n            } else if (t_thrd.postmaster_cxt.senderToDummyStandby) {\r\n                datasnd->sendRole = SNDROLE_PRIMARY_DUMMYSTANDBY;\r\n            } else if (t_thrd.postmaster_cxt.senderToBuildStandby) {\r\n                datasnd->sendRole = SNDROLE_PRIMARY_BUILDSTANDBY;\r\n            } else {\r\n                datasnd->sendRole = SNDROLE_PRIMARY_STANDBY;\r\n            }\r\n\r\n            datasnd->sendPosition.queueid = 0;\r\n            datasnd->sendPosition.queueoff = 0;\r\n            datasnd->receivePosition.queueid = 0;\r\n            datasnd->receivePosition.queueoff = 0;\r\n\r\n            SpinLockRelease(&datasnd->mutex);\r\n            /* don't need the lock anymore */\r\n            OwnLatch((Latch*)&datasnd->latch);\r\n            t_thrd.datasender_cxt.MyDataSnd = (DataSnd*)datasnd;\r\n            break;\r\n        }\r\n    }\r\n    if (t_thrd.datasender_cxt.MyDataSnd == NULL)\r\n        ereport(FATAL,\r\n            (errcode(ERRCODE_TOO_MANY_CONNECTIONS),\r\n                errmsg(\"number of requested standby connections \"\r\n                       \"exceeds max_wal_senders (currently %d)\",\r\n                    g_instance.attr.attr_storage.max_wal_senders)));\r\n\r\n    /* Arrange to clean up at walsender exit */\r\n    on_shmem_exit(DataSndKill, 0);\r\n}",
		"comment":"/* Initialize a per-walsender data structure for this walsender process */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"InitDataSnd"
	},
	"InitGlobalBcm":{
		"body":"void InitGlobalBcm(void)\r\n{\r\n    g_incrementalBcmInfo.receivedFileList = NULL;\r\n    g_incrementalBcmInfo.msgLength = 0;\r\n    SpinLockInit(&g_incrementalBcmInfo.mutex);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"InitGlobalBcm"
	},
	"ProcessRepliesIfAny":{
		"body":"static void ProcessRepliesIfAny(void)\r\n{\r\n    unsigned char firstchar;\r\n    int r;\r\n    bool received = false;\r\n\r\n    for (;;) {\r\n        r = pq_getbyte_if_available(&firstchar);\r\n        if (r < 0) {\r\n            /* unexpected error or EOF */\r\n            ereport(COMMERROR, (errcode(ERRCODE_PROTOCOL_VIOLATION), errmsg(\"unexpected EOF on standby connection\")));\r\n            proc_exit(0);\r\n        }\r\n        if (r == 0) {\r\n            /* no data available without blocking */\r\n            break;\r\n        }\r\n\r\n        /* Handle the very limited subset of commands expected in this phase */\r\n        switch (firstchar) {\r\n                /*\r\n                 * 'd' means a standby reply wrapped in a CopyData packet.\r\n                 */\r\n            case 'd':\r\n                ProcessStandbyMessage();\r\n                received = true;\r\n                break;\r\n\r\n                /*\r\n                 * 'X' means that the standby is closing down the socket.\r\n                 */\r\n            case 'X':\r\n                proc_exit(0);\r\n                /* fall-through */\r\n            default:\r\n                ereport(FATAL,\r\n                    (errcode(ERRCODE_PROTOCOL_VIOLATION), errmsg(\"invalid standby message type \\\"%c\\\"\", firstchar)));\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Save the last reply timestamp if we've received at least one reply.\r\n     */\r\n    if (received) {\r\n        t_thrd.datasender_cxt.last_reply_timestamp = GetCurrentTimestamp();\r\n        t_thrd.datasender_cxt.ping_sent = false;\r\n    }\r\n}",
		"comment":"/*\r\n * Check if the remote end has closed the connection.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"ProcessRepliesIfAny"
	},
	"ProcessStandbyMessage":{
		"body":"static void ProcessStandbyMessage(void)\r\n{\r\n    char msgtype;\r\n\r\n    resetStringInfo(t_thrd.datasender_cxt.reply_message);\r\n\r\n    /*\r\n     * Read the message contents.\r\n     */\r\n    if (pq_getmessage(t_thrd.datasender_cxt.reply_message, 0)) {\r\n        ereport(COMMERROR, (errcode(ERRCODE_PROTOCOL_VIOLATION), errmsg(\"unexpected EOF on standby connection\")));\r\n        proc_exit(0);\r\n    }\r\n\r\n    /*\r\n     * Check message type from the first byte.\r\n     */\r\n    msgtype = pq_getmsgbyte(t_thrd.datasender_cxt.reply_message);\r\n\r\n    switch (msgtype) {\r\n        case 'r':\r\n            ProcessStandbyReplyMessage();\r\n            break;\r\n        case 'x':\r\n            ereport(LOG, (errmsg(\"receive file list message from dummy_standby\")));\r\n            ProcessStandbySearchMessage();\r\n            break;\r\n        default:\r\n            ereport(\r\n                COMMERROR, (errcode(ERRCODE_PROTOCOL_VIOLATION), errmsg(\"unexpected message type \\\"%c\\\"\", msgtype)));\r\n            proc_exit(0);\r\n    }\r\n}",
		"comment":"/*\r\n * Process a status update message received from standby.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"ProcessStandbyMessage"
	},
	"ProcessStandbyReplyMessage":{
		"body":"static void ProcessStandbyReplyMessage(void)\r\n{\r\n    volatile DataSnd* datasnd = t_thrd.datasender_cxt.MyDataSnd;\r\n    StandbyDataReplyMessage reply;\r\n    bool log_receivePosition = false;\r\n\r\n    pq_copymsgbytes(t_thrd.datasender_cxt.reply_message, (char*)&reply, sizeof(StandbyDataReplyMessage));\r\n\r\n    ereport(DEBUG2,\r\n        (errmsg(\"receive queue position %u/%u\", reply.receivePosition.queueid, reply.receivePosition.queueoff)));\r\n\r\n    /* send a reply if the standby requested one */\r\n    if (reply.replyRequested)\r\n        DataSndKeepalive(false);\r\n\r\n    if (DataQueuePtrIsInvalid(reply.receivePosition))\r\n        return;\r\n\r\n    /*\r\n     * For secondery sender, the receiver position maybe more than\r\n     * sendposition. Explame for the scene:\r\n     * The secondery sender send 100, and receiver receive 100, the head2\r\n     * is 50, standby reconnect to primary, the secondery sender set\r\n     * sendPosition to 0, standby disconnect to primary, the secondery sender\r\n     * send from 50, maybe it will receive receivePosition 100.\r\n     */\r\n    SpinLockAcquire(&datasnd->mutex);\r\n    if (DQByteLE(reply.receivePosition, datasnd->sendPosition)) {\r\n        datasnd->receivePosition.queueid = reply.receivePosition.queueid;\r\n        datasnd->receivePosition.queueoff = reply.receivePosition.queueoff;\r\n    } else {\r\n        log_receivePosition = true;\r\n    }\r\n    SpinLockRelease(&datasnd->mutex);\r\n\r\n    if (log_receivePosition)\r\n        ereport(LOG,\r\n            (errmsg(\"receive position more than send position: receivePosition[%u/%u],\"\r\n                    \"sendPosition[%u/%u], use_head2[%u/%u]\",\r\n                reply.receivePosition.queueid,\r\n                reply.receivePosition.queueoff,\r\n                datasnd->sendPosition.queueid,\r\n                datasnd->sendPosition.queueoff,\r\n                t_thrd.dataqueue_cxt.DataSenderQueue->use_head2.queueid,\r\n                t_thrd.dataqueue_cxt.DataSenderQueue->use_head2.queueoff)));\r\n\r\n    if (datasnd->sending)\r\n        DataSyncRepReleaseWaiters();\r\n}",
		"comment":"/*\r\n * Regular reply from standby advising of received data info on standby server.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"ProcessStandbyReplyMessage"
	},
	"ProcessStandbySearchMessage":{
		"body":"static void ProcessStandbySearchMessage(void)\r\n{\r\n    char* fileList = NULL;\r\n    int msgLength = 0;\r\n\r\n    if (catchupState != CATCHUP_SEARCHING) {\r\n        dummySearching = false;\r\n        return;\r\n    }\r\n    /* No data need to be sent, only 'x' symbol */\r\n    if (t_thrd.datasender_cxt.reply_message->len == 1) {\r\n        catchupState = RECEIVED_NONE;\r\n        pg_memory_barrier();\r\n        dummySearching = false;\r\n        return;\r\n    }\r\n\r\n    msgLength = t_thrd.datasender_cxt.reply_message->len - 1;\r\n    fileList = (char*)MemoryContextAllocZero(g_instance.instance_context, msgLength);\r\n    pq_copymsgbytes(t_thrd.datasender_cxt.reply_message, fileList, t_thrd.datasender_cxt.reply_message->len - 1);\r\n    ReplaceOrFreeBcmFileListBuffer(fileList, msgLength);\r\n    catchupState = RECEIVED_OK;\r\n    pg_memory_barrier();\r\n    dummySearching = false;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"ProcessStandbySearchMessage"
	},
	"ReplaceOrFreeBcmFileListBuffer":{
		"body":"void ReplaceOrFreeBcmFileListBuffer(char* fileList, int msgLength)\r\n{\r\n    char* oldFileList = NULL;\r\n    SpinLockAcquire(&g_incrementalBcmInfo.mutex);\r\n    oldFileList = g_incrementalBcmInfo.receivedFileList;\r\n    g_incrementalBcmInfo.msgLength = (fileList != NULL) ? msgLength : 0;\r\n    g_incrementalBcmInfo.receivedFileList = fileList;\r\n    SpinLockRelease(&g_incrementalBcmInfo.mutex);\r\n    pfree_ext(oldFileList);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"ReplaceOrFreeBcmFileListBuffer"
	},
	"StartDataReplication":{
		"body":"static void StartDataReplication(StartDataReplicationCmd* cmd)\r\n{\r\n    StringInfoData buf;\r\n\r\n    /*\r\n     * When we first start replication the standby will be behind the primary.\r\n     * For some applications, for example, synchronous replication, it is\r\n     * important to have a clear state for this initial catchup mode, so we\r\n     * can trigger actions when we change streaming state later. We may stay\r\n     * in this state for a long time, which is exactly why we want to be able\r\n     * to monitor whether or not we are still here.\r\n     */\r\n    DataSndSetState(DATASNDSTATE_CATCHUP);\r\n\r\n    /* Tell postmaster to start the catchup process. */\r\n    if (!AmDataSenderToDummyStandby() && !dummyStandbyMode) {\r\n        /* update the newest status before read catchup_online */\r\n        pg_memory_barrier();\r\n        if (catchup_online)\r\n            ereport(ERROR, (errcode(ERRCODE_INVALID_STATUS), errmsg(\"catchup thread is online, wait it shutdown\")));\r\n\r\n        SendPostmasterSignal(PMSIGNAL_START_CATCHUP);\r\n    }\r\n\r\n    /* Send a CopyBothResponse message, and start streaming */\r\n    pq_beginmessage(&buf, 'W');\r\n    pq_sendbyte(&buf, 0);\r\n    pq_sendint16(&buf, 0);\r\n    pq_endmessage_noblock(&buf);\r\n    pq_flush_timedwait(u_sess->attr.attr_storage.wal_sender_timeout);\r\n}",
		"comment":"/*\r\n * START_REPLICATION(DATA)\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"StartDataReplication"
	},
	"pg_stat_get_data_senders":{
		"body":"Datum pg_stat_get_data_senders(PG_FUNCTION_ARGS)\r\n{\r\n#define PG_STAT_GET_DATA_SENDER_COLS 13\r\n    TupleDesc tupdesc;\r\n    Tuplestorestate* tupstore = NULL;\r\n\r\n    volatile HaShmemData* hashmdata = t_thrd.postmaster_cxt.HaShmData;\r\n    ServerMode local_role = UNKNOWN_MODE;\r\n    int i = 0;\r\n    errno_t rc = EOK;\r\n    int ret = 0;\r\n\r\n    tupstore = BuildTupleResult(fcinfo, &tupdesc);\r\n\r\n    SpinLockAcquire(&hashmdata->mutex);\r\n    local_role = hashmdata->current_mode;\r\n    SpinLockRelease(&hashmdata->mutex);\r\n\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile DataSnd* datasnd = &t_thrd.datasender_cxt.DataSndCtl->datasnds[i];\r\n        Datum values[PG_STAT_GET_DATA_SENDER_COLS];\r\n        bool nulls[PG_STAT_GET_DATA_SENDER_COLS];\r\n        char location[64] = {0};\r\n        int j = 0;\r\n\r\n        ThreadId pid;\r\n        int lwpid;\r\n        SndRole snd_role;\r\n        DataSndState state;\r\n        TimestampTz catchup_time[2];\r\n\r\n        uint32 queue_size;\r\n        DataQueuePtr queue_header;\r\n        DataQueuePtr queue_lower_tail;\r\n        DataQueuePtr queue_upper_tail;\r\n        DataQueuePtr send_position;\r\n        DataQueuePtr receive_position;\r\n\r\n        SpinLockAcquire(&datasnd->mutex);\r\n        if (datasnd->pid == 0) {\r\n            SpinLockRelease(&datasnd->mutex);\r\n            continue;\r\n        } else {\r\n            pid = datasnd->pid;\r\n            lwpid = datasnd->lwpId;\r\n            snd_role = datasnd->sendRole;\r\n            state = datasnd->state;\r\n            catchup_time[0] = datasnd->catchupTime[0]; /* catchup start */\r\n            catchup_time[1] = datasnd->catchupTime[1]; /* catchup end */\r\n            send_position.queueid = datasnd->sendPosition.queueid;\r\n            send_position.queueoff = datasnd->sendPosition.queueoff;\r\n            receive_position.queueid = datasnd->receivePosition.queueid;\r\n            receive_position.queueoff = datasnd->receivePosition.queueoff;\r\n            SpinLockRelease(&datasnd->mutex);\r\n        }\r\n\r\n        SpinLockAcquire(&t_thrd.dataqueue_cxt.DataSenderQueue->use_mutex);\r\n        queue_size = t_thrd.dataqueue_cxt.DataSenderQueue->size;\r\n        queue_header = t_thrd.dataqueue_cxt.DataSenderQueue->use_head2;\r\n        queue_lower_tail = t_thrd.dataqueue_cxt.DataSenderQueue->use_tail1;\r\n        queue_upper_tail = t_thrd.dataqueue_cxt.DataSenderQueue->use_tail2;\r\n        SpinLockRelease(&t_thrd.dataqueue_cxt.DataSenderQueue->use_mutex);\r\n\r\n        rc = memset_s(nulls, sizeof(nulls), 0, sizeof(nulls));\r\n        securec_check(rc, \"\", \"\");\r\n        /* pid */\r\n        values[j++] = Int64GetDatum(pid);\r\n        /* lwpid */\r\n        values[j++] = Int32GetDatum(lwpid);\r\n\r\n        if (!superuser()) {\r\n            /*\r\n             * Only superusers can see details. Other users only get the pid\r\n             * value to know it's a walsender, but no details.\r\n             */\r\n            rc = memset_s(&nulls[j], PG_STAT_GET_DATA_SENDER_COLS - j, true, PG_STAT_GET_DATA_SENDER_COLS - j);\r\n            securec_check(rc, \"\", \"\");\r\n        } else {\r\n            /* local_role */\r\n            values[j++] = CStringGetTextDatum(wal_get_role_string(local_role));\r\n\r\n            /* peer_role */\r\n            if (snd_role == SNDROLE_PRIMARY_DUMMYSTANDBY)\r\n                values[j++] = CStringGetTextDatum(\"Secondary\");\r\n            else\r\n                values[j++] = CStringGetTextDatum(\"Standby\");\r\n\r\n            /* state */\r\n            values[j++] = CStringGetTextDatum(DataSndGetStateString(state));\r\n\r\n            /* catchup time */\r\n            if (catchup_time[0] != 0)\r\n                values[j++] = TimestampTzGetDatum(catchup_time[0]);\r\n            else\r\n                nulls[j++] = true;\r\n            if (catchup_time[1] != 0 && (state != DATASNDSTATE_CATCHUP))\r\n                values[j++] = TimestampTzGetDatum(catchup_time[1]);\r\n            else\r\n                nulls[j++] = true;\r\n\r\n            /* queue */\r\n            values[j++] = UInt32GetDatum(queue_size);\r\n            ret = snprintf_s(location,\r\n                sizeof(location),\r\n                sizeof(location) - 1,\r\n                \"%X/%X\",\r\n                queue_lower_tail.queueid,\r\n                queue_lower_tail.queueoff);\r\n            securec_check_ss(ret, \"\", \"\");\r\n            values[j++] = CStringGetTextDatum(location);\r\n            ret = snprintf_s(\r\n                location, sizeof(location), sizeof(location) - 1, \"%X/%X\", queue_header.queueid, queue_header.queueoff);\r\n            securec_check_ss(ret, \"\", \"\");\r\n            values[j++] = CStringGetTextDatum(location);\r\n            ret = snprintf_s(location,\r\n                sizeof(location),\r\n                sizeof(location) - 1,\r\n                \"%X/%X\",\r\n                queue_upper_tail.queueid,\r\n                queue_upper_tail.queueoff);\r\n            securec_check_ss(ret, \"\", \"\");\r\n            values[j++] = CStringGetTextDatum(location);\r\n            /* send */\r\n            ret = snprintf_s(location,\r\n                sizeof(location),\r\n                sizeof(location) - 1,\r\n                \"%X/%X\",\r\n                send_position.queueid,\r\n                send_position.queueoff);\r\n            securec_check_ss(ret, \"\", \"\");\r\n            values[j++] = CStringGetTextDatum(location);\r\n            /* receive */\r\n            ret = snprintf_s(location,\r\n                sizeof(location),\r\n                sizeof(location) - 1,\r\n                \"%X/%X\",\r\n                receive_position.queueid,\r\n                receive_position.queueoff);\r\n            securec_check_ss(ret, \"\", \"\");\r\n            values[j++] = CStringGetTextDatum(location);\r\n        }\r\n        tuplestore_putvalues(tupstore, tupdesc, values, nulls);\r\n    }\r\n    tuplestore_donestoring(tupstore);\r\n\r\n    return (Datum)0;\r\n}",
		"comment":"/*\r\n * Returns activity of datasenders, including pids and queue position sent to\r\n * standby servers.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datasender.cpp",
		"name":"pg_stat_get_data_senders"
	}
}