{
	"BuildTupleResult":{
		"body":"Tuplestorestate* BuildTupleResult(FunctionCallInfo fcinfo, TupleDesc* tupdesc)\r\n{\r\n    ReturnSetInfo* rsinfo = (ReturnSetInfo*)fcinfo->resultinfo;\r\n    Tuplestorestate* tupstore = NULL;\r\n\r\n    MemoryContext per_query_ctx;\r\n    MemoryContext oldcontext;\r\n\r\n    /* check to see if caller supports returning a tuplestore */\r\n    if (rsinfo == NULL || !IsA(rsinfo, ReturnSetInfo)) {\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\r\n                errmsg(\"set-valued function called in context that cannot accept a set\")));\r\n    }\r\n\r\n    if (!(rsinfo->allowedModes & SFRM_Materialize))\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\r\n                errmsg(\"materialize mode required, but it is not \"\r\n                       \"allowed in this context\")));\r\n\r\n    /* Build a tuple descriptor for our result type */\r\n    if (get_call_result_type(fcinfo, NULL, tupdesc) != TYPEFUNC_COMPOSITE)\r\n        ereport(ERROR, (errcode(ERRCODE_DATATYPE_MISMATCH), errmsg(\"return type must be a row type\")));\r\n\r\n    per_query_ctx = rsinfo->econtext->ecxt_per_query_memory;\r\n    oldcontext = MemoryContextSwitchTo(per_query_ctx);\r\n\r\n    tupstore = tuplestore_begin_heap(true, false, u_sess->attr.attr_memory.work_mem);\r\n    rsinfo->returnMode = SFRM_Materialize;\r\n    rsinfo->setResult = tupstore;\r\n    rsinfo->setDesc = *tupdesc;\r\n\r\n    (void)MemoryContextSwitchTo(oldcontext);\r\n\r\n    return tupstore;\r\n}",
		"comment":"/*\r\n * Build tuple desc and store for the caller result\r\n * return the tuple store, the tupdesc would be return by pointer.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"BuildTupleResult"
	},
	"CalculateTimeout":{
		"body":"static inline TimestampTz CalculateTimeout(TimestampTz last_reply_time)\r\n{\r\n    const int MULTIPLE_TIME = 4;\r\n    volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n\r\n    if (walsnd->sendRole == SNDROLE_PRIMARY_BUILDSTANDBY) {\r\n        return TimestampTzPlusMilliseconds(\r\n            last_reply_time, MULTIPLE_TIME * u_sess->attr.attr_storage.wal_sender_timeout);\r\n    } else {\r\n        return TimestampTzPlusMilliseconds(last_reply_time, u_sess->attr.attr_storage.wal_sender_timeout);\r\n    }\r\n}",
		"comment":"/* return timeout time */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"CalculateTimeout"
	},
	"CheckPMstateAndRecoveryInProgress":{
		"body":"void CheckPMstateAndRecoveryInProgress(void)\r\n{\r\n    if (!PMstateIsRun() || RecoveryInProgress()) {\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_LOGICAL_DECODE_ERROR),\r\n                errmsg(\"can't decode in pmState is not run or recovery in progress.\")));\r\n    }\r\n}",
		"comment":"/* check PMstate and RecoveryInProgress */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"CheckPMstateAndRecoveryInProgress"
	},
	"ChooseStartPointForDummyStandby":{
		"body":"static void ChooseStartPointForDummyStandby(void)\r\n{\r\n    XLogRecPtr initSentPtr;\r\n\r\n    if (!XLByteEQ(t_thrd.walsender_cxt.sentPtr, InvalidXLogRecPtr)) {\r\n        ereport(DEBUG1,\r\n            (errmsg(\"use current sentPtr %X/%X as sync secondary startpoint\",\r\n                (uint32)(t_thrd.walsender_cxt.sentPtr >> 32),\r\n                (uint32)t_thrd.walsender_cxt.sentPtr)));\r\n        return;\r\n    }\r\n\r\n    t_thrd.xlog_cxt.server_mode = PRIMARY_MODE;\r\n    ReplicationSlotsComputeRequiredLSN(NULL);\r\n    initSentPtr = XLogGetReplicationSlotMaximumLSN();\r\n\r\n    ReplicationSlotReportRestartLSN();\r\n    ereport(LOG,\r\n        (errmsg(\"init sentPtr at %X/%X, latestValidRecord is %X/%X\",\r\n            (uint32)(initSentPtr >> 32),\r\n            (uint32)initSentPtr,\r\n            (uint32)(latestValidRecord >> 32),\r\n            (uint32)latestValidRecord)));\r\n\r\n    if (XLByteEQ(initSentPtr, InvalidXLogRecPtr))\r\n        initSentPtr = latestValidRecord;\r\n\r\n    /*\r\n     * Ref RequestXLogStreaming()\r\n     * We always start at the beginning of the segment. That prevents a broken\r\n     * segment (i.e., with no records in the first half of a segment) from\r\n     * being created by XLOG streaming, which might cause trouble later on if\r\n     * the segment is e.g archived.\r\n     * Prev the requested segment if request xlog from the beginning of a segment.\r\n     */\r\n    if (initSentPtr % XLogSegSize != 0) {\r\n        initSentPtr -= initSentPtr % XLogSegSize;\r\n    } else {\r\n        XLogSegNo _logSeg;\r\n        XLByteToSeg(initSentPtr, _logSeg);\r\n        _logSeg--;\r\n        initSentPtr = _logSeg * XLogSegSize;\r\n    }\r\n\r\n    t_thrd.walsender_cxt.sentPtr = MAX_XLOG_RECORD(t_thrd.walsender_cxt.sentPtr, initSentPtr);\r\n\r\n    ereport(DEBUG2,\r\n        (errmsg(\r\n            \"In ChooseStartPointForDummyStandby(): initSentPtr is %X/%X, latestValidRecord is %X/%X, sentPtr is %X/%X.\",\r\n            (uint32)(initSentPtr >> 32),\r\n            (uint32)initSentPtr,\r\n            (uint32)(latestValidRecord >> 32),\r\n            (uint32)latestValidRecord,\r\n            (uint32)(t_thrd.walsender_cxt.sentPtr >> 32),\r\n            (uint32)t_thrd.walsender_cxt.sentPtr)));\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"ChooseStartPointForDummyStandby"
	},
	"CreateReplicationSlot":{
		"body":"static void CreateReplicationSlot(const CreateReplicationSlotCmd* cmd)\r\n{\r\n    const char* slot_name = NULL;\r\n    StringInfoData buf;\r\n    bool isDummyStandby = false;\r\n    const char* snapshot_name = NULL;\r\n    char xpos[MAXFNAMELEN];\r\n    int rc = 0;\r\n\r\n    Assert(!t_thrd.slot_cxt.MyReplicationSlot);\r\n\r\n    /* setup state for XLogReadPage */\r\n    isDummyStandby = AmWalSenderToDummyStandby() ? true : false;\r\n\r\n    if (cmd->kind == REPLICATION_KIND_LOGICAL) {\r\n        CheckPMstateAndRecoveryInProgress();\r\n        CheckLogicalDecodingRequirements(u_sess->proc_cxt.MyDatabaseId);\r\n        /*\r\n         * Initially create the slot as ephemeral - that allows us to nicely\r\n         * handle errors during initialization because it'll get dropped if\r\n         * this transaction fails. We'll make it persistent at the end.\r\n         */\r\n        ReplicationSlotCreate(\r\n            cmd->slotname, RS_EPHEMERAL, isDummyStandby, u_sess->proc_cxt.MyDatabaseId, InvalidXLogRecPtr);\r\n    } else {\r\n        /*\r\n         * physical slot save init value if exist\r\n         */\r\n        ReplicationSlotCreate(cmd->slotname, RS_PERSISTENT, isDummyStandby, InvalidOid, cmd->init_slot_lsn);\r\n    }\r\n    slot_name = NameStr(t_thrd.slot_cxt.MyReplicationSlot->data.name);\r\n\r\n    if (cmd->kind == REPLICATION_KIND_LOGICAL) {\r\n        (void)ValidateName(cmd->slotname);\r\n        (void)ValidateName(cmd->plugin);\r\n        char* fullname = NULL;\r\n        fullname = expand_dynamic_library_name(cmd->plugin);\r\n\r\n        /* Load the shared library, unless we already did */\r\n        (void)internal_load_library(fullname);\r\n\r\n        LogicalDecodingContext* ctx = NULL;\r\n\r\n        ctx = CreateInitDecodingContext(\r\n            cmd->plugin, NIL, true, logical_read_xlog_page, WalSndPrepareWrite, WalSndWriteData);\r\n\r\n        /* build initial snapshot, might take a while */\r\n        DecodingContextFindStartpoint(ctx);\r\n\r\n        /*\r\n         * Export a plain (not of the snapbuild.c type) snapshot to the user\r\n         * that can be imported into another session.\r\n         */\r\n        snapshot_name = SnapBuildExportSnapshot(ctx->snapshot_builder);\r\n\r\n        /* don't need the decoding context anymore */\r\n        FreeDecodingContext(ctx);\r\n\r\n        ReplicationSlotPersist();\r\n\r\n        // write xlog\r\n        log_slot_create(&t_thrd.slot_cxt.MyReplicationSlot->data);\r\n    }\r\n\r\n    rc = snprintf_s(xpos,\r\n        sizeof(xpos),\r\n        sizeof(xpos) - 1,\r\n        \"%X/%X\",\r\n        (uint32)(t_thrd.slot_cxt.MyReplicationSlot->data.confirmed_flush >> 32),\r\n        (uint32)t_thrd.slot_cxt.MyReplicationSlot->data.confirmed_flush);\r\n    securec_check_ss(rc, \"\\0\", \"\\0\");\r\n\r\n    /*\r\n     * It may seem somewhat pointless to send back the same slot name the\r\n     * client just requested and nothing else, but logical replication\r\n     * will add more fields here.  (We could consider removing the slot\r\n     * name from what's sent back, though, since the client has specified\r\n     * that.)\r\n     */\r\n    pq_beginmessage(&buf, 'T');\r\n    pq_sendint16(&buf, 4); /* 4 field */\r\n\r\n    /* first field: slot name */\r\n    pq_sendstring(&buf, \"slot_name\"); /* col name */\r\n    pq_sendint32(&buf, 0);            /* table oid */\r\n    pq_sendint16(&buf, 0);            /* attnum */\r\n    pq_sendint32(&buf, TEXTOID);      /* type oid */\r\n    pq_sendint16(&buf, UINT16_MAX);   /* typlen */\r\n    pq_sendint32(&buf, 0);            /* typmod */\r\n    pq_sendint16(&buf, 0);            /* format code */\r\n\r\n    /* second field: LSN at which we became consistent */\r\n    pq_sendstring(&buf, \"consistent_point\"); /* col name */\r\n    pq_sendint32(&buf, 0);                   /* table oid */\r\n    pq_sendint16(&buf, 0);                   /* attnum */\r\n    pq_sendint32(&buf, TEXTOID);             /* type oid */\r\n    pq_sendint16(&buf, UINT16_MAX);          /* typlen */\r\n    pq_sendint32(&buf, 0);                   /* typmod */\r\n    pq_sendint16(&buf, 0);                   /* format code */\r\n\r\n    /* third field: exported snapshot's name */\r\n    pq_sendstring(&buf, \"snapshot_name\"); /* col name */\r\n    pq_sendint32(&buf, 0);                /* table oid */\r\n    pq_sendint16(&buf, 0);                /* attnum */\r\n    pq_sendint32(&buf, TEXTOID);          /* type oid */\r\n    pq_sendint16(&buf, UINT16_MAX);       /* typlen */\r\n    pq_sendint32(&buf, 0);                /* typmod */\r\n    pq_sendint16(&buf, 0);                /* format code */\r\n\r\n    /* fourth field: output plugin */\r\n    pq_sendstring(&buf, \"output_plugin\"); /* col name */\r\n    pq_sendint32(&buf, 0);                /* table oid */\r\n    pq_sendint16(&buf, 0);                /* attnum */\r\n    pq_sendint32(&buf, TEXTOID);          /* type oid */\r\n    pq_sendint16(&buf, UINT16_MAX);       /* typlen */\r\n    pq_sendint32(&buf, 0);                /* typmod */\r\n    pq_sendint16(&buf, 0);                /* format code */\r\n    pq_endmessage_noblock(&buf);\r\n\r\n    /* Send a DataRow message */\r\n    pq_beginmessage(&buf, 'D');\r\n    pq_sendint16(&buf, 4); /* # of columns */\r\n\r\n    /* slot_name */\r\n    pq_sendint32(&buf, strlen(slot_name)); /* col1 len */\r\n    pq_sendbytes(&buf, slot_name, strlen(slot_name));\r\n\r\n    /* consistent wal location */\r\n    pq_sendint32(&buf, strlen(xpos)); /* col2 len */\r\n    pq_sendbytes(&buf, xpos, strlen(xpos));\r\n\r\n    /* snapshot name */\r\n    if (snapshot_name != NULL) {\r\n        pq_sendint32(&buf, strlen(snapshot_name)); /* col3 len */\r\n        pq_sendbytes(&buf, snapshot_name, strlen(snapshot_name));\r\n    } else {\r\n        pq_sendint32(&buf, UINT32_MAX); /* col3 len, NULL */\r\n    }\r\n\r\n    /* plugin */\r\n    if (cmd->plugin != NULL) {\r\n        pq_sendint32(&buf, strlen(cmd->plugin)); /* col4 len */\r\n        pq_sendbytes(&buf, cmd->plugin, strlen(cmd->plugin));\r\n    } else\r\n        pq_sendint32(&buf, UINT32_MAX); /* col4 len, NULL */\r\n    pq_endmessage_noblock(&buf);\r\n\r\n    /* Send CommandComplete and ReadyForQuery messages */\r\n    EndCommand_noblock(\"SELECT\", DestRemote);\r\n    ReadyForQuery_noblock(DestRemote, u_sess->attr.attr_storage.wal_sender_timeout);\r\n    /* ReadyForQuery did pq_flush_if_available for us\r\n     *\r\n     * release active status again, START_REPLICATION will reacquire it\r\n     */\r\n    ReplicationSlotRelease();\r\n}",
		"comment":"/*\r\n * Create a new replication slot.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"CreateReplicationSlot"
	},
	"DropReplicationSlot":{
		"body":"static void DropReplicationSlot(DropReplicationSlotCmd* cmd)\r\n{\r\n    if (IsLogicalSlot(cmd->slotname)) {\r\n        CheckPMstateAndRecoveryInProgress();\r\n        ReplicationSlotDrop(cmd->slotname);\r\n        log_slot_drop(cmd->slotname);\r\n    } else {\r\n        ReplicationSlotDrop(cmd->slotname);\r\n    }\r\n\r\n    EndCommand_noblock(\"DROP_REPLICATION_SLOT\", DestRemote);\r\n    EndCommand_noblock(\"SELECT\", DestRemote);\r\n    ReadyForQuery_noblock(DestRemote, u_sess->attr.attr_storage.wal_sender_timeout);\r\n}",
		"comment":"/*\r\n * Get rid of a replication slot that is no longer wanted.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"DropReplicationSlot"
	},
	"GetFastestReplayStandByServiceAddress":{
		"body":"void GetFastestReplayStandByServiceAddress(\r\n    char* fastest_remote_address, char* second_fastest_remote_address, size_t address_len)\r\n{\r\n    if (fastest_remote_address == NULL || second_fastest_remote_address == NULL || address_len == 0 ||\r\n        t_thrd.walsender_cxt.WalSndCtl == NULL)\r\n        return;\r\n\r\n    int fastest = 0;\r\n    int second_fastest = 0;\r\n    XLogRecPtr fastest_replay = InvalidXLogRecPtr;\r\n    XLogRecPtr second_fastest_replay = InvalidXLogRecPtr;\r\n\r\n    errno_t rc = EOK;\r\n\r\n    for (int i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile WalSnd* walsnd = &t_thrd.walsender_cxt.WalSndCtl->walsnds[i];\r\n\r\n        if (walsnd->pid == 0 || !walsnd->replSender)\r\n            continue;\r\n\r\n        SpinLockAcquire(&walsnd->mutex);\r\n        XLogRecPtr walsnd_replay = walsnd->apply;\r\n        DbState peer_state = walsnd->peer_state;\r\n        SpinLockRelease(&walsnd->mutex);\r\n\r\n        /* remote can accept connections */\r\n        if (peer_state != NORMAL_STATE && peer_state != CATCHUP_STATE)\r\n            continue;\r\n\r\n        if (XLByteLT(second_fastest_replay, walsnd_replay)) {\r\n            if (XLByteLT(fastest_replay, walsnd_replay)) {\r\n                /* walsnd_replay is larger than fastest_replay */\r\n                second_fastest = fastest;\r\n                second_fastest_replay = fastest_replay;\r\n\r\n                fastest = i;\r\n                fastest_replay = walsnd_replay;\r\n            } else {\r\n                /* walsnd_replay is in the range (second_fastest_replay, fastest_replay] */\r\n                second_fastest = i;\r\n                second_fastest_replay = walsnd_replay;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* find fastest replay standby */\r\n    if (!XLogRecPtrIsInvalid(fastest_replay)) {\r\n        volatile WalSnd* walsnd = &t_thrd.walsender_cxt.WalSndCtl->walsnds[fastest];\r\n        SpinLockAcquire(&walsnd->mutex);\r\n        rc = snprintf_s(fastest_remote_address,\r\n            address_len,\r\n            (address_len - 1),\r\n            \"%s:%d\",\r\n            walsnd->wal_sender_channel.remotehost,\r\n            walsnd->wal_sender_channel.remoteservice);\r\n        SpinLockRelease(&walsnd->mutex);\r\n\r\n        securec_check_ss(rc, \"\", \"\");\r\n    }\r\n\r\n    /* find second fastest replay standby */\r\n    if (!XLogRecPtrIsInvalid(second_fastest_replay)) {\r\n        volatile WalSnd* walsnd = &t_thrd.walsender_cxt.WalSndCtl->walsnds[second_fastest];\r\n        SpinLockAcquire(&walsnd->mutex);\r\n        rc = snprintf_s(second_fastest_remote_address,\r\n            address_len,\r\n            (address_len - 1),\r\n            \"%s:%d\",\r\n            walsnd->wal_sender_channel.remotehost,\r\n            walsnd->wal_sender_channel.remoteservice);\r\n        SpinLockRelease(&walsnd->mutex);\r\n\r\n        securec_check_ss(rc, \"\\0\", \"\\0\");\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"GetFastestReplayStandByServiceAddress"
	},
	"GetHeartbeatLastReplyTimestamp":{
		"body":"static TimestampTz GetHeartbeatLastReplyTimestamp()\r\n{\r\n    int replindex;\r\n    volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n    SpinLockAcquire(&walsnd->mutex);\r\n    replindex = walsnd->channel_get_replc;\r\n    SpinLockRelease(&walsnd->mutex);\r\n\r\n    return get_last_reply_timestamp(replindex);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"GetHeartbeatLastReplyTimestamp"
	},
	"HandleWalReplicationCommand":{
		"body":"static bool HandleWalReplicationCommand(const char* cmd_string)\r\n{\r\n    bool replication_started = false;\r\n    int parse_rc;\r\n    Node* cmd_node = NULL;\r\n    MemoryContext cmd_context;\r\n    MemoryContext old_context;\r\n    replication_scanner_yyscan_t yyscanner = NULL;\r\n\r\n    /*\r\n     * CREATE_REPLICATION_SLOT ... LOGICAL exports a snapshot until the next\r\n     * command arrives. Clean up the old stuff if there's anything.\r\n     */\r\n    SnapBuildClearExportedSnapshot();\r\n\r\n    ereport(LOG, (errmsg(\"received wal replication command: %s\", cmd_string)));\r\n\r\n    if (cmdStringCheck(cmd_string) == false) {\r\n        ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), \r\n            (errmsg_internal(\"replication command, syntax error.\"))));\r\n    }\r\n\r\n    cmd_context = AllocSetContextCreate(CurrentMemoryContext,\r\n        \"Replication command context\",\r\n        ALLOCSET_DEFAULT_MINSIZE,\r\n        ALLOCSET_DEFAULT_INITSIZE,\r\n        ALLOCSET_DEFAULT_MAXSIZE);\r\n\r\n    yyscanner = replication_scanner_init(cmd_string);\r\n    parse_rc = replication_yyparse(yyscanner);\r\n    replication_scanner_finish(yyscanner);\r\n\r\n    if (parse_rc != 0) {\r\n        ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), \r\n            (errmsg_internal(\"replication command parser returned %d\", parse_rc))));\r\n    }\r\n\r\n    old_context = MemoryContextSwitchTo(cmd_context);\r\n\r\n    cmd_node = t_thrd.replgram_cxt.replication_parse_result;\r\n\r\n    switch (cmd_node->type) {\r\n        case T_IdentifySystemCmd:\r\n            IdentifySystem();\r\n            break;\r\n\r\n        case T_IdentifyVersionCmd:\r\n            IdentifyVersion();\r\n            break;\r\n\r\n        case T_IdentifyModeCmd:\r\n            IdentifyMode();\r\n            break;\r\n\r\n        case T_IdentifyMaxLsnCmd:\r\n            IdentifyMaxLsn();\r\n            break;\r\n\r\n        case T_IdentifyConsistenceCmd:\r\n            IdentifyConsistence((IdentifyConsistenceCmd*)cmd_node);\r\n            SetReplWalSender();\r\n            break;\r\n\r\n        case T_IdentifyChannelCmd:\r\n            IdentifyChannel((IdentifyChannelCmd*)cmd_node);\r\n            break;\r\n\r\n        case T_BaseBackupCmd:\r\n            MarkPostmasterChildNormal();\r\n            SetWalSndPeerMode(STANDBY_MODE);\r\n            SetWalSndPeerDbstate(BUILDING_STATE);\r\n\r\n            if (!IS_PGXC_COORDINATOR && IS_DN_DUMMY_STANDYS_MODE())\r\n                StopAliveBuildSender();\r\n            SendBaseBackup((BaseBackupCmd*)cmd_node);\r\n\r\n            /* Send CommandComplete and ReadyForQuery messages */\r\n            EndCommand_noblock(\"SELECT\", DestRemote);\r\n            ReadyForQuery_noblock(DestRemote, u_sess->attr.attr_storage.wal_sender_timeout);\r\n            /* ReadyForQuery did pq_flush for us */\r\n            /* Audit database recovery */\r\n            pgaudit_system_recovery_ok();\r\n            break;\r\n\r\n        case T_CreateReplicationSlotCmd:\r\n            CreateReplicationSlot((CreateReplicationSlotCmd*)cmd_node);\r\n            break;\r\n\r\n        case T_DropReplicationSlotCmd:\r\n            DropReplicationSlot((DropReplicationSlotCmd*)cmd_node);\r\n            break;\r\n\r\n        case T_StartReplicationCmd: {\r\n            StartReplicationCmd* cmd = (StartReplicationCmd*)cmd_node;\r\n            if (cmd->kind == REPLICATION_KIND_PHYSICAL) {\r\n                StartReplication(cmd);\r\n                /* break out of the loop */\r\n                replication_started = true;\r\n            } else {\r\n                CheckPMstateAndRecoveryInProgress();\r\n                StartLogicalReplication(cmd);\r\n            }\r\n            break;\r\n        }\r\n\r\n        case T_FetchMotCheckpointCmd:\r\n            PerformMotCheckpointFetch();\r\n            /* Send CommandComplete and ReadyForQuery messages */\r\n            EndCommand_noblock(\"SELECT\", DestRemote);\r\n            ReadyForQuery_noblock(DestRemote, u_sess->attr.attr_storage.wal_sender_timeout);\r\n            break;\r\n\r\n        default:\r\n            ereport(\r\n                FATAL, (errcode(ERRCODE_PROTOCOL_VIOLATION), errmsg(\"invalid standby query string: %s\", cmd_string)));\r\n    }\r\n\r\n    /* done */\r\n    (void)MemoryContextSwitchTo(old_context);\r\n    MemoryContextDelete(cmd_context);\r\n\r\n    return replication_started;\r\n}",
		"comment":"/*\r\n * Execute an incoming replication command.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"HandleWalReplicationCommand"
	},
	"IdentifyChannel":{
		"body":"static void IdentifyChannel(IdentifyChannelCmd* cmd)\r\n{\r\n    StringInfoData buf;\r\n\r\n    t_thrd.walsender_cxt.remotePort = cmd->channel_identifier;\r\n    bool is_success = UpdateHaWalSenderChannel(t_thrd.walsender_cxt.remotePort);\r\n\r\n    const char *result = is_success ? \"t\" : \"f\";\r\n    size_t result_len = strlen(result);\r\n\r\n    /* Send a RowDescription message */\r\n    pq_beginmessage(&buf, 'T');\r\n    pq_sendint16(&buf, 1); /* 1 fields */\r\n\r\n    /* first field */\r\n    pq_sendstring(&buf, \"identifier\"); /* col name */\r\n    pq_sendint32(&buf, 0);             /* table oid */\r\n    pq_sendint16(&buf, 0);             /* attnum */\r\n    pq_sendint32(&buf, BOOLOID);       /* type oid */\r\n    pq_sendint16(&buf, 1);             /* typlen */\r\n    pq_sendint32(&buf, 0);             /* typmod */\r\n    pq_sendint16(&buf, 0);             /* format code */\r\n    pq_endmessage_noblock(&buf);\r\n\r\n    /* Send a DataRow message */\r\n    pq_beginmessage(&buf, 'D');\r\n    pq_sendint16(&buf, 1);          /* # of columns */\r\n    pq_sendint32(&buf, result_len); /* col1 len */\r\n    pq_sendbytes(&buf, result, result_len);\r\n    pq_endmessage_noblock(&buf);\r\n\r\n    /* Send CommandComplete and ReadyForQuery messages */\r\n    EndCommand_noblock(\"SELECT\", DestRemote);\r\n    ReadyForQuery_noblock(DestRemote, u_sess->attr.attr_storage.wal_sender_timeout);\r\n}",
		"comment":"/*\r\n * IDENTIFY_CHANNEL\r\n * get channel identifier from standby\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"IdentifyChannel"
	},
	"IdentifyConsistence":{
		"body":"static void IdentifyConsistence(IdentifyConsistenceCmd* cmd)\r\n{\r\n    StringInfoData buf;\r\n    char        crc[CRC_LEN] = {0};\r\n    char        maxLsnCrcStr[CRC_LEN] = {0};\r\n    pg_crc32    requestRecCrc = 0;\r\n    pg_crc32    localMaxLsnCrc = 0;\r\n    bool        crcValid = false;\r\n    XLogRecPtr  localMaxPtr = InvalidXLogRecPtr;;\r\n    char        strMaxPtr[MAXFNAMELEN] = {0};\r\n    int         nRet = 0;\r\n    char        msgBuf[XLOG_READER_MAX_MSGLENTH] = {0};\r\n\r\n    requestRecCrc = GetXlogRecordCrc(cmd->recordptr, crcValid);\r\n\r\n    /* To support grayupgrade, msg with 1 row of 2 or 3 colums is used\r\n     * according to working version number. Will remove later.\r\n     */ \r\n    if (t_thrd.proc && t_thrd.proc->workingVersionNum >= 92060) {\r\n        /* Don't care max xlog when check with building process */\r\n        if (IsWalSenderToBuild() == false) {\r\n            if (dummyStandbyMode) {\r\n                localMaxPtr = FindMaxLSN(t_thrd.proc_cxt.DataDir, msgBuf, XLOG_READER_MAX_MSGLENTH, &localMaxLsnCrc);\r\n            } else {\r\n                if (AM_WAL_STANDBY_SENDER) {\r\n                    (void)GetXLogReplayRecPtr(NULL, &localMaxPtr);\r\n                    localMaxLsnCrc = GetXlogRecordCrc(localMaxPtr, crcValid);\r\n                } else {\r\n                    localMaxPtr =\r\n                        FindMaxLSN(t_thrd.proc_cxt.DataDir, msgBuf, XLOG_READER_MAX_MSGLENTH, &localMaxLsnCrc);\r\n                }\r\n            }\r\n\r\n            ereport(LOG, (errmsg(\"remote request lsn/crc: [%X/%X, %u] \"\r\n                \"local max lsn/crc: [%X/%X, %u]\",\r\n                (uint32)(cmd->recordptr >> 32), (uint32)cmd->recordptr,\r\n                (uint32)requestRecCrc, (uint32)(localMaxPtr >> 32),\r\n                (uint32)localMaxPtr, (uint32)localMaxLsnCrc)));\r\n        }\r\n\r\n        if (requestRecCrc == NONE_REC_CRC && WalSndCaughtup()) {\r\n            requestRecCrc = IGNORE_REC_CRC;\r\n        }\r\n\r\n        nRet = snprintf_s(crc, sizeof(crc), sizeof(crc) - 1, \"%X\", requestRecCrc);\r\n        securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n\r\n        nRet = snprintf_s(strMaxPtr, sizeof(strMaxPtr), sizeof(strMaxPtr) - 1, \"%X/%X\", (uint32)(localMaxPtr >> 32),\r\n            (uint32)localMaxPtr);\r\n        securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n\r\n        nRet = snprintf_s(maxLsnCrcStr, sizeof(maxLsnCrcStr), sizeof(maxLsnCrcStr) - 1, \"%X\", localMaxLsnCrc);\r\n        securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n\r\n        /* Send a RowDescription message */\r\n        pq_beginmessage(&buf, 'T');\r\n        pq_sendint16(&buf, 3); /* 1 fields */\r\n\r\n        /* first field */\r\n        pq_sendstring(&buf, \"requestRemoteCrc\"); /* col name */\r\n        pq_sendint32(&buf, 0); /* table oid */\r\n        pq_sendint16(&buf, 0); /* attnum */\r\n        pq_sendint32(&buf, TEXTOID); /* type oid */\r\n        pq_sendint16(&buf, UINT16_MAX); /* typlen */\r\n        pq_sendint32(&buf, 0); /* typmod */\r\n        pq_sendint16(&buf, 0); /* format code */\r\n\r\n        /* second field */\r\n        pq_sendstring(&buf, \"localMaxLsn\"); /* col name */\r\n        pq_sendint32(&buf, 0); /* table oid */\r\n        pq_sendint16(&buf, 1); /* attnum */\r\n        pq_sendint32(&buf, TEXTOID); /* type oid */\r\n        pq_sendint16(&buf, UINT16_MAX); /* typlen */\r\n        pq_sendint32(&buf, 0); /* typmod */\r\n        pq_sendint16(&buf, 0); /* format code */\r\n\r\n        /* third field */\r\n        pq_sendstring(&buf, \"localMaxLsnCrc\"); /* col name */\r\n        pq_sendint32(&buf, 0); /* table oid */\r\n        pq_sendint16(&buf, 2); /* attnum */\r\n        pq_sendint32(&buf, TEXTOID); /* type oid */\r\n        pq_sendint16(&buf, UINT16_MAX); /* typlen */\r\n        pq_sendint32(&buf, 0); /* typmod */\r\n        pq_sendint16(&buf, 0); /* format code */\r\n\r\n        pq_endmessage_noblock(&buf);\r\n\r\n        /* Send a DataRow message */\r\n        pq_beginmessage(&buf, 'D');\r\n        pq_sendint16(&buf, 3); /* # of columns */\r\n        pq_sendint32(&buf, strlen(crc)); /* col1 len */\r\n        pq_sendbytes(&buf, (char *) crc, strlen(crc));\r\n        pq_sendint32(&buf, strlen(strMaxPtr)); /* col2 len */\r\n        pq_sendbytes(&buf, (char *) strMaxPtr, strlen(strMaxPtr));\r\n        pq_sendint32(&buf, strlen(maxLsnCrcStr)); /* col3 len */\r\n        pq_sendbytes(&buf, (char *) maxLsnCrcStr, strlen(maxLsnCrcStr));\r\n        pq_endmessage_noblock(&buf);\r\n    } else {\r\n        char havexlog[8] = {0};\r\n        if (dummyStandbyMode) {\r\n            if (crcValid) {\r\n                havexlog[0] = '1';\r\n            } else {\r\n                localMaxPtr = FindMaxLSN(t_thrd.proc_cxt.DataDir, msgBuf, XLOG_READER_MAX_MSGLENTH, &localMaxLsnCrc);\r\n                if (XLByteLT(localMaxPtr, cmd->recordptr) || XLByteEQ(localMaxPtr, InvalidXLogRecPtr)) {\r\n                    havexlog[0] = '0';\r\n                } else {\r\n                    havexlog[0] = '1';\r\n                }\r\n            }\r\n            ereport(LOG,\r\n                    (errmsg(\"standby rec: %x/%x, havexlog: %s, crc:%u\",\r\n                            (uint32) (cmd->recordptr >> 32), (uint32) cmd->recordptr,\r\n                            havexlog, (uint32)requestRecCrc)));\r\n        } else {\r\n            havexlog[0] = '1';  /* have xlog be true if in primary mode */\r\n        }\r\n\r\n        nRet = snprintf_s(crc, sizeof(crc), sizeof(crc) - 1, \"%X\", requestRecCrc);\r\n        securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n        \r\n        /* Send a RowDescription message */\r\n        pq_beginmessage(&buf, 'T');\r\n        pq_sendint16(&buf, 2);      /* 1 fields */\r\n        \r\n        /* first field */\r\n        pq_sendstring(&buf, \"reccrc\");  /* col name */\r\n        pq_sendint32(&buf, 0);      /* table oid */\r\n        pq_sendint16(&buf, 0);      /* attnum */\r\n        pq_sendint32(&buf, TEXTOID);        /* type oid */\r\n        pq_sendint16(&buf, UINT16_MAX); /* typlen */\r\n        pq_sendint32(&buf, 0);      /* typmod */\r\n        pq_sendint16(&buf, 0);      /* format code */\r\n        \r\n        /* sencond field */\r\n        pq_sendstring(&buf, \"havexlog\");    /* col name */\r\n        pq_sendint32(&buf, 0);      /* table oid */\r\n        pq_sendint16(&buf, 0);      /* attnum */\r\n        pq_sendint32(&buf, INT4OID);        /* type oid */\r\n        pq_sendint16(&buf, 4);      /* typlen */\r\n        pq_sendint32(&buf, 0);      /* typmod */\r\n        pq_sendint16(&buf, 0);      /* format code */\r\n        pq_endmessage_noblock(&buf);\r\n        \r\n        /* Send a DataRow message */\r\n        pq_beginmessage(&buf, 'D');\r\n        pq_sendint16(&buf, 2);      /* # of columns */\r\n        pq_sendint32(&buf, strlen(crc));    /* col1 len */\r\n        pq_sendbytes(&buf, (char *) crc, strlen(crc));\r\n        pq_sendint32(&buf, strlen(havexlog));   /* col2 len */\r\n        pq_sendbytes(&buf, (char *) havexlog, strlen(havexlog));\r\n        pq_endmessage_noblock(&buf);\r\n    }\r\n\r\n    /* Send CommandComplete and ReadyForQuery messages */\r\n    EndCommand_noblock(\"SELECT\", DestRemote);\r\n    ReadyForQuery_noblock(DestRemote, u_sess->attr.attr_storage.wal_sender_timeout);\r\n    /* ReadyForQuery did pq_flush_if_available for us */\r\n}",
		"comment":"/*\r\n * IDENTIFY_CONSISTENCE\r\n * identify consistence of primary and standby\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"IdentifyConsistence"
	},
	"IdentifyMaxLsn":{
		"body":"static void IdentifyMaxLsn(void)\r\n{\r\n    int nRet = 0;\r\n    StringInfoData buf;\r\n    char str[MAXFNAMELEN];\r\n    char recptr[MAXFNAMELEN];\r\n\r\n    XLogRecPtr ptr = GetFlushRecPtr();\r\n\r\n    nRet = snprintf_s(recptr, sizeof(recptr), sizeof(recptr) - 1, \"%X/%X\", (uint32)(ptr >> 32), (uint32)ptr);\r\n    securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n    nRet = snprintf_s(str, sizeof(str), sizeof(str) - 1, \"%s|%s\", g_instance.attr.attr_common.PGXCNodeName, recptr);\r\n    securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n\r\n    pq_beginmessage(&buf, 'T'); /* RowDescription */\r\n    pq_sendint16(&buf, 1);      /* 1 field */\r\n\r\n    /* Field header */\r\n    pq_sendstring(&buf, \"recptr\");\r\n    pq_sendint32(&buf, 0);       /* table oid */\r\n    pq_sendint16(&buf, 0);       /* attnum */\r\n    pq_sendint32(&buf, TEXTOID); /* type oid */\r\n    pq_sendint16(&buf, UINT16_MAX);\r\n    pq_sendint32(&buf, 0);\r\n    pq_sendint16(&buf, 0);\r\n    pq_endmessage_noblock(&buf);\r\n\r\n    /* Data row */\r\n    pq_beginmessage(&buf, 'D');\r\n    pq_sendint16(&buf, 1);           /* number of columns */\r\n    pq_sendint32(&buf, strlen(str)); /* length */\r\n    pq_sendbytes(&buf, str, strlen(str));\r\n    pq_endmessage_noblock(&buf);\r\n\r\n    /* Send CommandComplete and ReadyForQuery messages */\r\n    EndCommand_noblock(\"SELECT\", DestRemote);\r\n    ReadyForQuery_noblock(DestRemote, u_sess->attr.attr_storage.wal_sender_timeout);\r\n    /* ReadyForQuery did pq_flush_if_available for us */\r\n}",
		"comment":"/*\r\n * IDENTIFY_MAXLSN\r\n * This LSN contains two part,node name and XLogRecPtr\r\n * One case is CN build DN and get current latest flushed LSN here\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"IdentifyMaxLsn"
	},
	"IdentifyMode":{
		"body":"void IdentifyMode(void)\r\n{\r\n    StringInfoData buf;\r\n    char smode[11];\r\n    volatile HaShmemData* hashmdata = t_thrd.postmaster_cxt.HaShmData;\r\n    int nRet = 0;\r\n\r\n    SpinLockAcquire(&hashmdata->mutex);\r\n    nRet = snprintf_s(smode, sizeof(smode), sizeof(smode) - 1, \"%d\", hashmdata->current_mode);\r\n    securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n    SpinLockRelease(&hashmdata->mutex);\r\n\r\n    /* Send a RowDescription message */\r\n    pq_beginmessage(&buf, 'T');\r\n    pq_sendint16(&buf, 1); /* 1 fields */\r\n\r\n    /* first field */\r\n    pq_sendstring(&buf, \"smode\"); /* col name */\r\n    pq_sendint32(&buf, 0);        /* table oid */\r\n    pq_sendint16(&buf, 0);        /* attnum */\r\n    pq_sendint32(&buf, INT4OID);  /* type oid */\r\n    pq_sendint16(&buf, 4);        /* typlen */\r\n    pq_sendint32(&buf, 0);        /* typmod */\r\n    pq_sendint16(&buf, 0);        /* format code */\r\n    pq_endmessage_noblock(&buf);\r\n\r\n    /* Send a DataRow message */\r\n    pq_beginmessage(&buf, 'D');\r\n    pq_sendint16(&buf, 1);             /* # of columns */\r\n    pq_sendint32(&buf, strlen(smode)); /* col1 len */\r\n    pq_sendbytes(&buf, (char*)smode, strlen(smode));\r\n    pq_endmessage_noblock(&buf);\r\n\r\n    /* Send CommandComplete and ReadyForQuery messages */\r\n    EndCommand_noblock(\"SELECT\", DestRemote);\r\n    ReadyForQuery_noblock(DestRemote, u_sess->attr.attr_storage.wal_sender_timeout);\r\n    /* ReadyForQuery did pq_flush_if_available for us */\r\n}",
		"comment":"/*\r\n * IDENTIFY_MODE extern  for datasender\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"IdentifyMode"
	},
	"IdentifySystem":{
		"body":"static void IdentifySystem(void)\r\n{\r\n    StringInfoData buf;\r\n    char sysid[32];\r\n    char tli[11];\r\n    char xpos[MAXFNAMELEN];\r\n    XLogRecPtr logptr;\r\n    int rc = 0;\r\n    char* dbname = NULL;\r\n\r\n    /*\r\n     * Reply with a result set with one row, four columns. First col is system\r\n     * ID, second is timeline ID, third is current xlog location and the fourth\r\n     * contains the database name if we are connected to one.\r\n     */\r\n    rc = snprintf_s(sysid, sizeof(sysid), sizeof(sysid) - 1, UINT64_FORMAT, GetSystemIdentifier());\r\n    securec_check_ss(rc, \"\\0\", \"\\0\");\r\n\r\n    rc = snprintf_s(tli, sizeof(tli), sizeof(tli) - 1, \"%u\", t_thrd.xlog_cxt.ThisTimeLineID);\r\n    securec_check_ss(rc, \"\\0\", \"\\0\");\r\n\r\n    logptr = AM_WAL_STANDBY_SENDER ? GetStandbyFlushRecPtr(NULL) : GetFlushRecPtr();\r\n\r\n    rc = snprintf_s(xpos, sizeof(xpos), sizeof(xpos) - 1, \"%X/%X\", (uint32)(logptr >> 32), (uint32)logptr);\r\n    securec_check_ss(rc, \"\\0\", \"\\0\");\r\n\r\n    if (u_sess->proc_cxt.MyDatabaseId != InvalidOid) {\r\n        MemoryContext cur = CurrentMemoryContext;\r\n\r\n        /* syscache access needs a transaction env. */\r\n        StartTransactionCommand();\r\n        /* make dbname live outside TX context */\r\n        (void)MemoryContextSwitchTo(cur);\r\n        dbname = get_database_name(u_sess->proc_cxt.MyDatabaseId);\r\n        if (dbname == NULL) {\r\n            ereport(ERROR, (errcode(ERRCODE_UNDEFINED_DATABASE),\r\n                        errmsg(\"database with OID %u does not exist\",\r\n                            u_sess->proc_cxt.MyDatabaseId)));\r\n        }\r\n        CommitTransactionCommand();\r\n        /* CommitTransactionCommand switches to t_thrd.top_mem_cxt */\r\n        (void)MemoryContextSwitchTo(cur);\r\n    }\r\n\r\n    /* Send a RowDescription message */\r\n    pq_beginmessage(&buf, 'T');\r\n    pq_sendint16(&buf, 4); /* 4 fields */\r\n\r\n    /* first field */\r\n    pq_sendstring(&buf, \"systemid\"); /* col name */\r\n    pq_sendint32(&buf, 0);           /* table oid */\r\n    pq_sendint16(&buf, 0);           /* attnum */\r\n    pq_sendint32(&buf, TEXTOID);     /* type oid */\r\n    pq_sendint16(&buf, UINT16_MAX);  /* typlen */\r\n    pq_sendint32(&buf, 0);           /* typmod */\r\n    pq_sendint16(&buf, 0);           /* format code */\r\n\r\n    /* second field */\r\n    pq_sendstring(&buf, \"timeline\"); /* col name */\r\n    pq_sendint32(&buf, 0);           /* table oid */\r\n    pq_sendint16(&buf, 0);           /* attnum */\r\n    pq_sendint32(&buf, INT4OID);     /* type oid */\r\n    pq_sendint16(&buf, 4);           /* typlen */\r\n    pq_sendint32(&buf, 0);           /* typmod */\r\n    pq_sendint16(&buf, 0);           /* format code */\r\n\r\n    /* third field */\r\n    pq_sendstring(&buf, \"xlogpos\"); /* col name */\r\n    pq_sendint32(&buf, 0);          /* table oid */\r\n    pq_sendint16(&buf, 0);          /* attnum */\r\n    pq_sendint32(&buf, TEXTOID);    /* type oid */\r\n    pq_sendint16(&buf, UINT16_MAX); /* typlen */\r\n    pq_sendint32(&buf, 0);          /* typmod */\r\n    pq_sendint16(&buf, 0);          /* format code */\r\n\r\n    /* fourth field */\r\n    pq_sendstring(&buf, \"dbname\");  /* col name */\r\n    pq_sendint32(&buf, 0);          /* table oid */\r\n    pq_sendint16(&buf, 0);          /* attnum */\r\n    pq_sendint32(&buf, TEXTOID);    /* type oid */\r\n    pq_sendint16(&buf, UINT16_MAX); /* typlen */\r\n    pq_sendint32(&buf, 0);          /* typmod */\r\n    pq_sendint16(&buf, 0);          /* format code */\r\n    pq_endmessage_noblock(&buf);\r\n\r\n    /* Send a DataRow message */\r\n    pq_beginmessage(&buf, 'D');\r\n    pq_sendint16(&buf, 4);             /* # of columns */\r\n    pq_sendint32(&buf, strlen(sysid)); /* col1 len */\r\n    pq_sendbytes(&buf, (char*)sysid, strlen(sysid));\r\n    pq_sendint32(&buf, strlen(tli)); /* col2 len */\r\n    pq_sendbytes(&buf, (char*)tli, strlen(tli));\r\n    pq_sendint32(&buf, strlen(xpos)); /* col3 len */\r\n    pq_sendbytes(&buf, (char*)xpos, strlen(xpos));\r\n    /* send NULL if not connected to a database */\r\n    if (dbname != NULL) {\r\n        pq_sendint32(&buf, strlen(dbname)); /* col4 len */\r\n        pq_sendbytes(&buf, (char*)dbname, strlen(dbname));\r\n    } else {\r\n        pq_sendint32(&buf, UINT32_MAX); /* col4 len, NULL */\r\n    }\r\n    pq_endmessage_noblock(&buf);\r\n\r\n    /* Send CommandComplete and ReadyForQuery messages */\r\n    EndCommand_noblock(\"SELECT\", DestRemote);\r\n    ReadyForQuery_noblock(DestRemote, u_sess->attr.attr_storage.wal_sender_timeout);\r\n    /* ReadyForQuery did pq_flush_if_available for us */\r\n}",
		"comment":"/*\r\n * IDENTIFY_SYSTEM\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"IdentifySystem"
	},
	"IdentifyVersion":{
		"body":"static void IdentifyVersion(void)\r\n{\r\n    StringInfoData buf;\r\n    char pg_sversion[11] = {0};\r\n    char pg_pversion[32] = {0};\r\n    char term[11] = {0};\r\n    uint32 sys_version = PG_VERSION_NUM;\r\n    int nRet = 0;\r\n    errno_t rc = EOK;\r\n\r\n    nRet = snprintf_s(pg_sversion, sizeof(pg_sversion), sizeof(pg_sversion) - 1, \"%u\", sys_version);\r\n    securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n\r\n    rc = strncpy_s(pg_pversion, sizeof(pg_pversion), PG_PROTOCOL_VERSION, strlen(PG_PROTOCOL_VERSION));\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n    nRet = snprintf_s(term, sizeof(term), sizeof(term) - 1, \"%u\", g_instance.comm_cxt.localinfo_cxt.term);\r\n    securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n    pg_pversion[strlen(PG_PROTOCOL_VERSION)] = '\\0';\r\n\r\n    /* Send a RowDescription message */\r\n    pq_beginmessage(&buf, 'T');\r\n    pq_sendint16(&buf, 3); /* 3 fields */\r\n\r\n    /* first field */\r\n    pq_sendstring(&buf, \"sversion\"); /* col name */\r\n    pq_sendint32(&buf, 0);           /* table oid */\r\n    pq_sendint16(&buf, 0);           /* attnum */\r\n    pq_sendint32(&buf, INT4OID);     /* type oid */\r\n    pq_sendint16(&buf, 4);           /* typlen */\r\n    pq_sendint32(&buf, 0);           /* typmod */\r\n    pq_sendint16(&buf, 0);           /* format code */\r\n\r\n    /* second field */\r\n    pq_sendstring(&buf, \"pversion\"); /* col name */\r\n    pq_sendint32(&buf, 0);           /* table oid */\r\n    pq_sendint16(&buf, 0);           /* attnum */\r\n    pq_sendint32(&buf, TEXTOID);     /* type oid */\r\n    pq_sendint16(&buf, UINT16_MAX);  /* typlen */\r\n    pq_sendint32(&buf, 0);           /* typmod */\r\n    pq_sendint16(&buf, 0);           /* format code */\r\n\r\n    /* first field */\r\n    pq_sendstring(&buf, \"term\"); /* col name */\r\n    pq_sendint32(&buf, 0);       /* table oid */\r\n    pq_sendint16(&buf, 0);       /* attnum */\r\n    pq_sendint32(&buf, INT4OID); /* type oid */\r\n    pq_sendint16(&buf, 4);       /* typlen */\r\n    pq_sendint32(&buf, 0);       /* typmod */\r\n    pq_sendint16(&buf, 0);       /* format code */\r\n    pq_endmessage_noblock(&buf);\r\n\r\n    /* Send a DataRow message */\r\n    pq_beginmessage(&buf, 'D');\r\n    pq_sendint16(&buf, 3);                   /* # of columns */\r\n    pq_sendint32(&buf, strlen(pg_sversion)); /* col1 len */\r\n    pq_sendbytes(&buf, (char*)pg_sversion, strlen(pg_sversion));\r\n    pq_sendint32(&buf, strlen(pg_pversion)); /* col2 len */\r\n    pq_sendbytes(&buf, (char*)pg_pversion, strlen(pg_pversion));\r\n    pq_sendint32(&buf, strlen(term)); /* col2 len */\r\n    pq_sendbytes(&buf, (char*)term, strlen(term));\r\n    pq_endmessage_noblock(&buf);\r\n\r\n    /* Send CommandComplete and ReadyForQuery messages */\r\n    EndCommand_noblock(\"SELECT\", DestRemote);\r\n    ReadyForQuery_noblock(DestRemote, u_sess->attr.attr_storage.wal_sender_timeout);\r\n    /* ReadyForQuery did pq_flush_if_available for us */\r\n}",
		"comment":"/*\r\n * IDENTIFY_VERSION\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"IdentifyVersion"
	},
	"InitWalSnd":{
		"body":"static void InitWalSnd(void)\r\n{\r\n    int i;\r\n    errno_t rc = 0;\r\n\r\n    /*\r\n     * WalSndCtl should be set up already (we inherit this by fork() or\r\n     * EXEC_BACKEND mechanism from the postmaster).\r\n     */\r\n    Assert(t_thrd.walsender_cxt.WalSndCtl != NULL);\r\n    Assert(t_thrd.walsender_cxt.MyWalSnd == NULL);\r\n\r\n    /*\r\n     * Find a free walsender slot and reserve it. If this fails, we must be\r\n     * out of WalSnd structures.\r\n     */\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile WalSnd* walsnd = &t_thrd.walsender_cxt.WalSndCtl->walsnds[i];\r\n\r\n        SpinLockAcquire(&walsnd->mutex);\r\n\r\n        if (walsnd->pid != 0) {\r\n            SpinLockRelease(&walsnd->mutex);\r\n            continue;\r\n        } else {\r\n            /*\r\n             * Found a free slot. Reserve it for us.\r\n             */\r\n            walsnd->pid = t_thrd.proc_cxt.MyProcPid;\r\n            rc = memset_s((XLogRecPtr* )&walsnd->sentPtr, sizeof(XLogRecPtr), 0, sizeof(XLogRecPtr));\r\n            securec_check(rc, \"\\0\", \"\\0\");\r\n            walsnd->state = WALSNDSTATE_STARTUP;\r\n            walsnd->node_state = NODESTATE_NORMAL;\r\n            if (dummyStandbyMode) {\r\n                walsnd->sendRole = SNDROLE_DUMMYSTANDBY_STANDBY;\r\n            } else if (t_thrd.postmaster_cxt.senderToDummyStandby) {\r\n                walsnd->sendRole = SNDROLE_PRIMARY_DUMMYSTANDBY;\r\n            } else if (t_thrd.postmaster_cxt.senderToBuildStandby) {\r\n                walsnd->sendRole = SNDROLE_PRIMARY_BUILDSTANDBY;\r\n            } else {\r\n                walsnd->sendRole = SNDROLE_PRIMARY_STANDBY;\r\n            }\r\n\r\n            walsnd->sendKeepalive = true;\r\n            walsnd->replSender = false;\r\n            walsnd->peer_role = UNKNOWN_MODE;\r\n            walsnd->peer_state = NORMAL_STATE;\r\n            walsnd->channel_get_replc = 0;\r\n            rc = memset_s((XLogRecPtr*)&walsnd->receive, sizeof(XLogRecPtr), 0, sizeof(XLogRecPtr));\r\n            securec_check(rc, \"\\0\", \"\\0\");\r\n            rc = memset_s((XLogRecPtr*)&walsnd->write, sizeof(XLogRecPtr), 0, sizeof(XLogRecPtr));\r\n            securec_check(rc, \"\\0\", \"\\0\");\r\n            rc = memset_s((XLogRecPtr*)&walsnd->flush, sizeof(XLogRecPtr), 0, sizeof(XLogRecPtr));\r\n            securec_check(rc, \"\\0\", \"\\0\");\r\n            rc = memset_s((XLogRecPtr*)&walsnd->apply, sizeof(XLogRecPtr), 0, sizeof(XLogRecPtr));\r\n            securec_check(rc, \"\\0\", \"\\0\");\r\n            rc = memset_s((XLogRecPtr*)&walsnd->data_flush, sizeof(XLogRecPtr), 0, sizeof(XLogRecPtr));\r\n            securec_check(rc, \"\\0\", \"\\0\");\r\n            rc = memset_s((XLogRecPtr*)&walsnd->wal_sender_channel, sizeof(ReplConnInfo), 0, sizeof(ReplConnInfo));\r\n            securec_check(rc, \"\\0\", \"\\0\");\r\n            walsnd->sync_standby_priority = 0;\r\n            walsnd->index = i;\r\n            walsnd->log_ctrl.sleep_time = 0;\r\n            walsnd->log_ctrl.balance_sleep_time = 0;\r\n            walsnd->log_ctrl.prev_RTO = -1;\r\n            walsnd->log_ctrl.current_RTO = -1;\r\n            walsnd->log_ctrl.sleep_count = 0;\r\n            walsnd->log_ctrl.sleep_count_limit = MAX_CONTROL_REPLY;\r\n            walsnd->log_ctrl.prev_flush = 0;\r\n            walsnd->log_ctrl.prev_apply = 0;\r\n            walsnd->log_ctrl.prev_reply_time = 0;\r\n            walsnd->log_ctrl.pre_rate1 = 0;\r\n            walsnd->log_ctrl.pre_rate2 = 0;\r\n            SpinLockRelease(&walsnd->mutex);\r\n            /* don't need the lock anymore */\r\n            OwnLatch((Latch*)&walsnd->latch);\r\n            t_thrd.walsender_cxt.MyWalSnd = (WalSnd*)walsnd;\r\n\r\n            break;\r\n        }\r\n    }\r\n    if (t_thrd.walsender_cxt.MyWalSnd == NULL)\r\n        ereport(FATAL,\r\n            (errcode(ERRCODE_TOO_MANY_CONNECTIONS),\r\n                errmsg(\"number of requested standby connections \"\r\n                       \"exceeds max_wal_senders (currently %d)\",\r\n                    g_instance.attr.attr_storage.max_wal_senders)));\r\n\r\n    /* Arrange to clean up at walsender exit */\r\n    on_shmem_exit(WalSndKill, 0);\r\n}",
		"comment":"/* Initialize a per-walsender data structure for this walsender process */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"InitWalSnd"
	},
	"InitWalSndXLogReader":{
		"body":"static void InitWalSndXLogReader()\r\n{\r\n    WSXLogPageReadPrivate* ws_private = NULL;\r\n    errno_t rc = 0;\r\n\r\n    if (t_thrd.walsender_cxt.ws_xlog_reader) {\r\n        if (t_thrd.walsender_cxt.ws_xlog_reader->private_data) {\r\n            pfree((WSXLogPageReadPrivate*)t_thrd.walsender_cxt.ws_xlog_reader->private_data);\r\n            t_thrd.walsender_cxt.ws_xlog_reader->private_data = NULL;\r\n        }\r\n\r\n        XLogReaderFree(t_thrd.walsender_cxt.ws_xlog_reader);\r\n        t_thrd.walsender_cxt.ws_xlog_reader = NULL;\r\n    }\r\n\r\n    /*\r\n     * Allocate the xlogreader used for xlog parsing.\r\n     */\r\n    ws_private = (WSXLogPageReadPrivate*)palloc(sizeof(WSXLogPageReadPrivate));\r\n\r\n    /* Set up XLOG reader facility */\r\n    rc = memset_s(ws_private, sizeof(WSXLogPageReadPrivate), 0, sizeof(WSXLogPageReadPrivate));\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n    ws_private->xlogreadfd = -1;\r\n    ws_private->tli = t_thrd.xlog_cxt.ThisTimeLineID;\r\n\r\n    t_thrd.walsender_cxt.ws_xlog_reader = XLogReaderAllocate(&WSXLogPageRead, ws_private);\r\n\r\n    if (!t_thrd.walsender_cxt.ws_xlog_reader)\r\n        ereport(ERROR, (errcode(ERRCODE_INVALID_STATUS), errmsg(\"Failed to init the xlog reader for the wal sender.\")));\r\n    else\r\n        ereport(LOG, (errmsg(\"Succeeded to init the xlog reader for the wal sender.\")));\r\n\r\n    return;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"InitWalSndXLogReader"
	},
	"IsLogicalSlot":{
		"body":"bool IsLogicalSlot(const char* name)\r\n{\r\n    bool ret = false;\r\n\r\n    LWLockAcquire(ReplicationSlotControlLock, LW_SHARED);\r\n    for (int i = 0; i < g_instance.attr.attr_storage.max_replication_slots; i++) {\r\n        ReplicationSlot* s = &t_thrd.slot_cxt.ReplicationSlotCtl->replication_slots[i];\r\n\r\n        if (s->in_use && strcmp(name, NameStr(s->data.name)) == 0 && s->data.database != InvalidOid) {\r\n            ret = true;\r\n            break;\r\n        }\r\n    }\r\n    LWLockRelease(ReplicationSlotControlLock);\r\n\r\n    return ret;\r\n}",
		"comment":"/* Determine if it is a logical slot */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"IsLogicalSlot"
	},
	"IsPrimaryStandByReadyToRemoteRead":{
		"body":"bool IsPrimaryStandByReadyToRemoteRead(void)\r\n{\r\n    /* only using  IS_DN_DUMMY_STANDYS_MODE && PRIMARY_MODE */\r\n    bool can_remte_read = false;\r\n\r\n    for (int i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile WalSnd* walsnd = &t_thrd.walsender_cxt.WalSndCtl->walsnds[i];\r\n\r\n        if (walsnd->pid == 0 || t_thrd.walsender_cxt.MyWalSnd == walsnd)\r\n            continue;\r\n\r\n        SpinLockAcquire(&walsnd->mutex);\r\n        SndRole sndrole = walsnd->sendRole;\r\n        DbState peer_state = walsnd->peer_state;\r\n        SpinLockRelease(&walsnd->mutex);\r\n\r\n        if (sndrole == SNDROLE_PRIMARY_STANDBY) {\r\n            if (peer_state == NORMAL_STATE || peer_state == CATCHUP_STATE) {\r\n                can_remte_read = true;\r\n            }\r\n\r\n            break;\r\n        }\r\n    }\r\n\r\n    return can_remte_read;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"IsPrimaryStandByReadyToRemoteRead"
	},
	"IsWalSenderToBuild":{
		"body":"static bool IsWalSenderToBuild(void)\r\n{\r\n    WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n    bool isWalToBuild = false;\r\n    if (walsnd == NULL) {\r\n        return false;\r\n    }\r\n    SpinLockAcquire(&walsnd->mutex);\r\n    SndRole sndrole = walsnd->sendRole;\r\n    ThreadId pid = walsnd->pid;\r\n    if (sndrole == SNDROLE_PRIMARY_BUILDSTANDBY && pid != 0) {\r\n        isWalToBuild = true;\r\n    }\r\n    SpinLockRelease(&walsnd->mutex);\r\n\r\n    return isWalToBuild;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"IsWalSenderToBuild"
	},
	"LogCtrlCalculateCurrentRTO":{
		"body":"static void LogCtrlCalculateCurrentRTO(StandbyReplyMessage* reply)\r\n{\r\n    volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n    long sec_to_time;\r\n    int microsec_to_time;\r\n    if (XLByteLT(reply->receive, reply->flush) || XLByteLT(reply->flush, reply->apply) ||\r\n        XLByteLT(reply->flush, walsnd->log_ctrl.prev_flush) || XLByteLT(reply->apply, walsnd->log_ctrl.prev_apply)) {\r\n        return;\r\n    }\r\n\r\n    uint64 part1 = reply->receive - reply->flush;\r\n    uint64 part2 = reply->flush - reply->apply;\r\n    uint64 part1_diff = reply->flush - walsnd->log_ctrl.prev_flush;\r\n    uint64 part2_diff = reply->apply - walsnd->log_ctrl.prev_apply;\r\n    if (walsnd->log_ctrl.prev_reply_time == 0) {\r\n        return;\r\n    }\r\n\r\n    TimestampDifference(walsnd->log_ctrl.prev_reply_time, reply->sendTime, &sec_to_time, &microsec_to_time);\r\n    long millisec_time_diff = sec_to_time * MILLISECONDS_PER_SECONDS + microsec_to_time / MILLISECONDS_PER_MICROSECONDS;\r\n    if (millisec_time_diff <= 0) {\r\n        return;\r\n    }\r\n\r\n    /*\r\n     * consumeRatePart1 and consumeRatePart2 is based on 7/8 previous_speed(walsnd->log_ctrl.pre_rate1) and 1/8\r\n     * speed_now(part1_diff / millisec_time_diff). To be more precise and keep more decimal point, we expand speed_now\r\n     * by multiply first then divide, which is (8 * previous_speed * 7/8 + speed_now) / 8.\r\n     */\r\n    if (walsnd->log_ctrl.pre_rate1 != 0) {\r\n        walsnd->log_ctrl.pre_rate1 =\r\n            LogCtrlCountBigSpeed(walsnd->log_ctrl.pre_rate1, (uint64)(part1_diff / millisec_time_diff));\r\n    } else {\r\n        walsnd->log_ctrl.pre_rate1 = ((part1_diff / (uint64)millisec_time_diff) << SHIFT_SPEED);\r\n    }\r\n    if (walsnd->log_ctrl.pre_rate2 != 0) {\r\n        walsnd->log_ctrl.pre_rate2 =\r\n            LogCtrlCountBigSpeed(walsnd->log_ctrl.pre_rate2, (uint64)(part2_diff / millisec_time_diff));\r\n    } else {\r\n        walsnd->log_ctrl.pre_rate2 = ((uint64)(part2_diff / millisec_time_diff) << SHIFT_SPEED);\r\n    }\r\n\r\n    uint64 consumeRatePart1 = (walsnd->log_ctrl.pre_rate1 >> SHIFT_SPEED);\r\n    uint64 consumeRatePart2 = (walsnd->log_ctrl.pre_rate2 >> SHIFT_SPEED);\r\n    if (consumeRatePart1 == 0 || consumeRatePart2 == 0) {\r\n        return;\r\n    }\r\n\r\n    uint64 sec_RTO_part1 = (part1 / consumeRatePart1) / MILLISECONDS_PER_SECONDS;\r\n    uint64 sec_RTO_part2 = ((part1 + part2) / consumeRatePart2) / MILLISECONDS_PER_SECONDS;\r\n    uint64 sec_RTO = sec_RTO_part1 > sec_RTO_part2 ? sec_RTO_part1 : sec_RTO_part2;\r\n    walsnd->log_ctrl.prev_RTO = walsnd->log_ctrl.current_RTO;\r\n    walsnd->log_ctrl.current_RTO = sec_RTO;\r\n    g_instance.rto_cxt.rto_standby_data[walsnd->index].current_rto = walsnd->log_ctrl.current_RTO;\r\n    ereport(DEBUG4,\r\n        (errmodule(MOD_RTO),\r\n            errmsg(\"The RTO estimated is = : %lu seconds. reply->reveive is %lu, reply->flush is %lu, \"\r\n                   \"reply->apply is %lu, pre_flush is %lu, pre_apply is %lu, TimestampDifference is %ld, \"\r\n                   \"consumeRatePart1 is %lu, consumeRatePart2 is %lu\",\r\n                sec_RTO,\r\n                reply->receive,\r\n                reply->flush,\r\n                reply->apply,\r\n                walsnd->log_ctrl.prev_flush,\r\n                walsnd->log_ctrl.prev_apply,\r\n                millisec_time_diff,\r\n                consumeRatePart1,\r\n                consumeRatePart2)));\r\n}",
		"comment":"/*\r\n * Estimate the time standby need to flush and apply log.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"LogCtrlCalculateCurrentRTO"
	},
	"LogCtrlCalculateSleepTime":{
		"body":"static void LogCtrlCalculateSleepTime(void)\r\n{\r\n    volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n    if (walsnd->log_ctrl.prev_RTO < 0) {\r\n        walsnd->log_ctrl.prev_RTO = walsnd->log_ctrl.current_RTO;\r\n        return;\r\n    }\r\n\r\n    int targetRTO = u_sess->attr.attr_storage.target_rto;\r\n    int64 currentRTO = walsnd->log_ctrl.current_RTO;\r\n    int64 gap = currentRTO - targetRTO;\r\n    int64 prev_gap = walsnd->log_ctrl.prev_RTO - targetRTO;\r\n    int64 gap_diff = gap - prev_gap;\r\n    int64 sleepTime = walsnd->log_ctrl.sleep_time;\r\n    /* use for rto log */\r\n    int64 pre_time = walsnd->log_ctrl.sleep_time;\r\n\r\n    /* mark balance sleep time */\r\n    if (abs(gap_diff) <= (targetRTO / FAULT_TOLERANCE)) {\r\n        walsnd->log_ctrl.balance_sleep_time = sleepTime;\r\n        ereport(DEBUG4,\r\n            (errmodule(MOD_RTO),\r\n                errmsg(\"The balance time for log control is : %ld microseconds\", walsnd->log_ctrl.balance_sleep_time)));\r\n    }\r\n\r\n    /* rto balance, currentRTO close to targetRTO */\r\n    if (abs(gap) <= (targetRTO / FAULT_TOLERANCE)) {\r\n        if (walsnd->log_ctrl.balance_sleep_time != 0) {\r\n            walsnd->log_ctrl.sleep_time = walsnd->log_ctrl.balance_sleep_time;\r\n        } else {\r\n            sleepTime -= SLEEP_LESS;\r\n            walsnd->log_ctrl.sleep_time = (sleepTime >= 0) ? sleepTime : 0;\r\n        }\r\n    }\r\n\r\n    /* need more sleep, currentRTO larger than targetRTO\r\n     *  get bigger, but no more than 1s\r\n     */\r\n    if (gap > (targetRTO / FAULT_TOLERANCE)) {\r\n        sleepTime += SLEEP_MORE;\r\n        walsnd->log_ctrl.sleep_time = (sleepTime < 1 * MICROSECONDS_PER_SECONDS) ? sleepTime : MICROSECONDS_PER_SECONDS;\r\n    }\r\n\r\n    /* need less sleep, currentRTO less than targetRTO */\r\n    if (gap < -(targetRTO / FAULT_TOLERANCE)) {\r\n        sleepTime -= SLEEP_LESS;\r\n        walsnd->log_ctrl.sleep_time = (sleepTime >= 0) ? sleepTime : 0;\r\n    }\r\n    /* log control take effect */\r\n    if (pre_time == 0 && walsnd->log_ctrl.sleep_time != 0) {\r\n        ereport(LOG,\r\n            (errmodule(MOD_RTO),\r\n                errmsg(\"Log control take effect, target_rto is %d, current_rto is %ld, current the sleep time is %ld \"\r\n                       \"microseconds\",\r\n                    u_sess->attr.attr_storage.target_rto,\r\n                    walsnd->log_ctrl.current_RTO,\r\n                    walsnd->log_ctrl.sleep_time)));\r\n    }\r\n    /* log control take does not effect */\r\n    if (pre_time != 0 && walsnd->log_ctrl.sleep_time == 0) {\r\n        ereport(LOG,\r\n            (errmodule(MOD_RTO),\r\n                errmsg(\"Log control does not take effect, target_rto is %d, current_rto is %ld, current the sleep time \"\r\n                       \"is %ld microseconds\",\r\n                    u_sess->attr.attr_storage.target_rto,\r\n                    walsnd->log_ctrl.current_RTO,\r\n                    walsnd->log_ctrl.sleep_time)));\r\n    }\r\n    ereport(DEBUG4,\r\n        (errmodule(MOD_RTO),\r\n            errmsg(\"The sleep time for log control is : %ld microseconds\", walsnd->log_ctrl.sleep_time)));\r\n}",
		"comment":"/*\r\n * If current RTO is less than target_rto, primary need less sleep.\r\n * If current RTO is more than target_rto, primary need more sleep.\r\n * If current RTO equals to target_rto, primary will sleep according to balance_sleep to maintain rto.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"LogCtrlCalculateSleepTime"
	},
	"LogCtrlCountBigSpeed":{
		"body":"static inline uint64 LogCtrlCountBigSpeed(uint64 originSpeed, uint64 curSpeed)\r\n{\r\n    uint64 updateSpeed = (((originSpeed << SHIFT_SPEED) - originSpeed) >> SHIFT_SPEED) + curSpeed;\r\n    return updateSpeed;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"LogCtrlCountBigSpeed"
	},
	"LogCtrlCountSleepLimit":{
		"body":"static void LogCtrlCountSleepLimit(void)\r\n{\r\n    volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n    int64 sleep_count_limit_count;\r\n    if (walsnd->log_ctrl.sleep_time == 0) {\r\n        sleep_count_limit_count = MAX_CONTROL_REPLY;\r\n    } else {\r\n        sleep_count_limit_count = INIT_CONTROL_REPLY * MICROSECONDS_PER_SECONDS / walsnd->log_ctrl.sleep_time;\r\n        sleep_count_limit_count =\r\n            (sleep_count_limit_count > MAX_CONTROL_REPLY) ? MAX_CONTROL_REPLY : sleep_count_limit_count;\r\n    }\r\n    if (sleep_count_limit_count <= 0) {\r\n        sleep_count_limit_count = INIT_CONTROL_REPLY;\r\n    }\r\n    walsnd->log_ctrl.sleep_count_limit = sleep_count_limit_count;\r\n}",
		"comment":"/*\r\n * Count the limit for sleep_count, it is based on sleep time.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"LogCtrlCountSleepLimit"
	},
	"LogCtrlSleep":{
		"body":"static void LogCtrlSleep(void)\r\n{\r\n    volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n    if (walsnd->log_ctrl.sleep_time > 0 && walsnd->log_ctrl.sleep_time <= MICROSECONDS_PER_SECONDS) {\r\n        pg_usleep(walsnd->log_ctrl.sleep_time);\r\n    } else if (walsnd->log_ctrl.sleep_time > MICROSECONDS_PER_SECONDS) {\r\n        pg_usleep(MICROSECONDS_PER_SECONDS);\r\n        walsnd->log_ctrl.sleep_time = MICROSECONDS_PER_SECONDS;\r\n    }\r\n    g_instance.rto_cxt.rto_standby_data[walsnd->index].current_sleep_time = walsnd->log_ctrl.sleep_time;\r\n}",
		"comment":"/*\r\n * Update the sleep time for primary.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"LogCtrlSleep"
	},
	"LogicalSlotSleepFlag":{
		"body":"static bool LogicalSlotSleepFlag(void)\r\n{\r\n    const int xlog_offset = 24;\r\n    const int sleep_time_unit = 100000;\r\n    int64 max_keep_log_seg = (int64)g_instance.attr.attr_storage.max_keep_log_seg;\r\n    if (max_keep_log_seg <= 0) {\r\n        return false;\r\n    }\r\n    XLogRecPtr min_restart_lsn = InvalidXLogRecPtr;\r\n    for (int i = 0; i < g_instance.attr.attr_storage.max_replication_slots; i++) {\r\n        ReplicationSlot* s = &t_thrd.slot_cxt.ReplicationSlotCtl->replication_slots[i];\r\n\r\n        if (s->in_use && s->data.database != InvalidOid) {\r\n            min_restart_lsn = min_restart_lsn == InvalidXLogRecPtr ? s->data.restart_lsn :\r\n                Min(min_restart_lsn, s->data.restart_lsn);\r\n        }\r\n    }\r\n    if (min_restart_lsn == InvalidXLogRecPtr) {\r\n        return false;\r\n    }\r\n    XLogRecPtr flush_lsn = GetFlushRecPtr();\r\n    if (((flush_lsn - min_restart_lsn) >> xlog_offset) > (uint64)max_keep_log_seg) {\r\n        g_logical_slot_sleep_time += sleep_time_unit;\r\n        if (g_logical_slot_sleep_time > MICROSECONDS_PER_SECONDS) {\r\n            g_logical_slot_sleep_time = MICROSECONDS_PER_SECONDS;\r\n        }\r\n        ereport(LOG,\r\n            (errmsg(\"flush_lsn %X/%X exceed min_restart_lsn %X/%X by threshold %ld, sleep time increase by 0.1s.\\n\",\r\n                (uint32)(flush_lsn >> 32),\r\n                (uint32)flush_lsn,\r\n                (uint32)(min_restart_lsn >> 32),\r\n                (uint32)min_restart_lsn,\r\n                max_keep_log_seg)));\r\n        return true;\r\n    } else {\r\n        g_logical_slot_sleep_time = 0;\r\n    }\r\n    return false;\r\n}",
		"comment":"/*\r\n * When flush_lsn exceeds min_restart_lsn by a margin of max_keep_log_seg,\r\n * walsender stream limitation is triggered.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"LogicalSlotSleepFlag"
	},
	"PhysicalConfirmReceivedLocation":{
		"body":"static void PhysicalConfirmReceivedLocation(XLogRecPtr lsn)\r\n{\r\n    bool changed = false;\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile ReplicationSlot* slot = t_thrd.slot_cxt.MyReplicationSlot;\r\n\r\n    Assert(!XLByteEQ(lsn, InvalidXLogRecPtr));\r\n    /* not update in boundary */\r\n    if (lsn % XLogSegSize == 0) {\r\n        return;\r\n    }\r\n    SpinLockAcquire(&slot->mutex);\r\n    if (!XLByteEQ(slot->data.restart_lsn, lsn)) {\r\n        changed = true;\r\n        slot->data.restart_lsn = lsn;\r\n    }\r\n    SpinLockRelease(&slot->mutex);\r\n\r\n    if (changed) {\r\n        ReplicationSlotMarkDirty();\r\n        ReplicationSlotsComputeRequiredLSN(NULL);\r\n    }\r\n\r\n    /*\r\n     * One could argue that the slot should saved to disk now, but that'd be\r\n     * energy wasted - the worst lost information can do here is give us wrong\r\n     * information in a statistics view - we'll just potentially be more\r\n     * conservative in removing files.\r\n     */\r\n}",
		"comment":"/*\r\n * Remember that a walreceiver just confirmed receipt of lsn `lsn`.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"PhysicalConfirmReceivedLocation"
	},
	"PhysicalReplicationSlotNewXmin":{
		"body":"static void PhysicalReplicationSlotNewXmin(TransactionId feedbackXmin)\r\n{\r\n    bool changed = false;\r\n    volatile ReplicationSlot* slot = t_thrd.slot_cxt.MyReplicationSlot;\r\n\r\n    SpinLockAcquire(&slot->mutex);\r\n    t_thrd.pgxact->xmin = InvalidTransactionId;\r\n    /*\r\n     * For physical replication we don't need the the interlock provided\r\n     * by xmin and effective_xmin since the consequences of a missed increase\r\n     * are limited to query cancellations, so set both at once.\r\n     */\r\n    if (!TransactionIdIsNormal(slot->data.xmin) || !TransactionIdIsNormal(feedbackXmin) ||\r\n        TransactionIdPrecedes(slot->data.xmin, feedbackXmin)) {\r\n        changed = true;\r\n        slot->data.xmin = feedbackXmin;\r\n        slot->effective_xmin = feedbackXmin;\r\n    }\r\n    SpinLockRelease(&slot->mutex);\r\n\r\n    if (changed) {\r\n        ReplicationSlotMarkDirty();\r\n        ReplicationSlotsComputeRequiredXmin(false);\r\n    }\r\n}",
		"comment":"/* compute new replication slot xmin horizon if needed */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"PhysicalReplicationSlotNewXmin"
	},
	"ProcessRepliesIfAny":{
		"body":"static void ProcessRepliesIfAny(void)\r\n{\r\n    unsigned char firstchar;\r\n    int r;\r\n    bool received = false;\r\n\r\n    for (;;) {\r\n        r = pq_getbyte_if_available(&firstchar);\r\n        if (r < 0) {\r\n            /* unexpected error or EOF */\r\n            ereport(COMMERROR, (errcode(ERRCODE_PROTOCOL_VIOLATION), errmsg(\"unexpected EOF on standby connection\")));\r\n            proc_exit(0);\r\n        }\r\n        if (r == 0) {\r\n            /* no data available without blocking */\r\n            break;\r\n        }\r\n\r\n        /* Handle the very limited subset of commands expected in this phase */\r\n        switch (firstchar) {\r\n                /*\r\n                 * 'd' means a standby reply wrapped in a CopyData packet.\r\n                 */\r\n            case 'd':\r\n                ProcessStandbyMessage();\r\n                received = true;\r\n                break;\r\n\r\n                /*\r\n                 * 'X' means that the standby is closing down the socket.\r\n                 */\r\n            case 'c':\r\n            case 'X':\r\n                proc_exit(0);\r\n                /* fall-through */\r\n            default:\r\n                ereport(FATAL,\r\n                    (errcode(ERRCODE_PROTOCOL_VIOLATION), errmsg(\"invalid standby message type \\\"%c\\\"\", firstchar)));\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Save the last reply timestamp if we've received at least one reply.\r\n     */\r\n    if (received) {\r\n        t_thrd.walsender_cxt.last_reply_timestamp = GetCurrentTimestamp();\r\n        t_thrd.walsender_cxt.waiting_for_ping_response = false;\r\n    } else {\r\n        TimestampTz now = GetCurrentTimestamp();\r\n        /* Check for replication timeout. */\r\n        WalSndCheckTimeOut(now);\r\n        /* Send keepalive if the time has come. */\r\n        WalSndKeepaliveIfNecessary(now);\r\n    }\r\n}",
		"comment":"/*\r\n * Check if the remote end has closed the connection.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"ProcessRepliesIfAny"
	},
	"ProcessStandbyFileTimeMessage":{
		"body":"static void ProcessStandbyFileTimeMessage(void)\r\n{\r\n    ConfigModifyTimeMessage reply_modify_file_time;\r\n    struct stat statbuf;\r\n\r\n    pq_copymsgbytes(\r\n        t_thrd.walsender_cxt.reply_message, (char*)&reply_modify_file_time, sizeof(ConfigModifyTimeMessage));\r\n    if (lstat(t_thrd.walsender_cxt.gucconf_file, &statbuf) != 0) {\r\n        if (errno != ENOENT)\r\n            ereport(ERROR,\r\n                (errcode_for_file_access(),\r\n                    errmsg(\"could not stat file or directory \\\"%s\\\": %m\", t_thrd.walsender_cxt.gucconf_file)));\r\n    }\r\n    if (reply_modify_file_time.config_modify_time != statbuf.st_mtime) {\r\n        ereport(LOG, (errmsg(\"the config file has been modified, so send it to the standby\")));\r\n        (void)SendConfigFile(t_thrd.walsender_cxt.gucconf_file);\r\n    } else\r\n        ereport(LOG, (errmsg(\"the config file has no change\")));\r\n}",
		"comment":"/*\r\n * Regular request from standby to send config file.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"ProcessStandbyFileTimeMessage"
	},
	"ProcessStandbyHSFeedbackMessage":{
		"body":"static void ProcessStandbyHSFeedbackMessage(void)\r\n{\r\n    StandbyHSFeedbackMessage reply;\r\n    TransactionId nextXid;\r\n\r\n    /* Decipher the reply message */\r\n    pq_copymsgbytes(t_thrd.walsender_cxt.reply_message, (char*)&reply, sizeof(StandbyHSFeedbackMessage));\r\n\r\n    ereport(DEBUG2, (errmsg(\"hot standby feedback xmin \" XID_FMT, reply.xmin)));\r\n\r\n    /* Ignore invalid xmin (can't actually happen with current walreceiver) */\r\n    if (!TransactionIdIsNormal(reply.xmin)) {\r\n        if (t_thrd.slot_cxt.MyReplicationSlot != NULL)\r\n            PhysicalReplicationSlotNewXmin(reply.xmin);\r\n        return;\r\n    }\r\n    nextXid = ReadNewTransactionId();\r\n    if (!TransactionIdPrecedesOrEquals(reply.xmin, nextXid)) {\r\n        /* epoch OK, but it's wrapped around */\r\n        return;\r\n    }\r\n\r\n    /*\r\n     * Set the WalSender's xmin equal to the standby's requested xmin, so that\r\n     * the xmin will be taken into account by GetOldestXmin.  This will hold\r\n     * back the removal of dead rows and thereby prevent the generation of\r\n     * cleanup conflicts on the standby server.\r\n     *\r\n     * There is a small window for a race condition here: although we just\r\n     * checked that reply.xmin precedes nextXid, the nextXid could have gotten\r\n     * advanced between our fetching it and applying the xmin below, perhaps\r\n     * far enough to make reply.xmin wrap around.  In that case the xmin we\r\n     * set here would be \"in the future\" and have no effect.  No point in\r\n     * worrying about this since it's too late to save the desired data\r\n     * anyway.	Assuming that the standby sends us an increasing sequence of\r\n     * xmins, this could only happen during the first reply cycle, else our\r\n     * own xmin would prevent nextXid from advancing so far.\r\n     *\r\n     * We don't bother taking the ProcArrayLock here.  Setting the xmin field\r\n     * is assumed atomic, and there's no real need to prevent a concurrent\r\n     * GetOldestXmin.  (If we're moving our xmin forward, this is obviously\r\n     * safe, and if we're moving it backwards, well, the data is at risk\r\n     * already since a VACUUM could have just finished calling GetOldestXmin.)\r\n     */\r\n    /* If we're using a replication slot we reserve the xmin via that,\r\n     * otherwise via the walsender's PGXACT entry.\r\n\r\n     * XXX: It might make sense to introduce ephemeral slots and always use\r\n     * the slot mechanism.\r\n     */\r\n    /* XXX: persistency configurable? */\r\n    if (t_thrd.slot_cxt.MyReplicationSlot != NULL) {\r\n        PhysicalReplicationSlotNewXmin(reply.xmin);\r\n    } else {\r\n        t_thrd.pgxact->xmin = reply.xmin;\r\n    }\r\n}",
		"comment":"/*\r\n * Hot Standby feedback\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"ProcessStandbyHSFeedbackMessage"
	},
	"ProcessStandbyMessage":{
		"body":"static void ProcessStandbyMessage(void)\r\n{\r\n    char msgtype;\r\n\r\n    resetStringInfo(t_thrd.walsender_cxt.reply_message);\r\n\r\n    /*\r\n     * Read the message contents.\r\n     */\r\n    if (pq_getmessage(t_thrd.walsender_cxt.reply_message, 0)) {\r\n        ereport(COMMERROR, (errcode(ERRCODE_PROTOCOL_VIOLATION), errmsg(\"unexpected EOF on standby connection\")));\r\n        proc_exit(0);\r\n    }\r\n\r\n    /*\r\n     * Check message type from the first byte.\r\n     */\r\n    msgtype = pq_getmsgbyte(t_thrd.walsender_cxt.reply_message);\r\n\r\n    switch (msgtype) {\r\n        case 'r':\r\n            ProcessStandbyReplyMessage();\r\n            break;\r\n\r\n        case 'h':\r\n            ProcessStandbyHSFeedbackMessage();\r\n            break;\r\n\r\n        case 's':\r\n            ProcessStandbySwitchRequestMessage();\r\n            break;\r\n\r\n        case 'A':\r\n            ProcessStandbyFileTimeMessage();\r\n            break;\r\n\r\n        default:\r\n            ereport(\r\n                COMMERROR, (errcode(ERRCODE_PROTOCOL_VIOLATION), errmsg(\"unexpected message type \\\"%d\\\"\", msgtype)));\r\n            proc_exit(0);\r\n    }\r\n}",
		"comment":"/*\r\n * Process a status update message received from standby.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"ProcessStandbyMessage"
	},
	"ProcessStandbyReplyMessage":{
		"body":"static void ProcessStandbyReplyMessage(void)\r\n{\r\n    StandbyReplyMessage reply;\r\n    XLogRecPtr sndFlush = InvalidXLogRecPtr;\r\n    int rc;\r\n    pq_copymsgbytes(t_thrd.walsender_cxt.reply_message, (char*)&reply, sizeof(StandbyReplyMessage));\r\n\r\n    ereport(DEBUG2,\r\n        (errmsg(\"receive %X/%X write %X/%X flush %X/%X apply %X/%X\",\r\n            (uint32)(reply.receive >> 32),\r\n            (uint32)reply.receive,\r\n            (uint32)(reply.write >> 32),\r\n            (uint32)reply.write,\r\n            (uint32)(reply.flush >> 32),\r\n            (uint32)reply.flush,\r\n            (uint32)(reply.apply >> 32),\r\n            (uint32)reply.apply)));\r\n\r\n    /* send a reply if the standby requested one */\r\n    if (reply.replyRequested) {\r\n        WalSndKeepalive(false);\r\n    }\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n    if (IS_PGXC_DATANODE) {\r\n        char* standby_name = (char*)(g_instance.rto_cxt.rto_standby_data[walsnd->index].id);\r\n        rc = strncpy_s(standby_name,\r\n            NODENAMELEN,\r\n            u_sess->attr.attr_common.application_name,\r\n            strlen(u_sess->attr.attr_common.application_name));\r\n        securec_check(rc, \"\\0\", \"\\0\");\r\n        if (u_sess->attr.attr_storage.target_rto == 0) {\r\n            g_instance.rto_cxt.rto_standby_data[walsnd->index].current_sleep_time = 0;\r\n        } else {\r\n            g_instance.rto_cxt.rto_standby_data[walsnd->index].current_sleep_time = walsnd->log_ctrl.sleep_time;\r\n        }\r\n        if (g_instance.rto_cxt.rto_standby_data[walsnd->index].target_rto != u_sess->attr.attr_storage.target_rto) {\r\n            ereport(LOG,\r\n                (errmodule(MOD_RTO),\r\n                    errmsg(\"target_rto changes to %d, previous target_rto is %d, current the sleep time is %ld\",\r\n                        u_sess->attr.attr_storage.target_rto,\r\n                        g_instance.rto_cxt.rto_standby_data[walsnd->index].target_rto,\r\n                        g_instance.rto_cxt.rto_standby_data[walsnd->index].current_sleep_time)));\r\n\r\n            g_instance.rto_cxt.rto_standby_data[walsnd->index].target_rto = u_sess->attr.attr_storage.target_rto;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Update shared state for this WalSender process based on reply data from\r\n     * standby.\r\n     */\r\n    {\r\n        SpinLockAcquire(&walsnd->mutex);\r\n        walsnd->receive = reply.receive;\r\n        walsnd->write = reply.write;\r\n        walsnd->flush = reply.flush;\r\n        walsnd->apply = reply.apply;\r\n        walsnd->peer_role = reply.peer_role;\r\n        walsnd->peer_state = reply.peer_state;\r\n        SpinLockRelease(&walsnd->mutex);\r\n    }\r\n\r\n    /*\r\n     * Only sleep when local role is not WAL_DB_SENDER.\r\n     */\r\n    if (!AM_WAL_DB_SENDER) {\r\n        if (IS_PGXC_DATANODE && walsnd->log_ctrl.sleep_count % walsnd->log_ctrl.sleep_count_limit == 0) {\r\n            LogCtrlCalculateCurrentRTO(&reply);\r\n            walsnd->log_ctrl.prev_reply_time = reply.sendTime;\r\n            walsnd->log_ctrl.prev_flush = reply.flush;\r\n            walsnd->log_ctrl.prev_apply = reply.apply;\r\n        }\r\n        do_actual_sleep(walsnd);\r\n    }\r\n    if (!AM_WAL_STANDBY_SENDER) {\r\n        SyncRepReleaseWaiters();\r\n    }\r\n\r\n    /*\r\n     * Advance our local xmin horizon when the client confirmed a flush.\r\n     */\r\n    if (t_thrd.slot_cxt.MyReplicationSlot && (!XLByteEQ(reply.flush, InvalidXLogRecPtr))) {\r\n        if (t_thrd.slot_cxt.MyReplicationSlot->data.database != InvalidOid) {\r\n            LogicalConfirmReceivedLocation(reply.flush);\r\n        } else {\r\n            PhysicalConfirmReceivedLocation(reply.flush);\r\n        }\r\n    }\r\n\r\n    if (AM_WAL_STANDBY_SENDER) {\r\n        sndFlush = GetFlushRecPtr();\r\n        WalSndRefreshPercentCountStartLsn(sndFlush, reply.flush);\r\n    }\r\n}",
		"comment":"/*\r\n * Regular reply from standby advising of WAL positions on standby server.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"ProcessStandbyReplyMessage"
	},
	"ProcessStandbySwitchRequestMessage":{
		"body":"static void ProcessStandbySwitchRequestMessage(void)\r\n{\r\n    int i;\r\n    StandbySwitchRequestMessage message;\r\n\r\n    pq_copymsgbytes(t_thrd.walsender_cxt.reply_message, (char*)&message, sizeof(StandbySwitchRequestMessage));\r\n\r\n    if (message.demoteMode < SmartDemote || message.demoteMode > FastDemote) {\r\n        ereport(\r\n            WARNING, (errmsg(\"invalid switchover mode in standby switchover request message: %d\", message.demoteMode)));\r\n        return;\r\n    }\r\n\r\n    SpinLockAcquire(&t_thrd.walsender_cxt.WalSndCtl->mutex);\r\n\r\n    /*\r\n     * If the catchup thread is alive, we must stop the demoting process\r\n     * at once. There will be some risk of losting data when catchup can't send the data pages.\r\n     */\r\n    if (catchup_online) {\r\n        volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n        ClusterNodeState old_mode = walsnd->node_state;\r\n\r\n        walsnd->node_state = NODESTATE_PRIMARY_DEMOTING_WAIT_CATCHUP;\r\n        WalSndResponseSwitchover(t_thrd.walsender_cxt.output_xlog_message);\r\n        walsnd->node_state = old_mode;\r\n\r\n        SpinLockRelease(&t_thrd.walsender_cxt.WalSndCtl->mutex);\r\n        ereport(NOTICE, (errmsg(\"could not continuing switchover process when catchup is alive.\")));\r\n        return;\r\n    }\r\n\r\n    if (t_thrd.walsender_cxt.WalSndCtl->demotion > NoDemote &&\r\n        t_thrd.walsender_cxt.Demotion != t_thrd.walsender_cxt.WalSndCtl->demotion) {\r\n        SpinLockRelease(&t_thrd.walsender_cxt.WalSndCtl->mutex);\r\n        ereport(NOTICE, (errmsg(\"master is doing switchover,\\\r\n						 probably another standby already requested switchover.\")));\r\n        return;\r\n    } else if (message.demoteMode <= t_thrd.walsender_cxt.Demotion) {\r\n        SpinLockRelease(&t_thrd.walsender_cxt.WalSndCtl->mutex);\r\n        ereport(NOTICE,\r\n            (errmsg(\"the standby already requested %s switchover, so ignore new %s switchover request.\",\r\n                DemoteModeDesc(t_thrd.walsender_cxt.Demotion),\r\n                DemoteModeDesc(message.demoteMode))));\r\n        return;\r\n    }\r\n\r\n    t_thrd.walsender_cxt.WalSndCtl->demotion = (DemoteMode)message.demoteMode;\r\n\r\n    /* update the demote state */\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n        volatile WalSnd* walsnd = &t_thrd.walsender_cxt.WalSndCtl->walsnds[i];\r\n\r\n        if (walsnd->pid == 0) {\r\n            continue;\r\n        }\r\n\r\n        walsnd->node_state = NODESTATE_PRIMARY_DEMOTING;\r\n    }\r\n    t_thrd.walsender_cxt.MyWalSnd->node_state = (ClusterNodeState)message.demoteMode;\r\n\r\n    SpinLockRelease(&t_thrd.walsender_cxt.WalSndCtl->mutex);\r\n\r\n    t_thrd.walsender_cxt.Demotion = (DemoteMode)message.demoteMode;\r\n    ereport(\r\n        LOG, (errmsg(\"received %s switchover request from standby\", DemoteModeDesc(t_thrd.walsender_cxt.Demotion))));\r\n\r\n    SendPostmasterSignal(PMSIGNAL_DEMOTE_PRIMARY);\r\n}",
		"comment":"/*\r\n * process message from standby request primary server making switchover.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"ProcessStandbySwitchRequestMessage"
	},
	"SendConfigFile":{
		"body":"static bool SendConfigFile(char* path)\r\n{\r\n    FILE* fp = NULL;\r\n    char* buf = NULL;\r\n    int nread = 0;\r\n    int len = 0;\r\n    struct stat statbuf;\r\n    ConfFileLock filelock = {NULL, 0};\r\n    ConfigModifyTimeMessage msgConfigTime;\r\n    errno_t errorno = EOK;\r\n\r\n    if (AmWalSenderToDummyStandby() || AmWalSenderOnDummyStandby())\r\n        return true;\r\n\r\n    if (lstat(path, &statbuf) < 0 || statbuf.st_size == 0) {\r\n        ereport(LOG, (errcode_for_file_access(), errmsg(\"could not stat file or directory \\\"%s\\\": %m\", path)));\r\n        return false;\r\n    }\r\n    if (get_file_lock(t_thrd.walsender_cxt.gucconf_lock_file, &filelock) != CODE_OK) {\r\n        ereport(LOG, (errmsg(\"get lock failed when send gaussdb config file to the peer.\")));\r\n        return false;\r\n    }\r\n    if ((fp = fopen(path, \"rb\")) == NULL) {\r\n        release_file_lock(&filelock);\r\n        ereport(LOG, (errmsg(\"could not open file or directory \\\"%s\\\": %m\", path)));\r\n        return false;\r\n    }\r\n    len = 1 + sizeof(ConfigModifyTimeMessage) + statbuf.st_size;\r\n    buf = (char*)palloc0(len);\r\n    buf[0] = 'm';\r\n    msgConfigTime.config_modify_time = statbuf.st_mtime;\r\n    errorno = memcpy_s(\r\n        buf + 1, sizeof(ConfigModifyTimeMessage) + statbuf.st_size, &msgConfigTime, sizeof(ConfigModifyTimeMessage));\r\n    securec_check(errorno, \"\\0\", \"\\0\");\r\n    nread = (int)fread(buf + 1 + sizeof(ConfigModifyTimeMessage), 1, statbuf.st_size, fp);\r\n    if (nread != statbuf.st_size) {\r\n        release_file_lock(&filelock);\r\n        (void)fclose(fp);\r\n        pfree(buf);\r\n        buf = NULL;\r\n        ereport(LOG, (errcode_for_file_access(), errmsg(\"could not read gaussdb config file: %m\")));\r\n        return false;\r\n    }\r\n    if (fclose(fp) != 0)\r\n        ereport(LOG, (errmsg(\"walsender close the file or directory error\\\"%s\\\": %m\", path)));\r\n    release_file_lock(&filelock);\r\n    /* Send the chunk as a CopyData message */\r\n    (void)pq_putmessage_noblock('d', buf, 1 + sizeof(ConfigModifyTimeMessage) + nread);\r\n    pfree(buf);\r\n    buf = NULL;\r\n    ereport(LOG, (errmsg(\"walsender send config file size :%d\", (int)(1 + sizeof(ConfigModifyTimeMessage) + nread))));\r\n    return true;\r\n}",
		"comment":"/* send config file to standby */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"SendConfigFile"
	},
	"SetHaWalSenderChannel":{
		"body":"static void SetHaWalSenderChannel()\r\n{\r\n    struct sockaddr* laddr = (struct sockaddr*)&(u_sess->proc_cxt.MyProcPort->laddr.addr);\r\n    struct sockaddr* raddr = (struct sockaddr*)&(u_sess->proc_cxt.MyProcPort->raddr.addr);\r\n    char local_ip[IP_LEN] = {0};\r\n    char remote_ip[IP_LEN] = {0};\r\n    volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n    char* result = NULL;\r\n    errno_t rc = 0;\r\n\r\n    if (laddr->sa_family == AF_INET6) {\r\n        result = inet_net_ntop(AF_INET6, &((struct sockaddr_in*)laddr)->sin_addr, 128, local_ip, IP_LEN);\r\n        if (result == NULL) {\r\n            ereport(WARNING, (errmsg(\"inet_net_ntop failed\")));\r\n        }\r\n    } else if (laddr->sa_family == AF_INET) {\r\n        result = inet_net_ntop(AF_INET, &((struct sockaddr_in*)laddr)->sin_addr, 32, local_ip, IP_LEN);\r\n        if (result == NULL) {\r\n            ereport(WARNING, (errmsg(\"inet_net_ntop failed\")));\r\n        }\r\n    }\r\n\r\n    if (raddr->sa_family == AF_INET6) {\r\n        result = inet_net_ntop(AF_INET6, &((struct sockaddr_in*)raddr)->sin_addr, 128, remote_ip, IP_LEN);\r\n        if (result == NULL) {\r\n            ereport(WARNING, (errmsg(\"inet_net_ntop failed\")));\r\n        }\r\n    } else if (raddr->sa_family == AF_INET) {\r\n        result = inet_net_ntop(AF_INET, &((struct sockaddr_in*)raddr)->sin_addr, 32, remote_ip, IP_LEN);\r\n        if (result == NULL) {\r\n            ereport(WARNING, (errmsg(\"inet_net_ntop failed\")));\r\n        }\r\n    }\r\n\r\n    SpinLockAcquire(&walsnd->mutex);\r\n    rc = strncpy_s((char*)walsnd->wal_sender_channel.localhost, IP_LEN, local_ip, IP_LEN - 1);\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n    walsnd->wal_sender_channel.localhost[IP_LEN - 1] = '\\0';\r\n    walsnd->wal_sender_channel.localport = ntohs(((struct sockaddr_in*)laddr)->sin_port);\r\n    rc = strncpy_s((char*)walsnd->wal_sender_channel.remotehost, IP_LEN, remote_ip, IP_LEN - 1);\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n    walsnd->wal_sender_channel.remotehost[IP_LEN - 1] = '\\0';\r\n    walsnd->wal_sender_channel.remoteport = ntohs(((struct sockaddr_in*)raddr)->sin_port);\r\n    SpinLockRelease(&walsnd->mutex);\r\n\r\n    /* for log control view. */\r\n    if (IS_PGXC_DATANODE) {\r\n        g_instance.rto_cxt.rto_standby_data[walsnd->index].source_port = walsnd->wal_sender_channel.localport;\r\n        g_instance.rto_cxt.rto_standby_data[walsnd->index].dest_port = walsnd->wal_sender_channel.remoteport;\r\n\r\n        char* localip = (char*)(g_instance.rto_cxt.rto_standby_data[walsnd->index].source_ip);\r\n        rc = strncpy_s(localip, IP_LEN, local_ip, IP_LEN - 1);\r\n        securec_check(rc, \"\\0\", \"\\0\");\r\n        g_instance.rto_cxt.rto_standby_data[walsnd->index].source_ip[IP_LEN - 1] = '\\0';\r\n\r\n        char* remoteip = (char*)(g_instance.rto_cxt.rto_standby_data[walsnd->index].dest_ip);\r\n        rc = strncpy_s(remoteip, IP_LEN, remote_ip, IP_LEN - 1);\r\n        securec_check(rc, \"\\0\", \"\\0\");\r\n        g_instance.rto_cxt.rto_standby_data[walsnd->index].dest_ip[IP_LEN - 1] = '\\0';\r\n    }\r\n}",
		"comment":"/*\r\n * Save the current connect channel of the walsender in walsnd.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"SetHaWalSenderChannel"
	},
	"SetReplWalSender":{
		"body":"static void SetReplWalSender(void)\r\n{\r\n    volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n\r\n    SpinLockAcquire(&walsnd->mutex);\r\n    walsnd->replSender = true;\r\n    SpinLockRelease(&walsnd->mutex);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"SetReplWalSender"
	},
	"SetWalSndPeerDbstate":{
		"body":"static void SetWalSndPeerDbstate(DbState state)\r\n{\r\n    volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n\r\n    SpinLockAcquire(&walsnd->mutex);\r\n    walsnd->peer_state = state;\r\n    SpinLockRelease(&walsnd->mutex);\r\n}",
		"comment":"/* Set walsnd peer_state */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"SetWalSndPeerDbstate"
	},
	"SetWalSndPeerMode":{
		"body":"static void SetWalSndPeerMode(ServerMode mode)\r\n{\r\n    volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n\r\n    SpinLockAcquire(&walsnd->mutex);\r\n    walsnd->peer_role = mode;\r\n    SpinLockRelease(&walsnd->mutex);\r\n}",
		"comment":"/* Set walsnd peer_mode */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"SetWalSndPeerMode"
	},
	"StandbyOrSecondaryIsAlive":{
		"body":"void StandbyOrSecondaryIsAlive(void)\r\n{\r\n    /*\r\n     * When the standby promote to primary wrongfully, and the old primary is\r\n     * alive, the new primary maybe overwrite the same name file on the dfs;\r\n     * At this moment, only one primary that the secondary is connected can\r\n     * commit transaction, so another primary that no standby or secondary is\r\n     * connected will report an ERROR to rollback transaction.\r\n     */\r\n    if (!(t_thrd.postmaster_cxt.HaShmData->current_mode == NORMAL_MODE ||\r\n            WalSndInProgress(SNDROLE_PRIMARY_STANDBY | SNDROLE_PRIMARY_DUMMYSTANDBY)))\r\n        ereport(LOG,\r\n            (errmsg(\"No standby or secondary is connected, a new dfs file \"\r\n                    \"can not be created\")));\r\n}",
		"comment":"/*\r\n * Check if there is any standby or secondeary alive through walsnd.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"StandbyOrSecondaryIsAlive"
	},
	"StartLogicalReplication":{
		"body":"static void StartLogicalReplication(StartReplicationCmd* cmd)\r\n{\r\n    StringInfoData buf;\r\n\r\n    /* make sure that our requirements are still fulfilled */\r\n    CheckLogicalDecodingRequirements(u_sess->proc_cxt.MyDatabaseId);\r\n\r\n    Assert(!t_thrd.slot_cxt.MyReplicationSlot);\r\n\r\n    ReplicationSlotAcquire(cmd->slotname, AmWalSenderToDummyStandby() ? true : false);\r\n\r\n    /*\r\n     * Force a disconnect, so that the decoding code doesn't need to care\r\n     * about a eventual switch from running in recovery, to running in a\r\n     * normal environment. Client code is expected to handle reconnects.\r\n     */\r\n    if (AM_WAL_STANDBY_SENDER && !RecoveryInProgress()) {\r\n        ereport(LOG, (errmsg(\"terminating walsender process after promotion\")));\r\n        t_thrd.walsender_cxt.walsender_ready_to_stop = true;\r\n    }\r\n\r\n    {\r\n        /*\r\n         * Rebuild snap dir\r\n         */\r\n        char snappath[MAXPGPATH];\r\n        struct stat st;\r\n        int rc = 0;\r\n\r\n        rc = snprintf_s(snappath,\r\n            MAXPGPATH,\r\n            MAXPGPATH - 1,\r\n            \"pg_replslot/%s/snap\",\r\n            NameStr(t_thrd.slot_cxt.MyReplicationSlot->data.name));\r\n        securec_check_ss(rc, \"\\0\", \"\\0\");\r\n\r\n        if (stat(snappath, &st) == 0 && S_ISDIR(st.st_mode)) {\r\n            if (!rmtree(snappath, true))\r\n                ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not remove directory \\\"%s\\\"\", snappath)));\r\n        }\r\n        if (mkdir(snappath, S_IRWXU) < 0)\r\n            ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not create directory \\\"%s\\\": %m\", snappath)));\r\n    }\r\n\r\n    WalSndSetState(WALSNDSTATE_CATCHUP);\r\n\r\n    /* Send a CopyBothResponse message, and start streaming */\r\n    pq_beginmessage(&buf, 'W');\r\n    pq_sendbyte(&buf, 0);\r\n    pq_sendint(&buf, 0, 2);\r\n    pq_endmessage(&buf);\r\n    pq_flush();\r\n\r\n    /*\r\n     * Initialize position to the last ack'ed one, then the xlog records begin\r\n     * to be shipped from that position.\r\n     */\r\n    t_thrd.walsender_cxt.logical_decoding_ctx = CreateDecodingContext(\r\n        cmd->startpoint, cmd->options, false, logical_read_xlog_page, WalSndPrepareWrite, WalSndWriteData);\r\n\r\n    /* Start reading WAL from the oldest required WAL. */\r\n    t_thrd.walsender_cxt.logical_startptr = t_thrd.slot_cxt.MyReplicationSlot->data.restart_lsn;\r\n\r\n    /*\r\n     * Report the location after which we'll send out further commits as the\r\n     * current sentPtr.\r\n     */\r\n    t_thrd.walsender_cxt.sentPtr = t_thrd.slot_cxt.MyReplicationSlot->data.confirmed_flush;\r\n\r\n    /* Also update the sent position status in shared memory */\r\n    {\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n\r\n        SpinLockAcquire(&walsnd->mutex);\r\n        walsnd->sentPtr = t_thrd.slot_cxt.MyReplicationSlot->data.restart_lsn;\r\n        SpinLockRelease(&walsnd->mutex);\r\n    }\r\n\r\n    replication_active = true;\r\n\r\n    SyncRepInitConfig();\r\n\r\n    /* Main loop of walsender */\r\n    WalSndLoop(XLogSendLogical);\r\n\r\n    FreeDecodingContext(t_thrd.walsender_cxt.logical_decoding_ctx);\r\n    ReplicationSlotRelease();\r\n\r\n    replication_active = false;\r\n    if (t_thrd.walsender_cxt.walsender_ready_to_stop)\r\n        proc_exit(0);\r\n    WalSndSetState(WALSNDSTATE_STARTUP);\r\n\r\n    /* Get out of COPY mode (CommandComplete). */\r\n    EndCommand(\"COPY 0\", DestRemote);\r\n}",
		"comment":"/*\r\n * Load previously initiated logical slot and prepare for sending data (via\r\n * WalSndLoop).\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"StartLogicalReplication"
	},
	"StartReplication":{
		"body":"static void StartReplication(StartReplicationCmd* cmd)\r\n{\r\n    StringInfoData buf;\r\n\r\n    /*\r\n     * When promoting a cascading standby, postmaster sends SIGUSR2 to any\r\n     * cascading walsenders to kill them. But there is a corner-case where\r\n     * such walsender fails to receive SIGUSR2 and survives a standby\r\n     * promotion unexpectedly. This happens when postmaster sends SIGUSR2\r\n     * before the walsender marks itself as a WAL sender, because postmaster\r\n     * sends SIGUSR2 to only the processes marked as a WAL sender.\r\n     *\r\n     * To avoid this corner-case, if recovery is NOT in progress even though\r\n     * the walsender is cascading one, we do the same thing as SIGUSR2 signal\r\n     * handler does, i.e., set t_thrd.walsender_cxt.walsender_ready_to_stop to true. Which causes\r\n     * the walsender to end later.\r\n     *\r\n     * When terminating cascading walsenders, usually postmaster writes the\r\n     * log message announcing the terminations. But there is a race condition\r\n     * here. If there is no walsender except this process before reaching\r\n     * here, postmaster thinks that there is no walsender and suppresses that\r\n     * log message. To handle this case, we always emit that log message here.\r\n     * This might cause duplicate log messages, but which is less likely to\r\n     * happen, so it's not worth writing some code to suppress them.\r\n     */\r\n    if (AM_WAL_STANDBY_SENDER && !RecoveryInProgress()) {\r\n        ereport(LOG,\r\n            (errmsg(\"terminating walsender process to force cascaded standby \"\r\n                    \"to update timeline and reconnect\")));\r\n        t_thrd.walsender_cxt.walsender_ready_to_stop = true;\r\n    }\r\n\r\n    /*\r\n     * We assume here that we're logging enough information in the WAL for\r\n     * log-shipping, since this is checked in PostmasterMain().\r\n     *\r\n     * NOTE: wal_level can only change at shutdown, so in most cases it is\r\n     * difficult for there to be WAL data that we can still see that was\r\n     * written at wal_level='minimal'.\r\n     */\r\n    if (cmd->slotname) {\r\n        ReplicationSlotAcquire(cmd->slotname, AmWalSenderToDummyStandby() ? true : false);\r\n        if (t_thrd.slot_cxt.MyReplicationSlot->data.database != InvalidOid)\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\r\n                    (errmsg(\"cannot use a logical replication slot for physical replication\"))));\r\n    }\r\n\r\n    /*\r\n     * When we first start replication the standby will be behind the primary.\r\n     * For some applications, for example, synchronous replication, it is\r\n     * important to have a clear state for this initial catchup mode, so we\r\n     * can trigger actions when we change streaming state later. We may stay\r\n     * in this state for a long time, which is exactly why we want to be able\r\n     * to monitor whether or not we are still here.\r\n     */\r\n    WalSndSetState(WALSNDSTATE_CATCHUP);\r\n\r\n    /* Send a CopyBothResponse message, and start streaming */\r\n    pq_beginmessage(&buf, 'W');\r\n    pq_sendbyte(&buf, 0);\r\n    pq_sendint16(&buf, 0);\r\n    pq_endmessage_noblock(&buf);\r\n    pq_flush_timedwait(u_sess->attr.attr_storage.wal_sender_timeout);\r\n\r\n    /*\r\n     * Initialize position to the received one, then the xlog records begin to\r\n     * be shipped from that position\r\n     */\r\n    if (AmWalSenderToDummyStandby())\r\n        ChooseStartPointForDummyStandby();\r\n    else {\r\n        t_thrd.walsender_cxt.sentPtr = cmd->startpoint;\r\n        WalSndSetPercentCountStartLsn(cmd->startpoint);\r\n    }\r\n}",
		"comment":"/*\r\n * START_REPLICATION\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"StartReplication"
	},
	"StopAliveBuildSender":{
		"body":"static void StopAliveBuildSender(void)\r\n{\r\n    for (int i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile WalSnd* walsnd = &t_thrd.walsender_cxt.WalSndCtl->walsnds[i];\r\n        SndRole sndrole;\r\n\r\n        if (walsnd->pid == 0 || t_thrd.walsender_cxt.MyWalSnd == walsnd)\r\n            continue;\r\n\r\n        SpinLockAcquire(&walsnd->mutex);\r\n        sndrole = walsnd->sendRole;\r\n        SpinLockRelease(&walsnd->mutex);\r\n\r\n        /* skip the last cycle using SIGTERM */\r\n        if (sndrole == SNDROLE_PRIMARY_BUILDSTANDBY)\r\n            (void)gs_signal_send(walsnd->pid, SIGTERM);\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"StopAliveBuildSender"
	},
	"UpdateHaWalSenderChannel":{
		"body":"static bool UpdateHaWalSenderChannel(int ha_remote_listen_port)\r\n{\r\n    volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n    bool is_found = false;\r\n    int i = 0;\r\n\r\n    for (i = 1; i < MAX_REPLNODE_NUM; i++) {\r\n        ReplConnInfo* replconninfo = t_thrd.postmaster_cxt.ReplConnArray[i];\r\n        if (replconninfo == NULL)\r\n            continue;\r\n\r\n        if (strncmp((char*)replconninfo->remotehost, (char*)walsnd->wal_sender_channel.remotehost, IP_LEN) == 0 &&\r\n            replconninfo->remoteport == ha_remote_listen_port) {\r\n            SpinLockAcquire(&walsnd->mutex);\r\n            walsnd->channel_get_replc = i;\r\n            walsnd->wal_sender_channel.localservice = replconninfo->localservice;\r\n            walsnd->wal_sender_channel.remoteservice = replconninfo->remoteservice;\r\n            SpinLockRelease(&walsnd->mutex);\r\n            is_found = true;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (is_found)\r\n        ereport(LOG, (errmsg(\"current repl of walsender is %d.\", i)));\r\n\r\n    return is_found;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"UpdateHaWalSenderChannel"
	},
	"WSDataSendInit":{
		"body":"static void WSDataSendInit()\r\n{\r\n    /*\r\n     * Allocate buffer that will be used for each output message.  We do this\r\n     * just once to reduce palloc overhead.  The buffer must be made large\r\n     * enough for maximum-sized messages.\r\n     */\r\n    if (!g_instance.attr.attr_storage.enable_mix_replication)\r\n        t_thrd.walsender_cxt.output_xlog_message =\r\n            (char*)palloc(1 + sizeof(WalDataMessageHeader) + (int)WS_MAX_SEND_SIZE);\r\n    else {\r\n        t_thrd.walsender_cxt.output_xlog_msg_prefix_len =\r\n            1 + sizeof(WalDataMessageHeader) + sizeof(uint32) + 1 + sizeof(XLogRecPtr);\r\n        t_thrd.walsender_cxt.output_xlog_message =\r\n            (char*)palloc(t_thrd.walsender_cxt.output_xlog_msg_prefix_len + (int)WS_MAX_SEND_SIZE);\r\n        t_thrd.walsender_cxt.output_data_message = (char*)palloc(\r\n            1 + sizeof(WalDataPageMessageHeader) + sizeof(uint32) + 1 + sizeof(XLogRecPtr) * 2 + (int)WS_MAX_SEND_SIZE);\r\n        t_thrd.walsender_cxt.output_data_msg_cur_len = 0;\r\n        t_thrd.walsender_cxt.load_cu_buffer = (char*)palloc(t_thrd.walsender_cxt.load_cu_buffer_size);\r\n\r\n        InitWalSndXLogReader();\r\n\r\n        t_thrd.walsender_cxt.wsXLogJustSendRegion->start_ptr = InvalidXLogRecPtr;\r\n        t_thrd.walsender_cxt.wsXLogJustSendRegion->end_ptr = InvalidXLogRecPtr;\r\n    }\r\n\r\n    return;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WSDataSendInit"
	},
	"WSXLogPageRead":{
		"body":"static int WSXLogPageRead(XLogReaderState* xlogreader, XLogRecPtr targetPagePtr, int reqLen, XLogRecPtr targetRecPtr,\r\n    char* readBuf, TimeLineID* pageTLI)\r\n{\r\n    WSXLogPageReadPrivate* ws_private = (WSXLogPageReadPrivate*)xlogreader->private_data;\r\n    uint32 targetPageOff;\r\n    int nRetCode = 0;\r\n    char xlogfile[MAXFNAMELEN];\r\n    char xlogfpath[MAXPGPATH];\r\n\r\n    if (ws_private == NULL) {\r\n        Assert(false);\r\n        ereport(WARNING, (errmsg(\"The WAL Streaming XLog Reader Private Info is NULL.\")));\r\n        return -1;\r\n    }\r\n\r\n    if (ws_private->xlogreadfd >= 0 && !XLByteInSeg(targetPagePtr, ws_private->xlogreadlogsegno)) {\r\n        (void)close(ws_private->xlogreadfd);\r\n        ws_private->xlogreadfd = -1;\r\n    }\r\n\r\n    XLByteToSeg(targetPagePtr, ws_private->xlogreadlogsegno);\r\n\r\n    if (ws_private->xlogreadfd < 0) {\r\n        XLogFileName(xlogfile, ws_private->tli, ws_private->xlogreadlogsegno);\r\n\r\n        nRetCode = snprintf_s(xlogfpath, MAXPGPATH, MAXPGPATH - 1, XLOGDIR \"/%s\", xlogfile);\r\n        securec_check_ss(nRetCode, \"\\0\", \"\\0\");\r\n\r\n        ws_private->xlogreadfd = BasicOpenFile(xlogfpath, O_RDONLY | PG_BINARY, 0);\r\n\r\n        if (ws_private->xlogreadfd < 0) {\r\n            ereport(DEBUG2, (errmsg(\"could not open the xlog file %s: %s.\", xlogfpath, gs_strerror(errno))));\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    targetPageOff = targetPagePtr % XLogSegSize;\r\n\r\n    /* Read the requested page */\r\n    if (lseek(ws_private->xlogreadfd, (off_t)targetPageOff, SEEK_SET) < 0) {\r\n        Assert(false);\r\n        ereport(WARNING,\r\n            (errmsg(\"could not seek %u bytes in the file %s: %s.\", targetPageOff, xlogfpath, gs_strerror(errno))));\r\n        return -1;\r\n    }\r\n\r\n    if (read(ws_private->xlogreadfd, readBuf, XLOG_BLCKSZ) != XLOG_BLCKSZ) {\r\n        Assert(false);\r\n        ereport(WARNING,\r\n            (errmsg(\"could not read the request %d bytes in the xlog file %s: %s.\",\r\n                reqLen,\r\n                xlogfpath,\r\n                gs_strerror(errno))));\r\n        return -1;\r\n    }\r\n\r\n    *pageTLI = ws_private->tli;\r\n    return XLOG_BLCKSZ;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WSXLogPageRead"
	},
	"WalGetSyncCountWindow":{
		"body":"XLogSegNo WalGetSyncCountWindow(void)\r\n{\r\n    return (XLogSegNo)(uint32)u_sess->attr.attr_storage.wal_keep_segments;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalGetSyncCountWindow"
	},
	"WalSegmentsRemovedChecker":{
		"body":"AlarmCheckResult WalSegmentsRemovedChecker(Alarm* alarm, AlarmAdditionalParam* additionalParam)\r\n{\r\n    if (WalSegmemtRemovedhappened == true) {\r\n        // fill the alarm message\r\n        WriteAlarmAdditionalInfo(additionalParam,\r\n            g_instance.attr.attr_common.PGXCNodeName,\r\n            \"\",\r\n            \"\",\r\n            alarm,\r\n            ALM_AT_Fault,\r\n            g_instance.attr.attr_common.PGXCNodeName);\r\n        return ALM_ACR_Abnormal;\r\n    } else {\r\n        // fill the alarm message\r\n        WriteAlarmAdditionalInfo(\r\n            additionalParam, g_instance.attr.attr_common.PGXCNodeName, \"\", \"\", alarm, ALM_AT_Resume);\r\n        return ALM_ACR_Normal;\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSegmentsRemovedChecker"
	},
	"WalSenderMain":{
		"body":"int WalSenderMain(void)\r\n{\r\n    MemoryContext walsnd_context;\r\n    int nRet = 0;\r\n\r\n    t_thrd.proc_cxt.MyProgName = \"WalSender\";\r\n    if (RecoveryInProgress()) {\r\n        t_thrd.role = WAL_STANDBY_SENDER;\r\n    }\r\n\r\n    if (g_threadPoolControler) {\r\n        ereport(INFO, (errmsg(\"Try to bind walsender thread to available CPUs in threadpool.\")));\r\n        g_threadPoolControler->BindThreadToAllAvailCpu(t_thrd.proc_cxt.MyProcPid);\r\n    }\r\n\r\n    /* Create a per-walsender data structure in shared memory */\r\n    InitWalSnd();\r\n\r\n    ereport(LOG, (errmsg(\"walsender thread started\")));\r\n    /*\r\n     * Create a memory context that we will do all our work in.  We do this so\r\n     * that we can reset the context during error recovery and thereby avoid\r\n     * possible memory leaks.  Formerly this code just ran in\r\n     * t_thrd.top_mem_cxt, but resetting that would be a really bad idea.\r\n     *\r\n     * XXX: we don't actually attempt error recovery in walsender, we just\r\n     * close the connection and exit.\r\n     */\r\n    walsnd_context = AllocSetContextCreate(t_thrd.top_mem_cxt,\r\n        \"Wal Sender\",\r\n        ALLOCSET_DEFAULT_MINSIZE,\r\n        ALLOCSET_DEFAULT_INITSIZE,\r\n        ALLOCSET_DEFAULT_MAXSIZE);\r\n    (void)MemoryContextSwitchTo(walsnd_context);\r\n\r\n    /* Set up resource owner */\r\n    t_thrd.utils_cxt.CurrentResourceOwner = ResourceOwnerCreate(NULL, \"walsender top-level resource owner\");\r\n\r\n    /*\r\n     * Let postmaster know that we're streaming. Once we've declared us as a\r\n     * WAL sender process, postmaster will let us outlive the bgwriter and\r\n     * kill us last in the shutdown sequence, so we get a chance to stream all\r\n     * remaining WAL at shutdown, including the shutdown checkpoint. Note that\r\n     * there's no going back, and we mustn't write any WAL records after this.\r\n     */\r\n    MarkPostmasterChildWalSender();\r\n    SendPostmasterSignal(PMSIGNAL_ADVANCE_STATE_MACHINE);\r\n\r\n    /* Unblock signals (they were blocked when the postmaster forked us) */\r\n    gs_signal_setmask(&t_thrd.libpq_cxt.UnBlockSig, NULL);\r\n\r\n    /*\r\n     * Use the recovery target timeline ID during recovery\r\n     */\r\n    if (AM_WAL_STANDBY_SENDER)\r\n        t_thrd.xlog_cxt.ThisTimeLineID = GetRecoveryTargetTLI();\r\n\r\n    if (dummyStandbyMode) {\r\n        ShutdownWalRcv();\r\n        t_thrd.xlog_cxt.ThisTimeLineID = GetRecoveryTargetTLI();\r\n        t_thrd.xlog_cxt.recoveryTargetTLI = GetRecoveryTargetTLI();\r\n        ereport(LOG, (errmsg(\"ThisTimeLineID: %u\", t_thrd.xlog_cxt.ThisTimeLineID)));\r\n    }\r\n\r\n    /* Tell the standby that walsender is ready for receiving commands */\r\n    ReadyForQuery_noblock(DestRemote, u_sess->attr.attr_storage.wal_sender_timeout);\r\n\r\n    if (t_thrd.postmaster_cxt.HaShmData)\r\n        t_thrd.walsender_cxt.server_run_mode = t_thrd.postmaster_cxt.HaShmData->current_mode;\r\n\r\n    SetHaWalSenderChannel();\r\n    /* Handle handshake messages before streaming */\r\n    WalSndHandshake();\r\n\r\n    /* Initialize shared memory status */\r\n    {\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n\r\n        SpinLockAcquire(&walsnd->mutex);\r\n        walsnd->pid = t_thrd.proc_cxt.MyProcPid;\r\n#ifndef WIN32\r\n        walsnd->lwpId = syscall(SYS_gettid);\r\n#else\r\n        walsnd->lwpId = (int)t_thrd.proc_cxt.MyProcPid\r\n#endif\r\n\r\n        if (AM_WAL_DB_SENDER) {\r\n            /* logical replication */\r\n            walsnd->sentPtr = t_thrd.slot_cxt.MyReplicationSlot->data.restart_lsn;\r\n        } else {\r\n            /* physical replication */\r\n            walsnd->sentPtr = t_thrd.walsender_cxt.sentPtr;\r\n        }\r\n\r\n        SpinLockRelease(&walsnd->mutex);\r\n\r\n        if (walsnd->sendRole == SNDROLE_PRIMARY_DUMMYSTANDBY) {\r\n            pgstat_report_appname(\"WalSender to Secondary\");\r\n        } else if (walsnd->sendRole == SNDROLE_PRIMARY_BUILDSTANDBY) {\r\n            pgstat_report_appname(\"WalSender to Build\");\r\n        } else if (walsnd->sendRole == SNDROLE_PRIMARY_STANDBY) {\r\n            pgstat_report_appname(\"WalSender to Standby\");\r\n        }\r\n    }\r\n\r\n    SyncRepInitConfig();\r\n\r\n    if (t_thrd.proc_cxt.DataDir) {\r\n        nRet = snprintf_s(\r\n            t_thrd.walsender_cxt.gucconf_file, MAXPGPATH, MAXPGPATH - 1, \"%s/postgresql.conf\", t_thrd.proc_cxt.DataDir);\r\n        securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n\r\n        nRet = snprintf_s(t_thrd.walsender_cxt.gucconf_lock_file,\r\n            MAXPGPATH,\r\n            MAXPGPATH - 1,\r\n            \"%s/postgresql.conf.lock\",\r\n            t_thrd.proc_cxt.DataDir);\r\n        securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n    } else {\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_PROTOCOL_VIOLATION),\r\n                errmsg_internal(\"cannot find GAUSSDATA: %s\", t_thrd.walsender_cxt.gucconf_file)));\r\n    }\r\n\r\n    /* init the dummy standby data num to write in wal streaming. */\r\n    if (g_instance.attr.attr_storage.enable_mix_replication && dummyStandbyMode)\r\n        InitWSDataNumOnDummyStandby();\r\n\r\n    if (g_instance.attr.attr_storage.enable_mix_replication && !u_sess->attr.attr_storage.enable_cbm_tracking)\r\n        ereport(PANIC, (errmsg(\"enable_cbm_tracking must be turn on when enable_mix_replication is on!\")));\r\n\r\n    /* Main loop of walsender */\r\n    if (AM_WAL_DB_SENDER)\r\n        return WalSndLoop(XLogSendLogical);\r\n    else\r\n        return WalSndLoop(XLogSendPhysical);\r\n}",
		"comment":"/* Main entry point for walsender process */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSenderMain"
	},
	"WalSndAllInProgress":{
		"body":"bool WalSndAllInProgress(int type)\r\n{\r\n    int i;\r\n    int num = 0;\r\n    int all_num = t_thrd.syncrep_cxt.SyncRepConfig->nmembers;\r\n\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile WalSnd* walsnd = &t_thrd.walsender_cxt.WalSndCtl->walsnds[i];\r\n        SpinLockAcquire(&walsnd->mutex);\r\n        if (walsnd->pid != 0 && walsnd->pid != t_thrd.proc_cxt.MyProcPid &&\r\n            ((walsnd->sendRole & type) == walsnd->sendRole)) {\r\n            num++;\r\n        }\r\n        SpinLockRelease(&walsnd->mutex);\r\n    }\r\n    if (num >= all_num) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}",
		"comment":"/* check if there is all wal sender in type status. */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndAllInProgress"
	},
	"WalSndCaughtup":{
		"body":"static bool WalSndCaughtup(void)\r\n{\r\n    int i;\r\n\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile WalSnd* walsnd = &t_thrd.walsender_cxt.WalSndCtl->walsnds[i];\r\n\r\n        SpinLockAcquire(&walsnd->mutex);\r\n\r\n        if (walsnd->pid != 0 && walsnd->sendRole == SNDROLE_PRIMARY_STANDBY && walsnd->state == WALSNDSTATE_STREAMING) {\r\n            SpinLockRelease(&walsnd->mutex);\r\n\r\n            return true;\r\n        }\r\n\r\n        SpinLockRelease(&walsnd->mutex);\r\n    }\r\n\r\n    return false;\r\n}",
		"comment":"/* return true if any standby(except dummy standby) caught up primary */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndCaughtup"
	},
	"WalSndCheckTimeOut":{
		"body":"static void WalSndCheckTimeOut(TimestampTz now)\r\n{\r\n    TimestampTz timeout;\r\n\r\n    /* don't bail out if we're doing something that doesn't require timeouts */\r\n    if (u_sess->attr.attr_storage.wal_sender_timeout <= 0 || t_thrd.walsender_cxt.last_reply_timestamp <= 0) {\r\n        return;\r\n    }\r\n\r\n    /*\r\n     * Use static last_reply_time to avoid call GetHeartbeatLastReplyTimestamp frequently\r\n     * when t_thrd.walsender_cxt.last_reply_timestamp has meet the timeout condition\r\n     * but last heartbeat time doesn't.\r\n     */\r\n    static TimestampTz last_reply_time = t_thrd.walsender_cxt.last_reply_timestamp;\r\n    /* t_thrd.walsender_cxt.last_reply_timestamp newer */\r\n    if (timestamptz_cmp_internal(t_thrd.walsender_cxt.last_reply_timestamp, last_reply_time) > 0) {\r\n        last_reply_time = t_thrd.walsender_cxt.last_reply_timestamp;\r\n    }\r\n\r\n    timeout = CalculateTimeout(last_reply_time);\r\n    if (now < timeout) {\r\n        return;\r\n    }\r\n\r\n    TimestampTz heartbeat = GetHeartbeatLastReplyTimestamp();\r\n    /* If heartbeat newer, use heartbeat to recalculate timeout. */\r\n    if (timestamptz_cmp_internal(heartbeat, last_reply_time) > 0) {\r\n        last_reply_time = heartbeat;\r\n        timeout = CalculateTimeout(last_reply_time);\r\n    }\r\n\r\n    if (heartbeat != 0 && now >= timeout) {\r\n        /*\r\n         * Since typically expiration of replication timeout means\r\n         * communication problem, we don't send the error message to the\r\n         * standby.\r\n         */\r\n        ereport(ERROR,\r\n            (errmsg(\"terminating Walsender process due to replication timeout.\"\r\n                    \"now time(%s) timeout time(%s) last recv time(%s) heartbeat time(%s)\",\r\n                timestamptz_to_str(now),\r\n                timestamptz_to_str(timeout),\r\n                timestamptz_to_str(last_reply_time),\r\n                timestamptz_to_str(heartbeat))));\r\n        WalSndShutdown();\r\n    }\r\n}",
		"comment":"/*\r\n * Check if time since last receive from standby has reached the\r\n * configured limit.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndCheckTimeOut"
	},
	"WalSndComputeSleeptime":{
		"body":"static long WalSndComputeSleeptime(TimestampTz now)\r\n{\r\n    /*\r\n     * Formally, sleep time is set according to wal sender timeout.\r\n     * Time is too long and sender can only be waked up when latch\r\n     * is set, resulting in poor performance. Here reduced to 1s.\r\n     */\r\n    long sleeptime = 1000;\r\n\r\n    if (u_sess->attr.attr_storage.wal_sender_timeout > 0 && t_thrd.walsender_cxt.last_reply_timestamp > 0) {\r\n        TimestampTz wakeup_time;\r\n        long sec_to_timeout;\r\n        int microsec_to_timeout;\r\n\r\n        /*\r\n         * At the latest stop sleeping once wal_sender_timeout has been\r\n         * reached.\r\n         */\r\n        wakeup_time = TimestampTzPlusMilliseconds(\r\n            t_thrd.walsender_cxt.last_reply_timestamp, u_sess->attr.attr_storage.wal_sender_timeout);\r\n\r\n        /*\r\n         * If no ping has been sent yet, wakeup when it's time to do so.\r\n         * DataSndKeepaliveIfNecessary() wants to send a keepalive once half of\r\n         * the timeout passed without a response.\r\n         */\r\n        if (!t_thrd.walsender_cxt.waiting_for_ping_response)\r\n            wakeup_time = TimestampTzPlusMilliseconds(\r\n                t_thrd.walsender_cxt.last_reply_timestamp, u_sess->attr.attr_storage.wal_sender_timeout / 2);\r\n\r\n        /* Compute relative time until wakeup. */\r\n        TimestampDifference(now, wakeup_time, &sec_to_timeout, &microsec_to_timeout);\r\n\r\n        sleeptime = sec_to_timeout * 1000 + microsec_to_timeout / 1000;\r\n    }\r\n\r\n    return sleeptime;\r\n}",
		"comment":"/*\r\n * Compute how long send/receive loops should sleep.\r\n *\r\n * If wal_sender_timeout is enabled we want to wake up in time to send\r\n * keepalives and to abort the connection if wal_sender_timeout has been\r\n * reached.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndComputeSleeptime"
	},
	"WalSndDummyLEStandby":{
		"body":"static bool WalSndDummyLEStandby(void)\r\n{\r\n    XLogRecPtr flushDummy = InvalidXLogRecPtr;\r\n    XLogRecPtr flushStandby = InvalidXLogRecPtr;\r\n    int i;\r\n\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile WalSnd* walsnd = &t_thrd.walsender_cxt.WalSndCtl->walsnds[i];\r\n\r\n        SpinLockAcquire(&walsnd->mutex);\r\n\r\n        if (walsnd->pid != 0 && walsnd->sendRole == SNDROLE_PRIMARY_STANDBY) {\r\n            flushStandby = walsnd->flush;\r\n        } else if (walsnd->pid != 0 && walsnd->sendRole == SNDROLE_PRIMARY_DUMMYSTANDBY) {\r\n            flushDummy = walsnd->flush;\r\n        }\r\n\r\n        SpinLockRelease(&walsnd->mutex);\r\n    }\r\n\r\n    if (XLByteEQ(flushDummy, InvalidXLogRecPtr) || XLByteEQ(flushStandby, InvalidXLogRecPtr))\r\n        return true;\r\n\r\n    return XLByteLE(flushDummy, flushStandby);\r\n}",
		"comment":"/* return true if standby has flush more xlog than dummy standby */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndDummyLEStandby"
	},
	"WalSndGetStateString":{
		"body":"static const char* WalSndGetStateString(WalSndState state)\r\n{\r\n    switch (state) {\r\n        case WALSNDSTATE_STARTUP:\r\n            return \"Startup\";\r\n        case WALSNDSTATE_BACKUP:\r\n            return \"Backup\";\r\n        case WALSNDSTATE_CATCHUP:\r\n            return \"Catchup\";\r\n        case WALSNDSTATE_STREAMING:\r\n            return \"Streaming\";\r\n    }\r\n    return \"Unknown\";\r\n}",
		"comment":"/*\r\n * Return a string constant representing the state. This is used\r\n * in system views, and should *not* be translated.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndGetStateString"
	},
	"WalSndHandshake":{
		"body":"static void WalSndHandshake(void)\r\n{\r\n    StringInfoData input_message;\r\n    bool replication_started = false;\r\n    int sleeptime = 0;\r\n    int timeout = 0;\r\n    const int TIMEOUT_TIMES = 4;\r\n    volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n\r\n    initStringInfo(&input_message);\r\n\r\n    if (walsnd->sendRole == SNDROLE_PRIMARY_BUILDSTANDBY)\r\n        timeout = TIMEOUT_TIMES * u_sess->attr.attr_storage.wal_sender_timeout;\r\n    else\r\n        timeout = u_sess->attr.attr_storage.wal_sender_timeout;\r\n\r\n    while (!replication_started) {\r\n        int firstchar;\r\n\r\n        WalSndSetState(WALSNDSTATE_STARTUP);\r\n        set_ps_display(\"idle\", false);\r\n        if (t_thrd.walsender_cxt.walsender_ready_to_stop || t_thrd.walsender_cxt.walsender_shutdown_requested) {\r\n            ereport(LOG, (errmsg(\"caught ready to stop or shutdown request\")));\r\n            proc_exit(0);\r\n        }\r\n        /* Wait for some data to arrive */\r\n        if (!pq_select(NAPTIME_PER_CYCLE)) {\r\n            sleeptime += NAPTIME_PER_CYCLE;\r\n\r\n            /*\r\n             * not yet data available without blocking,\r\n             * check if it is under maximum timeout\r\n             * period\r\n             */\r\n            if (timeout > 0 && sleeptime >= timeout) {\r\n                ereport(COMMERROR,\r\n                    (errcode(ERRCODE_PROTOCOL_VIOLATION), errmsg(\"No message received from standby for maximum time\")));\r\n                proc_exit(0);\r\n            }\r\n            continue;\r\n        }\r\n\r\n        sleeptime = 0;\r\n\r\n        /*\r\n         * Since select has indicated that data is available to read,\r\n         * then we can call blocking function itself, as there must be\r\n         * some data to get.\r\n         */\r\n        firstchar = pq_getbyte();\r\n\r\n        /*\r\n         * Emergency bailout if postmaster has died.  This is to avoid the\r\n         * necessity for manual cleanup of all postmaster children.\r\n         */\r\n        if (!PostmasterIsAlive())\r\n            gs_thread_exit(1);\r\n\r\n        /*\r\n         * Check for any other interesting events that happened while we\r\n         * slept.\r\n         */\r\n        if (t_thrd.walsender_cxt.got_SIGHUP) {\r\n            t_thrd.walsender_cxt.got_SIGHUP = false;\r\n            ProcessConfigFile(PGC_SIGHUP);\r\n        }\r\n\r\n        if (firstchar != EOF) {\r\n            /*\r\n             * Read the message contents. This is expected to be done without\r\n             * blocking because we've been able to get message type code.\r\n             */\r\n            if (pq_getmessage(&input_message, 0))\r\n                firstchar = EOF; /* suitable message already logged */\r\n        }\r\n\r\n        /* Handle the very limited subset of commands expected in this phase */\r\n        switch (firstchar) {\r\n            case 'Q': /* Query message */\r\n            {\r\n                const char* query_string = NULL;\r\n\r\n                query_string = pq_getmsgstring(&input_message);\r\n                pq_getmsgend(&input_message);\r\n\r\n                if (HandleWalReplicationCommand(query_string)) {\r\n                    replication_started = true;\r\n                }\r\n            } break;\r\n\r\n            case 'X':\r\n            case 'c':\r\n                /* standby is closing the connection */\r\n                proc_exit(0);\r\n                /* fall-through */\r\n            case 'P':\r\n                /* standby is closing the connection */\r\n                break;\r\n            case EOF:\r\n                /* standby disconnected unexpectedly */\r\n                ereport(\r\n                    COMMERROR, (errcode(ERRCODE_PROTOCOL_VIOLATION), errmsg(\"unexpected EOF on standby connection\")));\r\n                proc_exit(0);\r\n                /* fall-through */\r\n            default:\r\n                ereport(FATAL,\r\n                    (errcode(ERRCODE_PROTOCOL_VIOLATION),\r\n                        errmsg(\"invalid standby handshake message type %d\", firstchar)));\r\n        }\r\n    }\r\n}",
		"comment":"/*\r\n * Execute commands from walreceiver, until we enter streaming mode.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndHandshake"
	},
	"WalSndInProgress":{
		"body":"bool WalSndInProgress(int type)\r\n{\r\n    int i;\r\n\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile WalSnd* walsnd = &t_thrd.walsender_cxt.WalSndCtl->walsnds[i];\r\n\r\n        SpinLockAcquire(&walsnd->mutex);\r\n\r\n        if (walsnd->pid != 0 && walsnd->pid != t_thrd.proc_cxt.MyProcPid &&\r\n            ((walsnd->sendRole & type) == walsnd->sendRole)) {\r\n            SpinLockRelease(&walsnd->mutex);\r\n\r\n            return true;\r\n        }\r\n\r\n        SpinLockRelease(&walsnd->mutex);\r\n    }\r\n\r\n    return false;\r\n}",
		"comment":"/* check if there is any wal sender alive. */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndInProgress"
	},
	"WalSndKeepalive":{
		"body":"static void WalSndKeepalive(bool requestReply)\r\n{\r\n    PrimaryKeepaliveMessage keepalive_message;\r\n    volatile HaShmemData* hashmdata = t_thrd.postmaster_cxt.HaShmData;\r\n    errno_t errorno = EOK;\r\n\r\n    /* Construct a new message */\r\n    SpinLockAcquire(&hashmdata->mutex);\r\n    keepalive_message.peer_role = hashmdata->current_mode;\r\n    SpinLockRelease(&hashmdata->mutex);\r\n    keepalive_message.peer_state = get_local_dbstate();\r\n    keepalive_message.walEnd = t_thrd.walsender_cxt.sentPtr;\r\n    keepalive_message.sendTime = GetCurrentTimestamp();\r\n    keepalive_message.replyRequested = requestReply;\r\n    keepalive_message.catchup = (t_thrd.walsender_cxt.MyWalSnd->state == WALSNDSTATE_CATCHUP);\r\n\r\n    ereport(DEBUG2, (errmsg(\"sending wal replication keepalive\")));\r\n\r\n    /* Prepend with the message type and send it. */\r\n    t_thrd.walsender_cxt.output_xlog_message[0] = 'k';\r\n    errorno = memcpy_s(t_thrd.walsender_cxt.output_xlog_message + 1,\r\n        sizeof(WalDataMessageHeader) + g_instance.attr.attr_storage.MaxSendSize * 1024,\r\n        &keepalive_message,\r\n        sizeof(PrimaryKeepaliveMessage));\r\n    securec_check(errorno, \"\\0\", \"\\0\");\r\n    (void)pq_putmessage_noblock('d', t_thrd.walsender_cxt.output_xlog_message, sizeof(PrimaryKeepaliveMessage) + 1);\r\n\r\n    /* Flush the keepalive message to standby immediately. */\r\n    if (pq_flush_if_writable() != 0)\r\n        WalSndShutdown();\r\n}",
		"comment":"/*\r\n * This function is used to send keepalive message to standby.\r\n * If requestReply is set, sets a flag in the message requesting the standby\r\n * to send a message back to us, for heartbeat purposes.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndKeepalive"
	},
	"WalSndKeepaliveIfNecessary":{
		"body":"static void WalSndKeepaliveIfNecessary(TimestampTz now)\r\n{\r\n    TimestampTz ping_time;\r\n\r\n    /*\r\n     * Don't send keepalive messages if timeouts are globally disabled or\r\n     * we're doing something not partaking in timeouts.\r\n     */\r\n    if (u_sess->attr.attr_storage.wal_sender_timeout <= 0 || t_thrd.walsender_cxt.last_reply_timestamp <= 0)\r\n        return;\r\n\r\n    if (t_thrd.walsender_cxt.waiting_for_ping_response)\r\n        return;\r\n\r\n    /*\r\n     * If half of wal_sender_timeout has lapsed without receiving any reply\r\n     * from the standby, send a keep-alive message to the standby requesting\r\n     * an immediate reply.\r\n     */\r\n    ping_time = TimestampTzPlusMilliseconds(\r\n        t_thrd.walsender_cxt.last_reply_timestamp, u_sess->attr.attr_storage.wal_sender_timeout / 2);\r\n    if (now >= ping_time) {\r\n        WalSndKeepalive(true);\r\n        t_thrd.walsender_cxt.waiting_for_ping_response = true;\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndKeepaliveIfNecessary"
	},
	"WalSndKill":{
		"body":"static void WalSndKill(int code, Datum arg)\r\n{\r\n    WalSnd *walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n\r\n    Assert(walsnd != NULL);\r\n\r\n    /*\r\n     * Clear MyWalSnd first; then disown the latch.  This is so that signal\r\n     * handlers won't try to touch the latch after it's no longer ours.\r\n     */\r\n    t_thrd.walsender_cxt.MyWalSnd = NULL;\r\n\r\n    DisownLatch(&walsnd->latch);\r\n\r\n    if (code > 0) {\r\n        /* Sleep at least 0.1 second to wait for reporting the error to the client */\r\n        pg_usleep(100000L);\r\n    }\r\n\r\n    if (dummyStandbyMode) {\r\n        set_failover_host_conninfo_for_dummy(walsnd->wal_sender_channel.remotehost,\r\n            t_thrd.walsender_cxt.remotePort);\r\n        t_thrd.walsender_cxt.remotePort = 0;\r\n    }\r\n\r\n    /* Mark WalSnd struct no longer in use. */\r\n    WalSndReset(walsnd);\r\n\r\n    /*\r\n     * Here one standby is going down, then check if it was synchronous\r\n     * standby and also there is no more synchronous standby, if yes\r\n     * then wake all waiting transaction and also change the master\r\n     * mode to standalone. Should check lock is held or not already to\r\n     * prevent deadlock. (e.g., fatal occurs when lock held and then\r\n     * re-acquire the same lock when process exits)\r\n     */\r\n    if (LWLockHeldByMe(SyncRepLock)) {\r\n        LWLockRelease(SyncRepLock);\r\n    }\r\n    LWLockAcquire(SyncRepLock, LW_EXCLUSIVE);\r\n    SyncRepCheckSyncStandbyAlive();\r\n    LWLockRelease(SyncRepLock);\r\n\r\n    /* Close open wal file */\r\n    if (t_thrd.walsender_cxt.sendFile >= 0) {\r\n        (void)close(t_thrd.walsender_cxt.sendFile);\r\n        t_thrd.walsender_cxt.sendFile = -1;\r\n    }\r\n\r\n    t_thrd.walsender_cxt.wsXLogJustSendRegion->start_ptr = InvalidXLogRecPtr;\r\n    t_thrd.walsender_cxt.wsXLogJustSendRegion->end_ptr = InvalidXLogRecPtr;\r\n\r\n    ereport(LOG, (errmsg(\"walsender thread shut down\")));\r\n}",
		"comment":"/* Destroy the per-walsender data structure for this walsender process */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndKill"
	},
	"WalSndLastCycleHandler":{
		"body":"static void WalSndLastCycleHandler(SIGNAL_ARGS)\r\n{\r\n    int save_errno = errno;\r\n\r\n    t_thrd.walsender_cxt.walsender_ready_to_stop = true;\r\n    if (t_thrd.walsender_cxt.MyWalSnd)\r\n        SetLatch(&t_thrd.walsender_cxt.MyWalSnd->latch);\r\n\r\n    if (IS_DN_DUMMY_STANDYS_MODE()) {\r\n        if (t_thrd.walsender_cxt.MyWalSnd && !AmWalSenderToDummyStandby() &&\r\n            (t_thrd.walsender_cxt.MyWalSnd->node_state == NODESTATE_PROMOTE_APPROVE ||\r\n                t_thrd.walsender_cxt.MyWalSnd->node_state == NODESTATE_STANDBY_REDIRECT))\r\n            t_thrd.walsender_cxt.response_switchover_requested = true;\r\n    } else {\r\n        if (t_thrd.walsender_cxt.MyWalSnd && t_thrd.walsender_cxt.MyWalSnd->node_state == NODESTATE_PROMOTE_APPROVE)\r\n            t_thrd.walsender_cxt.response_switchover_requested = true;\r\n    }\r\n\r\n    errno = save_errno;\r\n}",
		"comment":"/* SIGUSR2: set flag to do a last cycle and shut down afterwards */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndLastCycleHandler"
	},
	"WalSndLoop":{
		"body":"static int WalSndLoop(WalSndSendDataCallback send_data)\r\n{\r\n    bool first_startup = true;\r\n    bool sync_config_needed = false;\r\n    bool marked_stream_replication = true;\r\n    TimestampTz last_syncconf_timestamp;\r\n\r\n    WSDataSendInit();\r\n\r\n    /*\r\n     * Allocate buffer that will be used for processing reply messages.  As\r\n     * above, do this just once to reduce palloc overhead.\r\n     */\r\n    initStringInfo(t_thrd.walsender_cxt.reply_message);\r\n    initStringInfo(t_thrd.walsender_cxt.tmpbuf);\r\n\r\n    /* Initialize the last reply timestamp */\r\n    t_thrd.walsender_cxt.last_reply_timestamp = GetCurrentTimestamp();\r\n    last_syncconf_timestamp = GetCurrentTimestamp();\r\n    t_thrd.walsender_cxt.last_logical_xlog_advanced_timestamp = GetCurrentTimestamp();\r\n    t_thrd.walsender_cxt.waiting_for_ping_response = false;\r\n\r\n    /* Loop forever, unless we get an error */\r\n    for (;;) {\r\n        TimestampTz now;\r\n\r\n        /* Clear any already-pending wakeups */\r\n        ResetLatch(&t_thrd.walsender_cxt.MyWalSnd->latch);\r\n#ifdef ENABLE_DISTRIBUTE_TEST\r\n        if (TEST_STUB(DN_WALSEND_MAINLOOP, stub_sleep_emit)) {\r\n            ereport(get_distribute_test_param()->elevel,\r\n                (errmsg(\"sleep_emit happen during WalSndLoop  time:%ds, stub_name:%s\",\r\n                    get_distribute_test_param()->sleep_time,\r\n                    get_distribute_test_param()->test_stub_name)));\r\n        }\r\n#endif\r\n\r\n        pgstat_report_activity(STATE_RUNNING, NULL);\r\n\r\n        /*\r\n         * Emergency bailout if postmaster has died.  This is to avoid the\r\n         * necessity for manual cleanup of all postmaster children.\r\n         */\r\n        if (!PostmasterIsAlive())\r\n            gs_thread_exit(1);\r\n\r\n        /* Process any requests or signals received recently */\r\n        if (t_thrd.walsender_cxt.got_SIGHUP) {\r\n            t_thrd.walsender_cxt.got_SIGHUP = false;\r\n            marked_stream_replication = u_sess->attr.attr_storage.enable_stream_replication;\r\n            ProcessConfigFile(PGC_SIGHUP);\r\n            SyncRepInitConfig();\r\n            sync_config_needed = true;\r\n        }\r\n\r\n        /* switchover is forbidden when catchup thread in progress */\r\n        if (catchup_online && t_thrd.walsender_cxt.WalSndCtl->demotion > NoDemote) {\r\n            volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n            SpinLockAcquire(&t_thrd.walsender_cxt.WalSndCtl->mutex);\r\n\r\n            walsnd->node_state = NODESTATE_PRIMARY_DEMOTING_WAIT_CATCHUP;\r\n            WalSndResponseSwitchover(t_thrd.walsender_cxt.output_xlog_message);\r\n\r\n            /* recover node_state and demotion state */\r\n            walsnd->node_state = NODESTATE_NORMAL;\r\n            t_thrd.walsender_cxt.WalSndCtl->demotion = NoDemote;\r\n            t_thrd.walsender_cxt.Demotion = NoDemote;\r\n\r\n            SpinLockRelease(&t_thrd.walsender_cxt.WalSndCtl->mutex);\r\n\r\n            ereport(PANIC,\r\n                (errmsg(\"walsender stop switchover process for catchup is alive, the process need to be restart\")));\r\n        }\r\n\r\n        /* Normal exit from the walsender is here */\r\n        if ((t_thrd.walsender_cxt.walsender_shutdown_requested &&\r\n                !t_thrd.walsender_cxt.response_switchover_requested) ||\r\n            t_thrd.walsender_cxt.MyWalSnd->node_state == NODESTATE_STANDBY_REDIRECT) {\r\n            /* Inform the standby that XLOG streaming is done */\r\n            if (!sync_config_needed) {\r\n                pq_puttextmessage('C', \"COPY 0\");\r\n                (void)pq_flush();\r\n\r\n                proc_exit(0);\r\n            }\r\n        }\r\n\r\n        /* if changed to stream replication, request for catchup. */\r\n        if (u_sess->attr.attr_storage.enable_stream_replication && !marked_stream_replication) {\r\n            marked_stream_replication = u_sess->attr.attr_storage.enable_stream_replication;\r\n            WalSndSetState(WALSNDSTATE_CATCHUP);\r\n        }\r\n\r\n        if (t_thrd.walsender_cxt.response_switchover_requested) {\r\n            if (t_thrd.walsender_cxt.MyWalSnd->peer_role != STANDBY_MODE) {\r\n                ereport(LOG, (errmsg(\"walsender closed because of switchover.\")));\r\n                proc_exit(0);\r\n            }\r\n        }\r\n\r\n        /* Check for input from the client */\r\n        ProcessRepliesIfAny();\r\n\r\n        /* Walsender first startup, send a keepalive to standby, no need reply. */\r\n        if (first_startup) {\r\n            WalSndKeepalive(false);\r\n            first_startup = false;\r\n        }\r\n\r\n        /* send switchover response message to standby if requested */\r\n        if (t_thrd.walsender_cxt.response_switchover_requested) {\r\n            XLogRecPtr WriteRqstPtr;\r\n            uint32 XLogPageOffSet;\r\n\r\n            WriteRqstPtr = GetXLogInsertEndRecPtr();\r\n            XLogPageOffSet = WriteRqstPtr % XLOG_BLCKSZ;\r\n\r\n            ereport(LOG, (errmsg(\"The WAL sender in primary is ready to do the switchover.\")));\r\n\r\n            ereport(\r\n                LOG, (errmsg(\"the latest WAL insert at %X/%X\", (uint32)(WriteRqstPtr >> 32), (uint32)WriteRqstPtr)));\r\n\r\n            /*\r\n             * Check whether the write requestptr points to the end of new\r\n             * page header, we try to flush to the end of last page instead\r\n             * of the new page header.\r\n             */\r\n            if (SizeOfXLogLongPHD == XLogPageOffSet || SizeOfXLogShortPHD == WriteRqstPtr % XLogSegSize) {\r\n                WriteRqstPtr -= XLogPageOffSet;\r\n                ereport(LOG,\r\n                    (errmsg(\"the latest WAL insert back off to %X/%X\",\r\n                        (uint32)(WriteRqstPtr >> 32),\r\n                        (uint32)WriteRqstPtr)));\r\n            }\r\n\r\n            /*\r\n             * Do a last xlog flush; then, if XLogNeedsFlush() found useful\r\n             * work to do, continue to loop.\r\n             */\r\n            if (XLogNeedsFlush(WriteRqstPtr)) {\r\n                XLogFlush(WriteRqstPtr);\r\n                ereport(LOG,\r\n                    (errmsg(\"the latest WAL flush to %X/%X.\", (uint32)(WriteRqstPtr >> 32), (uint32)WriteRqstPtr)));\r\n            } else {\r\n                XLogRecPtr SendRqstPtr;\r\n                SendRqstPtr = AM_WAL_STANDBY_SENDER ? GetStandbyFlushRecPtr(NULL) : GetFlushRecPtr();\r\n                /* Quick exit if nothing to do */\r\n                if (XLByteLE(SendRqstPtr, t_thrd.walsender_cxt.MyWalSnd->flush) &&\r\n                    !t_thrd.walsender_cxt.wal_send_completed) {\r\n                    t_thrd.walsender_cxt.wal_send_completed = true;\r\n                    ereport(LOG,\r\n                        (errmsg(\"the latest WAL complete at %X/%X\", (uint32)(SendRqstPtr >> 32), (uint32)SendRqstPtr)));\r\n                } else\r\n                    ereport(LOG,\r\n                        (errmsg(\"the latest WAL flush at %X/%X the latest standby flush at %X/%X\",\r\n                            (uint32)(SendRqstPtr >> 32),\r\n                            (uint32)SendRqstPtr,\r\n                            (uint32)(t_thrd.walsender_cxt.MyWalSnd->flush >> 32),\r\n                            (uint32)t_thrd.walsender_cxt.MyWalSnd->flush)));\r\n\r\n                if (!DataSndInProgress(SNDROLE_PRIMARY_STANDBY | SNDROLE_PRIMARY_DUMMYSTANDBY) &&\r\n                    !WalSndInProgress(SNDROLE_PRIMARY_DUMMYSTANDBY | SNDROLE_PRIMARY_STANDBY) &&\r\n                    t_thrd.walsender_cxt.wal_send_completed) {\r\n                    t_thrd.walsender_cxt.response_switchover_requested = false;\r\n                    WalSndResponseSwitchover(t_thrd.walsender_cxt.output_xlog_message);\r\n                    ereport(LOG,\r\n                        (errmsg(\r\n                            \"The WAL sender in primary has done the switchover waiting for the standby's promotion.\")));\r\n                }\r\n            }\r\n        }\r\n\r\n        if (sync_config_needed) {\r\n            if (t_thrd.walsender_cxt.walsender_shutdown_requested) {\r\n                if (!AM_WAL_DB_SENDER && !SendConfigFile(t_thrd.walsender_cxt.gucconf_file))\r\n                    ereport(LOG, (errmsg(\"failed to send config to the peer when walsender shutdown.\")));\r\n                sync_config_needed = false;\r\n            } else {\r\n                TimestampTz nowtime = GetCurrentTimestamp();\r\n                if (TimestampDifferenceExceeds(last_syncconf_timestamp, nowtime, 1000) ||\r\n                    last_syncconf_timestamp > nowtime) {\r\n                    sync_config_needed = false;\r\n                    /* begin send file to standby */\r\n                    if (t_thrd.walsender_cxt.MyWalSnd && t_thrd.walsender_cxt.MyWalSnd->peer_state != BUILDING_STATE) {\r\n                        if (!AM_WAL_DB_SENDER && !SendConfigFile(t_thrd.walsender_cxt.gucconf_file))\r\n                            sync_config_needed = true;\r\n                        else\r\n                            last_syncconf_timestamp = nowtime;\r\n                    } else {\r\n                        sync_config_needed = false;\r\n                        ereport(LOG, (errmsg(\"receive sigup,but the peer is building!\")));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (AmWalSenderToDummyStandby()) {\r\n            /*\r\n             * If i am sender to dummy and streaming to standby is online, do not\r\n             * send WAL to dummy. Especially, set WalSndCaughtUp to true, if the dummy\r\n             * sender is \"out of work\".\r\n             */\r\n            if (WalSndCaughtup()) {\r\n                WalSndCaughtUp = true;\r\n                t_thrd.walsender_cxt.sentPtr = InvalidXLogRecPtr;\r\n\r\n                /* Close open wal file */\r\n                if (t_thrd.walsender_cxt.sendFile >= 0) {\r\n                    (void)close(t_thrd.walsender_cxt.sendFile);\r\n                    t_thrd.walsender_cxt.sendFile = -1;\r\n                }\r\n\r\n                if (u_sess->attr.attr_storage.HaModuleDebug) {\r\n                    ereport(LOG,\r\n                        (errmsg(\"standby is steaming, \"\r\n                                \"stop sync to walsender, recycle local data.\")));\r\n                }\r\n\r\n                /* Notify dummy to cleanup WAL. False means not need response. */\r\n                if (WalSndDummyLEStandby()) {\r\n                    WalSndRmXLog(false);\r\n                }\r\n\r\n                /* Set dummy standby replication slot lsn invalid */\r\n                if (g_instance.attr.attr_storage.max_replication_slots > 0)\r\n                    SetDummyStandbySlotLsnInvalid();\r\n            } else {\r\n                ChooseStartPointForDummyStandby();\r\n\r\n                if (!pq_is_send_pending())\r\n                    send_data();\r\n                else\r\n                    WalSndCaughtUp = false;\r\n\r\n                /* Send DummyStandby end message */\r\n                if (WalSndCaughtUp) {\r\n                    /* Try to flush pending output to the client */\r\n                    if (pq_flush_if_writable() != 0)\r\n                        break;\r\n\r\n                    if (!pq_is_send_pending())\r\n                        WalSndSyncDummyStandbyDone(false);\r\n                }\r\n            }\r\n        } else {\r\n            /*\r\n             * If we don't have any pending data in the output buffer, try to send\r\n             * some more.  If there is some, we don't bother to call XLogSend\r\n             * again until we've flushed it ... but we'd better assume we are not\r\n             * caught up.\r\n             */\r\n            if (!pq_is_send_pending())\r\n                send_data();\r\n            else\r\n                WalSndCaughtUp = false;\r\n\r\n            if (WalSndCaughtUp && dummyStandbyMode) {\r\n                if (!pq_is_send_pending()) {\r\n                    WalSndSyncDummyStandbyDone(false);\r\n                    (void)pq_flush();\r\n                    ereport(LOG,\r\n                        (errmsg(\"dummystandby wal data replication completed at %X/%X\",\r\n                            (uint32)(t_thrd.walsender_cxt.sentPtr >> 32),\r\n                            (uint32)t_thrd.walsender_cxt.sentPtr)));\r\n                }\r\n            }\r\n        }\r\n\r\n        /* Try to flush pending output to the client */\r\n        if (pq_flush_if_writable() != 0) {\r\n            ereport(LOG, (errmsg(\"flush return not zero !\\n\")));\r\n            break;\r\n        }\r\n\r\n        /* If nothing remains to be sent right now ... */\r\n        if (WalSndCaughtUp && !pq_is_send_pending()) {\r\n            /*\r\n             * If we're in catchup state, move to streaming.  This is an\r\n             * important state change for users to know about, since before\r\n             * this point data loss might occur if the primary dies and we\r\n             * need to failover to the standby. The state change is also\r\n             * important for synchronous replication, since commits that\r\n             * started to wait at that point might wait for some time.\r\n             */\r\n            if (t_thrd.walsender_cxt.MyWalSnd->state == WALSNDSTATE_CATCHUP) {\r\n                ereport(DEBUG1,\r\n                    (errmsg(\r\n                        \"standby \\\"%s\\\" has now caught up with primary\", u_sess->attr.attr_common.application_name)));\r\n                WalSndSetState(WALSNDSTATE_STREAMING);\r\n                /* Refresh new state to peer */\r\n                WalSndKeepalive(true);\r\n            }\r\n\r\n            t_thrd.walsender_cxt.catchup_threshold = 0;\r\n\r\n            /*\r\n             * When SIGUSR2 arrives, we send any outstanding logs up to the\r\n             * shutdown checkpoint record (i.e., the latest record), wait\r\n             * for them to be replicated to the standby, and exit.\r\n             * This may be a normal termination at shutdown, or a promotion,\r\n             * the walsender is not sure which.\r\n             */\r\n            if (t_thrd.walsender_cxt.walsender_ready_to_stop) {\r\n                /*\r\n                 * Let's just be real sure we're caught up. For dummy sender,\r\n                 * during shutting down, if the sender to standby is in progress,\r\n                 * skip to send outstanding logs.\r\n                 */\r\n                if (AmWalSenderToDummyStandby() && WalSndInProgress(SNDROLE_PRIMARY_STANDBY))\r\n                    ; /* nothing to do */\r\n                else\r\n                    send_data();\r\n\r\n                if (WalSndCaughtUp && !pq_is_send_pending()) {\r\n                    if (dummyStandbyMode ||\r\n                        XLByteEQ(t_thrd.walsender_cxt.sentPtr, t_thrd.walsender_cxt.MyWalSnd->flush))\r\n                        t_thrd.walsender_cxt.walsender_shutdown_requested = true;\r\n                }\r\n            }\r\n        } else {\r\n            if (t_thrd.walsender_cxt.MyWalSnd->state == WALSNDSTATE_STREAMING &&\r\n                !XLByteLT(t_thrd.walsender_cxt.catchup_threshold,\r\n                    INT2UINT64(g_instance.attr.attr_storage.MaxSendSize) * 1024)) {\r\n                ereport(DEBUG1,\r\n                    (errmsg(\r\n                        \"standby \\\"%s\\\" has now caught up with primary\", u_sess->attr.attr_common.application_name)));\r\n                WalSndSetState(WALSNDSTATE_CATCHUP);\r\n                t_thrd.walsender_cxt.catchup_threshold = 0;\r\n            }\r\n        }\r\n\r\n        now = GetCurrentTimestamp();\r\n\r\n        if (u_sess->proc_cxt.MyDatabaseId != InvalidOid)\r\n            WalSndWriteLogicalAdvanceXLog(now);\r\n\r\n        /*\r\n         * We don't block if not caught up, unless there is unsent data\r\n         * pending in which case we'd better block until the socket is\r\n         * write-ready.  This test is only needed for the case where XLogSend\r\n         * loaded a subset of the available data but then pq_flush_if_writable\r\n         * flushed it all --- we should immediately try to send more.\r\n         */\r\n        if (WalSndCaughtUp || pq_is_send_pending()) {\r\n            long sleeptime;\r\n            int wakeEvents;\r\n\r\n            wakeEvents = WL_LATCH_SET | WL_POSTMASTER_DEATH | WL_SOCKET_READABLE | WL_TIMEOUT;\r\n\r\n            sleeptime = WalSndComputeSleeptime(now);\r\n\r\n            if (pq_is_send_pending())\r\n                wakeEvents |= WL_SOCKET_WRITEABLE;\r\n            else if (first_startup) {\r\n                /* Walsender first startup, send a keepalive to standby, no need reply. */\r\n                WalSndKeepalive(false);\r\n                first_startup = false;\r\n            }\r\n\r\n            /*\r\n             * if requested to response switchover, walsender need not to wait for new xlog data.\r\n             * if requested to shutdown, walsender need not to wait for new xlog data.\r\n             */\r\n            if (t_thrd.walsender_cxt.response_switchover_requested || t_thrd.walsender_cxt.walsender_shutdown_requested)\r\n                sleeptime = 100; /* 0.1s */\r\n\r\n            /* Sleep until something happens or we time out */\r\n            pgstat_report_activity(STATE_IDLE, NULL);\r\n            t_thrd.int_cxt.ImmediateInterruptOK = true;\r\n            CHECK_FOR_INTERRUPTS();\r\n\r\n            if (sleeptime > u_sess->attr.attr_storage.wal_sender_timeout / 2)\r\n                sleeptime = u_sess->attr.attr_storage.wal_sender_timeout / 2;\r\n\r\n            WaitLatchOrSocket(\r\n                &t_thrd.walsender_cxt.MyWalSnd->latch, wakeEvents, u_sess->proc_cxt.MyProcPort->sock, sleeptime);\r\n            t_thrd.int_cxt.ImmediateInterruptOK = false;\r\n        }\r\n\r\n        if (!bSyncStat && !dummyStandbyMode) {\r\n            if (XLByteEQ(GetFlushRecPtr(), t_thrd.walsender_cxt.sentPtr) && SyncRepRequested() &&\r\n                most_available_sync == false) {\r\n                bSyncStat = true;\r\n                ereport(LOG, (errmsg(\"The primary and standby reached syncstat in WalSndLoop.\")));\r\n            }\r\n        }\r\n    }\r\n\r\n    WalSndShutdown();\r\n    return 1; /* keep the compiler quiet */\r\n}",
		"comment":"/* Main loop of walsender process */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndLoop"
	},
	"WalSndPrepareWrite":{
		"body":"static void WalSndPrepareWrite(LogicalDecodingContext* ctx, XLogRecPtr lsn, TransactionId xid, bool last_write)\r\n{\r\n    /* can't have sync rep confused by sending the same LSN several times */\r\n    if (!last_write)\r\n        lsn = InvalidXLogRecPtr;\r\n\r\n    resetStringInfo(ctx->out);\r\n\r\n    pq_sendbyte(ctx->out, 'w');\r\n    pq_sendint64(ctx->out, lsn); /* dataStart */\r\n    pq_sendint64(ctx->out, lsn); /* walEnd */\r\n    /*\r\n     * Fill out the sendtime later, just as it's done in XLogSendPhysical, but\r\n     * reserve space here.\r\n     */\r\n    pq_sendint64(ctx->out, 0); /* sendtime */\r\n}",
		"comment":"/*\r\n * LogicalDecodingContext 'prepare_write' callback.\r\n *\r\n * Prepare a write into a StringInfo.\r\n *\r\n * Don't do anything lasting in here, it's quite possible that nothing will done\r\n * with the data.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndPrepareWrite"
	},
	"WalSndQuickDieHandler":{
		"body":"static void WalSndQuickDieHandler(SIGNAL_ARGS)\r\n{\r\n    gs_signal_setmask(&t_thrd.libpq_cxt.BlockSig, NULL);\r\n\r\n    /*\r\n     * We DO NOT want to run proc_exit() callbacks -- we're here because\r\n     * shared memory may be corrupted, so we don't want to try to clean up our\r\n     * transaction.  Just nail the windows shut and get out of town.  Now that\r\n     * there's an atexit callback to prevent third-party code from breaking\r\n     * things by calling exit() directly, we have to reset the callbacks\r\n     * explicitly to make this work as intended.\r\n     */\r\n    on_exit_reset();\r\n\r\n    /*\r\n     * Note we do exit(2) not exit(0).	This is to force the postmaster into a\r\n     * system reset cycle if some idiot DBA sends a manual SIGQUIT to a random\r\n     * backend.  This is necessary precisely because we don't clean up our\r\n     * shared memory state.  (The \"dead man switch\" mechanism in pmsignal.c\r\n     * should ensure the postmaster sees this as a crash, too, but no harm in\r\n     * being doubly sure.)\r\n     */\r\n    exit(2);\r\n}",
		"comment":"/*\r\n * WalSndQuickDieHandler() occurs when signalled SIGQUIT by the postmaster.\r\n *\r\n * Some backend has bought the farm,\r\n * so we need to stop what we're doing and exit.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndQuickDieHandler"
	},
	"WalSndQuorumInProgress":{
		"body":"bool WalSndQuorumInProgress(int type)\r\n{\r\n    int i;\r\n    int num = 0;\r\n    int num_sync = t_thrd.syncrep_cxt.SyncRepConfig->num_sync;\r\n\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile WalSnd* walsnd = &t_thrd.walsender_cxt.WalSndCtl->walsnds[i];\r\n        SpinLockAcquire(&walsnd->mutex);\r\n        if (walsnd->pid != 0 && walsnd->pid != t_thrd.proc_cxt.MyProcPid &&\r\n            ((walsnd->sendRole & type) == walsnd->sendRole)) {\r\n            num++;\r\n        }\r\n        SpinLockRelease(&walsnd->mutex);\r\n    }\r\n    if (num_sync <= num) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}",
		"comment":"/* check if there is quorum wal sender in type status. */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndQuorumInProgress"
	},
	"WalSndRefreshPercentCountStartLsn":{
		"body":"static void WalSndRefreshPercentCountStartLsn(XLogRecPtr currentMaxLsn, XLogRecPtr currentDoneLsn)\r\n{\r\n    uint64 coundWindow = ((uint64)WalGetSyncCountWindow() * XLOG_SEG_SIZE);\r\n    volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n    XLogRecPtr baseStartLsn = InvalidXLogRecPtr;\r\n\r\n    if (!walsnd) {\r\n        return;\r\n    }\r\n\r\n    /* don't refresh during catching up. */\r\n    if (walsnd->state == WALSNDSTATE_CATCHUP) {\r\n        return;\r\n    }\r\n\r\n    if (XLogDiff(currentMaxLsn, currentDoneLsn) < coundWindow) {\r\n        WalSndSetPercentCountStartLsn(InvalidXLogRecPtr);\r\n    } else {\r\n        SpinLockAcquire(&walsnd->mutex);\r\n        baseStartLsn = walsnd->syncPercentCountStart;\r\n        SpinLockRelease(&walsnd->mutex);\r\n        if (!XLByteEQ(baseStartLsn, InvalidXLogRecPtr)) {\r\n            return;\r\n        }\r\n        WalSndSetPercentCountStartLsn(currentDoneLsn);\r\n    }\r\n}",
		"comment":"/* Set start send lsn for current walsender (only called in walsender) */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndRefreshPercentCountStartLsn"
	},
	"WalSndReset":{
		"body":"static void WalSndReset(WalSnd *walsnd)\r\n{\r\n    errno_t	rc = 0;\r\n\r\n    SpinLockAcquire(&walsnd->mutex);\r\n    walsnd->pid = 0;\r\n    walsnd->lwpId = 0;\r\n    walsnd->peer_role = UNKNOWN_MODE;\r\n    walsnd->replSender = false;\r\n    walsnd->wal_sender_channel.localport = 0;\r\n    walsnd->wal_sender_channel.localservice = 0;\r\n    walsnd->wal_sender_channel.remoteport = 0;\r\n    walsnd->wal_sender_channel.remoteservice = 0;\r\n    walsnd->channel_get_replc = 0;\r\n    rc = memset_s(walsnd->wal_sender_channel.localhost, sizeof(walsnd->wal_sender_channel.localhost), 0,\r\n        sizeof(walsnd->wal_sender_channel.localhost));\r\n    securec_check_c(rc, \"\\0\", \"\\0\");\r\n    rc = memset_s(walsnd->wal_sender_channel.remotehost, sizeof(walsnd->wal_sender_channel.remotehost), 0,\r\n        sizeof(walsnd->wal_sender_channel.remotehost));\r\n    securec_check_c(rc, \"\\0\", \"\\0\");\r\n    SpinLockRelease(&walsnd->mutex);\r\n}",
		"comment":"/* Mark WalSnd struct no longer in use. */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndReset"
	},
	"WalSndResponseSwitchover":{
		"body":"static void WalSndResponseSwitchover(char* msgbuf)\r\n{\r\n    PrimarySwitchResponseMessage response_message;\r\n    volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n    errno_t errorno = EOK;\r\n\r\n    if (walsnd == NULL)\r\n        return;\r\n\r\n    switch (walsnd->node_state) {\r\n        case NODESTATE_PROMOTE_APPROVE:\r\n            response_message.switchResponse = SWITCHOVER_PROMOTE_REQUEST;\r\n            /* clean view data. */\r\n            int rc;\r\n            rc = memset_s(&(g_instance.rto_cxt), sizeof(knl_g_rto_context), 0, sizeof(knl_g_rto_context));\r\n            securec_check(rc, \"\\0\", \"\\0\");\r\n            break;\r\n        case NODESTATE_PRIMARY_DEMOTING_WAIT_CATCHUP:\r\n            response_message.switchResponse = SWITCHOVER_DEMOTE_CATCHUP_EXIST;\r\n            break;\r\n        case NODESTATE_STANDBY_REDIRECT:\r\n        case NODESTATE_DEMOTE_FAILED:\r\n        default:\r\n            return;\r\n    }\r\n\r\n    response_message.walEnd = t_thrd.walsender_cxt.sentPtr;\r\n    response_message.sendTime = GetCurrentTimestamp();\r\n\r\n    ereport(LOG,\r\n        (errmsg(\"sending switchover response message%s\",\r\n            walsnd->node_state == NODESTATE_PRIMARY_DEMOTING_WAIT_CATCHUP ? \", meeting alive catchup\" : \".\")));\r\n\r\n    /* Prepend with the message type and send it. */\r\n    msgbuf[0] = 'p';\r\n    errorno = memcpy_s(msgbuf + 1,\r\n        sizeof(WalDataMessageHeader) + g_instance.attr.attr_storage.MaxSendSize * 1024,\r\n        &response_message,\r\n        sizeof(PrimarySwitchResponseMessage));\r\n    securec_check(errorno, \"\\0\", \"\\0\");\r\n    (void)pq_putmessage_noblock('d', msgbuf, sizeof(PrimarySwitchResponseMessage) + 1);\r\n}",
		"comment":"/*\r\n * send switchover response message\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndResponseSwitchover"
	},
	"WalSndRmXLog":{
		"body":"static void WalSndRmXLog(bool requestReply)\r\n{\r\n    RmXLogMessage rmXLogMessage;\r\n    volatile HaShmemData* hashmdata = t_thrd.postmaster_cxt.HaShmData;\r\n    errno_t errorno = EOK;\r\n\r\n    /* Construct a new message */\r\n    SpinLockAcquire(&hashmdata->mutex);\r\n    rmXLogMessage.peer_role = hashmdata->current_mode;\r\n    SpinLockRelease(&hashmdata->mutex);\r\n    rmXLogMessage.peer_state = get_local_dbstate();\r\n    rmXLogMessage.sendTime = GetCurrentTimestamp();\r\n    rmXLogMessage.replyRequested = requestReply;\r\n\r\n    ereport(DEBUG2, (errmsg(\"sending dummystandby rm xlog message\")));\r\n\r\n    /* Prepend with the message type and send it. */\r\n    t_thrd.walsender_cxt.output_xlog_message[0] = 'x';\r\n    errorno = memcpy_s(t_thrd.walsender_cxt.output_xlog_message + 1,\r\n        sizeof(WalDataMessageHeader) + WS_MAX_SEND_SIZE,\r\n        &rmXLogMessage,\r\n        sizeof(RmXLogMessage));\r\n    securec_check(errorno, \"\\0\", \"\\0\");\r\n    (void)pq_putmessage_noblock('d', t_thrd.walsender_cxt.output_xlog_message, sizeof(RmXLogMessage) + 1);\r\n}",
		"comment":"/*\r\n * This function is used to send rm_xlog message to  xlogreceiver.\r\n * If requestReply is set, sets a flag in the message requesting the standby\r\n * to send a message back to us, for heartbeat purposes.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndRmXLog"
	},
	"WalSndRqstFileReload":{
		"body":"void WalSndRqstFileReload(void)\r\n{\r\n    int i;\r\n\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile WalSnd* walsnd = &t_thrd.walsender_cxt.WalSndCtl->walsnds[i];\r\n\r\n        if (walsnd->pid == 0)\r\n            continue;\r\n\r\n        SpinLockAcquire(&walsnd->mutex);\r\n        walsnd->needreload = true;\r\n        SpinLockRelease(&walsnd->mutex);\r\n    }\r\n}",
		"comment":"/*\r\n * Request walsenders to reload the currently-open WAL file\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndRqstFileReload"
	},
	"WalSndSetPercentCountStartLsn":{
		"body":"static void WalSndSetPercentCountStartLsn(XLogRecPtr startLsn)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n\r\n    SpinLockAcquire(&walsnd->mutex);\r\n    walsnd->syncPercentCountStart = startLsn;\r\n    SpinLockRelease(&walsnd->mutex);\r\n}",
		"comment":"/* Set start send lsn for current walsender (only called in walsender) */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndSetPercentCountStartLsn"
	},
	"WalSndSetState":{
		"body":"void WalSndSetState(WalSndState state)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n\r\n    Assert(AM_WAL_SENDER);\r\n\r\n    if (walsnd->state == state)\r\n        return;\r\n\r\n    SpinLockAcquire(&walsnd->mutex);\r\n    walsnd->state = state;\r\n    if (state == WALSNDSTATE_CATCHUP)\r\n        walsnd->catchupTime[0] = GetCurrentTimestamp();\r\n    else if (state == WALSNDSTATE_STREAMING)\r\n        walsnd->catchupTime[1] = GetCurrentTimestamp();\r\n    SpinLockRelease(&walsnd->mutex);\r\n}",
		"comment":"/* Set state for current walsender (only called in walsender) */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndSetState"
	},
	"WalSndShmemInit":{
		"body":"void WalSndShmemInit(void)\r\n{\r\n    bool found = false;\r\n    errno_t rc = 0;\r\n    int i;\r\n\r\n    t_thrd.walsender_cxt.WalSndCtl = (WalSndCtlData*)ShmemInitStruct(\"Wal Sender Ctl\", WalSndShmemSize(), &found);\r\n\r\n    if (!found) {\r\n        /* First time through, so initialize */\r\n        rc = memset_s(t_thrd.walsender_cxt.WalSndCtl, WalSndShmemSize(), 0, WalSndShmemSize());\r\n        securec_check(rc, \"\\0\", \"\\0\");\r\n\r\n        for (i = 0; i < NUM_SYNC_REP_WAIT_MODE; i++)\r\n            SHMQueueInit(&(t_thrd.walsender_cxt.WalSndCtl->SyncRepQueue[i]));\r\n\r\n        for (i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n            WalSnd* walsnd = &t_thrd.walsender_cxt.WalSndCtl->walsnds[i];\r\n\r\n            walsnd->sendKeepalive = true;\r\n            SpinLockInit(&walsnd->mutex);\r\n            InitSharedLatch(&walsnd->latch);\r\n        }\r\n        t_thrd.walsender_cxt.WalSndCtl->most_available_sync = false;\r\n        t_thrd.walsender_cxt.WalSndCtl->sync_master_standalone = false;\r\n        t_thrd.walsender_cxt.WalSndCtl->demotion = NoDemote;\r\n        SpinLockInit(&t_thrd.walsender_cxt.WalSndCtl->mutex);\r\n    }\r\n}",
		"comment":"/* Allocate and initialize walsender-related shared memory */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndShmemInit"
	},
	"WalSndShmemSize":{
		"body":"Size WalSndShmemSize(void)\r\n{\r\n    Size size = 0;\r\n\r\n    size = offsetof(WalSndCtlData, walsnds);\r\n    size = add_size(size, mul_size(g_instance.attr.attr_storage.max_wal_senders, sizeof(WalSnd)));\r\n\r\n    return size;\r\n}",
		"comment":"/* Report shared-memory space needed by WalSndShmemInit */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndShmemSize"
	},
	"WalSndShutdown":{
		"body":"static void WalSndShutdown(void)\r\n{\r\n    /*\r\n     * Reset whereToSendOutput to prevent ereport from attempting to send any\r\n     * more messages to the standby.\r\n     */\r\n    ereport(LOG, (errmsg(\"wal send shut down !\\n\")));\r\n    if (t_thrd.postgres_cxt.whereToSendOutput == DestRemote)\r\n        t_thrd.postgres_cxt.whereToSendOutput = DestNone;\r\n\r\n    proc_exit(0);\r\n    abort(); /* keep the compiler quiet */\r\n}",
		"comment":"/*\r\n * Handle a client's connection abort in an orderly manner.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndShutdown"
	},
	"WalSndShutdownHandler":{
		"body":"static void WalSndShutdownHandler(SIGNAL_ARGS)\r\n{\r\n    int save_errno = errno;\r\n\r\n    t_thrd.walsender_cxt.walsender_shutdown_requested = true;\r\n    if (t_thrd.walsender_cxt.MyWalSnd)\r\n        SetLatch(&t_thrd.walsender_cxt.MyWalSnd->latch);\r\n\r\n    /*\r\n     * Set the standard (non-walsender) state as well, so that we can abort\r\n     * things like do_pg_stop_backup().\r\n     */\r\n    InterruptPending = true;\r\n    t_thrd.int_cxt.ProcDiePending = true;\r\n\r\n    errno = save_errno;\r\n}",
		"comment":"/* SIGTERM: set flag to shut down */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndShutdownHandler"
	},
	"WalSndSigHupHandler":{
		"body":"static void WalSndSigHupHandler(SIGNAL_ARGS)\r\n{\r\n    int save_errno = errno;\r\n\r\n    t_thrd.walsender_cxt.got_SIGHUP = true;\r\n    if (t_thrd.walsender_cxt.MyWalSnd)\r\n        SetLatch(&t_thrd.walsender_cxt.MyWalSnd->latch);\r\n\r\n    errno = save_errno;\r\n}",
		"comment":"/* SIGHUP: set flag to re-read config file at next convenient time */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndSigHupHandler"
	},
	"WalSndSignals":{
		"body":"void WalSndSignals(void)\r\n{\r\n    /* Set up signal handlers */\r\n    (void)gspqsignal(SIGHUP, WalSndSigHupHandler);    /* set flag to read config file */\r\n    (void)gspqsignal(SIGINT, SIG_IGN);                /* not used */\r\n    (void)gspqsignal(SIGTERM, WalSndShutdownHandler); /* request shutdown */\r\n    (void)gspqsignal(SIGQUIT, WalSndQuickDieHandler); /* hard crash time */\r\n    (void)gspqsignal(SIGALRM, handle_sig_alarm);\r\n    (void)gspqsignal(SIGPIPE, SIG_IGN);\r\n    (void)gspqsignal(SIGUSR1, WalSndXLogSendHandler);  /* request WAL sending */\r\n    (void)gspqsignal(SIGUSR2, WalSndLastCycleHandler); /* request a last cycle and shutdown */\r\n\r\n    /* Reset some signals that are accepted by postmaster but not here */\r\n    (void)gspqsignal(SIGCHLD, SIG_DFL);\r\n    (void)gspqsignal(SIGTTIN, SIG_DFL);\r\n    (void)gspqsignal(SIGTTOU, SIG_DFL);\r\n    (void)gspqsignal(SIGCONT, SIG_DFL);\r\n    (void)gspqsignal(SIGWINCH, SIG_DFL);\r\n}",
		"comment":"/* Set up signal handlers */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndSignals"
	},
	"WalSndSyncDummyStandbyDone":{
		"body":"static void WalSndSyncDummyStandbyDone(bool requestReply)\r\n{\r\n    EndXLogMessage endXLogMessage;\r\n    volatile HaShmemData* hashmdata = t_thrd.postmaster_cxt.HaShmData;\r\n    errno_t errorno = EOK;\r\n\r\n    /* Construct a new message */\r\n    SpinLockAcquire(&hashmdata->mutex);\r\n    endXLogMessage.peer_role = hashmdata->current_mode;\r\n    SpinLockRelease(&hashmdata->mutex);\r\n    endXLogMessage.peer_state = get_local_dbstate();\r\n    endXLogMessage.sendTime = GetCurrentTimestamp();\r\n    endXLogMessage.percent = SYNC_DUMMY_STANDBY_END;\r\n\r\n    ereport(dummyStandbyMode ? LOG : DEBUG2, (errmsg(\"send Secondary Standby xlog done\")));\r\n\r\n    /* Prepend with the message type and send it. */\r\n    t_thrd.walsender_cxt.output_xlog_message[0] = 'e';\r\n    errorno = memcpy_s(t_thrd.walsender_cxt.output_xlog_message + 1,\r\n        sizeof(WalDataMessageHeader) + g_instance.attr.attr_storage.MaxSendSize * 1024,\r\n        &endXLogMessage,\r\n        sizeof(EndXLogMessage));\r\n    securec_check(errorno, \"\\0\", \"\\0\");\r\n    (void)pq_putmessage_noblock('d', t_thrd.walsender_cxt.output_xlog_message, sizeof(EndXLogMessage) + 1);\r\n}",
		"comment":"/*\r\n * This function is used to send rm_xlog message to  xlogreceiver.\r\n * If requestReply is set, sets a flag in the message requesting the standby\r\n * to send a message back to us, for heartbeat purposes.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndSyncDummyStandbyDone"
	},
	"WalSndWaitForWal":{
		"body":"static XLogRecPtr WalSndWaitForWal(XLogRecPtr loc)\r\n{\r\n    int wakeEvents;\r\n    static XLogRecPtr RecentFlushPtr = InvalidXLogRecPtr;\r\n\r\n    /*\r\n     * Fast path to avoid acquiring the spinlock in the we already know we\r\n     * have enough WAL available. This is particularly interesting if we're\r\n     * far behind.\r\n     */\r\n    if (!XLogRecPtrIsInvalid(RecentFlushPtr) && XLByteLE(loc, RecentFlushPtr))\r\n        return RecentFlushPtr;\r\n\r\n    /* Get a more recent flush pointer. */\r\n    if (!RecoveryInProgress())\r\n        RecentFlushPtr = GetFlushRecPtr();\r\n    else\r\n        RecentFlushPtr = GetXLogReplayRecPtr(NULL);\r\n\r\n    for (;;) {\r\n        long sleeptime;\r\n        TimestampTz now;\r\n\r\n        /*\r\n         * Emergency bailout if postmaster has died.  This is to avoid the\r\n         * necessity for manual cleanup of all postmaster children.\r\n         */\r\n        if (!PostmasterIsAlive())\r\n            exit(1);\r\n\r\n        /* Process any requests or signals received recently */\r\n        if (t_thrd.walsender_cxt.got_SIGHUP) {\r\n            t_thrd.walsender_cxt.got_SIGHUP = false;\r\n            ProcessConfigFile(PGC_SIGHUP);\r\n            SyncRepInitConfig();\r\n        }\r\n\r\n        /* Check for input from the client */\r\n        ProcessRepliesIfAny();\r\n\r\n        /* Clear any already-pending wakeups */\r\n        ResetLatch(&t_thrd.walsender_cxt.MyWalSnd->latch);\r\n\r\n        /* Update our idea of the currently flushed position. */\r\n        if (!RecoveryInProgress())\r\n            RecentFlushPtr = GetFlushRecPtr();\r\n        else\r\n            RecentFlushPtr = GetXLogReplayRecPtr(NULL);\r\n\r\n        /*\r\n         * If postmaster asked us to stop, don't wait here anymore. This will\r\n         * cause the xlogreader to return without reading a full record, which\r\n         * is the fastest way to reach the mainloop which then can quit.\r\n         *\r\n         * It's important to do this check after the recomputation of\r\n         * RecentFlushPtr, so we can send all remaining data before shutting\r\n         * down.\r\n         */\r\n        if (t_thrd.walsender_cxt.walsender_ready_to_stop)\r\n            break;\r\n\r\n        /*\r\n         * We only send regular messages to the client for full decoded\r\n         * transactions, but a synchronous replication and walsender shutdown\r\n         * possibly are waiting for a later location. So we send pings\r\n         * containing the flush location every now and then.\r\n         */\r\n        if (XLByteLT(t_thrd.walsender_cxt.MyWalSnd->flush, t_thrd.walsender_cxt.sentPtr) &&\r\n            !t_thrd.walsender_cxt.waiting_for_ping_response) {\r\n            WalSndKeepalive(false);\r\n            t_thrd.walsender_cxt.waiting_for_ping_response = true;\r\n        }\r\n\r\n        /* check whether we're done */\r\n        if (XLByteLE(loc, RecentFlushPtr))\r\n            break;\r\n\r\n        /* Waiting for new WAL. Since we need to wait, we're now caught up. */\r\n        WalSndCaughtUp = true;\r\n\r\n        /*\r\n         * Try to flush pending output to the client. Also wait for the socket\r\n         * becoming writable, if there's still pending output after an attempt\r\n         * to flush. Otherwise we might just sit on output data while waiting\r\n         * for new WAL being generated.\r\n         */\r\n        if (pq_flush_if_writable() != 0)\r\n            WalSndShutdown();\r\n\r\n        now = GetCurrentTimestamp();\r\n\r\n        sleeptime = WalSndComputeSleeptime(now);\r\n\r\n        wakeEvents = WL_LATCH_SET | WL_POSTMASTER_DEATH | WL_SOCKET_READABLE | WL_TIMEOUT;\r\n\r\n        if (pq_is_send_pending())\r\n            wakeEvents |= WL_SOCKET_WRITEABLE;\r\n\r\n        /* Sleep until something happens or we time out */\r\n        t_thrd.int_cxt.ImmediateInterruptOK = true;\r\n        CHECK_FOR_INTERRUPTS();\r\n        WaitLatchOrSocket(\r\n            &t_thrd.walsender_cxt.MyWalSnd->latch, wakeEvents, u_sess->proc_cxt.MyProcPort->sock, sleeptime);\r\n        t_thrd.int_cxt.ImmediateInterruptOK = false;\r\n    }\r\n\r\n    /* reactivate latch so WalSndLoop knows to continue */\r\n    SetLatch(&t_thrd.walsender_cxt.MyWalSnd->latch);\r\n    return RecentFlushPtr;\r\n}",
		"comment":"/*\r\n * Wait till WAL < loc is flushed to disk so it can be safely read.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndWaitForWal"
	},
	"WalSndWakeup":{
		"body":"void WalSndWakeup(void)\r\n{\r\n    int i;\r\n\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++)\r\n        SetLatch(&t_thrd.walsender_cxt.WalSndCtl->walsnds[i].latch);\r\n}",
		"comment":"/* Wake up all walsenders */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndWakeup"
	},
	"WalSndWriteData":{
		"body":"static void WalSndWriteData(LogicalDecodingContext* ctx, XLogRecPtr lsn, TransactionId xid, bool last_write)\r\n{\r\n    errno_t rc;\r\n\r\n    /* output previously gathered data in a CopyData packet */\r\n    pq_putmessage_noblock('d', ctx->out->data, ctx->out->len);\r\n\r\n    /*\r\n     * Fill the send timestamp last, so that it is taken as late as\r\n     * possible. This is somewhat ugly, but the protocol's set as it's already\r\n     * used for several releases by streaming physical replication.\r\n     */\r\n    resetStringInfo(t_thrd.walsender_cxt.tmpbuf);\r\n    pq_sendint64(t_thrd.walsender_cxt.tmpbuf, GetCurrentTimestamp());\r\n    rc = memcpy_s(&(ctx->out->data[1 + sizeof(int64) + sizeof(int64)]),\r\n        ctx->out->len,\r\n        t_thrd.walsender_cxt.tmpbuf->data,\r\n        sizeof(int64));\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n\r\n    /* fast path */\r\n    /* Try to flush pending output to the client */\r\n    if (pq_flush_if_writable() != 0)\r\n        WalSndShutdown();\r\n\r\n    if (!pq_is_send_pending())\r\n        return;\r\n\r\n    for (;;) {\r\n        int wakeEvents;\r\n        long sleeptime;\r\n        TimestampTz now;\r\n\r\n        /*\r\n         * Emergency bailout if postmaster has died.  This is to avoid the\r\n         * necessity for manual cleanup of all postmaster children.\r\n         */\r\n        if (!PostmasterIsAlive())\r\n            exit(1);\r\n\r\n        /* Process any requests or signals received recently */\r\n        if (t_thrd.walsender_cxt.got_SIGHUP) {\r\n            t_thrd.walsender_cxt.got_SIGHUP = false;\r\n            ProcessConfigFile(PGC_SIGHUP);\r\n            SyncRepInitConfig();\r\n        }\r\n\r\n        /* Check for input from the client */\r\n        ProcessRepliesIfAny();\r\n\r\n        /* Clear any already-pending wakeups */\r\n        ResetLatch(&t_thrd.walsender_cxt.MyWalSnd->latch);\r\n\r\n        /* Try to flush pending output to the client */\r\n        if (pq_flush_if_writable() != 0)\r\n            WalSndShutdown();\r\n\r\n        /* If we finished clearing the buffered data, we're done here. */\r\n        if (!pq_is_send_pending())\r\n            break;\r\n\r\n        now = GetCurrentTimestamp();\r\n\r\n        sleeptime = WalSndComputeSleeptime(now);\r\n\r\n        wakeEvents = WL_LATCH_SET | WL_POSTMASTER_DEATH | WL_SOCKET_WRITEABLE | WL_SOCKET_READABLE | WL_TIMEOUT;\r\n\r\n        /* Sleep until something happens or we time out */\r\n        t_thrd.int_cxt.ImmediateInterruptOK = true;\r\n        CHECK_FOR_INTERRUPTS();\r\n        WaitLatchOrSocket(\r\n            &t_thrd.walsender_cxt.MyWalSnd->latch, wakeEvents, u_sess->proc_cxt.MyProcPort->sock, sleeptime);\r\n        t_thrd.int_cxt.ImmediateInterruptOK = false;\r\n    }\r\n\r\n    /* reactivate latch so WalSndLoop knows to continue */\r\n    SetLatch(&t_thrd.walsender_cxt.MyWalSnd->latch);\r\n}",
		"comment":"/*\r\n * LogicalDecodingContext 'write' callback.\r\n *\r\n * Actually write out data previously prepared by WalSndPrepareWrite out to\r\n * the network. Take as long as needed, but process replies from the other\r\n * side and check timeouts during that.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndWriteData"
	},
	"WalSndWriteLogicalAdvanceXLog":{
		"body":"static void WalSndWriteLogicalAdvanceXLog(TimestampTz now)\r\n{\r\n    TimestampTz timegap;\r\n    if (t_thrd.walsender_cxt.last_logical_xlog_advanced_timestamp <= 0)\r\n        return;\r\n\r\n    timegap = TimestampTzPlusMilliseconds(\r\n        t_thrd.walsender_cxt.last_logical_xlog_advanced_timestamp, t_thrd.walsender_cxt.logical_xlog_advanced_timeout);\r\n    if (t_thrd.walsender_cxt.logical_xlog_advanced_timeout > 0 && now >= timegap) {\r\n        ereport(LOG, (errmsg(\"write xlog of logical slot advanced\")));\r\n        log_slot_advance(&t_thrd.slot_cxt.MyReplicationSlot->data);\r\n        t_thrd.walsender_cxt.last_logical_xlog_advanced_timestamp = now;\r\n    }\r\n}",
		"comment":"/*\r\n * Check if time since last write xlog of logical slot advancing has reached the limit.\r\n * If reached, write a new xlog.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndWriteLogicalAdvanceXLog"
	},
	"WalSndXLogSendHandler":{
		"body":"static void WalSndXLogSendHandler(SIGNAL_ARGS)\r\n{\r\n    int save_errno = errno;\r\n\r\n    latch_sigusr1_handler();\r\n\r\n    errno = save_errno;\r\n}",
		"comment":"/* SIGUSR1: set flag to send WAL records */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"WalSndXLogSendHandler"
	},
	"XLogRead":{
		"body":"static void XLogRead(char* buf, XLogRecPtr startptr, Size count)\r\n{\r\n    char* p = NULL;\r\n    XLogRecPtr recptr;\r\n    Size nbytes;\r\n    XLogSegNo segno;\r\n\r\nretry:\r\n    p = buf;\r\n    recptr = startptr;\r\n    nbytes = count;\r\n\r\n    while (nbytes > 0) {\r\n        uint32 startoff;\r\n        int segbytes;\r\n        int readbytes;\r\n\r\n        startoff = recptr % XLogSegSize;\r\n\r\n        /* Do we need to switch to a different xlog segment? */\r\n        if (t_thrd.walsender_cxt.sendFile < 0 || !XLByteInSeg(recptr, t_thrd.walsender_cxt.sendSegNo)) {\r\n            char path[MAXPGPATH];\r\n\r\n            if (t_thrd.walsender_cxt.sendFile >= 0) {\r\n                (void)close(t_thrd.walsender_cxt.sendFile);\r\n            }\r\n\r\n            XLByteToSeg(recptr, t_thrd.walsender_cxt.sendSegNo);\r\n            XLogFilePath(path, t_thrd.xlog_cxt.ThisTimeLineID, t_thrd.walsender_cxt.sendSegNo);\r\n\r\n            t_thrd.walsender_cxt.sendFile = BasicOpenFile(path, O_RDONLY | PG_BINARY, 0);\r\n            if (t_thrd.walsender_cxt.sendFile < 0) {\r\n                /*\r\n                 * If the file is not found, assume it's because the standby\r\n                 * asked for a too old WAL segment that has already been\r\n                 * removed or recycled.\r\n                 */\r\n                if (errno == ENOENT) {\r\n                    /* we suppose wal segments removed happend when we can't open the xlog file. */\r\n                    WalSegmemtRemovedhappened = true;\r\n                    ereport(ERROR,\r\n                        (errcode_for_file_access(),\r\n                            errmsg(\"requested WAL segment %s has already been removed\",\r\n                                XLogFileNameP(t_thrd.xlog_cxt.ThisTimeLineID, t_thrd.walsender_cxt.sendSegNo))));\r\n                } else {\r\n                    ereport(ERROR,\r\n                        (errcode_for_file_access(),\r\n                            errmsg(\"could not open file \\\"%s\\\" (log segment %s): %m\",\r\n                                path,\r\n                                XLogFileNameP(t_thrd.xlog_cxt.ThisTimeLineID, t_thrd.walsender_cxt.sendSegNo))));\r\n                }\r\n            }\r\n            t_thrd.walsender_cxt.sendOff = 0;\r\n        }\r\n\r\n        /* Need to seek in the file? */\r\n        if (t_thrd.walsender_cxt.sendOff != startoff) {\r\n            if (lseek(t_thrd.walsender_cxt.sendFile, (off_t)startoff, SEEK_SET) < 0) {\r\n                (void)close(t_thrd.walsender_cxt.sendFile);\r\n                t_thrd.walsender_cxt.sendFile = -1;\r\n                ereport(ERROR,\r\n                    (errcode_for_file_access(),\r\n                        errmsg(\"could not seek in log segment %s to offset %u: %m\",\r\n                            XLogFileNameP(t_thrd.xlog_cxt.ThisTimeLineID, t_thrd.walsender_cxt.sendSegNo),\r\n                            startoff)));\r\n            }\r\n            t_thrd.walsender_cxt.sendOff = startoff;\r\n        }\r\n\r\n        /* How many bytes are within this segment? */\r\n        if (nbytes > (XLogSegSize - startoff)) {\r\n            segbytes = XLogSegSize - startoff;\r\n        } else {\r\n            segbytes = nbytes;\r\n        }\r\n\r\n        pgstat_report_waitevent(WAIT_EVENT_WAL_READ);\r\n        readbytes = read(t_thrd.walsender_cxt.sendFile, p, segbytes);\r\n        pgstat_report_waitevent(WAIT_EVENT_END);\r\n        if (readbytes <= 0) {\r\n            (void)close(t_thrd.walsender_cxt.sendFile);\r\n            t_thrd.walsender_cxt.sendFile = -1;\r\n            ereport(ERROR,\r\n                (errcode_for_file_access(),\r\n                    errmsg(\"could not read from log segment %s, offset %u, length %lu: %m\",\r\n                        XLogFileNameP(t_thrd.xlog_cxt.ThisTimeLineID, t_thrd.walsender_cxt.sendSegNo),\r\n                        t_thrd.walsender_cxt.sendOff,\r\n                        INT2ULONG(segbytes))));\r\n        }\r\n\r\n        /* Update state for read */\r\n        XLByteAdvance(recptr, readbytes);\r\n\r\n        t_thrd.walsender_cxt.sendOff += readbytes;\r\n        nbytes -= readbytes;\r\n        p += readbytes;\r\n    }\r\n\r\n    /*\r\n     * After reading into the buffer, check that what we read was valid. We do\r\n     * this after reading, because even though the segment was present when we\r\n     * opened it, it might get recycled or removed while we read it. The\r\n     * read() succeeds in that case, but the data we tried to read might\r\n     * already have been overwritten with new WAL records.\r\n     */\r\n    XLByteToSeg(startptr, segno);\r\n    CheckXLogRemoved(segno, t_thrd.xlog_cxt.ThisTimeLineID);\r\n\r\n    /*\r\n     * During recovery, the currently-open WAL file might be replaced with the\r\n     * file of the same name retrieved from archive. So we always need to\r\n     * check what we read was valid after reading into the buffer. If it's\r\n     * invalid, we try to open and read the file again.\r\n     */\r\n    if (AM_WAL_STANDBY_SENDER) {\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n        bool reload = false;\r\n\r\n        SpinLockAcquire(&walsnd->mutex);\r\n        reload = walsnd->needreload;\r\n        walsnd->needreload = false;\r\n        SpinLockRelease(&walsnd->mutex);\r\n\r\n        if (reload && t_thrd.walsender_cxt.sendFile >= 0) {\r\n            (void)close(t_thrd.walsender_cxt.sendFile);\r\n            t_thrd.walsender_cxt.sendFile = -1;\r\n\r\n            goto retry;\r\n        }\r\n    }\r\n\r\n    /* we open the xlog file success. it seems we are in good status. */\r\n    WalSegmemtRemovedhappened = false;\r\n}",
		"comment":"/*\r\n * Read 'count' bytes from WAL into 'buf', starting at location 'startptr'.\r\n * XXX probably this should be improved to suck data directly from the\r\n * WAL buffers when possible. Will open, and keep open, one WAL segment \r\n * stored in the global file descriptor sendFile. This means if XLogRead is used\r\n * once, there will always be one descriptor left open until the process ends, but never\r\n * more than one.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"XLogRead"
	},
	"XLogSendLogical":{
		"body":"static void XLogSendLogical(void)\r\n{\r\n    CheckPMstateAndRecoveryInProgress();\r\n    XLogRecord* record = NULL;\r\n    char* errm = NULL;\r\n\r\n    /*\r\n     * Don't know whether we've caught up yet. We'll set it to true in\r\n     * WalSndWaitForWal, if we're actually waiting. We also set to true if\r\n     * XLogReadRecord() had to stop reading but WalSndWaitForWal didn't wait -\r\n     * i.e. when we're shutting down.\r\n     */\r\n    WalSndCaughtUp = false;\r\n\r\n    record =\r\n        XLogReadRecord(t_thrd.walsender_cxt.logical_decoding_ctx->reader, t_thrd.walsender_cxt.logical_startptr, &errm);\r\n    t_thrd.walsender_cxt.logical_startptr = InvalidXLogRecPtr;\r\n\r\n    /* xlog record was invalid */\r\n    if (errm != NULL)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_LOGICAL_DECODE_ERROR),\r\n                errmsg(\"Stopped to parse any valid XLog Record at %X/%X: %s.\",\r\n                    (uint32)(t_thrd.walsender_cxt.logical_decoding_ctx->reader->EndRecPtr >> 32),\r\n                    (uint32)t_thrd.walsender_cxt.logical_decoding_ctx->reader->EndRecPtr,\r\n                    errm)));\r\n\r\n    if (record != NULL) {\r\n        LogicalDecodingProcessRecord(\r\n            t_thrd.walsender_cxt.logical_decoding_ctx, t_thrd.walsender_cxt.logical_decoding_ctx->reader);\r\n\r\n        t_thrd.walsender_cxt.sentPtr = t_thrd.walsender_cxt.logical_decoding_ctx->reader->EndRecPtr;\r\n    } else {\r\n        /*\r\n         * If the record we just wanted read is at or beyond the flushed point,\r\n         * then we're caught up.\r\n         */\r\n        if (t_thrd.walsender_cxt.logical_decoding_ctx->reader->EndRecPtr >= GetFlushRecPtr())\r\n            WalSndCaughtUp = true;\r\n    }\r\n\r\n    /* Update shared memory status */\r\n    {\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n\r\n        SpinLockAcquire(&walsnd->mutex);\r\n        walsnd->sentPtr = t_thrd.walsender_cxt.sentPtr;\r\n        SpinLockRelease(&walsnd->mutex);\r\n    }\r\n}",
		"comment":"/*\r\n * Stream out logically decoded data.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"XLogSendLogical"
	},
	"XLogSendPhysical":{
		"body":"static void XLogSendPhysical(void)\r\n{\r\n    XLogRecPtr SendRqstPtr = InvalidXLogRecPtr;\r\n    XLogRecPtr startptr = InvalidXLogRecPtr;\r\n    XLogRecPtr endptr = InvalidXLogRecPtr;\r\n    Size nbytes = 0;\r\n    WalDataMessageHeader msghdr;\r\n    ServerMode local_role;\r\n    volatile HaShmemData* hashmdata = t_thrd.postmaster_cxt.HaShmData;\r\n    errno_t errorno = EOK;\r\n\r\n    t_thrd.walsender_cxt.catchup_threshold = 0;\r\n\r\n    /*\r\n     * Attempt to send all data that's already been written out and fsync'd to\r\n     * disk.  We cannot go further than what's been written out given the\r\n     * current implementation of XLogRead().  And in any case it's unsafe to\r\n     * send WAL that is not securely down to disk on the master: if the master\r\n     * subsequently crashes and restarts, slaves must not have applied any WAL\r\n     * that gets lost on the master.\r\n     */\r\n    if (AM_WAL_STANDBY_SENDER) {\r\n        TimeLineID currentTargetTLI;\r\n        SendRqstPtr = GetStandbyFlushRecPtr(&currentTargetTLI);\r\n\r\n        /*\r\n         * If the recovery target timeline changed, bail out. It's a bit\r\n         * unfortunate that we have to just disconnect, but there is no way\r\n         * to tell the client that the timeline changed. We also don't know\r\n         * exactly where the switch happened, so we cannot safely try to send\r\n         * up to the switchover point before disconnecting.\r\n         */\r\n        if (currentTargetTLI != t_thrd.xlog_cxt.ThisTimeLineID) {\r\n            if (!t_thrd.walsender_cxt.walsender_ready_to_stop)\r\n                ereport(LOG,\r\n                    (errmsg(\"terminating walsender process to force cascaded standby \"\r\n                            \"to update timeline and reconnect\")));\r\n            t_thrd.walsender_cxt.walsender_ready_to_stop = true;\r\n            WalSndCaughtUp = true;\r\n            return;\r\n        }\r\n    } else if (dummyStandbyMode)\r\n        SendRqstPtr = GetWalRcvWriteRecPtr(NULL);\r\n    else\r\n        SendRqstPtr = GetFlushRecPtr();\r\n\r\n    /* Quick exit if nothing to do */\r\n    if (!u_sess->attr.attr_storage.enable_stream_replication || XLByteLE(SendRqstPtr, t_thrd.walsender_cxt.sentPtr)) {\r\n        WalSndCaughtUp = true;\r\n        return;\r\n    }\r\n\r\n    /*\r\n     * Figure out how much to send in one message. If there's no more than\r\n     * MAX_SEND_SIZE bytes to send, send everything. Otherwise send\r\n     * MAX_SEND_SIZE bytes, but round back to logfile or page boundary.\r\n     *\r\n     * The rounding is not only for performance reasons. Walreceiver relies on\r\n     * the fact that we never split a WAL record across two messages. Since a\r\n     * long WAL record is split at page boundary into continuation records,\r\n     * page boundary is always a safe cut-off point. We also assume that\r\n     * SendRqstPtr never points to the middle of a WAL record.\r\n     */\r\n    startptr = t_thrd.walsender_cxt.sentPtr;\r\n    endptr = startptr;\r\n    XLByteAdvance(endptr, g_instance.attr.attr_storage.MaxSendSize * 1024);\r\n\r\n    /* if we went beyond SendRqstPtr, back off */\r\n    if (XLByteLE(SendRqstPtr, endptr)) {\r\n        endptr = SendRqstPtr;\r\n        WalSndCaughtUp = true;\r\n    } else {\r\n        /* round down to page boundary. */\r\n        endptr -= (endptr % XLOG_BLCKSZ);\r\n        WalSndCaughtUp = false;\r\n        t_thrd.walsender_cxt.catchup_threshold = XLByteDifference(SendRqstPtr, endptr);\r\n    }\r\n\r\n    nbytes = endptr - startptr;\r\n    Assert(nbytes <= (Size)g_instance.attr.attr_storage.MaxSendSize * 1024);\r\n\r\n    if (nbytes == 0)\r\n        ereport(NOTICE,\r\n            (errmsg(\"streaming body is empty, \"\r\n                    \"request send: %X/%X, already sent: %X/%X\",\r\n                (uint32)(SendRqstPtr >> 32),\r\n                (uint32)SendRqstPtr,\r\n                (uint32)(t_thrd.walsender_cxt.sentPtr >> 32),\r\n                (uint32)t_thrd.walsender_cxt.sentPtr)));\r\n\r\n    /*\r\n     * OK to read and send the slice.\r\n     */\r\n    t_thrd.walsender_cxt.output_xlog_message[0] = 'w';\r\n\r\n    /*\r\n     * Read the log directly into the output buffer to avoid extra memcpy\r\n     * calls.\r\n     */\r\n    XLogRead(t_thrd.walsender_cxt.output_xlog_message + 1 + sizeof(WalDataMessageHeader), startptr, nbytes);\r\n    ereport(DEBUG5,\r\n        (errmsg(\"conninfo:(%s,%d) start: %X/%X, end: %X/%X, %lu bytes\",\r\n            t_thrd.walsender_cxt.MyWalSnd->wal_sender_channel.localhost,\r\n            t_thrd.walsender_cxt.MyWalSnd->wal_sender_channel.localport,\r\n            (uint32)(startptr >> 32),\r\n            (uint32)startptr,\r\n            (uint32)(endptr >> 32),\r\n            (uint32)endptr,\r\n            nbytes)));\r\n\r\n    /*\r\n     * We fill the message header last so that the send timestamp is taken as\r\n     * late as possible.\r\n     */\r\n    msghdr.dataStart = startptr;\r\n    msghdr.walEnd = SendRqstPtr;\r\n    msghdr.sendTime = GetCurrentTimestamp();\r\n    msghdr.sender_sent_location = endptr;\r\n    msghdr.catchup = (t_thrd.walsender_cxt.MyWalSnd->state == WALSNDSTATE_CATCHUP && !WalSndCaughtUp);\r\n    SpinLockAcquire(&hashmdata->mutex);\r\n    local_role = hashmdata->current_mode;\r\n    SpinLockRelease(&hashmdata->mutex);\r\n    if (local_role == PRIMARY_MODE) {\r\n        /* Local role is a primary */\r\n        msghdr.sender_flush_location = GetFlushRecPtr();\r\n        msghdr.sender_replay_location = msghdr.sender_flush_location;\r\n        msghdr.sender_write_location = GetXLogWriteRecPtr();\r\n    } else {\r\n        /* Local role is not a primary */\r\n        msghdr.sender_write_location = GetWalRcvWriteRecPtr(NULL);\r\n        msghdr.sender_flush_location = GetStandbyFlushRecPtr(NULL);\r\n        msghdr.sender_replay_location = GetXLogReplayRecPtr(NULL);\r\n    }\r\n\r\n    errorno = memcpy_s(t_thrd.walsender_cxt.output_xlog_message + 1,\r\n        sizeof(WalDataMessageHeader) + g_instance.attr.attr_storage.MaxSendSize * 1024,\r\n        &msghdr,\r\n        sizeof(WalDataMessageHeader));\r\n    securec_check(errorno, \"\\0\", \"\\0\");\r\n    (void)pq_putmessage_noblock(\r\n        'd', t_thrd.walsender_cxt.output_xlog_message, 1 + sizeof(WalDataMessageHeader) + nbytes);\r\n\r\n    t_thrd.walsender_cxt.sentPtr = endptr;\r\n\r\n    /* Update shared memory status */\r\n    {\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile WalSnd* walsnd = t_thrd.walsender_cxt.MyWalSnd;\r\n\r\n        SpinLockAcquire(&walsnd->mutex);\r\n        walsnd->sentPtr = t_thrd.walsender_cxt.sentPtr;\r\n        SpinLockRelease(&walsnd->mutex);\r\n    }\r\n\r\n    /* Report progress of XLOG streaming in PS display */\r\n    if (u_sess->attr.attr_common.update_process_title) {\r\n        char activitymsg[50];\r\n        int rc = 0;\r\n\r\n        rc = snprintf_s(activitymsg,\r\n            sizeof(activitymsg),\r\n            sizeof(activitymsg) - 1,\r\n            \"streaming %X/%X\",\r\n            (uint32)(t_thrd.walsender_cxt.sentPtr >> 32),\r\n            (uint32)t_thrd.walsender_cxt.sentPtr);\r\n        securec_check_ss(rc, \"\\0\", \"\\0\");\r\n\r\n        set_ps_display(activitymsg, false);\r\n    }\r\n\r\n    return;\r\n}",
		"comment":"/*\r\n * Read up to MAX_SEND_SIZE bytes of WAL that's been flushed to disk,\r\n * but not yet sent to the client, and buffer it in the libpq output buffer.\r\n *\r\n * If there is no unsent WAL remaining, *caughtup is set to true, otherwise\r\n * *caughtup is set to false.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"XLogSendPhysical"
	},
	"cmdStringCheck":{
		"body":"bool cmdStringCheck(const char* cmd_string)\r\n{\r\n    const int maxStack = 100;\r\n    char charStack[maxStack];\r\n    int stackLen = 0;\r\n    for (int i = 0; cmd_string[i] != '\\0'; i++) {\r\n        if (cmd_string[i] == '\\\"') {\r\n            if (stackLen > 0 && charStack[stackLen - 1] == '\\\"') {\r\n                stackLen--;\r\n            } else {\r\n                charStack[stackLen++] = '\\\"';\r\n            }\r\n        } else if (cmd_string[i] == '\\'') {\r\n            if (stackLen > 0 && charStack[stackLen - 1] == '\\'') {\r\n                stackLen--;\r\n            } else {\r\n                charStack[stackLen++] = '\\'';\r\n            }\r\n        } else if (cmd_string[i] == '(') {\r\n            charStack[stackLen++] = '(';\r\n        } else if (cmd_string[i] == ')') {\r\n            if (stackLen > 0 && charStack[stackLen - 1] == '(') {\r\n                stackLen--;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    if (stackLen == 0) {\r\n        return true;\r\n    }\r\n    return false;\r\n}",
		"comment":"/*\r\n * Check cmdString format.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"cmdStringCheck"
	},
	"do_actual_sleep":{
		"body":"static void do_actual_sleep(volatile WalSnd* walsnd)\r\n{\r\n    bool logical_slot_sleep_flag = LogicalSlotSleepFlag();\r\n    /* try to control log sent rate so that standby can flush and apply log under RTO seconds */\r\n    if (walsnd->state == WALSNDSTATE_STREAMING && IS_PGXC_DATANODE) {\r\n        if (u_sess->attr.attr_storage.target_rto > 0) {\r\n            if (walsnd->log_ctrl.sleep_count % walsnd->log_ctrl.sleep_count_limit == 0) {\r\n                LogCtrlCalculateSleepTime();\r\n                LogCtrlCountSleepLimit();\r\n            }\r\n            LogCtrlSleep();\r\n            if (logical_slot_sleep_flag &&\r\n                g_logical_slot_sleep_time > t_thrd.walsender_cxt.MyWalSnd->log_ctrl.sleep_time) {\r\n                pg_usleep(g_logical_slot_sleep_time - t_thrd.walsender_cxt.MyWalSnd->log_ctrl.sleep_time);\r\n            }\r\n        } else {\r\n            if (logical_slot_sleep_flag) {\r\n                pg_usleep(g_logical_slot_sleep_time);\r\n            }\r\n        }\r\n    }\r\n    walsnd->log_ctrl.sleep_count++;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"do_actual_sleep"
	},
	"logical_read_xlog_page":{
		"body":"static int logical_read_xlog_page(XLogReaderState* state, XLogRecPtr targetPagePtr, int reqLen, XLogRecPtr targetRecPtr,\r\n    char* cur_page, TimeLineID* pageTLI)\r\n{\r\n    XLogRecPtr flushptr;\r\n    int count;\r\n\r\n    /* make sure we have enough WAL available */\r\n    flushptr = WalSndWaitForWal(targetPagePtr + reqLen);\r\n    /* fail if not (implies we are going to shut down) */\r\n    if (flushptr < targetPagePtr + reqLen)\r\n        return -1;\r\n\r\n    if (targetPagePtr + XLOG_BLCKSZ <= flushptr)\r\n        count = XLOG_BLCKSZ; /* more than one block available */\r\n    else\r\n        count = flushptr - targetPagePtr; /* part of the page available */\r\n\r\n    /* now actually read the data, we know it's there */\r\n    XLogRead(cur_page, targetPagePtr, XLOG_BLCKSZ);\r\n\r\n    return count;\r\n}",
		"comment":"/*\r\n * read_page callback for logical decoding contexts, as a walsender process.\r\n *\r\n * Inside the walsender we can do better than logical_read_local_xlog_page,\r\n * which has to do a plain sleep/busy loop, because the walsender's latch gets\r\n * set everytime WAL is flushed.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"logical_read_xlog_page"
	},
	"pg_stat_get_wal_senders":{
		"body":"Datum pg_stat_get_wal_senders(PG_FUNCTION_ARGS)\r\n{\r\n#define PG_STAT_GET_WAL_SENDERS_COLS 21\r\n\r\n    TupleDesc tupdesc;\r\n    Tuplestorestate* tupstore = NULL;\r\n    int* sync_priority = NULL;\r\n    int i = 0;\r\n    volatile HaShmemData* hashmdata = t_thrd.postmaster_cxt.HaShmData;\r\n    List* sync_standbys = NIL;\r\n\r\n    tupstore = BuildTupleResult(fcinfo, &tupdesc);\r\n\r\n    if (IS_DN_DUMMY_STANDYS_MODE()) {\r\n        /*\r\n         * Get the priorities of sync standbys all in one go, to minimise lock\r\n         * acquisitions and to allow us to evaluate who is the current sync\r\n         * standby. This code must match the code in SyncRepReleaseWaiters().\r\n         */\r\n        sync_priority = (int*)palloc(sizeof(int) * g_instance.attr.attr_storage.max_wal_senders);\r\n        for (i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n            /* use volatile pointer to prevent code rearrangement */\r\n            volatile WalSnd* walsnd = &t_thrd.walsender_cxt.WalSndCtl->walsnds[i];\r\n\r\n            if (walsnd->pid != 0) {\r\n                /*\r\n                 * Treat a standby such as a pg_basebackup background process\r\n                 * which always returns an invalid flush location, as an\r\n                 * asynchronous standby.\r\n                 */\r\n                sync_priority[i] = XLogRecPtrIsInvalid(walsnd->flush) ? 0 : walsnd->sync_standby_priority;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get the currently active synchronous standbys.\r\n     */\r\n    LWLockAcquire(SyncRepLock, LW_SHARED);\r\n    sync_standbys = SyncRepGetSyncStandbys(NULL);\r\n    LWLockRelease(SyncRepLock);\r\n\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile WalSnd* walsnd = &t_thrd.walsender_cxt.WalSndCtl->walsnds[i];\r\n        char location[MAXFNAMELEN] = {0};\r\n        XLogRecPtr sentRecPtr;\r\n        XLogRecPtr local_write;\r\n        XLogRecPtr flush;\r\n        XLogRecPtr apply;\r\n        WalSndState state;\r\n        XLogRecPtr sndWrite;\r\n        XLogRecPtr sndFlush;\r\n        XLogRecPtr sndReplay;\r\n        XLogRecPtr RcvReceived;\r\n        XLogRecPtr syncStart;\r\n\r\n        int sync_percent = 0;\r\n        ServerMode peer_role;\r\n        SndRole snd_role;\r\n        DbState peer_state;\r\n        ServerMode local_role;\r\n        char localip[IP_LEN] = {0};\r\n        char remoteip[IP_LEN] = {0};\r\n        TimestampTz catchup_time[2];\r\n        int localport = 0;\r\n        int remoteport = 0;\r\n        Datum values[PG_STAT_GET_WAL_SENDERS_COLS];\r\n        bool nulls[PG_STAT_GET_WAL_SENDERS_COLS];\r\n        int j = 0;\r\n        errno_t rc = 0;\r\n        int ret = 0;\r\n        int priority = 0;\r\n\r\n        SpinLockAcquire(&hashmdata->mutex);\r\n        local_role = hashmdata->current_mode;\r\n        if (walsnd->pid == 0) {\r\n            SpinLockRelease(&hashmdata->mutex);\r\n            continue;\r\n        }\r\n        SpinLockRelease(&hashmdata->mutex);\r\n        SpinLockAcquire(&walsnd->mutex);\r\n\r\n        localport = walsnd->wal_sender_channel.localport;\r\n        remoteport = walsnd->wal_sender_channel.remoteport;\r\n        rc = strncpy_s(localip, IP_LEN, (char*)walsnd->wal_sender_channel.localhost, IP_LEN - 1);\r\n        securec_check(rc, \"\\0\", \"\\0\");\r\n        rc = strncpy_s(remoteip, IP_LEN, (char*)walsnd->wal_sender_channel.remotehost, IP_LEN - 1);\r\n        securec_check(rc, \"\\0\", \"\\0\");\r\n        localip[IP_LEN - 1] = '\\0';\r\n        remoteip[IP_LEN - 1] = '\\0';\r\n        peer_role = walsnd->peer_role;\r\n        snd_role = walsnd->sendRole;\r\n        peer_state = walsnd->peer_state;\r\n        state = walsnd->state;\r\n\r\n        sentRecPtr = walsnd->sentPtr;\r\n        local_write = walsnd->write;\r\n        flush = walsnd->flush;\r\n        apply = walsnd->apply;\r\n        RcvReceived = walsnd->receive;\r\n        syncStart = walsnd->syncPercentCountStart;\r\n        catchup_time[0] = walsnd->catchupTime[0];\r\n        catchup_time[1] = walsnd->catchupTime[1];\r\n        if (IS_DN_MULTI_STANDYS_MODE())\r\n            priority = walsnd->sync_standby_priority;\r\n        SpinLockRelease(&walsnd->mutex);\r\n\r\n        if (local_role == PRIMARY_MODE) {\r\n            sndWrite = GetXLogWriteRecPtr();\r\n            sndFlush = GetFlushRecPtr();\r\n            sndReplay = sndFlush;\r\n        } else {\r\n            sndWrite = GetWalRcvWriteRecPtr(NULL);\r\n            sndFlush = GetStandbyFlushRecPtr(NULL);\r\n            sndReplay = GetXLogReplayRecPtr(NULL);\r\n        }\r\n\r\n        rc = memset_s(nulls, sizeof(nulls), 0, sizeof(nulls));\r\n        securec_check(rc, \"\\0\", \"\\0\");\r\n\r\n        values[j++] = Int64GetDatum(walsnd->pid);\r\n        values[j++] = Int32GetDatum(walsnd->lwpId);\r\n\r\n        if (!superuser()) {\r\n            /*\r\n             * Only superusers can see details. Other users only get the pid\r\n             * value to know it's a walsender, but no details.\r\n             */\r\n            rc = memset_s(&nulls[j], PG_STAT_GET_WAL_SENDERS_COLS - j, true, PG_STAT_GET_WAL_SENDERS_COLS - j);\r\n            securec_check(rc, \"\\0\", \"\\0\");\r\n        } else {\r\n            /* local_role */\r\n            values[j++] = CStringGetTextDatum(wal_get_role_string(local_role));\r\n\r\n            /* peer_role */\r\n            if (snd_role == SNDROLE_PRIMARY_DUMMYSTANDBY)\r\n                values[j++] = CStringGetTextDatum(\"Secondary\");\r\n            else\r\n                values[j++] = CStringGetTextDatum(wal_get_role_string(peer_role));\r\n\r\n            /* peer_state */\r\n            values[j++] = CStringGetTextDatum(wal_get_db_state_string(peer_state));\r\n\r\n            /* state */\r\n            values[j++] = CStringGetTextDatum(WalSndGetStateString(state));\r\n\r\n            /* catchup time */\r\n            if (catchup_time[0] != 0)\r\n                values[j++] = TimestampTzGetDatum(catchup_time[0]);\r\n            else\r\n                nulls[j++] = true;\r\n            if (catchup_time[1] != 0 && (state != WALSNDSTATE_CATCHUP))\r\n                values[j++] = TimestampTzGetDatum(catchup_time[1]);\r\n            else\r\n                nulls[j++] = true;\r\n\r\n            /* sender_sent_location */\r\n            ret = snprintf_s(location,\r\n                sizeof(location),\r\n                sizeof(location) - 1,\r\n                \"%X/%X\",\r\n                (uint32)(sentRecPtr >> 32),\r\n                (uint32)sentRecPtr);\r\n            securec_check_ss(ret, \"\\0\", \"\\0\");\r\n            values[j++] = CStringGetTextDatum(location);\r\n\r\n            /* sender_write_location */\r\n            if (sndWrite == 0)\r\n                SETXLOGLOCATION(sndWrite, sentRecPtr)\r\n            ret = snprintf_s(\r\n                location, sizeof(location), sizeof(location) - 1, \"%X/%X\", (uint32)(sndWrite >> 32), (uint32)sndWrite);\r\n            securec_check_ss(ret, \"\\0\", \"\\0\");\r\n            values[j++] = CStringGetTextDatum(location);\r\n\r\n            /* sender_flush_location */\r\n            if (sndFlush == 0)\r\n                SETXLOGLOCATION(sndFlush, sentRecPtr)\r\n            ret = snprintf_s(\r\n                location, sizeof(location), sizeof(location) - 1, \"%X/%X\", (uint32)(sndFlush >> 32), (uint32)sndFlush);\r\n            securec_check_ss(ret, \"\\0\", \"\\0\");\r\n            values[j++] = CStringGetTextDatum(location);\r\n\r\n            /* sender_replay_location */\r\n            if (sndReplay == 0)\r\n                SETXLOGLOCATION(sndReplay, sentRecPtr)\r\n            ret = snprintf_s(location,\r\n                sizeof(location),\r\n                sizeof(location) - 1,\r\n                \"%X/%X\",\r\n                (uint32)(sndReplay >> 32),\r\n                (uint32)sndReplay);\r\n            securec_check_ss(ret, \"\\0\", \"\\0\");\r\n            values[j++] = CStringGetTextDatum(location);\r\n\r\n            /* receiver_received_location */\r\n            if (RcvReceived == 0)\r\n                SETXLOGLOCATION(RcvReceived, sentRecPtr)\r\n            ret = snprintf_s(location,\r\n                sizeof(location),\r\n                sizeof(location) - 1,\r\n                \"%X/%X\",\r\n                (uint32)(RcvReceived >> 32),\r\n                (uint32)RcvReceived);\r\n            securec_check_ss(ret, \"\\0\", \"\\0\");\r\n            values[j++] = CStringGetTextDatum(location);\r\n\r\n            /* receiver_write_location */\r\n            if (local_write == 0)\r\n                SETXLOGLOCATION(local_write, sentRecPtr)\r\n            ret = snprintf_s(location,\r\n                sizeof(location),\r\n                sizeof(location) - 1,\r\n                \"%X/%X\",\r\n                (uint32)(local_write >> 32),\r\n                (uint32)local_write);\r\n            securec_check_ss(ret, \"\\0\", \"\\0\");\r\n            values[j++] = CStringGetTextDatum(location);\r\n\r\n            /* receiver_flush_location */\r\n            if (flush == 0)\r\n                SETXLOGLOCATION(flush, sentRecPtr)\r\n            ret = snprintf_s(\r\n                location, sizeof(location), sizeof(location) - 1, \"%X/%X\", (uint32)(flush >> 32), (uint32)flush);\r\n            securec_check_ss(ret, \"\\0\", \"\\0\");\r\n            values[j++] = CStringGetTextDatum(location);\r\n\r\n            /* receiver_replay_location */\r\n            if (apply == 0)\r\n                SETXLOGLOCATION(apply, sentRecPtr)\r\n            ret = snprintf_s(\r\n                location, sizeof(location), sizeof(location) - 1, \"%X/%X\", (uint32)(apply >> 32), (uint32)apply);\r\n            securec_check_ss(ret, \"\\0\", \"\\0\");\r\n            values[j++] = CStringGetTextDatum(location);\r\n\r\n            /* sync_percent */\r\n            sync_percent = GetSyncPercent(syncStart, sndFlush, flush);\r\n            ret = snprintf_s(location, sizeof(location), sizeof(location) - 1, \"%d%%\", sync_percent);\r\n            securec_check_ss(ret, \"\\0\", \"\\0\");\r\n            values[j++] = CStringGetTextDatum(location);\r\n\r\n            if (IS_DN_DUMMY_STANDYS_MODE()) {\r\n                /* sync_state and sync_prority */\r\n                if (!SyncRepRequested()) {\r\n                    values[j++] = CStringGetTextDatum(\"Async\");\r\n                    values[j++] = Int32GetDatum(0);\r\n                } else {\r\n                    values[j++] = CStringGetTextDatum(\"Sync\");\r\n                    values[j++] = Int32GetDatum(sync_priority[i]);\r\n                }\r\n            } else {\r\n                /*\r\n                 * Treat a standby such as a pg_basebackup background process\r\n                 * which always returns an invalid flush location, as an\r\n                 * asynchronous standby.\r\n                 */\r\n                priority = XLogRecPtrIsInvalid(walsnd->flush) ? 0 : priority;\r\n                /*\r\n                 * More easily understood version of standby state. This is purely\r\n                 * informational.\r\n                 * In quorum-based sync replication, the role of each standby\r\n                 * listed in synchronous_standby_names can be changing very\r\n                 * frequently. Any standbys considered as \"sync\" at one moment can\r\n                 * be switched to \"potential\" ones at the next moment. So, it's\r\n                 * basically useless to report \"sync\" or \"potential\" as their sync\r\n                 * states. We report just \"quorum\" for them.\r\n                 */\r\n                if (priority == 0)\r\n                    values[j++] = CStringGetTextDatum(\"Async\");\r\n                else if (list_member_int(sync_standbys, i)) {\r\n                    values[j++] = t_thrd.syncrep_cxt.SyncRepConfig->syncrep_method == SYNC_REP_PRIORITY ?\r\n                        CStringGetTextDatum(\"Sync\") :\r\n                        CStringGetTextDatum(\"Quorum\");\r\n                } else\r\n                    values[j++] = CStringGetTextDatum(\"Potential\");\r\n                values[j++] = Int32GetDatum(priority);\r\n            }\r\n\r\n            if (most_available_sync)\r\n                values[j++] = CStringGetTextDatum(\"On\");\r\n            else\r\n                values[j++] = CStringGetTextDatum(\"Off\");\r\n\r\n            /* channel */\r\n            ret = snprintf_s(location,\r\n                sizeof(location),\r\n                sizeof(location) - 1,\r\n                \"%s:%d-->%s:%d\",\r\n                localip,\r\n                localport,\r\n                remoteip,\r\n                remoteport);\r\n            securec_check_ss(ret, \"\\0\", \"\\0\");\r\n            values[j++] = CStringGetTextDatum(location);\r\n        }\r\n\r\n        tuplestore_putvalues(tupstore, tupdesc, values, nulls);\r\n    }\r\n    list_free(sync_standbys);\r\n    if (sync_priority != NULL) {\r\n        pfree(sync_priority);\r\n        sync_priority = NULL;\r\n    }\r\n\r\n    /* clean up and return the tuplestore */\r\n    tuplestore_donestoring(tupstore);\r\n\r\n    return (Datum)0;\r\n}",
		"comment":"/*\r\n * Returns activity of walsenders, including pids and xlog locations sent to\r\n * standby servers.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"pg_stat_get_wal_senders"
	},
	"remote_role_to_string":{
		"body":"char* remote_role_to_string(int role)\r\n{\r\n    switch (role) {\r\n        case SNDROLE_PRIMARY_STANDBY:\r\n            return \"STANDBY\";\r\n            break;\r\n        case SNDROLE_PRIMARY_BUILDSTANDBY:\r\n            return \"BUILD_STANDBY\";\r\n            break;\r\n        case SNDROLE_PRIMARY_DUMMYSTANDBY:\r\n            return \"DUMMYSTANDBY\";\r\n            break;\r\n        case SNDROLE_DUMMYSTANDBY_STANDBY:\r\n            return \"DSTANDBY\";\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n\r\n    return \"UNKNOW\";\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walsender.cpp",
		"name":"remote_role_to_string"
	}
}