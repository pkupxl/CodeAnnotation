{
	"ha_add_disconnect_count":{
		"body":"static void ha_add_disconnect_count()\r\n{\r\n    volatile HaShmemData* hashmdata = t_thrd.postmaster_cxt.HaShmData;\r\n\r\n    SpinLockAcquire(&hashmdata->mutex);\r\n    hashmdata->disconnect_count[hashmdata->current_repl] += 1;\r\n    SpinLockRelease(&hashmdata->mutex);\r\n}",
		"comment":"/* Add disconnect_count of the current repl */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\libpqwalreceiver.cpp",
		"name":"ha_add_disconnect_count"
	},
	"ha_set_conn_channel":{
		"body":"static void ha_set_conn_channel()\r\n{\r\n    struct sockaddr* laddr = (struct sockaddr*)PQLocalSockaddr(t_thrd.libwalreceiver_cxt.streamConn);\r\n    struct sockaddr* raddr = (struct sockaddr*)PQRemoteSockaddr(t_thrd.libwalreceiver_cxt.streamConn);\r\n    char local_ip[IP_LEN] = {0};\r\n    char remote_ip[IP_LEN] = {0};\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    errno_t rc = 0;\r\n\r\n    char* result = NULL;\r\n\r\n    if (laddr == NULL || raddr == NULL) {\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INVALID_STATUS), errmsg(\"sockaddr is NULL, because there is no connection to primary\")));\r\n        return;\r\n    }\r\n    if (laddr->sa_family == AF_INET6) {\r\n        result = inet_net_ntop(AF_INET6, &((struct sockaddr_in*)laddr)->sin_addr, 128, local_ip, IP_LEN);\r\n        if (result == NULL) {\r\n            ereport(WARNING, (errmsg(\"inet_net_ntop failed, error: %d\", EAFNOSUPPORT)));\r\n        }\r\n    } else if (laddr->sa_family == AF_INET) {\r\n        result = inet_net_ntop(AF_INET, &((struct sockaddr_in*)laddr)->sin_addr, 32, local_ip, IP_LEN);\r\n        if (result == NULL) {\r\n            ereport(WARNING, (errmsg(\"inet_net_ntop failed, error: %d\", EAFNOSUPPORT)));\r\n        }\r\n    }\r\n\r\n    if (raddr->sa_family == AF_INET6) {\r\n        result = inet_net_ntop(AF_INET6, &((struct sockaddr_in*)raddr)->sin_addr, 128, remote_ip, IP_LEN);\r\n        if (result == NULL) {\r\n            ereport(WARNING, (errmsg(\"inet_net_ntop failed, error: %d\", EAFNOSUPPORT)));\r\n        }\r\n    } else if (raddr->sa_family == AF_INET) {\r\n        result = inet_net_ntop(AF_INET, &((struct sockaddr_in*)raddr)->sin_addr, 32, remote_ip, IP_LEN);\r\n        if (result == NULL) {\r\n            ereport(WARNING, (errmsg(\"inet_net_ntop failed, error: %d\", EAFNOSUPPORT)));\r\n        }\r\n    }\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    rc = strncpy_s((char*)walrcv->conn_channel.localhost, sizeof(walrcv->conn_channel.localhost), local_ip, IP_LEN - 1);\r\n    securec_check(rc, \"\", \"\");\r\n    walrcv->conn_channel.localhost[IP_LEN - 1] = '\\0';\r\n    walrcv->conn_channel.localport = ntohs(((struct sockaddr_in*)laddr)->sin_port);\r\n    rc = strncpy_s(\r\n        (char*)walrcv->conn_channel.remotehost, sizeof(walrcv->conn_channel.remotehost), remote_ip, IP_LEN - 1);\r\n    securec_check(rc, \"\", \"\");\r\n    walrcv->conn_channel.remotehost[IP_LEN - 1] = '\\0';\r\n    walrcv->conn_channel.remoteport = ntohs(((struct sockaddr_in*)raddr)->sin_port);\r\n    SpinLockRelease(&walrcv->mutex);\r\n}",
		"comment":"/*\r\n * Get the current channel info from streamConn, then save it in WalRcv.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\libpqwalreceiver.cpp",
		"name":"ha_set_conn_channel"
	},
	"ha_set_port_to_remote":{
		"body":"static void ha_set_port_to_remote(PGconn *dummy_conn, int ha_port)\r\n{\r\n    int nRet = 0;\r\n    char cmd[64];\r\n    PGresult *res = NULL;\r\n\r\n    if (ha_port == 0 || dummy_conn == NULL) {\r\n        ereport(WARNING, (errcode(ERRCODE_INVALID_STATUS),\r\n                errmsg(\"could not set channel identifier, \"\r\n                        \"local port or connection is invalid\")));\r\n        return;\r\n    }\r\n\r\n    /*\r\n     * using localport for channel identifier,\r\n     * make primary can using ip and port to find out the channel\r\n     */\r\n    nRet = snprintf_s(cmd, sizeof(cmd), sizeof(cmd) - 1, \"IDENTIFY_CHANNEL %d\",	ha_port);\r\n    securec_check_ss(nRet, \"\", \"\");\r\n\r\n    res = libpqrcv_PQexec(cmd);\r\n    if (PQresultStatus(res) != PGRES_TUPLES_OK) {\r\n        PQclear(res);\r\n        ereport(ERROR, (errcode(ERRCODE_INVALID_STATUS),\r\n            errmsg(\"could not set channel identifier, localport %d : %s\", ha_port, PQerrorMessage(dummy_conn))));\r\n    }\r\n    PQclear(res);\r\n    return ;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\libpqwalreceiver.cpp",
		"name":"ha_set_port_to_remote"
	},
	"ha_set_rebuild_connerror":{
		"body":"static void ha_set_rebuild_connerror(HaRebuildReason reason, WalRcvConnError connerror)\r\n{\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n\r\n    ha_set_rebuild_reason(reason);\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    walrcv->conn_errno = connerror;\r\n    if (reason == NONE_REBUILD && connerror == NONE_ERROR)\r\n        walrcv->node_state = NODESTATE_NORMAL;\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    /* Only postmaster can update gaussdb.state file */\r\n    SendPostmasterSignal(PMSIGNAL_UPDATE_HAREBUILD_REASON);\r\n}",
		"comment":"/* set the rebuild reason and walreceiver connerror. */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\libpqwalreceiver.cpp",
		"name":"ha_set_rebuild_connerror"
	},
	"ha_set_rebuild_reason":{
		"body":"static void ha_set_rebuild_reason(HaRebuildReason reason)\r\n{\r\n    volatile HaShmemData* hashmdata = t_thrd.postmaster_cxt.HaShmData;\r\n    SpinLockAcquire(&hashmdata->mutex);\r\n    hashmdata->repl_reason[hashmdata->current_repl] = reason;\r\n    SpinLockRelease(&hashmdata->mutex);\r\n}",
		"comment":"/*\r\n * Set the specified rebuild reason in HaShmData. when set the rebuild reason,\r\n * the hashmdata->current_repl implys the current replconnlist.\r\n * Then set the reason in the corresponding variable.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\libpqwalreceiver.cpp",
		"name":"ha_set_rebuild_reason"
	},
	"libpq_select":{
		"body":"static bool libpq_select(int timeout_ms)\r\n{\r\n    int ret;\r\n\r\n    Assert(t_thrd.libwalreceiver_cxt.streamConn != NULL);\r\n    if (PQsocket(t_thrd.libwalreceiver_cxt.streamConn) < 0) {\r\n        ereport(ERROR, (errcode_for_socket_access(), errmsg(\"socket not open\")));\r\n    }\r\n\r\n    /* We use poll(2) if available, otherwise select(2) */\r\n    {\r\n#ifdef HAVE_POLL\r\n        struct pollfd input_fd;\r\n\r\n        input_fd.fd = PQsocket(t_thrd.libwalreceiver_cxt.streamConn);\r\n        input_fd.events = POLLIN | POLLERR;\r\n        input_fd.revents = 0;\r\n\r\n        ret = poll(&input_fd, 1, timeout_ms);\r\n#else  /* !HAVE_POLL */\r\n\r\n        fd_set input_mask;\r\n        struct timeval timeout = {0, 0};\r\n        struct timeval* ptr_timeout = NULL;\r\n\r\n        FD_ZERO(&input_mask);\r\n        FD_SET(PQsocket(t_thrd.libwalreceiver_cxt.streamConn), &input_mask);\r\n\r\n        if (timeout_ms < 0) {\r\n            ptr_timeout = NULL;\r\n        } else {\r\n            timeout.tv_sec = timeout_ms / 1000;\r\n            timeout.tv_usec = (timeout_ms % 1000) * 1000;\r\n            ptr_timeout = &timeout;\r\n        }\r\n\r\n        ret = select(PQsocket(t_thrd.libwalreceiver_cxt.streamConn) + 1, &input_mask, NULL, NULL, ptr_timeout);\r\n#endif /* HAVE_POLL */\r\n    }\r\n\r\n    if (ret == 0 || (ret < 0 && errno == EINTR)) {\r\n        return false;\r\n    }\r\n    if (ret < 0) {\r\n        ereport(ERROR, (errcode_for_socket_access(), errmsg(\"select() failed: %m\")));\r\n    }\r\n    return true;\r\n}",
		"comment":"/*\r\n * Wait until we can read WAL stream, or timeout.\r\n *\r\n * Returns true if data has become available for reading, false if timed out\r\n * or interrupted by signal.\r\n *\r\n * This is based on pqSocketCheck.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\libpqwalreceiver.cpp",
		"name":"libpq_select"
	},
	"libpqrcv_PQexec":{
		"body":"static PGresult* libpqrcv_PQexec(const char* query)\r\n{\r\n    PGresult* result = NULL;\r\n    PGresult* lastResult = NULL;\r\n\r\n    /*\r\n     * PQexec() silently discards any prior query results on the connection.\r\n     * This is not required for walreceiver since it's expected that walsender\r\n     * won't generate any such junk results.\r\n     */\r\n    /*\r\n     * Submit a query. Since we don't use non-blocking mode, this also can\r\n     * block. But its risk is relatively small, so we ignore that for now.\r\n     */\r\n    if (!PQsendQuery(t_thrd.libwalreceiver_cxt.streamConn, query)) {\r\n        return NULL;\r\n    }\r\n\r\n    for (;;) {\r\n        /*\r\n         * Receive data until PQgetResult is ready to get the result without\r\n         * blocking.\r\n         */\r\n        while (PQisBusy(t_thrd.libwalreceiver_cxt.streamConn)) {\r\n            /*\r\n             * We don't need to break down the sleep into smaller increments,\r\n             * and check for interrupts after each nap, since we can just\r\n             * elog(FATAL) within SIGTERM signal handler if the signal arrives\r\n             * in the middle of establishment of replication connection.\r\n             */\r\n            if (!libpq_select(-1)) {\r\n                pqClearAsyncResult(t_thrd.libwalreceiver_cxt.streamConn);\r\n                continue; /* interrupted */\r\n            }\r\n            if (PQconsumeInput(t_thrd.libwalreceiver_cxt.streamConn) == 0) {\r\n                pqClearAsyncResult(t_thrd.libwalreceiver_cxt.streamConn);\r\n\r\n                PQclear(lastResult);\r\n                return NULL; /* trouble */\r\n            }\r\n        }\r\n\r\n        /*\r\n         * Emulate the PQexec()'s behavior of returning the last result when\r\n         * there are many. Since walsender will never generate multiple\r\n         * results, we skip the concatenation of error messages.\r\n         */\r\n        result = PQgetResult(t_thrd.libwalreceiver_cxt.streamConn);\r\n        if (result == NULL) {\r\n            break; /* query is complete */\r\n        }\r\n\r\n        PQclear(lastResult);\r\n        lastResult = result;\r\n\r\n        if (PQresultStatus(lastResult) == PGRES_COPY_IN || PQresultStatus(lastResult) == PGRES_COPY_OUT ||\r\n            PQresultStatus(lastResult) == PGRES_COPY_BOTH ||\r\n            PQstatus(t_thrd.libwalreceiver_cxt.streamConn) == CONNECTION_BAD) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return lastResult;\r\n}",
		"comment":"/*\r\n * Send a query and wait for the results by using the asynchronous libpq\r\n * functions and the backend version of select().\r\n *\r\n * We must not use the regular blocking libpq functions like PQexec()\r\n * since they are uninterruptible by signals on some platforms, such as\r\n * Windows.\r\n *\r\n * We must also not use vanilla select() here since it cannot handle the\r\n * signal emulation layer on Windows.\r\n *\r\n * The function is modeled on PQexec() in libpq, but only implements\r\n * those parts that are in use in the walreceiver.\r\n *\r\n * Queries are always executed on the connection in streamConn.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\libpqwalreceiver.cpp",
		"name":"libpqrcv_PQexec"
	},
	"libpqrcv_connect":{
		"body":"bool libpqrcv_connect(char* conninfo, XLogRecPtr* startpoint, char* slotname, int channel_identifier)\r\n{\r\n    char conninfoRepl[MAXCONNINFO + 75];\r\n    char* remoteSysid = NULL;\r\n    char localSysid[32];\r\n    TimeLineID remoteTli;\r\n    TimeLineID localTli;\r\n    PGresult* res = NULL;\r\n    char cmd[1024];\r\n    char* remoteRecCrc = NULL;\r\n    pg_crc32 recCrc = 0;\r\n    XLogRecPtr localRec;\r\n    pg_crc32 localRecCrc = 0;\r\n    uint32 remoteSversion;\r\n    uint32 localSversion;\r\n    char* remotePversion = NULL;\r\n    char* localPversion = NULL;\r\n    uint32 remoteTerm;\r\n    uint32 localTerm;\r\n    ServerMode remoteMode = UNKNOWN_MODE;\r\n    int haveXlog = 0;\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    int count = 0;\r\n    int nRet = 0;\r\n    errno_t rc = EOK;\r\n    XLogRecPtr remoteMaxLsn = InvalidXLogRecPtr;\r\n    pg_crc32 remoteMaxLsnCrc = 0;\r\n    char *remoteMaxLsnStr = NULL;\r\n    char *remoteMaxLsnCrcStr = NULL;\r\n    uint32 hi, lo;\r\n    const int versionFields = 3;\r\n\r\n    /*\r\n     * Connect using deliberately undocumented parameter: replication. The\r\n     * database name is ignored by the server in replication mode, but specify\r\n     * \"replication\" for .pgpass lookup.\r\n     */\r\n    if (dummyStandbyMode)\r\n        nRet = snprintf_s(conninfoRepl,\r\n            sizeof(conninfoRepl),\r\n            sizeof(conninfoRepl) - 1,\r\n            \"%s dbname=replication replication=true \"\r\n            \"fallback_application_name=dummystandby \"\r\n            \"connect_timeout=%d\",\r\n            conninfo,\r\n            u_sess->attr.attr_storage.wal_receiver_connect_timeout);\r\n    else {\r\n        char hostname[255];\r\n\r\n        (void)gethostname(hostname, 255);\r\n\r\n        nRet = snprintf_s(conninfoRepl,\r\n            sizeof(conninfoRepl),\r\n            sizeof(conninfoRepl) - 1,\r\n            \"%s dbname=replication replication=true \"\r\n            \"fallback_application_name=%s \"\r\n            \"connect_timeout=%d\",\r\n            conninfo,\r\n            (u_sess->attr.attr_common.application_name && strlen(u_sess->attr.attr_common.application_name) > 0)\r\n                ? u_sess->attr.attr_common.application_name\r\n                : \"walreceiver\",\r\n            u_sess->attr.attr_storage.wal_receiver_connect_timeout);\r\n    }\r\n\r\n    securec_check_ss(nRet, \"\", \"\");\r\n\r\n    ereport(LOG, (errmsg(\"Connecting to remote server :%s\", conninfoRepl)));\r\n\r\nretry:\r\n    t_thrd.libwalreceiver_cxt.streamConn = PQconnectdb(conninfoRepl);\r\n    if (PQstatus(t_thrd.libwalreceiver_cxt.streamConn) != CONNECTION_OK) {\r\n        /* If startupxlog shut down walreceiver, we need not to retry. */\r\n        if (++count < u_sess->attr.attr_storage.wal_receiver_connect_retries && !WalRcvIsShutdown()) {\r\n            ereport(LOG,\r\n                (errmsg(\"retry: %d, walreceiver could not connect to the remote server,the connection info :%s : %s\",\r\n                    count,\r\n                    conninfo,\r\n                    PQerrorMessage(t_thrd.libwalreceiver_cxt.streamConn))));\r\n            libpqrcv_disconnect();\r\n            goto retry;\r\n        }\r\n\r\n        SpinLockAcquire(&walrcv->mutex);\r\n        walrcv->conn_errno = CHANNEL_ERROR;\r\n        if (AmWalReceiverForDummyStandby()) {\r\n            walrcv->dummyStandbyConnectFailed = true;\r\n        }\r\n        SpinLockRelease(&walrcv->mutex);\r\n        ha_add_disconnect_count();\r\n        ha_set_rebuild_reason(CONNECT_REBUILD);\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_CONNECTION_TIMED_OUT),\r\n                errmsg(\"walreceiver could not connect to the remote server,the connection info :%s : %s\",\r\n                    conninfo,\r\n                    PQerrorMessage(t_thrd.libwalreceiver_cxt.streamConn))));\r\n    }\r\n\r\n    ereport(LOG, (errmsg(\"Connected to remote server :%s success.\", conninfo)));\r\n\r\n    res = libpqrcv_PQexec(\"IDENTIFY_VERSION\");\r\n    if (PQresultStatus(res) != PGRES_TUPLES_OK) {\r\n        PQclear(res);\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INVALID_STATUS),\r\n                errmsg(\"could not receive database system version and protocol version from \"\r\n                       \"the remote server: %s\",\r\n                    PQerrorMessage(t_thrd.libwalreceiver_cxt.streamConn))));\r\n        return false;\r\n    }\r\n    if (PQnfields(res) != versionFields || PQntuples(res) != 1) {\r\n        int ntuples = PQntuples(res);\r\n        int nfields = PQnfields(res);\r\n\r\n        PQclear(res);\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INVALID_STATUS),\r\n                errmsg(\"invalid response from remote server\"),\r\n                errdetail(\"Expected 1 tuple with 3 fields, got %d tuples with %d fields.\", ntuples, nfields)));\r\n        return false;\r\n    }\r\n    remoteSversion = pg_strtoint32(PQgetvalue(res, 0, 0));\r\n    localSversion = PG_VERSION_NUM;\r\n    remotePversion = PQgetvalue(res, 0, 1);\r\n    localPversion = pstrdup(PG_PROTOCOL_VERSION);\r\n    remoteTerm = pg_strtoint32(PQgetvalue(res, 0, 2));\r\n    localTerm = g_instance.comm_cxt.localinfo_cxt.term;\r\n    ereport(LOG, (errmsg(\"remote term[%u], local term[%u]\", remoteTerm, localTerm)));\r\n    if (localPversion == NULL) {\r\n        PQclear(res);\r\n        ha_set_rebuild_connerror(VERSION_REBUILD, REPL_INFO_ERROR);\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INVALID_STATUS),\r\n                errmsg(\"could not get the local protocal version, make sure the PG_PROTOCOL_VERSION is defined\")));\r\n        return false;\r\n    }\r\n    if (walrcv->conn_target != REPCONNTARGET_DUMMYSTANDBY && (localTerm == 0 || localTerm > remoteTerm)) {\r\n        PQclear(res);\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INVALID_STATUS),\r\n                errmsg(\"invalid local term or remote term smaller than local. remote term[%u], local term[%u]\",\r\n                    remoteTerm,\r\n                    localTerm)));\r\n        return false;\r\n    }\r\n\r\n    /*\r\n     * If the version of the remote server is not the same as the local's, then set error\r\n     * message in WalRcv and rebuild reason in HaShmData\r\n     */\r\n    if (remoteSversion != localSversion ||\r\n        strncmp(remotePversion, localPversion, strlen(PG_PROTOCOL_VERSION)) != 0) {\r\n        PQclear(res);\r\n        ha_set_rebuild_connerror(VERSION_REBUILD, REPL_INFO_ERROR);\r\n\r\n        if (remoteSversion != localSversion) {\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_INVALID_STATUS),\r\n                    errmsg(\"database system version is different between the remote and local\"),\r\n                    errdetail(\"The remote's system version is %u, the local's system version is %u.\",\r\n                        remoteSversion,\r\n                        localSversion)));\r\n        } else {\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_INVALID_STATUS),\r\n                    errmsg(\"the remote protocal version %s is not the same as the local protocal version %s.\",\r\n                        remotePversion,\r\n                        localPversion)));\r\n        }\r\n\r\n        if (localPversion != NULL) {\r\n            pfree(localPversion);\r\n            localPversion = NULL;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    PQclear(res);\r\n\r\n    /* If connect to primary or standby (for failover), check remote role */\r\n    if (!t_thrd.walreceiver_cxt.AmWalReceiverForFailover || t_thrd.walreceiver_cxt.AmWalReceiverForStandby) {\r\n        /* Send query and get server mode of the remote server. */\r\n        res = libpqrcv_PQexec(\"IDENTIFY_MODE\");\r\n        if (PQresultStatus(res) != PGRES_TUPLES_OK) {\r\n            PQclear(res);\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_INVALID_STATUS),\r\n                    errmsg(\"could not receive the ongoing mode infomation from \"\r\n                           \"the remote server: %s\",\r\n                        PQerrorMessage(t_thrd.libwalreceiver_cxt.streamConn))));\r\n            return false;\r\n        }\r\n        if (PQnfields(res) != 1 || PQntuples(res) != 1) {\r\n            int num_tuples = PQntuples(res);\r\n            int num_fields = PQnfields(res);\r\n\r\n            PQclear(res);\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_INVALID_STATUS),\r\n                    errmsg(\"invalid response from remote server\"),\r\n                    errdetail(\r\n                        \"Expected 1 tuple with 1 fields, got %d tuples with %d fields.\", num_tuples, num_fields)));\r\n            return false;\r\n        }\r\n        remoteMode = (ServerMode)pg_strtoint32(PQgetvalue(res, 0, 0));\r\n        if (!t_thrd.walreceiver_cxt.AmWalReceiverForFailover && remoteMode != PRIMARY_MODE) {\r\n            PQclear(res);\r\n\r\n            if (dummyStandbyMode) {\r\n                clean_failover_host_conninfo_for_dummy();\r\n            }\r\n\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_INVALID_STATUS),\r\n                    errmsg(\"the mode of the remote server must be primary, current is %s\",\r\n                        wal_get_role_string(remoteMode))));\r\n            return false;\r\n        }\r\n\r\n        if (t_thrd.walreceiver_cxt.AmWalReceiverForStandby && remoteMode != STANDBY_MODE) {\r\n            PQclear(res);\r\n\r\n            SpinLockAcquire(&walrcv->mutex);\r\n            walrcv->conn_errno = REPL_INFO_ERROR;\r\n            SpinLockRelease(&walrcv->mutex);\r\n\r\n            ereport(ERROR,\r\n                    (errcode(ERRCODE_INTERNAL_ERROR),\r\n                     errmsg(\"the mode of the remote server must be standby, current is %s\",\r\n                            wal_get_role_string(remoteMode))));\r\n            return false;\r\n        }\r\n\r\n        PQclear(res);\r\n    }\r\n\r\n    /*\r\n     * Get the system identifier and timeline ID as a DataRow message from the\r\n     * primary server.\r\n     */\r\n    res = libpqrcv_PQexec(\"IDENTIFY_SYSTEM\");\r\n    if (PQresultStatus(res) != PGRES_TUPLES_OK) {\r\n        PQclear(res);\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INVALID_STATUS),\r\n                errmsg(\"could not receive database system identifier and timeline ID from \"\r\n                       \"the remote server: %s\",\r\n                    PQerrorMessage(t_thrd.libwalreceiver_cxt.streamConn))));\r\n        return false;\r\n    }\r\n    if (PQnfields(res) != 4 || PQntuples(res) != 1) {\r\n        int num_tuples = PQntuples(res);\r\n        int num_fields = PQnfields(res);\r\n\r\n        PQclear(res);\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INVALID_STATUS),\r\n                errmsg(\"invalid response from remote server\"),\r\n                errdetail(\r\n                    \"Could not identify system: Got %d rows and %d fields, expected %d rows and %d or more fields.\",\r\n                    num_tuples,\r\n                    num_fields,\r\n                    1,\r\n                    4)));\r\n\r\n        return false;\r\n    }\r\n    remoteSysid = PQgetvalue(res, 0, 0);\r\n    remoteTli = pg_strtoint32(PQgetvalue(res, 0, 1));\r\n\r\n    /*\r\n     * Confirm that the system identifier of the primary is the same as ours.\r\n     */\r\n    nRet = snprintf_s(\r\n        localSysid, sizeof(localSysid), sizeof(localSysid) - 1, UINT64_FORMAT, GetSystemIdentifier());\r\n    securec_check_ss(nRet, \"\", \"\");\r\n\r\n    if (strcmp(remoteSysid, localSysid) != 0) {\r\n        if (dummyStandbyMode) {\r\n            /* delete local xlog. */\r\n            ProcessWSRmXLog();\r\n            if (g_instance.attr.attr_storage.enable_mix_replication) {\r\n                while (true) {\r\n                    if (!ws_dummy_data_writer_use_file) {\r\n                        CloseWSDataFileOnDummyStandby();\r\n                        break;\r\n                    } else {\r\n                        pg_usleep(100000); /* sleep 0.1 s */\r\n                    }\r\n                }\r\n                ProcessWSRmData();\r\n            }\r\n\r\n            // only walreceiver set standby_sysid.datareceiver do not set again.\r\n            rc = memcpy_s(localSysid, sizeof(localSysid), remoteSysid, sizeof(localSysid));\r\n            securec_check(rc, \"\", \"\");\r\n\r\n            sync_system_identifier = strtoul(remoteSysid, 0, 10);\r\n\r\n            ereport(LOG,\r\n                (errmsg(\"DummyStandby system identifier differs between the primary\"),\r\n                    errdetail(\r\n                        \"The primary's identifier is %s, the standby's identifier is %s.sync_system_identifier=%lu\",\r\n                        remoteSysid,\r\n                        localSysid,\r\n                        sync_system_identifier)));\r\n        } else {\r\n            remoteSysid = pstrdup(remoteSysid);\r\n            PQclear(res);\r\n            /*\r\n             * If the system id is different,\r\n             * then set error message in WalRcv and rebuild reason in HaShmData.\r\n             */\r\n            SpinLockAcquire(&walrcv->mutex);\r\n            if (AmWalReceiverForDummyStandby()) {\r\n                walrcv->dummyStandbyConnectFailed = true;\r\n            }\r\n            SpinLockRelease(&walrcv->mutex);\r\n            ha_set_rebuild_connerror(SYSTEMID_REBUILD, REPL_INFO_ERROR);\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_INVALID_STATUS),\r\n                    errmsg(\"database system identifier differs between the primary and standby\"),\r\n                    errdetail(\"The primary's identifier is %s, the standby's identifier is %s.\",\r\n                        remoteSysid,\r\n                        localSysid)));\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Confirm that the current timeline of the primary is the same as the\r\n     * recovery target timeline.\r\n     */\r\n    if (dummyStandbyMode) {\r\n        localTli = remoteTli;\r\n    } else {\r\n        localTli = GetRecoveryTargetTLI();\r\n    }\r\n    PQclear(res);\r\n\r\n    if (t_thrd.walreceiver_cxt.AmWalReceiverForFailover) {\r\n        t_thrd.xlog_cxt.ThisTimeLineID = localTli;\r\n    } else {\r\n        if (remoteTli != localTli) {\r\n            /*\r\n             * If the timeline id different,\r\n             * then set error message in WalRcv and rebuild reason in HaShmData.\r\n             */\r\n            ha_set_rebuild_connerror(TIMELINE_REBUILD, REPL_INFO_ERROR);\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_INVALID_STATUS),\r\n                    errmsg(\"timeline %u of the primary does not match recovery target timeline %u\",\r\n                        remoteTli,\r\n                        localTli)));\r\n        }\r\n        t_thrd.xlog_cxt.ThisTimeLineID = remoteTli;\r\n    }\r\n\r\n    if (dummyStandbyMode) {\r\n        char        msgBuf[XLOG_READER_MAX_MSGLENTH] = {0};\r\n        /* find the max lsn by xlog file, if i'm dummystandby or standby for failover */\r\n        localRec = FindMaxLSN(t_thrd.proc_cxt.DataDir, msgBuf, XLOG_READER_MAX_MSGLENTH, &localRecCrc);\r\n    } else {\r\n        /* for last record should be lastreplayed xlog in StartupXLOG, no un-replay or un-flush one */\r\n        SpinLockAcquire(&walrcv->mutex);\r\n        localRecCrc = walrcv->latestRecordCrc;\r\n        localRec = walrcv->latestValidRecord;\r\n        SpinLockRelease(&walrcv->mutex);\r\n\r\n        ereport(LOG, (errmsg(\"local request lsn/crc [%X/%X, %u]\",\r\n            (uint32)(localRec >> 32), (uint32)localRec, localRecCrc)));\r\n\r\n        if (!XRecOffIsValid(localRec)) {\r\n            ereport(PANIC,\r\n                (errmsg(\"Invalid xlog offset at %X/%X. Please check xlog files or rebuild the primary/standby \"\r\n                        \"relationship.\",\r\n                    (uint32)(localRec >> 32),\r\n                    (uint32)localRec)));\r\n        }\r\n    }\r\n\r\n    /* if dummystandby has no xlog, dont check crc */\r\n    if (!(dummyStandbyMode && XLogRecPtrIsInvalid(localRec))) {\r\n        nRet = snprintf_s(cmd, sizeof(cmd), sizeof(cmd) - 1, \"IDENTIFY_CONSISTENCE %X/%X\",\r\n            (uint32) (localRec >> 32), (uint32) localRec);\r\n        securec_check_ss(nRet, \"\", \"\");\r\n\r\n        res = libpqrcv_PQexec(cmd);\r\n        if (PQresultStatus(res) != PGRES_TUPLES_OK) {\r\n            PQclear(res);\r\n            ha_set_rebuild_connerror(WALSEGMENT_REBUILD, REPL_INFO_ERROR);\r\n            ereport(ERROR, (errcode(ERRCODE_INVALID_STATUS), errmsg(\"failed to identify consistence at %X/%X: %s\",\r\n                (uint32)(localRec >> 32), (uint32)localRec, PQerrorMessage(t_thrd.libwalreceiver_cxt.streamConn))));\r\n            return false;\r\n        }\r\n\r\n        /*\r\n         * Indentify consistence is motified when importing cm-ha enhancement code.\r\n         * To support greyupgrade, msg with 1 row of 2 and 3 cols is handled to \r\n         * go through two different logics. Will remove later.\r\n         */\r\n        if ((PQnfields(res) != 3 && PQnfields(res) != 2) || PQntuples(res) != 1) {\r\n            int ntuples = PQntuples(res);\r\n            int nfields = PQnfields(res);\r\n\r\n            PQclear(res);\r\n            ha_set_rebuild_connerror(WALSEGMENT_REBUILD, REPL_INFO_ERROR);\r\n            ereport(ERROR,\r\n                    (errcode(ERRCODE_INVALID_STATUS),\r\n                    errmsg(\"invalid response from primary server\"),\r\n                     errdetail(\"Could not identify system: Got %d rows and %d fields, expected 1 row and 2 or 3 fields\",\r\n                               ntuples, nfields)));\r\n            return false;\r\n        }\r\n\r\n        if (PQnfields(res) == 3) {\r\n            /* col1: crc of standby rec. */\r\n            remoteRecCrc = PQgetvalue(res, 0, 0);\r\n            if (remoteRecCrc && sscanf_s(remoteRecCrc, \"%8X\", &recCrc) != 1) {\r\n                PQclear(res);\r\n                ha_set_rebuild_connerror(WALSEGMENT_REBUILD, REPL_INFO_ERROR);\r\n                ereport(ERROR, \r\n                    (errcode(ERRCODE_INVALID_STATUS),\r\n                     errmsg(\"could not parse remote record's crc, remoteRecCrc=%s recCrc=%u\",\r\n                         (remoteRecCrc[0] != 0) ? remoteRecCrc : \"NULL\", (uint32)recCrc)));\r\n                return false;\r\n            }\r\n\r\n            /* col2: max lsn of dummy standby. */\r\n            remoteMaxLsnStr = PQgetvalue(res, 0, 1);\r\n            if (sscanf_s(remoteMaxLsnStr, \"%X/%X\", &hi, &lo) != 2) {\r\n                PQclear(res);\r\n                ha_set_rebuild_connerror(WALSEGMENT_REBUILD, REPL_INFO_ERROR);\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_INVALID_STATUS),\r\n                     errmsg(\"could not parse remoteMaxLsn\")));\r\n                return false;\r\n            }\r\n            remoteMaxLsn = ((uint64) hi << 32) | lo;\r\n\r\n            /* col3: crc of max lsn of dummy standby. */\r\n            remoteMaxLsnCrcStr = PQgetvalue(res, 0, 2);\r\n            if (remoteMaxLsnCrcStr && sscanf_s(remoteMaxLsnCrcStr, \"%8X\", &remoteMaxLsnCrc) != 1) {\r\n                PQclear(res);\r\n                ha_set_rebuild_connerror(WALSEGMENT_REBUILD, REPL_INFO_ERROR);\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_INVALID_STATUS),\r\n                     errmsg(\"could not parse remote max record's crc, remoteMaxLsnCrc=%s maxLsnCrc=%u\",\r\n                         (remoteMaxLsnCrcStr[0] != 0) ? remoteMaxLsnCrcStr : \"NULL\", (uint32)remoteMaxLsnCrc)));\r\n                return false;\r\n            }\r\n\r\n            PQclear(res);\r\n\r\n            if (!t_thrd.walreceiver_cxt.AmWalReceiverForFailover) {\r\n                /* including recCrc == 0, which means local has more xlog */\r\n                if (recCrc != localRecCrc) {\r\n                    /* dummy standby connect to primary */\r\n                    if (dummyStandbyMode) {\r\n                        if (recCrc == IGNORE_REC_CRC) {\r\n                            ereport(LOG,\r\n                                (errmsg(\"receive ignore reccrc, rm xlog.\")));\r\n                            ProcessWSRmXLog();\r\n                        } else {\r\n                            ereport(ERROR,\r\n                                (errcode(ERRCODE_INVALID_STATUS),\r\n                                 errmsg(\"dummystandby's local request lsn[%X/%X] 's crc \"\r\n                                        \"mismatched with remote server\"\r\n                                        \"crc(local, remote):[%u,%u].\",\r\n                                        (uint32)(localRec >> 32), (uint32)localRec, localRecCrc, recCrc)));\r\n                        }\r\n                    } else {\r\n                        /* \r\n                         * standby connect to primary \r\n                         * Direct check Primary and Standby, trigger build. \r\n                         */\r\n                        ha_set_rebuild_connerror(WALSEGMENT_REBUILD, REPL_INFO_ERROR);\r\n                        ereport(ERROR,\r\n                            (errcode(ERRCODE_INVALID_STATUS),\r\n                             errmsg(\"standby's local request lsn[%X/%X] 's crc mismatched with remote server\"\r\n                            \"crc(local, remote):[%u,%u].\",\r\n                                (uint32)(localRec >> 32), (uint32)localRec, localRecCrc, recCrc)));\r\n                    }\r\n                }\r\n            } else if (t_thrd.walreceiver_cxt.AmWalReceiverForStandby) {\r\n                /* standby connect to standby */\r\n                bool        crcvalid = false;\r\n                /* local xlog must be more than(or equal to) remote, and last crc must be matched */\r\n                if (XLByteLE(remoteMaxLsn, localRec) && \r\n                    remoteMaxLsnCrc == GetXlogRecordCrc(remoteMaxLsn, crcvalid)) {\r\n                    ereport(LOG,\r\n                        (errmsg(\"crc check on remote standby success, local standby \" \r\n                                \"will promote to primary\")));   \r\n                    SetWalRcvDummyStandbySyncPercent(SYNC_DUMMY_STANDBY_END);\r\n                    /* also set datareceiver to continue failover */\r\n                    SetDataRcvDummyStandbySyncPercent(SYNC_DUMMY_STANDBY_END);\r\n                    haveXlog = false;\r\n                } else {\r\n                    SpinLockAcquire(&walrcv->mutex);\r\n                    walrcv->conn_errno = REPL_INFO_ERROR;\r\n                    SpinLockRelease(&walrcv->mutex);\r\n                    ereport(ERROR, (errcode(ERRCODE_INVALID_STATUS),\r\n                        errmsg(\"crc of %X/%X is different across remote and local standby, \"\r\n                        \"standby promote failed\",\r\n                            (uint32)(remoteMaxLsn >> 32), (uint32)remoteMaxLsn)));\r\n                }\r\n            } else {\r\n                /* standby connect to dummystandby */\r\n                if (recCrc != 0 && recCrc != localRecCrc) {\r\n                    /* FUTURE CASE::\r\n                     * When standby failover, its xlog is not the same with secondary \r\n                     * standby, walreceiver will ereport ERROR, or the standby \r\n                     * promoting will hang, and if the primary is pending, cm server \r\n                     * will not arbitrate the primary.\r\n                     */\r\n                    SpinLockAcquire(&walrcv->mutex);\r\n                    if (AmWalReceiverForDummyStandby()) {\r\n                        walrcv->dummyStandbyConnectFailed = true;\r\n                    }\r\n                    SpinLockRelease(&walrcv->mutex);\r\n                    ereport(ERROR,\r\n                        (errcode(ERRCODE_INVALID_STATUS),\r\n                         errmsg(\"invalid crc on secondary standby, has xlog, standby promote failed, \"\r\n                                \"(local, remote) = (%u, %u) on %X/%X\",\r\n                                    localRecCrc, recCrc, (uint32)(localRec >> 32), (uint32)localRec)));\r\n                } else if (recCrc == 0) {\r\n                    bool crcvalid = false;\r\n    \r\n                    /*\r\n                     *  Standby      ------>(lsn is 10)\r\n                     *  DummyStandby --->(lsn is 5)\r\n                     *  recCrc of lsn == 10 of dummy is 0\r\n                     *  We should check crc of lsn is 5 of standby\r\n                     */\r\n                    if (XLByteEQ(remoteMaxLsn, InvalidXLogRecPtr) ||\r\n                        (XLByteLT(remoteMaxLsn, localRec) &&\r\n                         remoteMaxLsnCrc == GetXlogRecordCrc(remoteMaxLsn, crcvalid))) {\r\n                        ereport(LOG,\r\n                            (errmsg(\"invalid crc on secondary standby, no xlog, standby \" \r\n                                \"will promote primary\")));  \r\n                        SetWalRcvDummyStandbySyncPercent(SYNC_DUMMY_STANDBY_END);\r\n                        haveXlog = false;\r\n                    } else {\r\n                        SpinLockAcquire(&walrcv->mutex);\r\n                        if (AmWalReceiverForDummyStandby()) {\r\n                            walrcv->dummyStandbyConnectFailed = true;\r\n                        }\r\n                        SpinLockRelease(&walrcv->mutex);\r\n                        ereport(ERROR, (errcode(ERRCODE_INVALID_STATUS),\r\n                            errmsg(\"crc of %X/%X is different across dummy and standby, \"\r\n                                   \"standby promote failed\",\r\n                                       (uint32)(remoteMaxLsn >> 32), (uint32)remoteMaxLsn)));\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            char* primary_reccrc = PQgetvalue(res, 0, 0);\r\n            bool havexlog = pg_strtoint32(PQgetvalue(res, 0, 1));\r\n\r\n            if (primary_reccrc && sscanf_s(primary_reccrc, \"%8X\", &recCrc) != 1) {\r\n                PQclear(res);\r\n                ha_set_rebuild_connerror(WALSEGMENT_REBUILD, REPL_INFO_ERROR);\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_INVALID_STATUS),\r\n                        errmsg(\"could not parse primary record's crc,primary_reccrc=%s reccrc=%u\",\r\n                            (primary_reccrc[0] != 0) ? primary_reccrc : \"NULL\",\r\n                            (uint32)recCrc)));\r\n                return false;\r\n            }\r\n\r\n            PQclear(res);\r\n\r\n            if (0 == recCrc && t_thrd.walreceiver_cxt.AmWalReceiverForFailover) {\r\n                if (0 == havexlog) {\r\n                    ereport(LOG,\r\n                        (errmsg(\"invalid crc on secondary standby, no xlog, standby \"\r\n                                \"will promoting primary\")));\r\n                    SetWalRcvDummyStandbySyncPercent(SYNC_DUMMY_STANDBY_END);\r\n                    return true;\r\n                } else {\r\n                    /* FUTURE CASE::\r\n                     * When standby failover, its xlog is not the same with secondary\r\n                     * standby, walreceiver will ereport ERROR, or the standby\r\n                     * promoting will hang, and if the primary is pending, cm server\r\n                     * will not arbitrate the primary.\r\n                     */\r\n                    ereport(ERROR,\r\n                        (errcode(ERRCODE_INVALID_STATUS),\r\n                            errmsg(\"invalid crc on secondary standby, has xlog, \"\r\n                                   \"standby promote failed\")));\r\n                }\r\n            } else if (recCrc != walrcv->latestRecordCrc) {\r\n                ha_set_rebuild_connerror(WALSEGMENT_REBUILD, REPL_INFO_ERROR);\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_INVALID_STATUS),\r\n                        errmsg(\"standby_rec=%x/%x \"\r\n                               \"standby latest record's crc %u and primary corresponding record's crc %u not matched\",\r\n                            (uint32)(walrcv->latestValidRecord >> 32),\r\n                            (uint32)walrcv->latestValidRecord,\r\n                            walrcv->latestRecordCrc,\r\n                            recCrc)));\r\n            }\r\n        }\r\n    }\r\n\r\n    if (t_thrd.walreceiver_cxt.AmWalReceiverForFailover) {\r\n        if (t_thrd.walreceiver_cxt.AmWalReceiverForStandby) {\r\n            /* failover to standby */\r\n            if (!haveXlog) {\r\n                return true;\r\n            }\r\n        } else {\r\n            /* failover to dummy */\r\n            ha_set_port_to_remote(t_thrd.libwalreceiver_cxt.streamConn, channel_identifier);\r\n            if  (recCrc == 0 && !haveXlog) {\r\n                return true;\r\n            }\r\n        }\r\n    } else {\r\n        ha_set_port_to_remote(t_thrd.libwalreceiver_cxt.streamConn, channel_identifier);\r\n    }\r\n\r\n    /* Create replication slot if need */\r\n    if (!t_thrd.walreceiver_cxt.AmWalReceiverForFailover && slotname != NULL) {\r\n        nRet = snprintf_s(cmd,\r\n            sizeof(cmd),\r\n            sizeof(cmd) - 1,\r\n            \"CREATE_REPLICATION_SLOT \\\"%s\\\" PHYSICAL %X/%X\",\r\n            slotname,\r\n            (uint32)(*startpoint >> 32),\r\n            (uint32)(*startpoint));\r\n        securec_check_ss(nRet, \"\", \"\");\r\n\r\n        res = libpqrcv_PQexec(cmd);\r\n        if (PQresultStatus(res) != PGRES_TUPLES_OK) {\r\n            PQclear(res);\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_INVALID_STATUS),\r\n                    errmsg(\"could not create replication slot %s : %s\",\r\n                        slotname,\r\n                        PQerrorMessage(t_thrd.libwalreceiver_cxt.streamConn))));\r\n        }\r\n        PQclear(res);\r\n    }\r\n\r\n    /* Start streaming from the point requested by startup process */\r\n    if (!t_thrd.walreceiver_cxt.AmWalReceiverForFailover && slotname != NULL)\r\n        nRet = snprintf_s(cmd,\r\n            sizeof(cmd),\r\n            sizeof(cmd) - 1,\r\n            \"START_REPLICATION SLOT \\\"%s\\\" %X/%X\",\r\n            slotname,\r\n            (uint32)(*startpoint >> 32),\r\n            (uint32)(*startpoint));\r\n    else\r\n        nRet = snprintf_s(cmd,\r\n            sizeof(cmd),\r\n            sizeof(cmd) - 1,\r\n            \"START_REPLICATION %X/%X\",\r\n            (uint32)(*startpoint >> 32),\r\n            (uint32)(*startpoint));\r\n    securec_check_ss(nRet, \"\", \"\");\r\n\r\n    res = libpqrcv_PQexec(cmd);\r\n    if (PQresultStatus(res) != PGRES_COPY_BOTH) {\r\n        PQclear(res);\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INVALID_STATUS),\r\n                errmsg(\"could not start WAL streaming: %s\", PQerrorMessage(t_thrd.libwalreceiver_cxt.streamConn))));\r\n    }\r\n    PQclear(res);\r\n\r\n    ereport(LOG,\r\n        (errmsg(\"streaming replication successfully connected to primary, the connection is %s, start from %X/%X \",\r\n            conninfo,\r\n            (uint32)(*startpoint >> 32),\r\n            (uint32)(*startpoint))));\r\n\r\n    if (!t_thrd.walreceiver_cxt.AmWalReceiverForFailover) {\r\n        SpinLockAcquire(&walrcv->mutex);\r\n        walrcv->peer_role = remoteMode;\r\n        SpinLockRelease(&walrcv->mutex);\r\n    }\r\n\r\n    /*\r\n     * If the streaming replication successfully connected to primary,\r\n     * then clean the rebuild reason in HaShmData.\r\n     */\r\n    ha_set_rebuild_connerror(NONE_REBUILD, NONE_ERROR);\r\n\r\n    /* Save the current connect channel info in WalRcv */\r\n    ha_set_conn_channel();\r\n\r\n    return true;\r\n}",
		"comment":"/*\r\n * Establish the connection to the primary server for XLOG streaming\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\libpqwalreceiver.cpp",
		"name":"libpqrcv_connect"
	},
	"libpqrcv_connect_for_TLI":{
		"body":"bool libpqrcv_connect_for_TLI(TimeLineID* timeLineID, char* conninfo)\r\n{\r\n    char conninfoRepl[MAXCONNINFO + 75] = {0};\r\n    TimeLineID remoteTli;\r\n    PGresult* res = NULL;\r\n    int nRet = 0;\r\n\r\n    /*\r\n     * Connect using deliberately undocumented parameter: replication. The\r\n     * database name is ignored by the server in replication mode, but specify\r\n     * \"replication\" for .pgpass lookup.\r\n     */\r\n    AssertEreport(dummyStandbyMode, MOD_FUNCTION, \"dummyStandbyMode should be true\");\r\n    nRet = snprintf_s(conninfoRepl,\r\n        sizeof(conninfoRepl),\r\n        sizeof(conninfoRepl) - 1,\r\n        \"%s dbname=replication replication=true \"\r\n        \"fallback_application_name=dummystandby connect_timeout=%d\",\r\n        conninfo,\r\n        u_sess->attr.attr_storage.wal_receiver_connect_timeout);\r\n    securec_check_ss(nRet, \"\", \"\");\r\n\r\n    ereport(LOG, (errmsg(\"Connecting to primary :%s\", conninfo)));\r\n\r\n    t_thrd.libwalreceiver_cxt.streamConn = PQconnectdb(conninfoRepl);\r\n    if (PQstatus(t_thrd.libwalreceiver_cxt.streamConn) != CONNECTION_OK) {\r\n        char *errMsg = PQerrorMessage(t_thrd.libwalreceiver_cxt.streamConn);\r\n        char *subErrMsg = \"can not accept connection in standby mode\";\r\n\r\n        ereport(LOG,\r\n            (errmsg(\"wal receiver could not connect to the primary server,the connection info :%s : %s\",\r\n                conninfo, PQerrorMessage(t_thrd.libwalreceiver_cxt.streamConn))));\r\n\r\n        if (errMsg != NULL && strstr(errMsg, subErrMsg) != NULL) {\r\n            clean_failover_host_conninfo_for_dummy();\r\n        }\r\n\r\n        PQfinish(t_thrd.libwalreceiver_cxt.streamConn);\r\n        t_thrd.libwalreceiver_cxt.streamConn = NULL;\r\n\r\n        return false;\r\n    }\r\n\r\n    ereport(LOG, (errmsg(\"Connected to primary :%s success.\", conninfo)));\r\n\r\n    /*\r\n     * Get the system identifier and timeline ID as a DataRow message from the\r\n     * primary server.\r\n     */\r\n    res = libpqrcv_PQexec(\"IDENTIFY_SYSTEM\");\r\n    if (PQresultStatus(res) != PGRES_TUPLES_OK) {\r\n        PQclear(res);\r\n        ereport(LOG,\r\n            (errmsg(\"could not receive database system identifier and timeline ID from \"\r\n                    \"the primary server: %s\",\r\n                PQerrorMessage(t_thrd.libwalreceiver_cxt.streamConn))));\r\n        PQfinish(t_thrd.libwalreceiver_cxt.streamConn);\r\n        t_thrd.libwalreceiver_cxt.streamConn = NULL;\r\n\r\n        return false;\r\n    }\r\n    if (PQnfields(res) < 3 || PQntuples(res) != 1) {\r\n        int ntuples = PQntuples(res);\r\n        int nfields = PQnfields(res);\r\n\r\n        PQclear(res);\r\n        ereport(LOG,\r\n            (errmsg(\"invalid response from primary server\"),\r\n                errdetail(\r\n                    \"Could not identify system: Got %d rows and %d fields, expected %d rows and %d or more fields.\",\r\n                    ntuples,\r\n                    nfields,\r\n                    1,\r\n                    3)));\r\n        PQfinish(t_thrd.libwalreceiver_cxt.streamConn);\r\n        t_thrd.libwalreceiver_cxt.streamConn = NULL;\r\n\r\n        return false;\r\n    }\r\n    remoteTli = pg_strtoint32(PQgetvalue(res, 0, 1));\r\n\r\n    /*\r\n     * Confirm that the current timeline of the primary is the same as the\r\n     * recovery target timeline.\r\n     */\r\n    PQclear(res);\r\n\r\n    *timeLineID = t_thrd.xlog_cxt.ThisTimeLineID = remoteTli;\r\n\r\n    libpqrcv_disconnect();\r\n\r\n    return true;\r\n}",
		"comment":"/*\r\n * Establish the connection to the primary server for XLOG streaming\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\libpqwalreceiver.cpp",
		"name":"libpqrcv_connect_for_TLI"
	},
	"libpqrcv_disconnect":{
		"body":"void libpqrcv_disconnect(void)\r\n{\r\n    PQfinish(t_thrd.libwalreceiver_cxt.streamConn);\r\n    t_thrd.libwalreceiver_cxt.streamConn = NULL;\r\n}",
		"comment":"/*\r\n * Disconnect connection to primary, if any.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\libpqwalreceiver.cpp",
		"name":"libpqrcv_disconnect"
	},
	"libpqrcv_receive":{
		"body":"bool libpqrcv_receive(int timeout, unsigned char* type, char** buffer, int* len)\r\n{\r\n    int rawlen;\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n\r\n    if (t_thrd.libwalreceiver_cxt.recvBuf != NULL) {\r\n        PQfreemem(t_thrd.libwalreceiver_cxt.recvBuf);\r\n    }\r\n    t_thrd.libwalreceiver_cxt.recvBuf = NULL;\r\n\r\n    /* Try to receive a CopyData message */\r\n    rawlen = PQgetCopyData(t_thrd.libwalreceiver_cxt.streamConn, &t_thrd.libwalreceiver_cxt.recvBuf, 1);\r\n    if (rawlen == 0) {\r\n        /*\r\n         * No data available yet. If the caller requested to block, wait for\r\n         * more data to arrive.\r\n         */\r\n        if (timeout > 0) {\r\n            if (!libpq_select(timeout)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (PQconsumeInput(t_thrd.libwalreceiver_cxt.streamConn) == 0) {\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_INVALID_STATUS),\r\n                    errmsg(\"could not receive data from WAL streaming: %s\",\r\n                        PQerrorMessage(t_thrd.libwalreceiver_cxt.streamConn))));\r\n        }\r\n\r\n        /* Now that we've consumed some input, try again */\r\n        rawlen = PQgetCopyData(t_thrd.libwalreceiver_cxt.streamConn, &t_thrd.libwalreceiver_cxt.recvBuf, 1);\r\n        if (rawlen == 0) {\r\n            return false;\r\n        }\r\n    }\r\n    if (rawlen == -1) { /* end-of-streaming or error */\r\n        PGresult* res = NULL;\r\n        const char* sqlstate = NULL;\r\n        int retcode = 0;\r\n\r\n        res = PQgetResult(t_thrd.libwalreceiver_cxt.streamConn);\r\n        if (PQresultStatus(res) == PGRES_COMMAND_OK) {\r\n            PQclear(res);\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_INVALID_STATUS),\r\n                    errmsg(\"replication terminated by primary server at %X/%X\",\r\n                        (uint32)(walrcv->receivedUpto >> 32),\r\n                        (uint32)walrcv->receivedUpto)));\r\n            return false;\r\n        }\r\n\r\n        sqlstate = PQresultErrorField(res, PG_DIAG_SQLSTATE);\r\n        if (sqlstate && strlen(sqlstate) == 5) {\r\n            retcode = MAKE_SQLSTATE(sqlstate[0], sqlstate[1], sqlstate[2], sqlstate[3], sqlstate[4]);\r\n        }\r\n        if (retcode == ERRCODE_UNDEFINED_FILE) {\r\n            ha_set_rebuild_reason(WALSEGMENT_REBUILD);\r\n            SpinLockAcquire(&walrcv->mutex);\r\n            walrcv->conn_errno = REPL_INFO_ERROR;\r\n            walrcv->ntries++;\r\n            SpinLockRelease(&walrcv->mutex);\r\n        }\r\n\r\n        PQclear(res);\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INVALID_STATUS),\r\n                errmsg(\"could not receive data from WAL stream: %s\",\r\n                    PQerrorMessage(t_thrd.libwalreceiver_cxt.streamConn))));\r\n    }\r\n    if (rawlen < -1) {\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INVALID_STATUS),\r\n                errmsg(\"could not receive data from WAL stream: %s\",\r\n                    PQerrorMessage(t_thrd.libwalreceiver_cxt.streamConn))));\r\n    }\r\n\r\n    /* Return received messages to caller */\r\n    *type = *((unsigned char*)t_thrd.libwalreceiver_cxt.recvBuf);\r\n    *buffer = t_thrd.libwalreceiver_cxt.recvBuf + sizeof(*type);\r\n    *len = rawlen - sizeof(*type);\r\n\r\n    return true;\r\n}",
		"comment":"/*\r\n * Receive a message available from XLOG stream, blocking for\r\n * maximum of 'timeout' ms.\r\n *\r\n * Returns:\r\n *\r\n *	 True if data was received. *type, *buffer and *len are set to\r\n *	 the type of the received data, buffer holding it, and length,\r\n *	 respectively.\r\n *\r\n *	 False if no data was available within timeout, or wait was interrupted\r\n *	 by signal.\r\n *\r\n * The buffer returned is only valid until the next call of this function or\r\n * libpq_connect/disconnect.\r\n *\r\n * ereports on error.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\libpqwalreceiver.cpp",
		"name":"libpqrcv_receive"
	},
	"libpqrcv_send":{
		"body":"void libpqrcv_send(const char* buffer, int nbytes)\r\n{\r\n    if (PQputCopyData(t_thrd.libwalreceiver_cxt.streamConn, buffer, nbytes) <= 0 ||\r\n        PQflush(t_thrd.libwalreceiver_cxt.streamConn))\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INVALID_STATUS),\r\n                errmsg(\"could not send data to WAL stream: %s\", PQerrorMessage(t_thrd.libwalreceiver_cxt.streamConn))));\r\n}",
		"comment":"/*\r\n * Send a message to XLOG stream.\r\n *\r\n * ereports on error.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\libpqwalreceiver.cpp",
		"name":"libpqrcv_send"
	}
}