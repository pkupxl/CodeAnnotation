{
	"ConnParamFree":{
		"body":"static void ConnParamFree(ConnParam* param)\r\n{\r\n    if (param == NULL) {\r\n        return;\r\n    }\r\n\r\n    if (param->remoteIp != NULL) {\r\n        pfree(param->remoteIp);\r\n        param->remoteIp = NULL;\r\n    }\r\n\r\n    if (param->localIp != NULL) {\r\n        pfree(param->localIp);\r\n        param->localIp = NULL;\r\n    }\r\n\r\n    pfree(param);\r\n    param = NULL;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\heartbeat\\libpq\\fe-connect.cpp",
		"name":"ConnParamFree"
	},
	"PQconnect":{
		"body":"Port* PQconnect(const char* conninfo)\r\n{\r\n    Port* port = NULL;\r\n    ConnParam* param = (ConnParam*)palloc0(sizeof(ConnParam));\r\n\r\n    /*\r\n     * Parse the conninfo string\r\n     */\r\n    if (!parseConnParam(conninfo, param)) {\r\n        ConnParamFree(param);\r\n        return NULL;\r\n    }\r\n\r\n    int sock = internalConnect(param);\r\n    ConnParamFree(param);\r\n    if (sock < 0) {\r\n        return NULL;\r\n    }\r\n\r\n    port = (Port*)palloc0(sizeof(Port));\r\n    /* fill in the server (remote) address */\r\n    port->raddr.salen = sizeof(port->raddr.addr);\r\n    if (getpeername(sock, (struct sockaddr*)&port->raddr.addr, (socklen_t*)&port->raddr.salen) < 0) {\r\n        ereport(COMMERROR, (errmsg(\"getsockname() failed.\")));\r\n        close(sock);\r\n        pfree(port);\r\n        return NULL;\r\n    }\r\n    port->sock = sock;\r\n\r\n    return port;\r\n}",
		"comment":"/*\r\n *		PQconnect\r\n *\r\n * Returns a Port*.  If NULL is returned, a error has occurred.\r\n *\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\heartbeat\\libpq\\fe-connect.cpp",
		"name":"PQconnect"
	},
	"PQconninfoFree":{
		"body":"static void PQconninfoFree(PQconninfoOption* connOptions)\r\n{\r\n    PQconninfoOption* option = NULL;\r\n\r\n    if (connOptions == NULL) {\r\n        return;\r\n    }\r\n\r\n    for (option = connOptions; option->keyword != NULL; option++) {\r\n        FREE_AND_RESET(option->val);\r\n    }\r\n    free(connOptions);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\heartbeat\\libpq\\fe-connect.cpp",
		"name":"PQconninfoFree"
	},
	"connectNoDelay":{
		"body":"static int connectNoDelay(int sock)\r\n{\r\n#ifdef TCP_NODELAY\r\n    int on = 1;\r\n\r\n    if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (char*)&on, sizeof(on)) < 0) {\r\n        ereport(COMMERROR, (errmsg(\"could not set socket to TCP no delay mode.\")));\r\n        return 0;\r\n    }\r\n#endif\r\n\r\n    return 1;\r\n}",
		"comment":"/* ----------\r\n * connectNoDelay -\r\n * Sets the TCP_NODELAY socket option.\r\n * Returns 1 if successful, 0 if not.\r\n * ----------\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\heartbeat\\libpq\\fe-connect.cpp",
		"name":"connectNoDelay"
	},
	"conninfo_getval":{
		"body":"static char* conninfo_getval(PQconninfoOption* connOptions, const char* keyword)\r\n{\r\n    PQconninfoOption* option = NULL;\r\n\r\n    for (option = connOptions; option->keyword != NULL; option++) {\r\n        if (strcmp(option->keyword, keyword) == 0) {\r\n            return option->val;\r\n        }\r\n    }\r\n\r\n    return NULL;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\heartbeat\\libpq\\fe-connect.cpp",
		"name":"conninfo_getval"
	},
	"conninfo_parse":{
		"body":"static PQconninfoOption* conninfo_parse(const char* conninfo, bool use_defaults)\r\n{\r\n    char* pname = NULL;\r\n    char* pval = NULL;\r\n    char* buf = NULL;\r\n    char* cp = NULL;\r\n    char* cp2 = NULL;\r\n    PQconninfoOption* options = NULL;\r\n    PQconninfoOption* option = NULL;\r\n    errno_t rc;\r\n\r\n    /* Make a working copy of PQconninfoOptions */\r\n    options = (PQconninfoOption*)malloc(sizeof(PQconninfoOptions));\r\n    if (options == NULL) {\r\n        ereport(COMMERROR, (errmsg(\"out of memory.\")));\r\n        return NULL;\r\n    }\r\n    rc = memcpy_s(options, sizeof(PQconninfoOptions), PQconninfoOptions, sizeof(PQconninfoOptions));\r\n    securec_check_c(rc, \"\", \"\");\r\n\r\n    /* Need a modifiable copy of the input string */\r\n    if ((buf = strdup(conninfo)) == NULL) {\r\n        ereport(COMMERROR, (errmsg(\"out of memory.\")));\r\n        PQconninfoFree(options);\r\n        options = NULL;\r\n        return NULL;\r\n    }\r\n    cp = buf;\r\n\r\n    while (*cp) {\r\n        /* Skip blanks before the parameter name */\r\n        if (isspace((unsigned char)*cp)) {\r\n            cp++;\r\n            continue;\r\n        }\r\n\r\n        /* Get the parameter name */\r\n        pname = cp;\r\n        while (*cp) {\r\n            if (*cp == '=') {\r\n                break;\r\n            }\r\n            if (isspace((unsigned char)*cp)) {\r\n                *cp++ = '\\0';\r\n                while (*cp) {\r\n                    if (!isspace((unsigned char)*cp)) {\r\n                        break;\r\n                    }\r\n                    cp++;\r\n                }\r\n                break;\r\n            }\r\n            cp++;\r\n        }\r\n\r\n        /* Check that there is a following '=' */\r\n        if (*cp != '=') {\r\n            ereport(COMMERROR, (errmsg(\"missing \\\"=\\\" after \\\"%s\\\" in connection info string.\", pname)));\r\n            PQconninfoFree(options);\r\n            options = NULL;\r\n\r\n            FREE_AND_RESET(buf);\r\n            return NULL;\r\n        }\r\n        *cp++ = '\\0';\r\n\r\n        /* Skip blanks after the '=' */\r\n        while (*cp) {\r\n            if (!isspace((unsigned char)*cp)) {\r\n                break;\r\n            }\r\n            cp++;\r\n        }\r\n\r\n        /* Get the parameter value */\r\n        pval = cp;\r\n\r\n        if (*cp != '\\'') {\r\n            cp2 = pval;\r\n            while (*cp) {\r\n                if (isspace((unsigned char)*cp)) {\r\n                    *cp++ = '\\0';\r\n                    break;\r\n                }\r\n                if (*cp == '\\\\') {\r\n                    cp++;\r\n                    if (*cp != '\\0') {\r\n                        *cp2++ = *cp++;\r\n                    }\r\n                } else {\r\n                    *cp2++ = *cp++;\r\n                }\r\n            }\r\n            *cp2 = '\\0';\r\n        } else {\r\n            cp2 = pval;\r\n            cp++;\r\n            for (;;) {\r\n                if (*cp == '\\0') {\r\n                    ereport(COMMERROR, (errmsg(\"unterminated quoted string in connection info string.\")));\r\n                    PQconninfoFree(options);\r\n                    options = NULL;\r\n\r\n                    FREE_AND_RESET(buf);\r\n                    return NULL;\r\n                }\r\n                if (*cp == '\\\\') {\r\n                    cp++;\r\n                    if (*cp != '\\0') {\r\n                        *cp2++ = *cp++;\r\n                    }\r\n                    continue;\r\n                }\r\n                if (*cp == '\\'') {\r\n                    *cp2 = '\\0';\r\n                    cp++;\r\n                    break;\r\n                }\r\n                *cp2++ = *cp++;\r\n            }\r\n        }\r\n\r\n        /*\r\n         * Now we have the name and the value. Search for the param record.\r\n         */\r\n        for (option = options; option->keyword != NULL; option++) {\r\n            if (strcmp(option->keyword, pname) == 0) {\r\n                break;\r\n            }\r\n        }\r\n        if (option->keyword == NULL) {\r\n            ereport(COMMERROR, (errmsg(\"invalid connection option \\\"%s\\\".\", pname)));\r\n            PQconninfoFree(options);\r\n            options = NULL;\r\n\r\n            FREE_AND_RESET(buf);\r\n            return NULL;\r\n        }\r\n\r\n        /*\r\n         * Store the value\r\n         */\r\n        FREE_AND_RESET(option->val);\r\n        option->val = strdup(pval);\r\n        if (option->val == NULL) {\r\n            ereport(COMMERROR, (errmsg(\"out of memory.\")));\r\n            PQconninfoFree(options);\r\n            options = NULL;\r\n\r\n            FREE_AND_RESET(buf);\r\n            return NULL;\r\n        }\r\n    }\r\n\r\n    /* Done with the modifiable input string */\r\n    FREE_AND_RESET(buf);\r\n\r\n    return options;\r\n}",
		"comment":"/*\r\n * Conninfo parser routine\r\n *\r\n * If successful, a malloc'd PQconninfoOption array is returned.\r\n * If not successful, NULL is returned and an error message is\r\n * left in errorMessage.\r\n * Defaults are supplied (from a service file, environment variables, etc)\r\n * for unspecified options, but only if use_defaults is TRUE.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\heartbeat\\libpq\\fe-connect.cpp",
		"name":"conninfo_parse"
	},
	"internalConnect":{
		"body":"static int internalConnect(ConnParam* param)\r\n{\r\n    int sock = -1;\r\n    errno_t rc = 0;\r\n    struct sockaddr_in remoteAddr;\r\n    rc = memset_s(&remoteAddr, sizeof(remoteAddr), 0, sizeof(remoteAddr));\r\n    securec_check(rc, \"\", \"\");\r\n    remoteAddr.sin_family = AF_INET;\r\n    remoteAddr.sin_addr.s_addr = inet_addr(param->remoteIp);\r\n    remoteAddr.sin_port = htons(param->remotePort);\r\n\r\n    /* Open a socket */\r\n    sock = socket(remoteAddr.sin_family, SOCK_STREAM, 0);\r\n    if (sock < 0) {\r\n        ereport(COMMERROR, (errmsg(\"could not create socket.\")));\r\n        return sock;\r\n    }\r\n\r\n    struct sockaddr_in localaddr;\r\n    rc = memset_s(&localaddr, sizeof(sockaddr_in), 0, sizeof(sockaddr_in));\r\n    securec_check(rc, \"\", \"\");\r\n    localaddr.sin_family = AF_INET;\r\n    localaddr.sin_addr.s_addr = inet_addr(param->localIp);\r\n    localaddr.sin_port = 0; /* Any local port will do */\r\n\r\n    rc = bind(sock, (struct sockaddr*)&localaddr, sizeof(localaddr));\r\n    if (rc != 0) {\r\n        ereport(COMMERROR, (errmsg(\"could not bind localhost:%s, result is %d\", param->localIp, rc)));\r\n        close(sock);\r\n        return -1;\r\n    }\r\n\r\n#ifdef F_SETFD\r\n    if (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1) {\r\n        ereport(COMMERROR, (errmsg(\"could not set socket(FD_CLOEXEC): %d\", SOCK_ERRNO)));\r\n        close(sock);\r\n        return -1;\r\n    }\r\n#endif /* F_SETFD */\r\n\r\n    /*\r\n     * Random_Port_Reuse need set SO_REUSEADDR on.\r\n     * Random_Port_Reuse must not use bind interface,\r\n     * because socket owns a random port private when used bind interface.\r\n     * SO_REUSEPORT solve this problem in kernel 3.9.\r\n     */\r\n    if (!IS_AF_UNIX(remoteAddr.sin_family)) {\r\n        int on = 1;\r\n\r\n        if ((setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char*)&on, sizeof(on))) == -1) {\r\n            ereport(COMMERROR, (errmsg(\"could not set socket(FD_CLOEXEC): %d\", SOCK_ERRNO)));\r\n            close(sock);\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Select socket options: no delay of outgoing data for\r\n     * TCP sockets, nonblock mode, close-on-exec. Fail if any\r\n     * of this fails.\r\n     */\r\n    if (!IS_AF_UNIX(remoteAddr.sin_family)) {\r\n        if (!connectNoDelay(sock)) {\r\n            close(sock);\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    if (param->connTimeout > 0) {\r\n        struct timeval timeout = {0, 0};\r\n        timeout.tv_sec = param->connTimeout;\r\n        (void)setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));\r\n    }\r\n\r\n    /*\r\n     * Start/make connection.  This should not block, since we\r\n     * are in nonblock mode.  If it does, well, too bad.\r\n     */\r\n    if (connect(sock, (struct sockaddr*)&remoteAddr, sizeof(struct sockaddr)) < 0) {\r\n        ereport(COMMERROR, (errmsg(\"Connect failed.\")));\r\n        close(sock);\r\n        return -1;\r\n    }\r\n\r\n    return sock;\r\n}",
		"comment":"/* Only support IPV4 now */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\heartbeat\\libpq\\fe-connect.cpp",
		"name":"internalConnect"
	},
	"parseConnParam":{
		"body":"static bool parseConnParam(const char* conninfo, ConnParam* param)\r\n{\r\n    PQconninfoOption* connOptions = NULL;\r\n    char* tmp = NULL;\r\n    const int CONN_TIMED_OUT = 2;\r\n    bool ret = false;\r\n\r\n    /*\r\n     * Parse the conninfo string\r\n     */\r\n    connOptions = conninfo_parse(conninfo, true);\r\n    if (connOptions == NULL) {\r\n        return false;\r\n    }\r\n\r\n    /*\r\n     * Move option values into conn structure\r\n     *\r\n     * XXX: probably worth checking strdup() return value here...\r\n     */\r\n    tmp = conninfo_getval(connOptions, \"host\");\r\n    if (tmp == NULL) {\r\n        ereport(COMMERROR, (errmsg(\"The remote host is NULL.\")));\r\n        goto OUT;\r\n    }\r\n    param->remoteIp = pstrdup(tmp);\r\n\r\n    tmp = conninfo_getval(connOptions, \"port\");\r\n    if (tmp == NULL) {\r\n        ereport(COMMERROR, (errmsg(\"The remote port is NULL.\")));\r\n        goto OUT;\r\n    }\r\n    param->remotePort = atoi(tmp);\r\n\r\n    tmp = conninfo_getval(connOptions, \"localhost\");\r\n    if (tmp == NULL) {\r\n        ereport(COMMERROR, (errmsg(\"The local host is NULL.\")));\r\n        goto OUT;\r\n    }\r\n    param->localIp = pstrdup(tmp);\r\n\r\n    tmp = conninfo_getval(connOptions, \"connect_timeout\");\r\n    param->connTimeout = tmp != NULL ? atoi(tmp) : 0;\r\n\r\n    /*\r\n     * Rounding could cause connection to fail; need at least 2 secs\r\n     */\r\n    if (param->connTimeout < CONN_TIMED_OUT) {\r\n        param->connTimeout = CONN_TIMED_OUT;\r\n    }\r\n\r\n    ret = true;\r\n\r\nOUT:\r\n    /*\r\n     * Free the option info - all is in conn now\r\n     */\r\n    PQconninfoFree(connOptions);\r\n    connOptions = NULL;\r\n\r\n    return ret;\r\n}",
		"comment":"/*\r\n *		parseConnParam\r\n *\r\n * Internal subroutine to set up connection parameters given an already-\r\n * created ConnParam and a conninfo string.\r\n *\r\n * Returns true if OK, false if trouble.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\heartbeat\\libpq\\fe-connect.cpp",
		"name":"parseConnParam"
	}
}