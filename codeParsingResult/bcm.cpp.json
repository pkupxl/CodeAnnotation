{
	"BCMClearFile":{
		"body":"static void BCMClearFile(const RelFileNode& relfilenode, int col)\r\n{\r\n    RelFileNode InvalidRelFileNode = {0, 0, 0, -1};\r\n    Relation rel;\r\n\r\n    if (0 == memcmp(&relfilenode, &InvalidRelFileNode, sizeof(RelFileNode)))\r\n        return;\r\n\r\n    rel = CreateFakeRelcacheEntry(relfilenode);\r\n    BCMClearRel(rel, col);\r\n    FreeFakeRelcacheEntry(rel);\r\n}",
		"comment":"/*\r\n * BCMClearFile: set the BCM file's pages to init pages\r\n * except the first page(BCM File Header).\r\n * FUTURE CASE:: Maybe we should Consider concurrency scenarios,\r\n * one is clearing file another is setting.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"BCMClearFile"
	},
	"BCMClearMetaBit":{
		"body":"static void BCMClearMetaBit(Relation rel, int col)\r\n{\r\n    BlockNumber metablock = 1;\r\n    Buffer metabuffer = InvalidBuffer;\r\n    Page page;\r\n    unsigned char* map = NULL;\r\n    uint32 bshift = 0;\r\n    BCMBitStatus pageStatus0 = 0;\r\n    int i = 0;\r\n    int j = 0;\r\n    bool dirty = false;\r\n\r\n    metabuffer = BCM_readbuf(rel, metablock, false, col);\r\n    if (!BufferIsValid(metabuffer))\r\n        return; /* nothing to */\r\n\r\n    do {\r\n        LockBuffer(metabuffer, BUFFER_LOCK_EXCLUSIVE);\r\n        page = BufferGetPage(metabuffer);\r\n        map = (unsigned char*)PageGetContents(page);\r\n\r\n        ereport(DEBUG1, (errmsg(\"relation %u/%u/%u col %d try to clear meta block %u\",\r\n            rel->rd_node.spcNode, rel->rd_node.dbNode, rel->rd_node.relNode,\r\n            col, metablock)));\r\n\r\n        /* clear sync bit 0 status */\r\n        START_CRIT_SECTION();\r\n        for (i = 0; i < (int)BCMMAPSIZE; i++) {\r\n            for (j = 0; j < META_BLOCKS_PER_BYTE; j++) {\r\n                bshift = (uint32)j * META_BITS_PER_BLOCK;\r\n                pageStatus0 = ((map[i] >> bshift) & META_SYNC0_BITMASK) >> 3;\r\n                Assert(pageStatus0 == SYNCED || pageStatus0 == NOTSYNCED);\r\n                if (pageStatus0 == NOTSYNCED) {\r\n                    SET_SYNC0_BYTE_STATUS(map[i], SYNCED, bshift);\r\n                    dirty = true;\r\n                }\r\n            }\r\n        }\r\n        if (dirty)\r\n            MarkBufferDirty(metabuffer);\r\n        END_CRIT_SECTION();\r\n\r\n        UnlockReleaseBuffer(metabuffer);\r\n\r\n        /* caculate the next meta page, than clear again. */\r\n        metablock += META_BLOCKS_PER_PAGE + 1;\r\n        metabuffer = BCM_readbuf(rel, metablock, false, col);\r\n    } while (BufferIsValid(metabuffer));\r\n\r\n    return;\r\n}",
		"comment":"/*\r\n * Clear all bcm page sync status bit 0 in meta pages before catchup.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"BCMClearMetaBit"
	},
	"BCMClearRel":{
		"body":"void BCMClearRel(Relation rel, int col)\r\n{\r\n    BlockNumber totalblocks = 0;\r\n    BlockNumber mapBlock;\r\n    ForkNumber forknum = BCM_FORKNUM;\r\n\r\n#ifdef TRACE_BCMMAP\r\n    elog(LOG, \"BCMClearRel %s\", RelationGetRelationName(rel));\r\n#endif\r\n\r\n    if (col > 0) {\r\n        forknum = ColumnId2ColForkNum(col);\r\n        CStoreRelationOpenSmgr(rel, col);\r\n    } else {\r\n        RelationOpenSmgr(rel);\r\n    }\r\n\r\n    /*\r\n     * If no bcm map has been created yet for this relation, there's\r\n     * nothing to clear.\r\n     */\r\n    if (!smgrexists(rel->rd_smgr, forknum))\r\n        return;\r\n\r\n    totalblocks = smgrnblocks(rel->rd_smgr, forknum);\r\n    /*\r\n     * If  bcm map only has a file header, there's nothing to clear.\r\n     */\r\n    if (totalblocks == 0 || totalblocks == 1)\r\n        return;\r\n\r\n    /* We begin clear from page 1 not page 0 */\r\n    for (mapBlock = 1; mapBlock < totalblocks; mapBlock++) {\r\n        Buffer mapBuffer;\r\n        unsigned char* map = NULL;\r\n        errno_t rc = 0;\r\n\r\n        mapBuffer = BCM_readbuf(rel, mapBlock, false, col);\r\n        if (!BufferIsValid(mapBuffer))\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_DATA_CORRUPTED),\r\n                    errmsg(\"%u/%u/%u invalid bcm buffer %u\",\r\n                        rel->rd_node.spcNode,\r\n                        rel->rd_node.dbNode,\r\n                        rel->rd_node.relNode,\r\n                        mapBlock)));\r\n\r\n        LockBuffer(mapBuffer, BUFFER_LOCK_EXCLUSIVE);\r\n        map = (unsigned char*)PageGetContents(BufferGetPage(mapBuffer));\r\n\r\n        /* NB: We clear the whole page, including the dcm bits, is that ok? */\r\n        rc = memset_s(map, BCMMAPSIZE, 0, BCMMAPSIZE);\r\n        securec_check(rc, \"\", \"\");\r\n        MarkBufferDirty(mapBuffer);\r\n\r\n        UnlockReleaseBuffer(mapBuffer);\r\n    }\r\n}",
		"comment":"/* Clear all the bcm bits of a relation */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"BCMClearRel"
	},
	"BCMGetDataFileMaxSize":{
		"body":"static BlockNumber BCMGetDataFileMaxSize(Relation rel, int col)\r\n{\r\n    BlockNumber maxHeapBlock = 0;\r\n\r\n    if (col > 0) {\r\n        uint64 filesize = GetColDataFileSize(rel, col);\r\n        maxHeapBlock = (BlockNumber)(filesize / ALIGNOF_CUSIZE);\r\n    } else {\r\n        if (smgrexists(rel->rd_smgr, MAIN_FORKNUM)) {\r\n            maxHeapBlock = smgrnblocks(rel->rd_smgr, MAIN_FORKNUM);\r\n        } else {\r\n            char* rpath = NULL;\r\n            RelFileNodeBackend smgr_rnode;\r\n            smgr_rnode.node = rel->rd_node;\r\n            smgr_rnode.backend = InvalidBackendId;\r\n            rpath = relpath(smgr_rnode, MAIN_FORKNUM);\r\n            ereport(WARNING,\r\n                (errcode_for_file_access(),\r\n                    errmsg(\"relation file is not exist when get max block num \"\r\n                           \"for bcm file relfilenode: \\\"%s\\\": %m\",\r\n                        rpath)));\r\n            pfree(rpath);\r\n            rpath = NULL;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Block is from 0 to nblocks-1, if maxHeapBlock is 0, we should return 0\r\n     */\r\n    return maxHeapBlock ? (maxHeapBlock - 1) : InvalidBlockNumber;\r\n}",
		"comment":"/*\r\n * Get max block num for bcm file relfilenode\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"BCMGetDataFileMaxSize"
	},
	"BCMLogCU":{
		"body":"void BCMLogCU(Relation rel, uint64 offset, int col, BCMBitStatus status, int count)\r\n{\r\n    bool needwal = false;\r\n\r\n    needwal = (RelationNeedsWAL(rel) && !t_thrd.xlog_cxt.InRecovery);\r\n\r\n    if (needwal) {\r\n        Buffer bcmbuffer = InvalidBuffer;\r\n        Page page;\r\n\r\n        BCM_CStore_pin(rel, col, offset, &bcmbuffer);\r\n        LockBuffer(bcmbuffer, BUFFER_LOCK_EXCLUSIVE);\r\n        page = BufferGetPage(bcmbuffer);\r\n\r\n        START_CRIT_SECTION();\r\n        {\r\n            uint64 cuBlock = 0;\r\n            XLogRecPtr recptr = InvalidXLogRecPtr;\r\n\r\n            cuBlock = CSTORE_OFFSET_TO_CSTOREBLOCK(offset);\r\n            recptr = log_cu_bcm(&(rel->rd_node), col, cuBlock, status, count);\r\n\r\n            PageSetLSN(page, recptr);\r\n        }\r\n        END_CRIT_SECTION();\r\n\r\n        LockBuffer(bcmbuffer, BUFFER_LOCK_UNLOCK);\r\n        ReleaseBuffer(bcmbuffer);\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"BCMLogCU"
	},
	"BCMResetMetaBit":{
		"body":"static void BCMResetMetaBit(Relation rel, BlockNumber metablk, int col)\r\n{\r\n    BlockNumber metablock = 1;\r\n    Buffer metabuffer = InvalidBuffer;\r\n    Page page;\r\n    unsigned char* map = NULL;\r\n    uint32 bshift = 0;\r\n    BCMBitStatus pageStatus0 = 0;\r\n    BCMBitStatus pageStatus1 = 0;\r\n    int i = 0;\r\n    int j = 0;\r\n    bool dirty = false;\r\n\r\n    for (metablock = 1; metablock < metablk; metablock += (META_BLOCKS_PER_PAGE + 1)) {\r\n        metabuffer = BCM_readbuf(rel, metablock, false, col);\r\n        if (!BufferIsValid(metabuffer))\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_DATA_CORRUPTED),\r\n                    errmsg(\"%u/%u/%u invalid bcm meta buffer %u\",\r\n                        rel->rd_node.spcNode,\r\n                        rel->rd_node.dbNode,\r\n                        rel->rd_node.relNode,\r\n                        metablock)));\r\n\r\n        LockBuffer(metabuffer, BUFFER_LOCK_EXCLUSIVE);\r\n        page = BufferGetPage(metabuffer);\r\n        map = (unsigned char*)PageGetContents(page);\r\n\r\n        ereport(DEBUG1, (errmsg(\"relation %u/%u/%u col %d try to reset meta block %u\",\r\n            rel->rd_node.spcNode, rel->rd_node.dbNode, rel->rd_node.relNode,\r\n            col, metablock)));\r\n        /*\r\n         * Clear the latest set sync bit 1 status, the the page status 0 has been set\r\n         * to NOTSYNCED sync last meta clear, we should skip this BCM block.\r\n         */\r\n        START_CRIT_SECTION();\r\n        for (i = 0; i < (int)BCMMAPSIZE; i++) {\r\n            for (j = 0; j < META_BLOCKS_PER_BYTE; j++) {\r\n                bshift = (uint32)j * META_BITS_PER_BLOCK;\r\n                pageStatus0 = ((map[i] >> bshift) & META_SYNC0_BITMASK) >> 3;\r\n                Assert(SYNCED == pageStatus0 || NOTSYNCED == pageStatus0);\r\n                pageStatus1 = ((map[i] >> bshift) & META_SYNC1_BITMASK) >> 1;\r\n                Assert(SYNCED == pageStatus1 || NOTSYNCED == pageStatus1);\r\n                if (SYNCED == pageStatus0 && NOTSYNCED == pageStatus1) {\r\n                    SET_SYNC1_BYTE_STATUS(map[i], SYNCED, bshift);\r\n                    dirty = true;\r\n                }\r\n            }\r\n        }\r\n        if (dirty)\r\n            MarkBufferDirty(metabuffer);\r\n        END_CRIT_SECTION();\r\n\r\n        UnlockReleaseBuffer(metabuffer);\r\n    }\r\n\r\n    return;\r\n}",
		"comment":"/*\r\n * Reset the bcm page sync status bit 1 in meta pages after catchup.\r\n * Notes: we skip those bcm pages which are recently marked as unsynced\r\n * by checking the sync status bit 0.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"BCMResetMetaBit"
	},
	"BCMSendData":{
		"body":"static void BCMSendData(const RelFileNode& relfilenode, const char* bcmpath, int col)\r\n{\r\n    RelFileNode InvalidRelFileNode = {0, 0, 0, -1};\r\n    Relation rel;\r\n    Buffer metabuffer = InvalidBuffer;\r\n    ForkNumber forknum = BCM_FORKNUM;\r\n    BlockNumber heapBlock = InvalidBlockNumber;\r\n    BlockNumber metanum = 1;\r\n    BlockNumber maxHeapBlock = InvalidBlockNumber;\r\n    struct stat stat_buf;\r\n\r\n    volatile DataSndCtlData* datasndctl = t_thrd.datasender_cxt.DataSndCtl;\r\n    bool isColStore = col > 0 ? true : false;\r\n    int contibits = 0;\r\n\r\n    /* if disabled stream replication or relfilenode is invalid, skip current relation. */\r\n    if (!u_sess->attr.attr_storage.enable_stream_replication ||\r\n        (0 == memcmp(&relfilenode, &InvalidRelFileNode, sizeof(RelFileNode))))\r\n        return;\r\n\r\n    /*\r\n     * Here we lock the database to solve the checkpoint failure \" ERROR:checkpoint request failed\r\n     * CONTEXT:  Error message received from nodes:xxx\" because of the concurrent execution of drop\r\n     * database and catchup.Steps to reproduce:\r\n     * 1.create database test,and create table t1 in test;\r\n     * 2.copy data to t1(without standby)\r\n     * 3.drop database and sleep before rm data\r\n     * 4.start standby, catchup thread will start and send data in primary\r\n     * 5.conitue step 3\r\n     * 6.drop database will success\r\n     * 7.create database or checkpoint will get the error.\r\n     */\r\n    LockSharedObject(DatabaseRelationId, relfilenode.dbNode, 0, RowExclusiveLock);\r\n\r\n    rel = CreateFakeRelcacheEntry(relfilenode);\r\n\r\n    /*\r\n     * First lock relfilenode(Notes: relfilenode.relNode maybe differnt from oid),\r\n     * at this time, LockRelation is equal to LockRelFileNode,\r\n     * then read the bcm file, if it is not exit,\r\n     * the table maybe delete, so we will return.\r\n     *\r\n     * ExclusiveLock will block insert, because catchup maybe read a zero block\r\n     * after insert, it is tested on xfs file system.\r\n     */\r\n    LockRelFileNode(relfilenode, ExclusiveLock);\r\n\r\n    if (isColStore) {\r\n        forknum = ColumnId2ColForkNum(col);\r\n        CStoreRelationOpenSmgr(rel, col);\r\n    } else {\r\n        RelationOpenSmgr(rel);\r\n    }\r\n\r\n    /*\r\n     * BCM file is just removed, skip following check.\r\n     * smgrexists maybe not correct(After the table is dropped), so we should use\r\n     * stat to check it.\r\n     */\r\n    if (!smgrexists(rel->rd_smgr, forknum) || stat(bcmpath, &stat_buf) != 0) {\r\n        UnlockRelFileNode(relfilenode, ExclusiveLock);\r\n        FreeFakeRelcacheEntry(rel);\r\n        UnlockSharedObject(DatabaseRelationId, relfilenode.dbNode, 0, RowExclusiveLock);\r\n        return;\r\n    }\r\n\r\n    BCMClearMetaBit(rel, col);\r\n\r\n    metabuffer = BCM_readbuf(rel, metanum, false, col);\r\n    if (!BufferIsValid(metabuffer)) {\r\n        /* Nothing to do, the file was already smaller */\r\n        UnlockRelFileNode(relfilenode, ExclusiveLock);\r\n        FreeFakeRelcacheEntry(rel);\r\n        UnlockSharedObject(DatabaseRelationId, relfilenode.dbNode, 0, RowExclusiveLock);\r\n        return;\r\n    }\r\n\r\n    /* get max size of data file */\r\n    maxHeapBlock = BCMGetDataFileMaxSize(rel, col);\r\n    if (maxHeapBlock == InvalidBlockNumber) {\r\n        /* Nothing to do, the file size was zero */\r\n        UnlockRelFileNode(relfilenode, ExclusiveLock);\r\n        FreeFakeRelcacheEntry(rel);\r\n        UnlockSharedObject(DatabaseRelationId, relfilenode.dbNode, 0, RowExclusiveLock);\r\n        return;\r\n    }\r\n\r\n    CUFile* cFile = isColStore ? New(CurrentMemoryContext) CUFile(relfilenode, col) : NULL;\r\n    do {\r\n        ereport(DEBUG3, (errmsg(\"valid bcm meta buffer :%u\", metanum)));\r\n\r\n        BCMWalkMetaBuffer(rel, cFile, metabuffer, heapBlock, contibits, maxHeapBlock, col);\r\n        ReleaseBuffer(metabuffer);\r\n\r\n        /* caculate the next meta page, than check again. */\r\n        metanum += META_BLOCKS_PER_PAGE + 1;\r\n        metabuffer = BCM_readbuf(rel, metanum, false, col);\r\n    } while (BufferIsValid(metabuffer));\r\n\r\n    /*\r\n     * For column store, after we loaded all the bcm buffers, especially when\r\n     * the last bcm status was NOTSYNCED, we should finish the surplus work --\r\n     * push the last contibits data to queue.\r\n     */\r\n    if (contibits > 0)\r\n        bcm_read_multi_cu(cFile, rel, col, heapBlock, contibits, maxHeapBlock);\r\n\r\n    if (cFile)\r\n        DELETE_EX(cFile);\r\n\r\n    /*\r\n     * we should wait until all the pushed data has been send to the standby,\r\n     * then clear the BCMArray.\r\n     */\r\n    while (DQByteLT(datasndctl->queue_offset, t_thrd.proc->waitDataSyncPoint)) {\r\n        CatchupShutdownIfNoDataSender();\r\n        pg_usleep(1000L); /* 1ms */\r\n    }\r\n\r\n    ClearBCMArray();\r\n    BCMResetMetaBit(rel, metanum, col);\r\n\r\n    UnlockRelFileNode(relfilenode, ExclusiveLock);\r\n    FreeFakeRelcacheEntry(rel);\r\n\r\n    UnlockSharedObject(DatabaseRelationId, relfilenode.dbNode, 0, RowExclusiveLock);\r\n}",
		"comment":"/*\r\n * BCMSendData\r\n *\r\n * Traverse every BCM page of current relation to see if a corresponding\r\n * heap page or CU unit needs to send to standby. If needed, load the\r\n * heap page or CU unit data and push it to the send queue. We should\r\n * hold the relation lock to avoid been dropped during catchup.\r\n * In order to speed up the check efficiency, we just need to walk the\r\n * bcm meta buffer instead. More comments see in bcm meta buffer.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"BCMSendData"
	},
	"BCMSendOneBuffer":{
		"body":"static void BCMSendOneBuffer(Relation rel, CUFile* cFile, Buffer bcmbuffer, BlockNumber& heapBlock, int& contibits,\r\n    BlockNumber maxHeapBlock, int col)\r\n{\r\n    Buffer heapbuffer = InvalidBuffer;\r\n    Page bcmpage;\r\n    int i;\r\n    int j;\r\n    uint32 bshift;\r\n    unsigned char* map = NULL;\r\n    BCMBitStatus status;\r\n    BlockNumber blocknum = 0;\r\n    bool isColStore = col > 0 ? true : false;\r\n\r\n    blocknum = BufferGetBlockNumber(bcmbuffer);\r\n    Assert(isColStore || (cFile == NULL));\r\n\r\n    /*\r\n     * Do not lock buffer, maybe deadlock, if\r\n     * Catchup held this buffer share lock, and push to dataqueue, but queue has no freespace,\r\n     * Catchup will sleep with share lock; wait for DataSender to free queue's space;\r\n     * But DataSender need to get this buffer exclusive lock to set BCM bit: 1-->0, so\r\n     * Catchup held share lock wait DataSender; DataSender wait exclusive lock held by Catchup;\r\n     * then deadlock occured.\r\n     */\r\n    bcmpage = BufferGetPage(bcmbuffer);\r\n    map = (unsigned char*)PageGetContents(bcmpage);\r\n\r\n    for (i = 0; i < (int)BCMMAPSIZE; i++) {\r\n        for (j = 0; j < BCM_BLOCKS_PER_BYTE; j++) {\r\n            bshift = (uint32)j * BCM_BITS_PER_BLOCK;\r\n            status = ((map[i] >> bshift) & BCM_SYNC_BITMASK) >> 1;\r\n\r\n            /* If not sync */\r\n            if (status == NOTSYNCED) {\r\n                CatchupShutdownIfNoDataSender();\r\n                if (isColStore) { /* column store */\r\n                    /* get heap page block */\r\n                    if (contibits == 0)\r\n                        heapBlock = GET_HEAP_BLOCK(blocknum, i, j);\r\n                    contibits++;\r\n                } else { /* row store */\r\n                    /* get heap page block */\r\n                    heapBlock = GET_HEAP_BLOCK(blocknum, i, j);\r\n\r\n                    if (u_sess->attr.attr_storage.HaModuleDebug) {\r\n                        ereport(LOG,\r\n                            (errmsg(\"HA-BCMSendOneBuffer: relation %u/%u/%u col %d try to sync bcm \"\r\n                                    \"blockno %u heap blockno %u maxHeapBlock %u\",\r\n                                rel->rd_node.spcNode,\r\n                                rel->rd_node.dbNode,\r\n                                rel->rd_node.relNode,\r\n                                col,\r\n                                blocknum,\r\n                                heapBlock,\r\n                                maxHeapBlock)));\r\n                    }\r\n\r\n                    /*\r\n                     * For OS crash, Data file block maybe not fsync disk to 100(For example),\r\n                     * but BCM maybe flush disk to 101. We can not read data file block.\r\n                     */\r\n                    if (heapBlock > maxHeapBlock)\r\n                        return;\r\n\r\n                    heapbuffer = ReadBuffer(rel, heapBlock);\r\n\r\n                    LockBuffer(heapbuffer, BUFFER_LOCK_SHARE);\r\n                    PushHeapPageToDataQueue(heapbuffer);\r\n                    UnlockReleaseBuffer(heapbuffer);\r\n                }\r\n            }\r\n\r\n            if (isColStore) {\r\n                /*\r\n                 * for column store, we record the continuous no-sync status,\r\n                 * load CU data for once as much as possible.\r\n                 */\r\n                if (contibits > 0 && (status == SYNCED || contibits >= MAXCONTIBITS))\r\n                    bcm_read_multi_cu(cFile, rel, col, heapBlock, contibits, maxHeapBlock);\r\n            }\r\n        }\r\n    }\r\n}",
		"comment":"/*\r\n * BCMSendOneBuffer\r\n *\r\n * Walk through every bit in current bcm page to find out if any corresponding\r\n * heap pages or CU units need to send to standby.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"BCMSendOneBuffer"
	},
	"BCMSetMetaBit":{
		"body":"static void BCMSetMetaBit(Relation rel, BlockNumber block, BCMBitStatus status, int col)\r\n{\r\n    BlockNumber metablock = BCMBLK_TO_METABLOCK(block);\r\n    int metaByte = BCMBLK_TO_METABYTE(block);\r\n    int metaBit = BCMBLK_TO_METABIT(block);\r\n    uint32 bshift = (uint32)metaBit * META_BITS_PER_BLOCK;\r\n    Buffer metabuffer = InvalidBuffer;\r\n    BCMBitStatus pageStatus0 = 0;\r\n    BCMBitStatus pageStatus1 = 0;\r\n    Page page;\r\n    unsigned char* map = NULL;\r\n\r\n    Assert(status == SYNCED || status == NOTSYNCED);\r\n\r\n    metabuffer = BCM_readbuf(rel, metablock, false, col);\r\n    Assert(BufferIsValid(metabuffer));\r\n    LockBuffer(metabuffer, BUFFER_LOCK_EXCLUSIVE);\r\n    page = BufferGetPage(metabuffer);\r\n    map = (unsigned char*)PageGetContents(page);\r\n\r\n    /* get sync bit 0 & 1 status */\r\n    pageStatus0 = ((map[metaByte] >> bshift) & META_SYNC0_BITMASK) >> 3;\r\n    Assert(pageStatus0 == SYNCED || pageStatus0 == NOTSYNCED);\r\n    pageStatus1 = ((map[metaByte] >> bshift) & META_SYNC1_BITMASK) >> 1;\r\n    Assert(pageStatus1 == SYNCED || pageStatus1 == NOTSYNCED);\r\n\r\n    /* set sync bit status */\r\n    if (status != pageStatus0 || status != pageStatus1) {\r\n        START_CRIT_SECTION();\r\n        if (status != pageStatus0)\r\n            SET_SYNC0_BYTE_STATUS(map[metaByte], status, bshift);\r\n        if (status != pageStatus1)\r\n            SET_SYNC1_BYTE_STATUS(map[metaByte], status, bshift);\r\n        MarkBufferDirty(metabuffer);\r\n        END_CRIT_SECTION();\r\n    }\r\n\r\n    UnlockReleaseBuffer(metabuffer);\r\n}",
		"comment":"/*\r\n * Set the meta page sync bit where the bcm block refers to.\r\n * Here, we use two sync bits(sync bit 0 and sync bit 1) to represent\r\n * the sync status of a bcm page. When we set sync bit 1 to unsynced, it\r\n * means the bcm page may have unsynced heap blocks. sync. When we set\r\n * sync bit 0 to unsynced during catchup, it means that the bcm page status\r\n * bit in meta page should not be reset after catchup which can be perceived\r\n * by the next catchup.\r\n * Note: call the function should first hold BUFFER_LOCK_EXCLUSIVE lock\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"BCMSetMetaBit"
	},
	"BCMSetStatusBit":{
		"body":"void BCMSetStatusBit(Relation rel, uint64 heapBlk, Buffer buf, BCMBitStatus status, int col)\r\n{\r\n    BlockNumber mapBlock = HEAPBLK_TO_BCMBLOCK(heapBlk);\r\n    int mapByte = HEAPBLK_TO_BCMBYTE(heapBlk);\r\n    int mapBit = HEAPBLK_TO_BCMBIT(heapBlk);\r\n    uint32 bshift = (uint32)mapBit * BCM_BITS_PER_BLOCK;\r\n    BCMBitStatus bcmStatus = 0;\r\n    bool needwal = false;\r\n    Page page;\r\n    unsigned char* map = NULL;\r\n\r\n#ifdef TRACE_BCMMAP\r\n    elog(LOG,\r\n        \"BCMSetStatusBit: rel: %s col: %d blk: %lu  status: %d \",\r\n        RelationGetRelationName(rel),\r\n        col,\r\n        heapBlk,\r\n        status);\r\n#endif\r\n\r\n    if (!BufferIsValid(buf) || BufferGetBlockNumber(buf) != mapBlock)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_DATA_CORRUPTED),\r\n                errmsg(\"wrong buffer passed to BCM_clear, BlockNumber from buf is %u,\"\r\n                       \"mapBlock is %u\",\r\n                    BufferGetBlockNumber(buf),\r\n                    mapBlock)));\r\n\r\n    Assert(status == SYNCED || status == NOTSYNCED);\r\n\r\n    if (status == NOTSYNCED)\r\n        BCMSetMetaBit(rel, mapBlock, NOTSYNCED, col);\r\n\r\n    page = BufferGetPage(buf);\r\n    map = (unsigned char*)PageGetContents(page);\r\n\r\n    bcmStatus = (map[mapByte] >> bshift) & BCM_SYNC_BITMASK;\r\n    bcmStatus = bcmStatus >> 1;\r\n    Assert(bcmStatus == SYNCED || bcmStatus == NOTSYNCED);\r\n\r\n    /* Bcm status must be 0 before it will be set to 1 */\r\n    if (!RecoveryInProgress() && status == NOTSYNCED && bcmStatus == NOTSYNCED)\r\n        ereport(WARNING,\r\n            (errmsg(\"BCM page maybe damage, rnode[%u,%u,%u] col:%d block:%lu \",\r\n                rel->rd_node.spcNode,\r\n                rel->rd_node.dbNode,\r\n                rel->rd_node.relNode,\r\n                col,\r\n                heapBlk)));\r\n\r\n    needwal = (RelationNeedsWAL(rel) && !t_thrd.xlog_cxt.InRecovery);\r\n\r\n    if (status != bcmStatus) {\r\n        START_CRIT_SECTION();\r\n\r\n        /* set status */\r\n        SET_SYNC_BYTE_STATUS(map[mapByte], status, bshift);\r\n        MarkBufferDirty(buf);\r\n\r\n        /*\r\n         * we record one cu bcm xlog in BCMLogCU for column store.\r\n         */\r\n        bool isRowStore = (col == 0);\r\n\r\n        if (needwal && isRowStore) {\r\n            XLogRecPtr recptr = InvalidXLogRecPtr;\r\n\r\n            recptr = log_heap_bcm(&(rel->rd_node), 0, heapBlk, status);\r\n\r\n            PageSetLSN(page, recptr);\r\n        }\r\n        END_CRIT_SECTION();\r\n    }\r\n}",
		"comment":"/*\r\n * Set the corresponding bit of the heap block as status, before call\r\n * this function we should call BCM_pin to get the right bcmbuffer.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"BCMSetStatusBit"
	},
	"BCMWalkMetaBuffer":{
		"body":"static void BCMWalkMetaBuffer(Relation rel, CUFile* cFile, Buffer metabuffer, BlockNumber& heapBlock, int& contibits,\r\n    BlockNumber maxHeapBlock, int col)\r\n{\r\n    Buffer bcmbuffer = InvalidBuffer;\r\n    BlockNumber metaBlock;\r\n    BlockNumber bcmBlock;\r\n    int i;\r\n    int j;\r\n    uint32 bshift;\r\n    BCMBitStatus status;\r\n    Page metapage;\r\n    unsigned char* map = NULL;\r\n\r\n    Assert(BufferIsValid(metabuffer));\r\n    metaBlock = BufferGetBlockNumber(metabuffer);\r\n    metapage = BufferGetPage(metabuffer);\r\n    map = (unsigned char*)PageGetContents(metapage);\r\n\r\n    for (i = 0; i < (int)BCMMAPSIZE; i++) {\r\n        for (j = 0; j < META_BLOCKS_PER_BYTE; j++) {\r\n            bshift = (uint32)j * META_BITS_PER_BLOCK;\r\n            status = ((map[i] >> bshift) & META_SYNC1_BITMASK) >> 1;\r\n\r\n            /* the bcm block needs to sync */\r\n            if (status == NOTSYNCED) {\r\n                CatchupShutdownIfNoDataSender();\r\n                /* get bcm page block */\r\n                bcmBlock = GET_BCM_BLOCK(metaBlock, i, j);\r\n                ereport(DEBUG2,\r\n                    (errmsg(\"relation %u/%u/%u col %d try to sync bcm block %u\",\r\n                        rel->rd_node.spcNode,\r\n                        rel->rd_node.dbNode,\r\n                        rel->rd_node.relNode,\r\n                        col,\r\n                        bcmBlock)));\r\n                /*\r\n                 * We assume that if the bcm buffer is invalid, it means that some\r\n                 * thread has just extended that block, and we can see it in meta page\r\n                 * but not in the opened smgr of current relation. It's safe to skip this\r\n                 * block 'cause we can sync it by data replication.\r\n                 */\r\n                bcmbuffer = BCM_readbuf(rel, bcmBlock, false, col);\r\n                if (BufferIsValid(bcmbuffer)) {\r\n                    BCMSendOneBuffer(rel, cFile, bcmbuffer, heapBlock, contibits, maxHeapBlock, col);\r\n                    ReleaseBuffer(bcmbuffer);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}",
		"comment":"/*\r\n * BCMWalkMetaBuffer\r\n *\r\n * Walk through every bit in current meta page to find out if any corresponding\r\n * BCM page needs to search.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"BCMWalkMetaBuffer"
	},
	"BCM_CStore_pin":{
		"body":"void BCM_CStore_pin(Relation rel, int col, uint64 offset, Buffer* buf)\r\n{\r\n    Assert(col > 0);\r\n\r\n    BlockNumber mapBlock = CSTORE_OFFSET_TO_BCMBLOCK(offset);\r\n\r\n    *buf = BCM_readbuf(rel, mapBlock, true, col);\r\n}",
		"comment":"/* Read bcm page */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"BCM_CStore_pin"
	},
	"BCM_extend":{
		"body":"static void BCM_extend(Relation rel, BlockNumber bcm_nblocks, int col)\r\n{\r\n    BlockNumber bcm_nblocks_now;\r\n    Page pg;\r\n    ForkNumber forknum = BCM_FORKNUM;\r\n\r\n    ADIO_RUN()\r\n    {\r\n        pg = (Page)adio_align_alloc(BLCKSZ);\r\n    }\r\n    ADIO_ELSE()\r\n    {\r\n        pg = (Page)palloc(BLCKSZ);\r\n    }\r\n    ADIO_END();\r\n\r\n    PageInit(pg, BLCKSZ, 0);\r\n\r\n    /*\r\n     * We use the relation extension lock to lock out other backends trying to\r\n     * extend the bcm map at the same time. It also locks out extension\r\n     * of the main fork, unnecessarily, but extending the bcm map\r\n     * happens seldom enough that it doesn't seem worthwhile to have a\r\n     * separate lock tag type for it.\r\n     *\r\n     * Note that another backend might have extended or created the relation\r\n     * by the time we get the lock.\r\n     */\r\n    LockRelationForExtension(rel, ExclusiveLock);\r\n\r\n    /*\r\n     * Create the file first if it doesn't exist.  If smgr_bcm_nblocks is\r\n     * positive then it must exist, no need for an smgrexists call.\r\n     */\r\n    if (col > 0) {\r\n        forknum = ColumnId2ColForkNum(col);\r\n        CStoreRelationOpenSmgr(rel, col);\r\n    } else {\r\n        /* Might have to re-open if a cache flush happened */\r\n        RelationOpenSmgr(rel);\r\n    }\r\n\r\n    if ((rel->rd_smgr->smgr_bcm_nblocks[col] == 0 || rel->rd_smgr->smgr_bcm_nblocks[col] == InvalidBlockNumber) &&\r\n        !smgrexists(rel->rd_smgr, forknum)) {\r\n        createBCMFile(rel, col);\r\n    }\r\n\r\n    bcm_nblocks_now = smgrnblocks(rel->rd_smgr, forknum);\r\n\r\n    if (bcm_nblocks_now < bcm_nblocks) {\r\n        VerifyTblspcWhenBcmExtend(rel, col, bcm_nblocks - bcm_nblocks_now);\r\n    }\r\n\r\n    /* Now extend the file */\r\n    while (bcm_nblocks_now < bcm_nblocks) {\r\n        PageSetChecksumInplace(pg, bcm_nblocks_now);\r\n\r\n        smgrextend(rel->rd_smgr, forknum, bcm_nblocks_now, (char*)pg, false);\r\n        bcm_nblocks_now++;\r\n    }\r\n\r\n    /*\r\n     * Send a shared-inval message to force other backends to close any smgr\r\n     * references they may have for this rel, which we are about to change.\r\n     * This is a useful optimization because it means that backends don't have\r\n     * to keep checking for creation or extension of the file, which happens\r\n     * infrequently.\r\n     */\r\n    CacheInvalidateSmgr(rel->rd_smgr->smgr_rnode);\r\n\r\n    /* Update local cache with the up-to-date size */\r\n    rel->rd_smgr->smgr_bcm_nblocks[col] = bcm_nblocks_now;\r\n\r\n    UnlockRelationForExtension(rel, ExclusiveLock);\r\n\r\n    ADIO_RUN();\r\n    {\r\n        adio_align_free(pg);\r\n    }\r\n    ADIO_ELSE()\r\n    {\r\n        pfree(pg);\r\n        pg = NULL;\r\n    }\r\n    ADIO_END();\r\n}",
		"comment":"/*\r\n * Ensure that the bcm map fork is at least bcm_nblocks long, extending\r\n * it if necessary with zeroed pages.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"BCM_extend"
	},
	"BCM_pin":{
		"body":"void BCM_pin(Relation rel, BlockNumber heapBlk, Buffer* buf)\r\n{\r\n    BlockNumber mapBlock = HEAPBLK_TO_BCMBLOCK(heapBlk);\r\n\r\n    *buf = BCM_readbuf(rel, mapBlock, true);\r\n}",
		"comment":"/* Read bcm page */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"BCM_pin"
	},
	"BCM_readbuf":{
		"body":"static Buffer BCM_readbuf(Relation rel, BlockNumber blkno, bool extend, int col)\r\n{\r\n    Buffer buf;\r\n    ForkNumber forknum = BCM_FORKNUM;\r\n\r\n    if (col > 0) {\r\n        forknum = ColumnId2ColForkNum(col);\r\n\r\n        /*\r\n         * We might not have opened the relation at the smgr level yet, or we\r\n         * might have been forced to close it by a sinval message.	The code below\r\n         * won't necessarily notice relation extension immediately when extend =\r\n         * false, so we rely on sinval messages to ensure that our ideas about the\r\n         * size of the map aren't too far out of date.\r\n         */\r\n        CStoreRelationOpenSmgr(rel, col);\r\n    } else {\r\n        RelationOpenSmgr(rel);\r\n    }\r\n\r\n    /*\r\n     * If we haven't cached the size of the bcm map fork yet, check it\r\n     * first.\r\n     */\r\n    if (rel->rd_smgr->smgr_bcm_nblocks[col] == InvalidBlockNumber) {\r\n        if (smgrexists(rel->rd_smgr, forknum))\r\n            rel->rd_smgr->smgr_bcm_nblocks[col] = smgrnblocks(rel->rd_smgr, forknum);\r\n        else\r\n            rel->rd_smgr->smgr_bcm_nblocks[col] = 0;\r\n    }\r\n\r\n    /* Handle requests beyond EOF */\r\n    if (blkno >= rel->rd_smgr->smgr_bcm_nblocks[col]) {\r\n        if (extend)\r\n            BCM_extend(rel, blkno + 1, col);\r\n        else\r\n            return InvalidBuffer;\r\n    }\r\n\r\n    /*\r\n     * Use ZERO_ON_ERROR mode, and initialize the page if necessary. It's\r\n     * always safe to clear bits, so it's better to clear corrupt pages than\r\n     * error out.\r\n     */\r\n    buf = ReadBufferExtended(rel, forknum, blkno, RBM_ZERO_ON_ERROR, NULL);\r\n    if (PageIsNew(BufferGetPage(buf)))\r\n        PageInit(BufferGetPage(buf), BLCKSZ, 0);\r\n    return buf;\r\n}",
		"comment":"/*\r\n * Read a bcm map page.\r\n *\r\n * If the page doesn't exist, InvalidBuffer is returned, or if 'extend' is\r\n * true, the bcm map file is extended.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"BCM_readbuf"
	},
	"BCM_truncate":{
		"body":"void BCM_truncate(Relation rel)\r\n{\r\n\r\n#ifdef TRACE_BCMMAP\r\n    ereport(DEBUG1, (errmodule(MOD_REP), errmsg(\"bcm_truncate %s\", RelationGetRelationName(rel))));\r\n#endif\r\n\r\n    RelationOpenSmgr(rel);\r\n\r\n    /*\r\n     * If no bcm map has been created yet for this relation, there's\r\n     * nothing to truncate.\r\n     */\r\n    if (!smgrexists(rel->rd_smgr, BCM_FORKNUM))\r\n        return;\r\n\r\n    /* Truncate the bcm pages, and send smgr inval message */\r\n    smgrtruncate(rel->rd_smgr, BCM_FORKNUM, 0);\r\n\r\n    /*\r\n     * We might as well update the local smgr_bcm_nblocks setting. smgrtruncate\r\n     * sent an smgr cache inval message, which will cause other backends to\r\n     * invalidate their copy of smgr_bcm_nblocks, and this one too at the next\r\n     * command boundary.  But this ensures it isn't outright wrong until then.\r\n     */\r\n    for (int i = 0; i < rel->rd_smgr->smgr_bcmarry_size; i++)\r\n        rel->rd_smgr->smgr_bcm_nblocks[i] = 0;\r\n}",
		"comment":"/*\r\n * BCM_truncate - truncate the bcm map\r\n *\r\n * The caller must hold AccessExclusiveLock on the relation, to ensure that\r\n * other backends receive the smgr invalidation event that this function sends\r\n * before they access the bcm again.\r\n *\r\n * Note: bcm will be truncated to zero. Only data replication can generate bcm\r\n * file, and heap can not be truncated by lazy vacuum(the function of\r\n * lazy_truncate_heap has been disabled at data replication mode), so we need\r\n * not to realize the code about truncate the bcm file to nblock.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"BCM_truncate"
	},
	"CheckFilePostfix":{
		"body":"static bool CheckFilePostfix(const char* str1, const char* str2)\r\n{\r\n    int len1 = 0;\r\n    int len2 = 0;\r\n    if (str1 == NULL || str2 == NULL) {\r\n        return false;\r\n    }\r\n    len1 = (int)strlen(str1);\r\n    len2 = (int)strlen(str2);\r\n    if ((len1 < len2) || (len1 == 0 || len2 == 0)) {\r\n        return false;\r\n    }\r\n    while (len2 >= 1) {\r\n        if (str2[len2 - 1] != str1[len1 - 1]) {\r\n            return false;\r\n        }\r\n        len2--;\r\n        len1--;\r\n    }\r\n    return true;\r\n}",
		"comment":"/*\r\n * Check if we have specific postfix in the string.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"CheckFilePostfix"
	},
	"HandleBCMfile":{
		"body":"static void HandleBCMfile(char* bcmpath, bool clear)\r\n{\r\n    RelFileNodeForkNum bcmfilenode;\r\n\r\n    bcmfilenode = relpath_to_filenode(bcmpath);\r\n    if (bcmfilenode.forknumber == InvalidForkNumber) {\r\n        ereport(WARNING,\r\n            (errmsg(\"relfilenode [spcNode%u] [dbNode%u] [relNode%u]\"\r\n                    \"[backendId%d] [segno%u] [forkNumber-%d] forkNumber is invalid\",\r\n                bcmfilenode.rnode.node.spcNode,\r\n                bcmfilenode.rnode.node.dbNode,\r\n                bcmfilenode.rnode.node.relNode,\r\n                bcmfilenode.rnode.backend,\r\n                bcmfilenode.segno,\r\n                bcmfilenode.forknumber)));\r\n        return;\r\n    }\r\n\r\n    ereport(DEBUG3,\r\n        (errmsg(\"relfilenode [spcNode%u] [dbNode%u] [relNode%u]\"\r\n                \"[backendId%d] [segno%u] [forkNumber-%d]\",\r\n            bcmfilenode.rnode.node.spcNode,\r\n            bcmfilenode.rnode.node.dbNode,\r\n            bcmfilenode.rnode.node.relNode,\r\n            bcmfilenode.rnode.backend,\r\n            bcmfilenode.segno,\r\n            bcmfilenode.forknumber)));\r\n\r\n    if (clear) {\r\n        /* Clear this bcm file */\r\n        ereport(DEBUG2, (errmsg(\"clear bcm file %s \", bcmpath)));\r\n        BCMClearFile(bcmfilenode.rnode.node, GetColumnNum(bcmfilenode.forknumber));\r\n    } else {\r\n        /*\r\n         * According to bcm file bcmPath, we put the data(not synchronized)\r\n         * to the queue.\r\n         */\r\n        ereport(DEBUG2, (errmsg(\"according to bcm file %s, send data(not synchronized)\", bcmpath)));\r\n\r\n        CatchupShutdownIfNoDataSender();\r\n        BCMSendData(bcmfilenode.rnode.node, bcmpath, GetColumnNum(bcmfilenode.forknumber));\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"HandleBCMfile"
	},
	"VerifyTblspcWhenBcmExtend":{
		"body":"static inline void VerifyTblspcWhenBcmExtend(Relation rel, int col, int nblocks)\r\n{\r\n    Assert(nblocks > 0);\r\n    STORAGE_SPACE_OPERATION(rel, (uint64)BLCKSZ * nblocks);\r\n\r\n    // Might have to re-open if a cache flush happened\r\n    if (col > 0) {\r\n        CStoreRelationOpenSmgr(rel, col);\r\n    } else {\r\n        RelationOpenSmgr(rel);\r\n    }\r\n}",
		"comment":"// check tablespace size limitation when extending BCM file.",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"VerifyTblspcWhenBcmExtend"
	},
	"bcm_read_multi_cu":{
		"body":"static void bcm_read_multi_cu(\r\n    CUFile* cFile, Relation rel, int col, BlockNumber heapBlock, int& contibits, BlockNumber maxHeapBlock)\r\n{\r\n    uint64 offset = ALIGNOF_CUSIZE * (uint64)heapBlock;\r\n    char* write_buf = NULL;\r\n    int realSize = 0;\r\n\r\n    if (u_sess->attr.attr_storage.HaModuleDebug) {\r\n        ereport(LOG,\r\n            (errmsg(\"HA-bcm_read_multi_cu: relation %u/%u/%u col %d try to sync \"\r\n                    \"cu blockno %u, contibits %d, maxHeapBlock %u\",\r\n                rel->rd_node.spcNode,\r\n                rel->rd_node.dbNode,\r\n                rel->rd_node.relNode,\r\n                col,\r\n                heapBlock,\r\n                contibits,\r\n                maxHeapBlock)));\r\n    }\r\n\r\n    /* The heapBlock of data file must be not exist */\r\n    if (heapBlock > maxHeapBlock) {\r\n        contibits = 0;\r\n        return;\r\n    }\r\n\r\n    /* we should send the NOTSYNCED data from heapBlock to maxHeapBlock */\r\n    contibits = (int)Min((uint32)contibits, maxHeapBlock - heapBlock + 1);\r\n\r\n    while (contibits > 0) {\r\n        CatchupShutdownIfNoDataSender();\r\n        write_buf = cFile->Read(offset, ALIGNOF_CUSIZE * contibits, &realSize);\r\n        if (write_buf == NULL) {\r\n            Assert(realSize == 0);\r\n            contibits = 0;\r\n            return;\r\n        }\r\n\r\n        if (u_sess->attr.attr_storage.HaModuleDebug)\r\n            check_cu_block(write_buf, realSize);\r\n\r\n        PushCUToDataQueue(rel, col, write_buf, offset, realSize, false);\r\n        ereport(DEBUG3, (errmsg(\"cuBlock %u col %d read and send data's realsize is %d.\", heapBlock, col, realSize)));\r\n        offset += realSize;\r\n        contibits -= realSize / ALIGNOF_CUSIZE;\r\n    }\r\n    Assert(contibits == 0);\r\n}",
		"comment":"/*\r\n * Load multiple CU units to buffer, push data to sender queue.\r\n * Cause the CU manager may not return the exact size we expected,\r\n * so try again until we get the data we need.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"bcm_read_multi_cu"
	},
	"check_cu_block":{
		"body":"void check_cu_block(char* mem, int size)\r\n{\r\n    int cuUnit = size / ALIGNOF_CUSIZE;\r\n    char zeroBlock[ALIGNOF_CUSIZE] = {0};\r\n    char* mem_temp = mem;\r\n\r\n    for (int i = 0; i < cuUnit; i++) {\r\n        if (memcmp(mem_temp, zeroBlock, ALIGNOF_CUSIZE) == 0)\r\n            ereport(WARNING, (errmsg(\"HA-check_cu_block: check cu blockno %d failed, it is zeropage\", i)));\r\n\r\n        mem_temp += ALIGNOF_CUSIZE;\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"check_cu_block"
	},
	"createBCMFile":{
		"body":"void createBCMFile(Relation rel, int col)\r\n{\r\n    Page bcmHeader;\r\n\r\n    ADIO_RUN()\r\n    {\r\n        bcmHeader = (Page)adio_align_alloc(BLCKSZ);\r\n    }\r\n    ADIO_ELSE()\r\n    {\r\n        bcmHeader = (Page)palloc(BLCKSZ);\r\n    }\r\n    ADIO_END();\r\n\r\n    PageInit(bcmHeader, BLCKSZ, 0);\r\n    BCMHeader* hd = NULL;\r\n    ForkNumber forknum = BCM_FORKNUM;\r\n\r\n    hd = (BCMHeader*)PageGetContents(bcmHeader);\r\n\r\n    /* FUTURE CASE:: for COLUMN_STORE, only support ROW_STORE by now. */\r\n    hd->type = col > 0 ? COLUMN_STORE : ROW_STORE;\r\n    hd->node.dbNode = rel->rd_node.dbNode;\r\n    hd->node.relNode = rel->rd_node.relNode;\r\n    hd->node.spcNode = rel->rd_node.spcNode;\r\n    hd->node.bucketNode = rel->rd_node.bucketNode;\r\n    hd->blockSize = col > 0 ? ALIGNOF_CUSIZE : BLCKSZ; /* defaut size for ROW_STORE */\r\n\r\n    if (col > 0)\r\n        forknum = ColumnId2ColForkNum(col);\r\n\r\n    smgrcreate(rel->rd_smgr, forknum, false);\r\n\r\n    VerifyTblspcWhenBcmExtend(rel, col, 1);\r\n\r\n    PageSetChecksumInplace(bcmHeader, 0);\r\n\r\n    /* Now extend the file */\r\n    smgrextend(rel->rd_smgr, forknum, 0, (char*)bcmHeader, false);\r\n\r\n    ADIO_RUN()\r\n    {\r\n        adio_align_free(bcmHeader);\r\n    }\r\n    ADIO_ELSE()\r\n    {\r\n        pfree(bcmHeader);\r\n        bcmHeader = NULL;\r\n    }\r\n    ADIO_END();\r\n}",
		"comment":"/* Create a bcm file with an inited bcm file header */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"createBCMFile"
	},
	"searchBCMFiles":{
		"body":"static void searchBCMFiles(\r\n    const char* tableSpacePath, const char* relativepath, bool undertablespace, bool clear, int iterations)\r\n{\r\n    DIR* dir = NULL;\r\n    struct dirent* de;\r\n    char path[MAXPGPATH] = {'\\0'};\r\n    char rpath[MAXPGPATH] = {'\\0'};\r\n    int nRet = 0;\r\n\r\n    /* the layer number of searchBCMFiles iterations */\r\n    iterations++;\r\n\r\n    dir = AllocateDir(tableSpacePath);\r\n    while ((de = ReadDir(dir, tableSpacePath)) != NULL) {\r\n        if (strcmp(de->d_name, \".\") == 0 || strcmp(de->d_name, \"..\") == 0)\r\n            continue;\r\n\r\n        if (strncmp(de->d_name, PG_TEMP_FILE_PREFIX, strlen(PG_TEMP_FILE_PREFIX)) == 0)\r\n            continue;\r\n\r\n        if (strncmp(de->d_name, \"pg_log\", strlen(\"pg_log\")) == 0 ||\r\n            strncmp(de->d_name, \"pg_location\", strlen(\"pg_location\")) == 0)\r\n            continue;\r\n\r\n        if (strncmp(de->d_name, \"pg_xlog\", strlen(\"pg_xlog\")) == 0)\r\n            continue;\r\n\r\n        if (strncmp(de->d_name, \"full_upgrade_bak\", strlen(\"full_upgrade_bak\")) == 0)\r\n            continue;\r\n\r\n        nRet = snprintf_s(path, sizeof(path), MAXPGPATH - 1, \"%s/%s\", tableSpacePath, de->d_name);\r\n        securec_check_ss(nRet, \"\", \"\");\r\n\r\n        if (undertablespace) {\r\n            if (NULL == strstr(path, TABLESPACE_VERSION_DIRECTORY) ||\r\n                NULL == strstr(path, g_instance.attr.attr_common.PGXCNodeName))\r\n                continue;\r\n        } else {\r\n            if (strcmp(de->d_name, \"pg_tblspc\") == 0)\r\n                continue;\r\n        }\r\n\r\n        if (relativepath) {\r\n            nRet = snprintf_s(rpath, sizeof(rpath), MAXPGPATH - 1, \"%s/%s\", relativepath, de->d_name);\r\n            securec_check_ss(nRet, \"\", \"\");\r\n        } else {\r\n            nRet = snprintf_s(rpath, sizeof(rpath), MAXPGPATH - 1, \"%s\", de->d_name);\r\n            securec_check_ss(nRet, \"\", \"\");\r\n        }\r\n\r\n        /*\r\n         * serchBCMFiles will be recursive call 3 interations to get file path. In the third layer,\r\n         * the file path is table file, not Dir, so we need not to decide whether it is a folder,\r\n         * because the performance of stat interface is too bad. The file path such as\r\n         * ./base/13764 or /home/xxx/tablespace/PG_9.2_201611171_datanode1/13764\r\n         */\r\n        if (iterations < 3 && isDirExist(path)) {\r\n            ereport(DEBUG3, (errmsg(\"search path %s, relative path: %s, iterations: %d.\", path, rpath, iterations)));\r\n            searchBCMFiles(path, rpath, undertablespace, clear, iterations);\r\n        } else {\r\n            /*\r\n             * When we handle the bcm files, we will find if we end with \"_bcm\".\r\n             */\r\n            if (CheckFilePostfix(rpath, BCM)) {\r\n                HandleBCMfile(rpath, clear);\r\n            }\r\n        }\r\n    }\r\n    FreeDir(dir);\r\n}",
		"comment":"/* Recursion search BCM files with the tableSpacePath */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\bcm.cpp",
		"name":"searchBCMFiles"
	}
}