{
	"ApplyLogicalMappingFile":{
		"body":"static void ApplyLogicalMappingFile(HTAB* tuplecid_data, Oid relid, const char* fname)\r\n{\r\n    char path[MAXPGPATH];\r\n    int fd;\r\n    int readBytes;\r\n    LogicalRewriteMappingData map;\r\n    int rc = 0;\r\n    rc = sprintf_s(path, sizeof(path), \"pg_llog/mappings/%s\", fname);\r\n    securec_check_ss(rc, \"\", \"\");\r\n    fd = OpenTransientFile(path, O_RDONLY | PG_BINARY, 0);\r\n    if (fd < 0) {\r\n        ereport(ERROR, (errcode(ERRCODE_LOGICAL_DECODE_ERROR), errmsg(\"could not open file \\\"%s\\\": %m\", path)));\r\n    }\r\n\r\n    while (true) {\r\n        ReorderBufferTupleCidKey key;\r\n        ReorderBufferTupleCidEnt* ent = NULL;\r\n        ReorderBufferTupleCidEnt* new_ent = NULL;\r\n        bool found = false;\r\n\r\n        /* be careful about padding */\r\n        rc = memset_s(&key, sizeof(ReorderBufferTupleCidKey), 0, sizeof(ReorderBufferTupleCidKey));\r\n        securec_check(rc, \"\", \"\");\r\n\r\n        /* read all mappings till the end of the file */\r\n        readBytes = read(fd, &map, sizeof(LogicalRewriteMappingData));\r\n        if (readBytes < 0) {\r\n            ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not read file \\\"%s\\\": %m\", path)));\r\n        } else if (readBytes == 0) { /* EOF */\r\n            break;\r\n        } else if (readBytes != sizeof(LogicalRewriteMappingData)) {\r\n            ereport(ERROR,\r\n                (errcode_for_file_access(),\r\n                    errmsg(\"could not read file \\\"%s\\\", read %d instead of %d\",\r\n                        path,\r\n                        readBytes,\r\n                        (int32)sizeof(LogicalRewriteMappingData))));\r\n        }\r\n\r\n        key.relnode = map.old_node;\r\n        ItemPointerCopy(&map.old_tid, &key.tid);\r\n\r\n        ent = (ReorderBufferTupleCidEnt*)hash_search(tuplecid_data, (void*)&key, HASH_FIND, NULL);\r\n        /* no existing mapping, no need to update */\r\n        if (ent == NULL) {\r\n            continue;\r\n        }\r\n\r\n        key.relnode = map.new_node;\r\n        ItemPointerCopy(&map.new_tid, &key.tid);\r\n\r\n        new_ent = (ReorderBufferTupleCidEnt*)hash_search(tuplecid_data, (void*)&key, HASH_ENTER, &found);\r\n\r\n        if (found) {\r\n            /*\r\n             * Make sure the existing mapping makes sense. We sometime update\r\n             * old records that did not yet have a cmax (e.g. pg_class' own\r\n             * entry while rewriting it) during rewrites, so allow that.\r\n             */\r\n            Assert(ent->cmin == InvalidCommandId || ent->cmin == new_ent->cmin);\r\n            Assert(ent->cmax == InvalidCommandId || ent->cmax == new_ent->cmax);\r\n        } else {\r\n            /* update mapping */\r\n            new_ent->cmin = ent->cmin;\r\n            new_ent->cmax = ent->cmax;\r\n            new_ent->combocid = ent->combocid;\r\n        }\r\n    }\r\n}",
		"comment":"/*\r\n * Apply a single mapping file to tuplecid_data.\r\n *\r\n * The mapping file has to have been verified to be a) committed b) for our\r\n * transaction c) applied in LSN order.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ApplyLogicalMappingFile"
	},
	"AssertTXNLsnOrder":{
		"body":"static void AssertTXNLsnOrder(ReorderBuffer* rb)\r\n{\r\n#ifdef USE_ASSERT_CHECKING\r\n    dlist_iter iter;\r\n    XLogRecPtr prev_first_lsn = InvalidXLogRecPtr;\r\n    XLogRecPtr prev_base_snap_lsn = InvalidXLogRecPtr;\r\n\r\n    dlist_foreach(iter, &rb->toplevel_by_lsn)\r\n    {\r\n        ReorderBufferTXN* cur_txn = dlist_container(ReorderBufferTXN, node, iter.cur);\r\n        /* start LSN must be set */\r\n        Assert(!XLByteEQ(cur_txn->first_lsn, InvalidXLogRecPtr));\r\n\r\n        /* If there is an end LSN, it must be higher than start LSN */\r\n        if (!XLByteEQ(cur_txn->end_lsn, InvalidXLogRecPtr))\r\n            Assert(XLByteLE(cur_txn->first_lsn, cur_txn->end_lsn));\r\n\r\n        /* Current initial LSN must be strictly higher than previous */\r\n        if (!XLByteEQ(prev_first_lsn, InvalidXLogRecPtr))\r\n            Assert(XLByteLE(prev_first_lsn, cur_txn->first_lsn));\r\n\r\n        /* known-as-subtxn txns must not be listed */\r\n        Assert(!cur_txn->is_known_as_subxact);\r\n        prev_first_lsn = cur_txn->first_lsn;\r\n    }\r\n    dlist_foreach(iter, &rb->txns_by_base_snapshot_lsn)\r\n    {\r\n        ReorderBufferTXN* cur_txn = dlist_container(ReorderBufferTXN, base_snapshot_node, iter.cur);\r\n\r\n        /* base snapshot (and its LSN) must be set */\r\n        Assert(cur_txn->base_snapshot != NULL);\r\n        Assert(cur_txn->base_snapshot_lsn != InvalidXLogRecPtr);\r\n\r\n        /* current LSN must be strictly higher than previous */\r\n        if (prev_base_snap_lsn != InvalidXLogRecPtr)\r\n            Assert(prev_base_snap_lsn < cur_txn->base_snapshot_lsn);\r\n\r\n        /* known-as-subtxn txns must not be listed */\r\n        Assert(!cur_txn->is_known_as_subxact);\r\n\r\n        prev_base_snap_lsn = cur_txn->base_snapshot_lsn;\r\n    }\r\n\r\n#endif\r\n}",
		"comment":"/*\r\n * AssertTXNLsnOrder\r\n *     Verify LSN ordering of transaction lists in the reorderbuffer\r\n *\r\n * Other LSN-related invariants are checked too.\r\n *\r\n * No-op if assertions are not in use.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"AssertTXNLsnOrder"
	},
	"ReorderBufferAbort":{
		"body":"void ReorderBufferAbort(ReorderBuffer* rb, TransactionId xid, XLogRecPtr lsn)\r\n{\r\n    ReorderBufferTXN* txn = NULL;\r\n\r\n    txn = ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr, false);\r\n    /* unknown, nothing to remove */\r\n    if (txn == NULL)\r\n        return;\r\n\r\n    /* cosmetic... */\r\n    txn->final_lsn = lsn;\r\n\r\n    /* remove potential on-disk data, and deallocate */\r\n    ReorderBufferCleanupTXN(rb, txn);\r\n}",
		"comment":"/*\r\n * Abort a transaction that possibly has previous changes. Needs to be first\r\n * called for subtransactions and then for the toplevel xid.\r\n *\r\n * NB: Transactions handled here have to have actively aborted (i.e. have\r\n * produced an abort record). Implicitly aborted transactions are handled via\r\n * ReorderBufferAbortOld(); transactions we're just not interesteded in, but\r\n * which have committed are handled in ReorderBufferForget().\r\n *\r\n * This function purges this transaction and its contents from memory and\r\n * disk.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferAbort"
	},
	"ReorderBufferAbortOld":{
		"body":"void ReorderBufferAbortOld(ReorderBuffer* rb, TransactionId oldestRunningXid, XLogRecPtr lsn)\r\n{\r\n    dlist_mutable_iter it;\r\n\r\n    /*\r\n     * Iterate through all (potential) toplevel TXNs and abort all that are\r\n     * older than what possibly can be running. Once we've found the first\r\n     * that is alive we stop, there might be some that acquired an xid earlier\r\n     * but started writing later, but it's unlikely and they will cleaned up\r\n     * in a later call to ReorderBufferAbortOld().\r\n     */\r\n    dlist_foreach_modify(it, &rb->toplevel_by_lsn)\r\n    {\r\n        ReorderBufferTXN* txn = NULL;\r\n\r\n        txn = dlist_container(ReorderBufferTXN, node, it.cur);\r\n        if (TransactionIdPrecedes(txn->xid, oldestRunningXid)) {\r\n            if (!RecoveryInProgress())\r\n                ereport(DEBUG2, (errmsg(\"aborting old transaction %lu\", txn->xid)));\r\n\r\n            /* remove potential on-disk data, and deallocate this tx */\r\n            ReorderBufferCleanupTXN(rb, txn, lsn);\r\n        } else\r\n            return;\r\n    }\r\n}",
		"comment":"/*\r\n * Abort all transactions that aren't actually running anymore because the\r\n * server restarted.\r\n *\r\n * NB: These really have to be transactions that have aborted due to a server\r\n * crash/immediate restart, as we don't deal with invalidations here.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferAbortOld"
	},
	"ReorderBufferAddInvalidations":{
		"body":"void ReorderBufferAddInvalidations(\r\n    ReorderBuffer* rb, TransactionId xid, XLogRecPtr lsn, Size nmsgs, SharedInvalidationMessage* msgs)\r\n{\r\n    ReorderBufferTXN* txn = NULL;\r\n\r\n    txn = ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true);\r\n    int rc = 0;\r\n    if (txn->ninvalidations != 0)\r\n        ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"only ever add one set of invalidations\")));\r\n\r\n    Assert(nmsgs > 0);\r\n\r\n    txn->ninvalidations = nmsgs;\r\n    txn->invalidations =\r\n        (SharedInvalidationMessage*)MemoryContextAlloc(rb->context, sizeof(SharedInvalidationMessage) * nmsgs);\r\n    if (nmsgs) {\r\n        rc = memcpy_s(txn->invalidations,\r\n            sizeof(SharedInvalidationMessage) * nmsgs,\r\n            msgs,\r\n            sizeof(SharedInvalidationMessage) * nmsgs);\r\n        securec_check(rc, \"\", \"\");\r\n    }\r\n}",
		"comment":"/*\r\n * Setup the invalidation of the toplevel transaction.\r\n *\r\n * This needs to be done before ReorderBufferCommit is called!\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferAddInvalidations"
	},
	"ReorderBufferAddNewCommandId":{
		"body":"void ReorderBufferAddNewCommandId(ReorderBuffer* rb, TransactionId xid, XLogRecPtr lsn, CommandId cid)\r\n{\r\n    ReorderBufferChange* change = ReorderBufferGetChange(rb);\r\n\r\n    change->data.command_id = cid;\r\n    change->action = REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID;\r\n\r\n    ReorderBufferQueueChange(rb, xid, lsn, change);\r\n}",
		"comment":"/*\r\n * Access the catalog with this CommandId at this point in the changestream.\r\n *\r\n * May only be called for command ids > 1\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferAddNewCommandId"
	},
	"ReorderBufferAddNewTupleCids":{
		"body":"void ReorderBufferAddNewTupleCids(ReorderBuffer* rb, TransactionId xid, XLogRecPtr lsn, const RelFileNode& node,\r\n    const ItemPointerData& tid, CommandId cmin, CommandId cmax, CommandId combocid)\r\n{\r\n    ReorderBufferChange* change = ReorderBufferGetChange(rb);\r\n    ReorderBufferTXN* txn = NULL;\r\n\r\n    txn = ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true);\r\n\r\n    change->data.tuplecid.node = node;\r\n    change->data.tuplecid.tid = tid;\r\n    change->data.tuplecid.cmin = cmin;\r\n    change->data.tuplecid.cmax = cmax;\r\n    change->data.tuplecid.combocid = combocid;\r\n    change->lsn = lsn;\r\n    change->action = REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID;\r\n\r\n    dlist_push_tail(&txn->tuplecids, &change->node);\r\n    txn->ntuplecids++;\r\n}",
		"comment":"/*\r\n * Add new (relfilenode, tid) -> (cmin, cmax) mappings.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferAddNewTupleCids"
	},
	"ReorderBufferAddSnapshot":{
		"body":"void ReorderBufferAddSnapshot(ReorderBuffer* rb, TransactionId xid, XLogRecPtr lsn, Snapshot snap)\r\n{\r\n    ReorderBufferChange* change = ReorderBufferGetChange(rb);\r\n\r\n    change->data.snapshot = snap;\r\n    change->action = REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT;\r\n\r\n    ReorderBufferQueueChange(rb, xid, lsn, change);\r\n}",
		"comment":"/*\r\n * Add a new snapshot to this transaction that may only used after lsn 'lsn'\r\n * because the previous snapshot doesn't describe the catalog correctly for\r\n * following rows.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferAddSnapshot"
	},
	"ReorderBufferAllocate":{
		"body":"ReorderBuffer* ReorderBufferAllocate(void)\r\n{\r\n    ReorderBuffer* buffer = NULL;\r\n    HASHCTL hash_ctl;\r\n    MemoryContext new_ctx = NULL;\r\n    int rc = 0;\r\n    /* allocate memory in own context, to have better accountability */\r\n    new_ctx = AllocSetContextCreate(CurrentMemoryContext,\r\n        \"ReorderBuffer\",\r\n        ALLOCSET_DEFAULT_MINSIZE,\r\n        ALLOCSET_DEFAULT_INITSIZE,\r\n        ALLOCSET_DEFAULT_MAXSIZE);\r\n\r\n    buffer = (ReorderBuffer*)MemoryContextAlloc(new_ctx, sizeof(ReorderBuffer));\r\n\r\n    rc = memset_s(&hash_ctl, sizeof(hash_ctl), 0, sizeof(hash_ctl));\r\n    securec_check(rc, \"\", \"\");\r\n\r\n    buffer->context = new_ctx;\r\n\r\n    hash_ctl.keysize = sizeof(TransactionId);\r\n    hash_ctl.entrysize = sizeof(ReorderBufferTXNByIdEnt);\r\n    hash_ctl.hash = tag_hash;\r\n    hash_ctl.hcxt = buffer->context;\r\n\r\n    buffer->by_txn = hash_create(\"ReorderBufferByXid\", 1000, &hash_ctl, HASH_ELEM | HASH_FUNCTION | HASH_CONTEXT);\r\n\r\n    buffer->by_txn_last_xid = InvalidTransactionId;\r\n    buffer->by_txn_last_txn = NULL;\r\n\r\n    buffer->nr_cached_transactions = 0;\r\n    buffer->nr_cached_changes = 0;\r\n    buffer->nr_cached_tuplebufs = 0;\r\n\r\n    buffer->outbuf = NULL;\r\n    buffer->outbufsize = 0;\r\n\r\n    buffer->current_restart_decoding_lsn = InvalidXLogRecPtr;\r\n\r\n    dlist_init(&buffer->toplevel_by_lsn);\r\n    dlist_init(&buffer->txns_by_base_snapshot_lsn);\r\n    dlist_init(&buffer->cached_transactions);\r\n    dlist_init(&buffer->cached_changes);\r\n    slist_init(&buffer->cached_tuplebufs);\r\n\r\n    return buffer;\r\n}",
		"comment":"/*\r\n * Allocate a new ReorderBuffer\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferAllocate"
	},
	"ReorderBufferAssignChild":{
		"body":"void ReorderBufferAssignChild(ReorderBuffer* rb, TransactionId xid, TransactionId subxid, XLogRecPtr lsn)\r\n{\r\n    ReorderBufferTXN* txn = NULL;\r\n    ReorderBufferTXN* subtxn = NULL;\r\n    bool new_top = false;\r\n    bool new_sub = false;\r\n\r\n    txn = ReorderBufferTXNByXid(rb, xid, true, &new_top, lsn, true);\r\n    subtxn = ReorderBufferTXNByXid(rb, subxid, true, &new_sub, lsn, false);\r\n\r\n    if (new_top && !new_sub) {\r\n        ereport(WARNING,\r\n            (errmsg(\"subtransaction logged without previous top-level txn record\"),\r\n                errdetail(\"This tracsaction has been decoded.\")));\r\n        return;\r\n    }\r\n\r\n    if (!new_sub) {\r\n        if (subtxn->is_known_as_subxact) {\r\n            /* already associated, nothing to do */\r\n            return;\r\n        } else {\r\n            /*\r\n             * We already saw this transaction, but initially added it to the list\r\n             * of top-level txns.  Now that we know it's not top-level, remove\r\n             * it from there.\r\n             */\r\n            dlist_delete(&subtxn->node);\r\n        }\r\n    }\r\n    subtxn->is_known_as_subxact = true;\r\n    subtxn->toplevel_xid = xid;\r\n    Assert(subtxn->nsubtxns == 0);\r\n    /* add to subtransaction list */\r\n    dlist_push_tail(&txn->subtxns, &subtxn->node);\r\n    txn->nsubtxns++;\r\n\r\n    /* Possibly transfer the subtxn's snapshot to its top-level txn. */\r\n    ReorderBufferTransferSnapToParent(txn, subtxn);\r\n\r\n    /* Verify LSN-ordering invariant */\r\n    AssertTXNLsnOrder(rb);\r\n}",
		"comment":"/* Make note that we know that subxid is a subtransaction of xid, seen as of the given lsn. */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferAssignChild"
	},
	"ReorderBufferBuildTupleCidHash":{
		"body":"static void ReorderBufferBuildTupleCidHash(ReorderBuffer* rb, ReorderBufferTXN* txn)\r\n{\r\n    dlist_iter iter;\r\n    HASHCTL hash_ctl;\r\n    int rc = 0;\r\n\r\n    if (!txn->has_catalog_changes || dlist_is_empty(&txn->tuplecids))\r\n        return;\r\n\r\n    rc = memset_s(&hash_ctl, sizeof(hash_ctl), 0, sizeof(hash_ctl));\r\n    securec_check(rc, \"\", \"\");\r\n\r\n    hash_ctl.keysize = sizeof(ReorderBufferTupleCidKey);\r\n    hash_ctl.entrysize = sizeof(ReorderBufferTupleCidEnt);\r\n    hash_ctl.hash = tag_hash;\r\n    hash_ctl.hcxt = rb->context;\r\n\r\n    /*\r\n     * create the hash with the exact number of to-be-stored tuplecids from\r\n     * the start\r\n     */\r\n    txn->tuplecid_hash =\r\n        hash_create(\"ReorderBufferTupleCid\", txn->ntuplecids, &hash_ctl, HASH_ELEM | HASH_FUNCTION | HASH_CONTEXT);\r\n\r\n    dlist_foreach(iter, &txn->tuplecids)\r\n    {\r\n        ReorderBufferTupleCidKey key;\r\n        ReorderBufferTupleCidEnt* ent = NULL;\r\n        bool found = false;\r\n        ReorderBufferChange* change = NULL;\r\n\r\n        change = dlist_container(ReorderBufferChange, node, iter.cur);\r\n\r\n        Assert(change->action == REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID);\r\n\r\n        /* be careful about padding */\r\n        rc = memset_s(&key, sizeof(ReorderBufferTupleCidKey), 0, sizeof(ReorderBufferTupleCidKey));\r\n        securec_check(rc, \"\", \"\");\r\n\r\n        key.relnode = change->data.tuplecid.node;\r\n\r\n        ItemPointerCopy(&change->data.tuplecid.tid, &key.tid);\r\n\r\n        ent = (ReorderBufferTupleCidEnt*)hash_search(\r\n            txn->tuplecid_hash, (void*)&key, HASHACTION(HASH_ENTER | HASH_FIND), &found);\r\n        if (!found) {\r\n            ent->cmin = change->data.tuplecid.cmin;\r\n            ent->cmax = change->data.tuplecid.cmax;\r\n            ent->combocid = change->data.tuplecid.combocid;\r\n        } else {\r\n            /*\r\n             * if the tuple got valid in this transaction and now got deleted\r\n             * we already have a valid cmin stored. The cmax will be\r\n             * InvalidCommandId though.\r\n             */\r\n            ent->cmax = change->data.tuplecid.cmax;\r\n        }\r\n    }\r\n}",
		"comment":"/*\r\n * Build a hash with a (relfilenode, ctid) -> (cmin, cmax) mapping for use by\r\n * tqual.c's HeapTupleSatisfiesHistoricMVCC.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferBuildTupleCidHash"
	},
	"ReorderBufferCheckSerializeTXN":{
		"body":"static void ReorderBufferCheckSerializeTXN(ReorderBuffer* rb, ReorderBufferTXN* txn)\r\n{\r\n    /*\r\n     * description: improve accounting so we cheaply can take subtransactions into\r\n     * account here.\r\n     */\r\n    if (txn->nentries_mem >= (unsigned)g_instance.attr.attr_common.max_changes_in_memory) {\r\n        ReorderBufferSerializeTXN(rb, txn);\r\n        Assert(txn->nentries_mem == 0);\r\n    }\r\n}",
		"comment":"/*\r\n * Check whether the transaction tx should spill its data to disk.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferCheckSerializeTXN"
	},
	"ReorderBufferCleanupTXN":{
		"body":"static void ReorderBufferCleanupTXN(ReorderBuffer* rb, ReorderBufferTXN* txn, XLogRecPtr lsn = InvalidXLogRecPtr)\r\n{\r\n    bool found = false;\r\n    dlist_mutable_iter iter;\r\n\r\n    /* cleanup subtransactions & their changes */\r\n    dlist_foreach_modify(iter, &txn->subtxns)\r\n    {\r\n        ReorderBufferTXN* subtxn = NULL;\r\n\r\n        subtxn = dlist_container(ReorderBufferTXN, node, iter.cur);\r\n\r\n        /*\r\n         * Subtransactions are always associated to the toplevel TXN, even if\r\n         * they originally were happening inside another subtxn, so we won't\r\n         * ever recurse more than one level deep here.\r\n         */\r\n        Assert(subtxn->is_known_as_subxact);\r\n        Assert(subtxn->nsubtxns == 0);\r\n\r\n        ReorderBufferCleanupTXN(rb, subtxn, lsn);\r\n    }\r\n\r\n    /* cleanup changes in the toplevel txn */\r\n    dlist_foreach_modify(iter, &txn->changes)\r\n    {\r\n        ReorderBufferChange* change = NULL;\r\n\r\n        change = dlist_container(ReorderBufferChange, node, iter.cur);\r\n\r\n        ReorderBufferReturnChange(rb, change);\r\n    }\r\n\r\n    /*\r\n     * Cleanup the tuplecids we stored for decoding catalog snapshot\r\n     * access. They are always stored in the toplevel transaction.\r\n     */\r\n    dlist_foreach_modify(iter, &txn->tuplecids)\r\n    {\r\n        ReorderBufferChange* change = NULL;\r\n\r\n        change = dlist_container(ReorderBufferChange, node, iter.cur);\r\n        Assert(change->action == REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID);\r\n        ReorderBufferReturnChange(rb, change);\r\n    }\r\n    /*\r\n     * Cleanup the base snapshot, if set.\r\n     */\r\n    if (txn->base_snapshot != NULL) {\r\n        SnapBuildSnapDecRefcount(txn->base_snapshot);\r\n        dlist_delete(&txn->base_snapshot_node);\r\n    }\r\n\r\n    /*\r\n     * Remove TXN from its containing list.\r\n     *\r\n     * Note: if txn->is_known_as_subxact, we are deleting the TXN from its\r\n     * parent's list of known subxacts; this leaves the parent's nsubxacts\r\n     * count too high, but we don't care.  Otherwise, we are deleting the TXN\r\n     * from the LSN-ordered list of toplevel TXNs.\r\n     */\r\n    dlist_delete(&txn->node);\r\n\r\n    /* now remove reference from buffer */\r\n    (void)hash_search(rb->by_txn, (void*)&txn->xid, HASH_REMOVE, &found);\r\n    Assert(found);\r\n\r\n    /* remove entries spilled to disk */\r\n    if (txn->serialized)\r\n        ReorderBufferRestoreCleanup(rb, txn, lsn);\r\n\r\n    /* deallocate */\r\n    ReorderBufferReturnTXN(rb, txn);\r\n}",
		"comment":"/*\r\n * Cleanup the contents of a transaction, usually after the transaction\r\n * committed or aborted.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferCleanupTXN"
	},
	"ReorderBufferCommit":{
		"body":"void ReorderBufferCommit(ReorderBuffer* rb, TransactionId xid, XLogRecPtr commit_lsn, XLogRecPtr end_lsn,\r\n    RepOriginId origin_id, CommitSeqNo csn, TimestampTz commit_time)\r\n{\r\n    ReorderBufferTXN* txn = NULL;\r\n    ReorderBufferIterTXNState* volatile iterstate = NULL;\r\n    ReorderBufferChange* change = NULL;\r\n\r\n    volatile CommandId command_id = FirstCommandId;\r\n    volatile Snapshot snapshot_now = NULL;\r\n    volatile bool txn_started = false;\r\n    volatile bool subtxn_started = false;\r\n\r\n    txn = ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr, false);\r\n    /* unknown transaction, nothing to replay */\r\n    if (txn == NULL)\r\n        return;\r\n\r\n    txn->final_lsn = commit_lsn;\r\n    txn->end_lsn = end_lsn;\r\n    txn->origin_id = origin_id;\r\n    txn->csn = csn;\r\n    txn->commit_time = commit_time;\r\n\r\n    /*\r\n     * If this transaction has no snapshot, it didn't make any changes to the\r\n     * database, so there's nothing to decode.  Note that\r\n     * ReorderBufferCommitChild will have transferred any snapshots from\r\n     * subtransactions if there were any.\r\n     */\r\n    if (txn->base_snapshot == NULL) {\r\n        Assert(txn->ninvalidations == 0);\r\n        ReorderBufferCleanupTXN(rb, txn);\r\n        return;\r\n    }\r\n\r\n    snapshot_now = txn->base_snapshot;\r\n\r\n    /* build data to be able to lookup the CommandIds of catalog tuples */\r\n    ReorderBufferBuildTupleCidHash(rb, txn);\r\n\r\n    /* setup the initial snapshot */\r\n    SetupHistoricSnapshot(snapshot_now, txn->tuplecid_hash);\r\n\r\n    PG_TRY();\r\n    {\r\n        txn_started = false;\r\n\r\n        /*\r\n         * Decoding needs access to syscaches et al., which in turn use\r\n         * heavyweight locks and such. Thus we need to have enough state around\r\n         * to keep track of those. The easiest way is to simply use a\r\n         * transaction internally. That also allows us to easily enforce that\r\n         * nothing writes to the database by checking for xid assignments.\r\n         *\r\n         * When we're called via the SQL SRF there's already a transaction\r\n         * started, so start an explicit subtransaction there.\r\n         */\r\n        if (IsTransactionOrTransactionBlock()) {\r\n            BeginInternalSubTransaction(\"replay\");\r\n            subtxn_started = true;\r\n        } else {\r\n            StartTransactionCommand();\r\n            txn_started = true;\r\n        }\r\n\r\n        rb->begin(rb, txn);\r\n\r\n        iterstate = ReorderBufferIterTXNInit(rb, txn);\r\n        while ((change = ReorderBufferIterTXNNext(rb, iterstate))) {\r\n            Relation relation = NULL;\r\n            Oid reloid;\r\n            Oid partitionReltoastrelid = InvalidOid;\r\n\r\n            switch (change->action) {\r\n                case REORDER_BUFFER_CHANGE_INSERT:\r\n                case REORDER_BUFFER_CHANGE_UPDATE:\r\n                case REORDER_BUFFER_CHANGE_DELETE:\r\n                    Assert(snapshot_now);\r\n\r\n                    reloid = RelidByRelfilenode(change->data.tp.relnode.spcNode, change->data.tp.relnode.relNode);\r\n                    if (reloid == InvalidOid) {\r\n                        reloid = PartitionRelidByRelfilenode(\r\n                            change->data.tp.relnode.spcNode, change->data.tp.relnode.relNode, partitionReltoastrelid);\r\n                    }\r\n                    /*\r\n                     * Catalog tuple without data, emitted while catalog was\r\n                     * in the process of being rewritten.\r\n                     */\r\n                    if (reloid == InvalidOid && change->data.tp.newtuple == NULL && change->data.tp.oldtuple == NULL)\r\n                        continue;\r\n                    else if (reloid == InvalidOid) {\r\n                        /*\r\n                         * description:\r\n                         * When we try to decode a table who is already dropped.\r\n                         * Maybe we could not find it relnode.In this time, we will undecode this log.\r\n                         * It will be solve when we use MVCC.\r\n                         */\r\n                        ereport(DEBUG1,\r\n                            (errmsg(\r\n                                \"could not lookup relation %s\", relpathperm(change->data.tp.relnode, MAIN_FORKNUM))));\r\n                        continue;\r\n                    }\r\n\r\n                    relation = RelationIdGetRelation(reloid);\r\n                    if (relation == NULL) {\r\n                        ereport(DEBUG1,\r\n                            (errmsg(\"could open relation descriptor %s\",\r\n                                relpathperm(change->data.tp.relnode, MAIN_FORKNUM))));\r\n                        continue;\r\n                    }\r\n\r\n                    if (CSTORE_NAMESPACE == get_rel_namespace(RelationGetRelid(relation))) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (RelationIsLogicallyLogged(relation)) {\r\n                        /*\r\n                         * For now ignore sequence changes entirely. Most of\r\n                         * the time they don't log changes using records we\r\n                         * understand, so it doesn't make sense to handle the\r\n                         * few cases we do.\r\n                         */\r\n                        if (relation->rd_rel->relkind == RELKIND_SEQUENCE) {\r\n                        } else if (!IsToastRelation(relation)) { /* user-triggered change */\r\n                            ReorderBufferToastReplace(rb, txn, relation, change, partitionReltoastrelid);\r\n                            rb->apply_change(rb, txn, relation, change);\r\n                            /*\r\n                             * Only clear reassembled toast chunks if we're\r\n                             * sure they're not required anymore. The creator\r\n                             * of the tuple tells us.\r\n                             */\r\n                            if (change->data.tp.clear_toast_afterwards)\r\n                                ReorderBufferToastReset(rb, txn);\r\n                        } else if (change->action == REORDER_BUFFER_CHANGE_INSERT) {\r\n                            /* we're not interested in toast deletions\r\n                             *\r\n                             * Need to reassemble the full toasted Datum in\r\n                             * memory, to ensure the chunks don't get reused\r\n                             * till we're done remove it from the list of this\r\n                             * transaction's changes. Otherwise it will get\r\n                             * freed/reused while restoring spooled data from\r\n                             * disk.\r\n                             */\r\n                            dlist_delete(&change->node);\r\n                            ReorderBufferToastAppendChunk(rb, txn, relation, change);\r\n                        }\r\n                    }\r\n                    RelationClose(relation);\r\n                    break;\r\n                case REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT:\r\n                    /* get rid of the old */\r\n                    TeardownHistoricSnapshot(false);\r\n\r\n                    if (snapshot_now->copied) {\r\n                        ReorderBufferFreeSnap(rb, snapshot_now);\r\n                        snapshot_now = NULL;\r\n                        snapshot_now = ReorderBufferCopySnap(rb, change->data.snapshot, txn, command_id);\r\n                    } else if (change->data.snapshot->copied) {\r\n                        /*\r\n                         * Restored from disk, need to be careful not to double\r\n                         * free. We could introduce refcounting for that, but for\r\n                         * now this seems infrequent enough not to care.\r\n                         */\r\n                        snapshot_now = ReorderBufferCopySnap(rb, change->data.snapshot, txn, command_id);\r\n                    } else {\r\n                        snapshot_now = change->data.snapshot;\r\n                    }\r\n\r\n                    /* and continue with the new one */\r\n                    SetupHistoricSnapshot(snapshot_now, txn->tuplecid_hash);\r\n                    break;\r\n\r\n                case REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID:\r\n                    Assert(change->data.command_id != InvalidCommandId);\r\n\r\n                    if (command_id < change->data.command_id) {\r\n                        command_id = change->data.command_id;\r\n\r\n                        if (!snapshot_now->copied) {\r\n                            /* we don't use the global one anymore */\r\n                            snapshot_now = ReorderBufferCopySnap(rb, snapshot_now, txn, command_id);\r\n                        }\r\n\r\n                        snapshot_now->curcid = command_id;\r\n\r\n                        TeardownHistoricSnapshot(false);\r\n                        SetupHistoricSnapshot(snapshot_now, txn->tuplecid_hash);\r\n\r\n                        /*\r\n                         * Every time the CommandId is incremented, we could\r\n                         * see new catalog contents, so execute all\r\n                         * invalidations.\r\n                         */\r\n                        ReorderBufferExecuteInvalidations(rb, txn);\r\n                    }\r\n\r\n                    break;\r\n\r\n                case REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID:\r\n                    ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"tuplecid value in changequeue\")));\r\n                    break;\r\n            }\r\n        }\r\n\r\n        ReorderBufferIterTXNFinish(rb, iterstate);\r\n        iterstate = NULL;\r\n\r\n        /* call commit callback */\r\n        rb->commit(rb, txn, commit_lsn);\r\n\r\n        /* this is just a sanity check against bad output plugin behaviour */\r\n        if (GetCurrentTransactionIdIfAny() != InvalidTransactionId)\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\r\n                    errmsg(\"output plugin used xid %lu\", GetCurrentTransactionId())));\r\n\r\n        /* make sure there's no cache pollution */\r\n        ReorderBufferExecuteInvalidations(rb, txn);\r\n\r\n        /* cleanup */\r\n        TeardownHistoricSnapshot(false);\r\n\r\n        /*\r\n         * Abort subtransaction or the transaction as a whole has the right\r\n         * semantics. We want all locks acquired in here to be released, not\r\n         * reassigned to the parent and we do not want any database access\r\n         * have persistent effects.\r\n         */\r\n        if (subtxn_started)\r\n            RollbackAndReleaseCurrentSubTransaction();\r\n        else if (txn_started)\r\n            AbortCurrentTransaction();\r\n\r\n        if (snapshot_now->copied)\r\n            ReorderBufferFreeSnap(rb, snapshot_now);\r\n\r\n        /* remove potential on-disk data, and deallocate */\r\n        ReorderBufferCleanupTXN(rb, txn);\r\n    }\r\n    PG_CATCH();\r\n    {\r\n        /* description: Encapsulate cleanup from the PG_TRY and PG_CATCH blocks */\r\n        if (iterstate != NULL)\r\n            ReorderBufferIterTXNFinish(rb, iterstate);\r\n\r\n        TeardownHistoricSnapshot(true);\r\n\r\n        if (snapshot_now != NULL && snapshot_now->copied)\r\n            ReorderBufferFreeSnap(rb, snapshot_now);\r\n\r\n        if (subtxn_started)\r\n            RollbackAndReleaseCurrentSubTransaction();\r\n        else if (txn_started)\r\n            AbortCurrentTransaction();\r\n\r\n        /*\r\n         * Invalidations in an aborted transactions aren't allowed to do\r\n         * catalog access, so we don't need to still have the snapshot setup.\r\n         */\r\n        ReorderBufferExecuteInvalidations(rb, txn);\r\n\r\n        /* remove potential on-disk data, and deallocate */\r\n        ReorderBufferCleanupTXN(rb, txn);\r\n\r\n        PG_RE_THROW();\r\n    }\r\n    PG_END_TRY();\r\n}",
		"comment":"/*\r\n * Perform the replay of a transaction and its non-aborted subtransactions.\r\n *\r\n * Subtransactions previously have to be processed by\r\n * ReorderBufferCommitChild(), even if previously assigned to the toplevel\r\n * transaction with ReorderBufferAssignChild.\r\n *\r\n * We currently can only decode a transaction's contents when its commit\r\n * record is read because that's the only place where we know about cache\r\n * invalidations. Thus, once a toplevel commit is read, we iterate over the top\r\n * and subtransactions (using a k-way merge) and replay the changes in lsn\r\n * order.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferCommit"
	},
	"ReorderBufferCommitChild":{
		"body":"void ReorderBufferCommitChild(\r\n    ReorderBuffer* rb, TransactionId xid, TransactionId subxid, XLogRecPtr commit_lsn, XLogRecPtr end_lsn)\r\n{\r\n    ReorderBufferTXN* subtxn = NULL;\r\n\r\n    subtxn = ReorderBufferTXNByXid(rb, subxid, false, NULL, InvalidXLogRecPtr, false);\r\n    /*\r\n     * No need to do anything if that subtxn didn't contain any changes\r\n     */\r\n    if (subtxn == NULL)\r\n        return;\r\n\r\n    subtxn->final_lsn = commit_lsn;\r\n    subtxn->end_lsn = end_lsn;\r\n    /*\r\n     * Assign this subxact as a child of the toplevel xact (no-op if already\r\n     * done.)\r\n     */\r\n    ReorderBufferAssignChild(rb, xid, subxid, InvalidXLogRecPtr);\r\n}",
		"comment":"/*\r\n * Associate a subtransaction with its toplevel transaction at commit\r\n * time. There may be no further changes added after this.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferCommitChild"
	},
	"ReorderBufferCopySnap":{
		"body":"static Snapshot ReorderBufferCopySnap(ReorderBuffer* rb, Snapshot orig_snap, ReorderBufferTXN* txn, CommandId cid)\r\n{\r\n    Snapshot snap;\r\n    dlist_iter iter;\r\n    int i = 0;\r\n    Size size;\r\n    int rc = 0;\r\n    size = sizeof(SnapshotData) + sizeof(TransactionId) * orig_snap->xcnt + sizeof(TransactionId) * (txn->nsubtxns + 1);\r\n\r\n    snap = (SnapshotData*)MemoryContextAllocZero(rb->context, size);\r\n    rc = memcpy_s(snap, sizeof(SnapshotData), orig_snap, sizeof(SnapshotData));\r\n    securec_check(rc, \"\", \"\");\r\n    snap->copied = true;\r\n    snap->active_count = 1;\r\n    snap->regd_count = 0;\r\n    snap->xip = (TransactionId*)(snap + 1);\r\n\r\n    if (snap->xcnt) {\r\n        rc =\r\n            memcpy_s(snap->xip, sizeof(TransactionId) * snap->xcnt, orig_snap->xip, sizeof(TransactionId) * snap->xcnt);\r\n        securec_check(rc, \"\", \"\");\r\n    }\r\n    /*\r\n     * snap->subxip contains all txids that belong to our transaction which we\r\n     * need to check via cmin/cmax. Thats why we store the toplevel\r\n     * transaction in there as well.\r\n     */\r\n    snap->subxip = snap->xip + snap->xcnt;\r\n    snap->subxip[i++] = txn->xid;\r\n\r\n    /*\r\n     * nsubxcnt isn't decreased when subtransactions abort, so count\r\n     * manually. Since it's an upper boundary it is safe to use it for the\r\n     * allocation above.\r\n     */\r\n    snap->subxcnt = 1;\r\n\r\n    dlist_foreach(iter, &txn->subtxns)\r\n    {\r\n        ReorderBufferTXN* sub_txn = NULL;\r\n\r\n        sub_txn = dlist_container(ReorderBufferTXN, node, iter.cur);\r\n        snap->subxip[i++] = sub_txn->xid;\r\n        snap->subxcnt++;\r\n    }\r\n\r\n    /* sort so we can bsearch() later */\r\n    qsort(snap->subxip, snap->subxcnt, sizeof(TransactionId), xidComparator);\r\n\r\n    /* store the specified current CommandId */\r\n    snap->curcid = cid;\r\n\r\n    return snap;\r\n}",
		"comment":"/*\r\n * Copy a provided snapshot so we can modify it privately. This is needed so\r\n * that catalog modifying transactions can look into intermediate catalog\r\n * states.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferCopySnap"
	},
	"ReorderBufferExecuteInvalidations":{
		"body":"static void ReorderBufferExecuteInvalidations(ReorderBuffer* rb, ReorderBufferTXN* txn)\r\n{\r\n    uint32 i;\r\n\r\n    for (i = 0; i < txn->ninvalidations; i++)\r\n        LocalExecuteInvalidationMessage(&txn->invalidations[i]);\r\n}",
		"comment":"/*\r\n * Apply all invalidations we know. Possibly we only need parts at this point\r\n * in the changestream but we don't know which those are.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferExecuteInvalidations"
	},
	"ReorderBufferForget":{
		"body":"void ReorderBufferForget(ReorderBuffer* rb, TransactionId xid, XLogRecPtr lsn)\r\n{\r\n    ReorderBufferTXN* txn = NULL;\r\n\r\n    txn = ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr, false);\r\n    /* unknown, nothing to forget */\r\n    if (txn == NULL)\r\n        return;\r\n\r\n    /* cosmetic... */\r\n    txn->final_lsn = lsn;\r\n\r\n    /*\r\n     * Proccess cache invalidation messages if there are any. Even if we're\r\n     * not interested in the transaction's contents, it could have manipulated\r\n     * the catalog and we need to update the caches according to that.\r\n     */\r\n    if (txn->base_snapshot != NULL && txn->ninvalidations > 0) {\r\n        /* setup snapshot to perform the invalidations in */\r\n        SetupHistoricSnapshot(txn->base_snapshot, txn->tuplecid_hash);\r\n        PG_TRY();\r\n        {\r\n            ReorderBufferExecuteInvalidations(rb, txn);\r\n            TeardownHistoricSnapshot(false);\r\n        }\r\n        PG_CATCH();\r\n        {\r\n            /* cleanup */\r\n            TeardownHistoricSnapshot(true);\r\n            PG_RE_THROW();\r\n        }\r\n        PG_END_TRY();\r\n    } else\r\n        Assert(txn->ninvalidations == 0);\r\n\r\n    /* remove potential on-disk data, and deallocate */\r\n    ReorderBufferCleanupTXN(rb, txn);\r\n}",
		"comment":"/*\r\n * Forget the contents of a transaction if we aren't interested in it's\r\n * contents. Needs to be first called for subtransactions and then for the\r\n * toplevel xid.\r\n *\r\n * This is significantly different to ReorderBufferAbort() because\r\n * transactions that have committed need to be treated differenly from aborted\r\n * ones since they may have modified the catalog.\r\n *\r\n * Note that this is only allowed to be called in the moment a transaction\r\n * commit has just been read, not earlier; otherwise later records referring\r\n * to this xid might re-create the transaction incompletely.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferForget"
	},
	"ReorderBufferFree":{
		"body":"void ReorderBufferFree(ReorderBuffer* rb)\r\n{\r\n    MemoryContext context = rb->context;\r\n\r\n    /*\r\n     * We free separately allocated data by entirely scrapping reorderbuffer's\r\n     * memory context.\r\n     */\r\n    MemoryContextDelete(context);\r\n}",
		"comment":"/*\r\n * Free a ReorderBuffer\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferFree"
	},
	"ReorderBufferFreeSnap":{
		"body":"static void ReorderBufferFreeSnap(ReorderBuffer* rb, Snapshot snap)\r\n{\r\n    if (snap->copied) {\r\n        if (GTM_LITE_MODE && (snap->prepared_array != NULL))\r\n            pfree_ext(snap->prepared_array);\r\n\r\n        pfree(snap);\r\n        snap = NULL;\r\n    } else\r\n        SnapBuildSnapDecRefcount(snap);\r\n}",
		"comment":"/*\r\n * Free a previously ReorderBufferCopySnap'ed snapshot\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferFreeSnap"
	},
	"ReorderBufferGetChange":{
		"body":"ReorderBufferChange* ReorderBufferGetChange(ReorderBuffer* rb)\r\n{\r\n    ReorderBufferChange* change = NULL;\r\n    int rc = 0;\r\n    /* check the slab cache */\r\n    if (rb->nr_cached_changes) {\r\n        rb->nr_cached_changes--;\r\n        change =\r\n            (ReorderBufferChange*)dlist_container(ReorderBufferChange, node, dlist_pop_head_node(&rb->cached_changes));\r\n    } else {\r\n        change = (ReorderBufferChange*)MemoryContextAlloc(rb->context, sizeof(ReorderBufferChange));\r\n    }\r\n\r\n    rc = memset_s(change, sizeof(ReorderBufferChange), 0, sizeof(ReorderBufferChange));\r\n    securec_check(rc, \"\", \"\");\r\n\r\n    return change;\r\n}",
		"comment":"/*\r\n * Get a unused, possibly preallocated, ReorderBufferChange.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferGetChange"
	},
	"ReorderBufferGetOldestTXN":{
		"body":"ReorderBufferTXN* ReorderBufferGetOldestTXN(ReorderBuffer* rb)\r\n{\r\n    ReorderBufferTXN* txn = NULL;\r\n\r\n    AssertTXNLsnOrder(rb);\r\n\r\n    if (dlist_is_empty(&rb->toplevel_by_lsn))\r\n        return NULL;\r\n\r\n    txn = dlist_head_element(ReorderBufferTXN, node, &rb->toplevel_by_lsn);\r\n\r\n    Assert(!txn->is_known_as_subxact);\r\n    Assert(!XLByteEQ(txn->first_lsn, InvalidXLogRecPtr));\r\n    return txn;\r\n}",
		"comment":"/*\r\n * ReorderBufferGetOldestTXN\r\n *     Return oldest transaction in reorderbuffer\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferGetOldestTXN"
	},
	"ReorderBufferGetOldestXmin":{
		"body":"TransactionId ReorderBufferGetOldestXmin(ReorderBuffer* rb)\r\n{\r\n    ReorderBufferTXN* txn = NULL;\r\n\r\n    AssertTXNLsnOrder(rb);\r\n\r\n    if (dlist_is_empty(&rb->txns_by_base_snapshot_lsn))\r\n        return InvalidTransactionId;\r\n\r\n    txn = dlist_head_element(ReorderBufferTXN, base_snapshot_node, &rb->txns_by_base_snapshot_lsn);\r\n    return txn->base_snapshot->xmin;\r\n}",
		"comment":"/*\r\n * ReorderBufferGetOldestXmin\r\n *     Return oldest Xmin in reorderbuffer\r\n *\r\n * Returns oldest possibly running Xid from the point of view of snapshots\r\n * used in the transactions kept by reorderbuffer, or InvalidTransactionId if\r\n * there are none.\r\n *\r\n * Since snapshots are assigned monotonically, this equals the Xmin of the\r\n * base snapshot with minimal base_snapshot_lsn.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferGetOldestXmin"
	},
	"ReorderBufferGetTXN":{
		"body":"static ReorderBufferTXN* ReorderBufferGetTXN(ReorderBuffer* rb)\r\n{\r\n    ReorderBufferTXN* txn = NULL;\r\n    int rc = 0;\r\n    /* check the slab cache */\r\n    if (rb->nr_cached_transactions > 0) {\r\n        rb->nr_cached_transactions--;\r\n        txn = (ReorderBufferTXN*)dlist_container(ReorderBufferTXN, node, dlist_pop_head_node(&rb->cached_transactions));\r\n    } else {\r\n        txn = (ReorderBufferTXN*)MemoryContextAlloc(rb->context, sizeof(ReorderBufferTXN));\r\n    }\r\n\r\n    rc = memset_s(txn, sizeof(ReorderBufferTXN), 0, sizeof(ReorderBufferTXN));\r\n    securec_check(rc, \"\", \"\");\r\n\r\n    dlist_init(&txn->changes);\r\n    dlist_init(&txn->tuplecids);\r\n    dlist_init(&txn->subtxns);\r\n\r\n    return txn;\r\n}",
		"comment":"/*\r\n * Get a unused, possibly preallocated, ReorderBufferTXN.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferGetTXN"
	},
	"ReorderBufferGetTupleBuf":{
		"body":"ReorderBufferTupleBuf* ReorderBufferGetTupleBuf(ReorderBuffer* rb, Size tuple_len)\r\n{\r\n    ReorderBufferTupleBuf* tuple = NULL;\r\n    Size alloc_len = tuple_len + SizeofHeapTupleHeader;\r\n    /*\r\n     * Most tuples are below MaxHeapTupleSize, so we use a slab allocator for\r\n     * those. Thus always allocate at least MaxHeapTupleSize. Note that tuples\r\n     * tuples generated for oldtuples can be bigger, as they don't have\r\n     * out-of-line toast columns.\r\n     */\r\n    if (alloc_len < MaxHeapTupleSize)\r\n        alloc_len = MaxHeapTupleSize;\r\n\r\n    /* if small enough, check the slab cache */\r\n    if (alloc_len <= MaxHeapTupleSize && rb->nr_cached_tuplebufs) {\r\n        rb->nr_cached_tuplebufs--;\r\n        tuple = slist_container(ReorderBufferTupleBuf, node, slist_pop_head_node(&rb->cached_tuplebufs));\r\n#ifdef USE_ASSERT_CHECKING\r\n        int rc = memset_s(&tuple->tuple, sizeof(HeapTupleData), 0xa9, sizeof(HeapTupleData));\r\n        securec_check(rc, \"\", \"\");\r\n\r\n#endif\r\n        tuple->tuple.t_data = ReorderBufferTupleBufData(tuple);\r\n#ifdef USE_ASSERT_CHECKING\r\n        int ret = memset_s(tuple->tuple.t_data, tuple->alloc_tuple_size, 0xa8, tuple->alloc_tuple_size);\r\n        securec_check(ret, \"\", \"\");\r\n\r\n#endif\r\n    } else {\r\n        tuple = (ReorderBufferTupleBuf*)MemoryContextAlloc(rb->context, sizeof(ReorderBufferTupleBuf) + alloc_len);\r\n        tuple->alloc_tuple_size = alloc_len;\r\n        tuple->tuple.t_data = ReorderBufferTupleBufData(tuple);\r\n    }\r\n\r\n    return tuple;\r\n}",
		"comment":"/*\r\n * Get an unused, possibly preallocated, ReorderBufferTupleBuf fitting at\r\n * least a tuple of size tuple_len (excluding header overhead).\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferGetTupleBuf"
	},
	"ReorderBufferIterCompare":{
		"body":"static int ReorderBufferIterCompare(Datum a, Datum b, void* arg)\r\n{\r\n    ReorderBufferIterTXNState* state = (ReorderBufferIterTXNState*)arg;\r\n    XLogRecPtr pos_a = state->entries[DatumGetInt32(a)].lsn;\r\n    XLogRecPtr pos_b = state->entries[DatumGetInt32(b)].lsn;\r\n    if (XLByteLT(pos_a, pos_b))\r\n        return 1;\r\n    else if (XLByteEQ(pos_a, pos_b))\r\n        return 0;\r\n    return -1;\r\n}",
		"comment":"/*\r\n * Support for efficiently iterating over a transaction's and its\r\n * subtransactions' changes.\r\n *\r\n * We do by doing a k-way merge between transactions/subtransactions. For that\r\n * we model the current heads of the different transactions as a binary heap\r\n * so we easily know which (sub-)transaction has the change with the smallest\r\n * lsn next.\r\n *\r\n * We assume the changes in individual transactions are already sorted by LSN.\r\n *\r\n *\r\n * Binary heap comparison function.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferIterCompare"
	},
	"ReorderBufferIterTXNFinish":{
		"body":"static void ReorderBufferIterTXNFinish(ReorderBuffer* rb, ReorderBufferIterTXNState* state)\r\n{\r\n    Size off;\r\n\r\n    for (off = 0; off < state->nr_txns; off++) {\r\n        if (state->entries[off].fd != -1) {\r\n            (void)CloseTransientFile(state->entries[off].fd);\r\n        }\r\n    }\r\n\r\n    /* free memory we might have \"leaked\" in the last *Next call */\r\n    if (!dlist_is_empty(&state->old_change)) {\r\n        ReorderBufferChange* change = NULL;\r\n\r\n        change = dlist_container(ReorderBufferChange, node, dlist_pop_head_node(&state->old_change));\r\n        ReorderBufferReturnChange(rb, change);\r\n        Assert(dlist_is_empty(&state->old_change));\r\n    }\r\n\r\n    binaryheap_free(state->heap);\r\n    pfree(state);\r\n    state = NULL;\r\n}",
		"comment":"/*\r\n * Deallocate the iterator\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferIterTXNFinish"
	},
	"ReorderBufferIterTXNInit":{
		"body":"static ReorderBufferIterTXNState* ReorderBufferIterTXNInit(ReorderBuffer* rb, ReorderBufferTXN* txn)\r\n{\r\n    Size nr_txns = 0;\r\n    ReorderBufferIterTXNState* state = 0;\r\n    dlist_iter cur_txn_i;\r\n    Size off;\r\n\r\n    /*\r\n     * Calculate the size of our heap: one element for every transaction that\r\n     * contains changes.  (Besides the transactions already in the reorder\r\n     * buffer, we count the one we were directly passed.)\r\n     */\r\n    if (txn->nentries > 0)\r\n        nr_txns++;\r\n\r\n    dlist_foreach(cur_txn_i, &txn->subtxns)\r\n    {\r\n        ReorderBufferTXN* cur_txn = NULL;\r\n\r\n        cur_txn = dlist_container(ReorderBufferTXN, node, cur_txn_i.cur);\r\n        if (cur_txn->nentries > 0)\r\n            nr_txns++;\r\n    }\r\n\r\n    /*\r\n     * description: Consider adding fastpath for the rather common nr_txns=1 case, no\r\n     * need to allocate/build a heap then.\r\n     *\r\n     * allocate iteration state\r\n     */\r\n    state = (ReorderBufferIterTXNState*)MemoryContextAllocZero(\r\n        rb->context, sizeof(ReorderBufferIterTXNState) + sizeof(ReorderBufferIterTXNEntry) * nr_txns);\r\n\r\n    state->nr_txns = nr_txns;\r\n    dlist_init(&state->old_change);\r\n\r\n    for (off = 0; off < state->nr_txns; off++) {\r\n        state->entries[off].fd = -1;\r\n        state->entries[off].segno = 0;\r\n    }\r\n\r\n    /* allocate heap */\r\n    state->heap = binaryheap_allocate(state->nr_txns, ReorderBufferIterCompare, state);\r\n\r\n    /*\r\n     * Now insert items into the binary heap, in an unordered fashion.  (We\r\n     * will run a heap assembly step at the end; this is more efficient.)\r\n     */\r\n    off = 0;\r\n\r\n    /* add toplevel transaction if it contains changes */\r\n    if (txn->nentries > 0) {\r\n        ReorderBufferChange* cur_change = NULL;\r\n\r\n        if (txn->serialized) {\r\n            /* serialize remaining changes */\r\n            ReorderBufferSerializeTXN(rb, txn);\r\n            (void)ReorderBufferRestoreChanges(rb, txn, &state->entries[off].fd, &state->entries[off].segno);\r\n        }\r\n\r\n        cur_change = dlist_head_element(ReorderBufferChange, node, &txn->changes);\r\n\r\n        state->entries[off].lsn = cur_change->lsn;\r\n        state->entries[off].change = cur_change;\r\n        state->entries[off].txn = txn;\r\n\r\n        binaryheap_add_unordered(state->heap, Int32GetDatum(off++));\r\n    }\r\n\r\n    /* add subtransactions if they contain changes */\r\n    dlist_foreach(cur_txn_i, &txn->subtxns)\r\n    {\r\n        ReorderBufferTXN* cur_txn = NULL;\r\n\r\n        cur_txn = dlist_container(ReorderBufferTXN, node, cur_txn_i.cur);\r\n        if (cur_txn->nentries > 0) {\r\n            ReorderBufferChange* cur_change = NULL;\r\n\r\n            if (cur_txn->serialized) {\r\n                /* serialize remaining changes */\r\n                ReorderBufferSerializeTXN(rb, cur_txn);\r\n                (void)ReorderBufferRestoreChanges(rb, cur_txn, &state->entries[off].fd, &state->entries[off].segno);\r\n            }\r\n\r\n            cur_change = dlist_head_element(ReorderBufferChange, node, &cur_txn->changes);\r\n\r\n            state->entries[off].lsn = cur_change->lsn;\r\n            state->entries[off].change = cur_change;\r\n            state->entries[off].txn = cur_txn;\r\n\r\n            binaryheap_add_unordered(state->heap, Int32GetDatum(off++));\r\n        }\r\n    }\r\n\r\n    /* assemble a valid binary heap */\r\n    binaryheap_build(state->heap);\r\n\r\n    return state;\r\n}",
		"comment":"/*\r\n * Allocate & initialize an iterator which iterates in lsn order over a\r\n * transaction and all its subtransactions.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferIterTXNInit"
	},
	"ReorderBufferIterTXNNext":{
		"body":"static ReorderBufferChange* ReorderBufferIterTXNNext(ReorderBuffer* rb, ReorderBufferIterTXNState* state)\r\n{\r\n    ReorderBufferChange* change = NULL;\r\n    ReorderBufferIterTXNEntry* entry = NULL;\r\n    int32 off = 0;\r\n\r\n    /* nothing there anymore */\r\n    if (state->heap->bh_size == 0)\r\n        return NULL;\r\n\r\n    off = DatumGetInt32(binaryheap_first(state->heap));\r\n    entry = &state->entries[off];\r\n\r\n    /* free memory we might have \"leaked\" in the previous *Next call */\r\n    if (!dlist_is_empty(&state->old_change)) {\r\n        change = dlist_container(ReorderBufferChange, node, dlist_pop_head_node(&state->old_change));\r\n        ReorderBufferReturnChange(rb, change);\r\n        Assert(dlist_is_empty(&state->old_change));\r\n    }\r\n\r\n    change = entry->change;\r\n\r\n    /*\r\n     * update heap with information about which transaction has the next\r\n     * relevant change in LSN order\r\n     *\r\n     * there are in-memory changes\r\n     */\r\n    if (dlist_has_next(&entry->txn->changes, &entry->change->node)) {\r\n        dlist_node* next = dlist_next_node(&entry->txn->changes, &change->node);\r\n        ReorderBufferChange* next_change = dlist_container(ReorderBufferChange, node, next);\r\n\r\n        /* txn stays the same */\r\n        state->entries[off].lsn = next_change->lsn;\r\n        state->entries[off].change = next_change;\r\n\r\n        binaryheap_replace_first(state->heap, Int32GetDatum(off));\r\n        return change;\r\n    }\r\n\r\n    /* try to load changes from disk */\r\n    if (entry->txn->nentries != entry->txn->nentries_mem) {\r\n        /*\r\n         * Ugly: restoring changes will reuse *Change records, thus delete the\r\n         * current one from the per-tx list and only free in the next call.\r\n         */\r\n        dlist_delete(&change->node);\r\n        dlist_push_tail(&state->old_change, &change->node);\r\n\r\n        if (ReorderBufferRestoreChanges(rb, entry->txn, &entry->fd, &state->entries[off].segno)) {\r\n            /* successfully restored changes from disk */\r\n            ReorderBufferChange* next_change = dlist_head_element(ReorderBufferChange, node, &entry->txn->changes);\r\n\r\n            if (!RecoveryInProgress())\r\n                ereport(DEBUG2,\r\n                    (errmsg(\"restored %u/%u changes from disk\",\r\n                        (uint32)entry->txn->nentries_mem,\r\n                        (uint32)entry->txn->nentries)));\r\n\r\n            Assert(entry->txn->nentries_mem);\r\n            /* txn stays the same */\r\n            state->entries[off].lsn = next_change->lsn;\r\n            state->entries[off].change = next_change;\r\n            binaryheap_replace_first(state->heap, Int32GetDatum(off));\r\n\r\n            return change;\r\n        }\r\n    }\r\n\r\n    /* ok, no changes there anymore, remove */\r\n    (void)binaryheap_remove_first(state->heap);\r\n\r\n    return change;\r\n}",
		"comment":"/*\r\n * Return the next change when iterating over a transaction and its\r\n * subtransactions.\r\n *\r\n * Returns NULL when no further changes exist.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferIterTXNNext"
	},
	"ReorderBufferProcessXid":{
		"body":"void ReorderBufferProcessXid(ReorderBuffer* rb, TransactionId xid, XLogRecPtr lsn)\r\n{\r\n    /* many records won't have an xid assigned, centralize check here */\r\n    if (xid != InvalidTransactionId) {\r\n        (void)ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true);\r\n    }\r\n}",
		"comment":"/*\r\n * Tell reorderbuffer about an xid seen in the WAL stream. Has to be called at\r\n * least once for every xid in XLogRecord->xl_xid (other places in records\r\n * may, but do not have to be passed through here).\r\n *\r\n * Reorderbuffer keeps some datastructures about transactions in LSN order,\r\n * for efficiency. To do that it has to know about when transactions are seen\r\n * first in the WAL. As many types of records are not actually interesting for\r\n * logical decoding, they do not necessarily pass though here.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferProcessXid"
	},
	"ReorderBufferQueueChange":{
		"body":"void ReorderBufferQueueChange(ReorderBuffer* rb, TransactionId xid, XLogRecPtr lsn, ReorderBufferChange* change)\r\n{\r\n    ReorderBufferTXN* txn = NULL;\r\n\r\n    txn = ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true);\r\n\r\n    change->lsn = lsn;\r\n    Assert(!XLByteEQ(InvalidXLogRecPtr, lsn));\r\n    dlist_push_tail(&txn->changes, &change->node);\r\n    txn->nentries++;\r\n    txn->nentries_mem++;\r\n\r\n    ReorderBufferCheckSerializeTXN(rb, txn);\r\n}",
		"comment":"/*\r\n * Queue a change into a transaction so it can be replayed upon commit.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferQueueChange"
	},
	"ReorderBufferRestoreChange":{
		"body":"static void ReorderBufferRestoreChange(ReorderBuffer* rb, ReorderBufferTXN* txn, char* data)\r\n{\r\n    ReorderBufferDiskChange* ondisk = NULL;\r\n    ReorderBufferChange* change = NULL;\r\n    int rc = 0;\r\n    ondisk = (ReorderBufferDiskChange*)data;\r\n\r\n    change = ReorderBufferGetChange(rb);\r\n\r\n    /* copy static part */\r\n    rc = memcpy_s(change, sizeof(ReorderBufferChange), &ondisk->change, sizeof(ReorderBufferChange));\r\n    securec_check(rc, \"\", \"\");\r\n\r\n    data += sizeof(ReorderBufferDiskChange);\r\n\r\n    /* restore individual stuff */\r\n    switch (change->action) {\r\n        case REORDER_BUFFER_CHANGE_INSERT:\r\n        /* fall through */\r\n        case REORDER_BUFFER_CHANGE_UPDATE:\r\n        /* fall through */\r\n        case REORDER_BUFFER_CHANGE_DELETE:\r\n            if (change->data.tp.oldtuple) {\r\n                Size tuplelen = ((HeapTuple)data)->t_len;\r\n                change->data.tp.oldtuple = ReorderBufferGetTupleBuf(rb, tuplelen - SizeofHeapTupleHeader);\r\n\r\n                /* restore ->tuple */\r\n                rc = memcpy_s(&change->data.tp.oldtuple->tuple, sizeof(HeapTupleData), data, sizeof(HeapTupleData));\r\n                securec_check(rc, \"\", \"\");\r\n                data += sizeof(HeapTupleData);\r\n                change->data.tp.oldtuple->tuple.t_data = ReorderBufferTupleBufData(change->data.tp.oldtuple);\r\n                /* restore tuple data itself */\r\n                rc = memcpy_s(change->data.tp.oldtuple->tuple.t_data, tuplelen, data, tuplelen);\r\n                securec_check(rc, \"\", \"\");\r\n                data += tuplelen;\r\n            }\r\n            if (change->data.tp.newtuple) {\r\n                Size tuplelen = ((HeapTuple)data)->t_len;\r\n                change->data.tp.newtuple = ReorderBufferGetTupleBuf(rb, tuplelen - SizeofHeapTupleHeader);\r\n\r\n                /* restore ->tuple */\r\n                rc = memcpy_s(&change->data.tp.newtuple->tuple, sizeof(HeapTupleData), data, sizeof(HeapTupleData));\r\n                securec_check(rc, \"\", \"\");\r\n                data += sizeof(HeapTupleData);\r\n\r\n                /* reset t_data pointer into the new tuplebuf */\r\n                change->data.tp.newtuple->tuple.t_data = ReorderBufferTupleBufData(change->data.tp.newtuple);\r\n\r\n                /* restore tuple data itself */\r\n                rc = memcpy_s(change->data.tp.newtuple->tuple.t_data, tuplelen, data, tuplelen);\r\n                securec_check(rc, \"\", \"\");\r\n                data += tuplelen;\r\n            }\r\n\r\n            break;\r\n        case REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT: {\r\n            Snapshot oldsnap;\r\n            Snapshot newsnap;\r\n            Size size;\r\n\r\n            oldsnap = (Snapshot)data;\r\n\r\n            size = sizeof(SnapshotData) + sizeof(TransactionId) * oldsnap->xcnt +\r\n                   sizeof(TransactionId) * (oldsnap->subxcnt + 0);\r\n\r\n            change->data.snapshot = (SnapshotData*)MemoryContextAllocZero(rb->context, size);\r\n\r\n            newsnap = change->data.snapshot;\r\n\r\n            rc = memcpy_s(newsnap, size, data, size);\r\n            securec_check(rc, \"\", \"\");\r\n            newsnap->xip = (TransactionId*)(((char*)newsnap) + sizeof(SnapshotData));\r\n            newsnap->subxip = newsnap->xip + newsnap->xcnt;\r\n            newsnap->copied = true;\r\n            break;\r\n        }\r\n        /* the base struct contains all the data, easy peasy */\r\n        case REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID:\r\n        case REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID:\r\n            break;\r\n    }\r\n\r\n    dlist_push_tail(&txn->changes, &change->node);\r\n    txn->nentries_mem++;\r\n}",
		"comment":"/*\r\n * Convert change from its on-disk format to in-memory format and queue it onto\r\n * the TXN's ->changes list.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferRestoreChange"
	},
	"ReorderBufferRestoreChanges":{
		"body":"static Size ReorderBufferRestoreChanges(ReorderBuffer* rb, ReorderBufferTXN* txn, int* fd, XLogSegNo* segno)\r\n{\r\n    Size restored = 0;\r\n    XLogSegNo last_segno;\r\n    int rc = 0;\r\n    dlist_mutable_iter cleanup_iter;\r\n\r\n    Assert(!XLByteEQ(txn->first_lsn, InvalidXLogRecPtr));\r\n    Assert(!XLByteEQ(txn->final_lsn, InvalidXLogRecPtr));\r\n\r\n    /* free current entries, so we have memory for more */\r\n    dlist_foreach_modify(cleanup_iter, &txn->changes)\r\n    {\r\n        ReorderBufferChange* cleanup = dlist_container(ReorderBufferChange, node, cleanup_iter.cur);\r\n\r\n        dlist_delete(&cleanup->node);\r\n        ReorderBufferReturnChange(rb, cleanup);\r\n    }\r\n    txn->nentries_mem = 0;\r\n    Assert(dlist_is_empty(&txn->changes));\r\n\r\n    last_segno = (txn->final_lsn) / XLogSegSize;\r\n    while (restored < (unsigned)g_instance.attr.attr_common.max_changes_in_memory && *segno <= last_segno) {\r\n        int readBytes;\r\n        ReorderBufferDiskChange* ondisk = NULL;\r\n\r\n        if (*fd == -1) {\r\n            XLogRecPtr recptr;\r\n            char path[MAXPGPATH];\r\n\r\n            /* first time in */\r\n            if (*segno == 0) {\r\n                *segno = (txn->first_lsn) / XLogSegSize;\r\n            }\r\n\r\n            Assert(*segno != 0 || dlist_is_empty(&txn->changes));\r\n\r\n            recptr = (*segno * XLOG_SEG_SIZE);\r\n\r\n            /*\r\n             * No need to care about TLIs here, only used during a single run,\r\n             * so each LSN only maps to a specific WAL record.\r\n             */\r\n            rc = sprintf_s(path,\r\n                sizeof(path),\r\n                \"pg_replslot/%s/snap/xid-%lu-lsn-%X-%X.snap\",\r\n                NameStr(t_thrd.slot_cxt.MyReplicationSlot->data.name),\r\n                txn->xid,\r\n                (uint32)(recptr >> 32),\r\n                (uint32)recptr);\r\n            securec_check_ss(rc, \"\", \"\");\r\n            *fd = OpenTransientFile(path, O_RDONLY | PG_BINARY, 0);\r\n            if (*fd < 0 && errno == ENOENT) {\r\n                *fd = -1;\r\n                (*segno)++;\r\n                continue;\r\n            } else if (*fd < 0)\r\n                ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not open file \\\"%s\\\": %m\", path)));\r\n        }\r\n\r\n        /*\r\n         * Read the statically sized part of a change which has information\r\n         * about the total size. If we couldn't read a record, we're at the\r\n         * end of this file.\r\n         */\r\n        ReorderBufferSerializeReserve(rb, sizeof(ReorderBufferDiskChange));\r\n        readBytes = read(*fd, rb->outbuf, sizeof(ReorderBufferDiskChange));\r\n        /* eof */\r\n        if (readBytes == 0) {\r\n            (void)CloseTransientFile(*fd);\r\n            *fd = -1;\r\n            (*segno)++;\r\n            continue;\r\n        } else if (readBytes < 0) {\r\n            ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not read from reorderbuffer spill file: %m\")));\r\n        } else if (readBytes != sizeof(ReorderBufferDiskChange)) {\r\n            ereport(ERROR,\r\n                (errcode_for_file_access(),\r\n                    errmsg(\"incomplete read from reorderbuffer spill file: read %d instead of %u\",\r\n                        readBytes,\r\n                        (uint32)sizeof(ReorderBufferDiskChange))));\r\n        }\r\n\r\n        ondisk = (ReorderBufferDiskChange*)rb->outbuf;\r\n\r\n        ReorderBufferSerializeReserve(rb, sizeof(ReorderBufferDiskChange) + ondisk->size);\r\n        ondisk = (ReorderBufferDiskChange*)rb->outbuf;\r\n        if (ondisk->size < sizeof(ReorderBufferDiskChange)) {\r\n            ereport(ERROR,\r\n                (errcode_for_file_access(),\r\n                    errmsg(\"illegality read length %lu\", (ondisk->size - sizeof(ReorderBufferDiskChange)))));\r\n        }\r\n        readBytes = read(\r\n            *fd, rb->outbuf + sizeof(ReorderBufferDiskChange), uint64(ondisk->size) - sizeof(ReorderBufferDiskChange));\r\n        if (readBytes < 0) {\r\n            ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not read from reorderbuffer spill file: %m\")));\r\n        } else if (INT2SIZET(readBytes) != ondisk->size - sizeof(ReorderBufferDiskChange)) {\r\n            ereport(ERROR,\r\n                (errcode_for_file_access(),\r\n                    errmsg(\"could not read from reorderbuffer spill file: read %d instead of %u\",\r\n                        readBytes,\r\n                        (uint32)(ondisk->size - sizeof(ReorderBufferDiskChange)))));\r\n        }\r\n\r\n        /*\r\n         * ok, read a full change from disk, now restore it into proper\r\n         * in-memory format\r\n         */\r\n        ReorderBufferRestoreChange(rb, txn, rb->outbuf);\r\n        restored++;\r\n    }\r\n\r\n    return restored;\r\n}",
		"comment":"/*\r\n * Restore a number of changes spilled to disk back into memory.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferRestoreChanges"
	},
	"ReorderBufferRestoreCleanup":{
		"body":"static void ReorderBufferRestoreCleanup(ReorderBuffer* rb, ReorderBufferTXN* txn, XLogRecPtr lsn = InvalidXLogRecPtr)\r\n{\r\n    XLogSegNo first;\r\n    XLogSegNo cur;\r\n    XLogSegNo last;\r\n    ReplicationSlot* slot = NULL;\r\n    int rc = 0;\r\n    if (txn->final_lsn == InvalidXLogRecPtr) {\r\n        txn->final_lsn = lsn;\r\n    }\r\n    Assert(!XLByteEQ(txn->first_lsn, InvalidXLogRecPtr));\r\n\r\n    first = (txn->first_lsn) / XLogSegSize;\r\n    last = (txn->final_lsn) / XLogSegSize;\r\n    if (t_thrd.slot_cxt.MyReplicationSlot) {\r\n        slot = t_thrd.slot_cxt.MyReplicationSlot;\r\n    } else {\r\n        slot = ((LogicalDecodingContext*)rb->private_data)->slot;\r\n    }\r\n    /* iterate over all possible filenames, and delete them */\r\n    for (cur = first; cur <= last; cur++) {\r\n        char path[MAXPGPATH];\r\n        XLogRecPtr recptr;\r\n        recptr = (cur * XLOG_SEG_SIZE);\r\n        rc = sprintf_s(path,\r\n            sizeof(path),\r\n            \"pg_replslot/%s/snap/xid-%lu-lsn-%X-%X.snap\",\r\n            NameStr(slot->data.name),\r\n            txn->xid,\r\n            (uint32)(recptr >> 32),\r\n            uint32(recptr));\r\n        securec_check_ss(rc, \"\", \"\");\r\n        if (unlink(path) != 0 && errno != ENOENT)\r\n            ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not unlink file \\\"%s\\\": %m\", path)));\r\n    }\r\n}",
		"comment":"/*\r\n * Remove all on-disk stored for the passed in transaction.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferRestoreCleanup"
	},
	"ReorderBufferReturnChange":{
		"body":"void ReorderBufferReturnChange(ReorderBuffer* rb, ReorderBufferChange* change)\r\n{\r\n    /* free contained data */\r\n    switch (change->action) {\r\n        case REORDER_BUFFER_CHANGE_INSERT:\r\n        case REORDER_BUFFER_CHANGE_UPDATE:\r\n        case REORDER_BUFFER_CHANGE_DELETE:\r\n            if (change->data.tp.newtuple) {\r\n                ReorderBufferReturnTupleBuf(rb, change->data.tp.newtuple);\r\n                change->data.tp.newtuple = NULL;\r\n            }\r\n\r\n            if (change->data.tp.oldtuple) {\r\n                ReorderBufferReturnTupleBuf(rb, change->data.tp.oldtuple);\r\n                change->data.tp.oldtuple = NULL;\r\n            }\r\n            break;\r\n        case REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT:\r\n            if (change->data.snapshot) {\r\n                ReorderBufferFreeSnap(rb, change->data.snapshot);\r\n                change->data.snapshot = NULL;\r\n            }\r\n            break;\r\n        case REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID:\r\n            break;\r\n        case REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID:\r\n            break;\r\n    }\r\n\r\n    pfree(change);\r\n    change = NULL;\r\n}",
		"comment":"/*\r\n * Free an ReorderBufferChange.\r\n *\r\n * Deallocation might be delayed for efficiency purposes, for details check\r\n * the comments above max_cached_changes's definition.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferReturnChange"
	},
	"ReorderBufferReturnTXN":{
		"body":"void ReorderBufferReturnTXN(ReorderBuffer* rb, ReorderBufferTXN* txn)\r\n{\r\n    /* clean the lookup cache if we were cached (quite likely) */\r\n    if (rb->by_txn_last_xid == txn->xid) {\r\n        rb->by_txn_last_xid = InvalidTransactionId;\r\n        rb->by_txn_last_txn = NULL;\r\n    }\r\n\r\n    /* free data that's contained */\r\n    if (txn->tuplecid_hash != NULL) {\r\n        hash_destroy(txn->tuplecid_hash);\r\n        txn->tuplecid_hash = NULL;\r\n    }\r\n\r\n    if (txn->invalidations) {\r\n        pfree(txn->invalidations);\r\n        txn->invalidations = NULL;\r\n    }\r\n\r\n    /* check whether to put into the slab cache */\r\n    if (rb->nr_cached_transactions < g_max_cached_transactions) {\r\n        rb->nr_cached_transactions++;\r\n        dlist_push_head(&rb->cached_transactions, &txn->node);\r\n    } else {\r\n        pfree(txn);\r\n        txn = NULL;\r\n    }\r\n}",
		"comment":"/*\r\n * Free a ReorderBufferTXN.\r\n *\r\n * Deallocation might be delayed for efficiency purposes, for details check\r\n * the comments above max_cached_changes's definition.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferReturnTXN"
	},
	"ReorderBufferReturnTupleBuf":{
		"body":"void ReorderBufferReturnTupleBuf(ReorderBuffer* rb, ReorderBufferTupleBuf* tuple)\r\n{\r\n    /* check whether to put into the slab cache, oversized tuples never are */\r\n    if (tuple->alloc_tuple_size == MaxHeapTupleSize &&\r\n        rb->nr_cached_tuplebufs < (unsigned)g_instance.attr.attr_common.max_cached_tuplebufs) {\r\n        rb->nr_cached_tuplebufs++;\r\n        slist_push_head(&rb->cached_tuplebufs, &tuple->node);\r\n    } else {\r\n        pfree(tuple);\r\n        tuple = NULL;\r\n    }\r\n}",
		"comment":"/*\r\n * Free an ReorderBufferTupleBuf.\r\n *\r\n * Deallocation might be delayed for efficiency purposes, for details check\r\n * the comments above max_cached_changes's definition.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferReturnTupleBuf"
	},
	"ReorderBufferSerializeChange":{
		"body":"static void ReorderBufferSerializeChange(ReorderBuffer* rb, ReorderBufferTXN* txn, int fd, ReorderBufferChange* change)\r\n{\r\n    ReorderBufferDiskChange* ondisk = NULL;\r\n    Size sz = sizeof(ReorderBufferDiskChange);\r\n    int rc = 0;\r\n    ReorderBufferSerializeReserve(rb, sz);\r\n\r\n    ondisk = (ReorderBufferDiskChange*)rb->outbuf;\r\n    rc = memcpy_s(&ondisk->change, sizeof(ReorderBufferChange), change, sizeof(ReorderBufferChange));\r\n    securec_check(rc, \"\", \"\");\r\n\r\n    switch (change->action) {\r\n        case REORDER_BUFFER_CHANGE_INSERT:\r\n        /* fall through */\r\n        case REORDER_BUFFER_CHANGE_UPDATE:\r\n        /* fall through */\r\n        case REORDER_BUFFER_CHANGE_DELETE: {\r\n            char* data = NULL;\r\n            ReorderBufferTupleBuf *oldtup = NULL;\r\n            ReorderBufferTupleBuf *newtup = NULL;\r\n            Size oldlen = 0;\r\n            Size newlen = 0;\r\n\r\n            oldtup = change->data.tp.oldtuple;\r\n            newtup = change->data.tp.newtuple;\r\n\r\n            if (oldtup != NULL) {\r\n                sz += sizeof(HeapTupleData);\r\n                oldlen = oldtup->tuple.t_len;\r\n                sz += oldlen;\r\n            }\r\n\r\n            if (newtup != NULL) {\r\n                sz += sizeof(HeapTupleData);\r\n                newlen = newtup->tuple.t_len;\r\n                sz += newlen;\r\n            }\r\n\r\n            /* make sure we have enough space */\r\n            ReorderBufferSerializeReserve(rb, sz);\r\n\r\n            data = ((char*)rb->outbuf) + sizeof(ReorderBufferDiskChange);\r\n            /* might have been reallocated above */\r\n            ondisk = (ReorderBufferDiskChange*)rb->outbuf;\r\n\r\n            if (oldlen) {\r\n                rc = memcpy_s(data, sizeof(HeapTupleData), &oldtup->tuple, sizeof(HeapTupleData));\r\n                securec_check(rc, \"\", \"\");\r\n                data += sizeof(HeapTupleData);\r\n                rc = memcpy_s(data, oldlen, oldtup->tuple.t_data, oldlen);\r\n                securec_check(rc, \"\", \"\");\r\n                data += oldlen;\r\n            }\r\n\r\n            if (newlen) {\r\n                rc = memcpy_s(data, sizeof(HeapTupleData), &newtup->tuple, sizeof(HeapTupleData));\r\n                securec_check(rc, \"\", \"\");\r\n\r\n                data += sizeof(HeapTupleData);\r\n                rc = memcpy_s(data, newlen, newtup->tuple.t_data, newlen);\r\n                securec_check(rc, \"\", \"\");\r\n                data += newlen;\r\n            }\r\n            break;\r\n        }\r\n        case REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT: {\r\n            Snapshot snap = NULL;\r\n            char* data = NULL;\r\n\r\n            snap = change->data.snapshot;\r\n\r\n            sz += sizeof(SnapshotData) + sizeof(TransactionId) * snap->xcnt + sizeof(TransactionId) * snap->subxcnt;\r\n\r\n            /* make sure we have enough space */\r\n            ReorderBufferSerializeReserve(rb, sz);\r\n            data = ((char*)rb->outbuf) + sizeof(ReorderBufferDiskChange);\r\n            /* might have been reallocated above */\r\n            ondisk = (ReorderBufferDiskChange*)rb->outbuf;\r\n\r\n            rc = memcpy_s(data, sizeof(SnapshotData), snap, sizeof(SnapshotData));\r\n            securec_check(rc, \"\", \"\");\r\n            data += sizeof(SnapshotData);\r\n\r\n            if (snap->xcnt) {\r\n                rc = memcpy_s(data, sizeof(TransactionId) * snap->xcnt, snap->xip, sizeof(TransactionId) * snap->xcnt);\r\n                securec_check(rc, \"\", \"\");\r\n                data += sizeof(TransactionId) * snap->xcnt;\r\n            }\r\n\r\n            if (snap->subxcnt) {\r\n                rc = memcpy_s(\r\n                    data, sizeof(TransactionId) * snap->subxcnt, snap->subxip, sizeof(TransactionId) * snap->subxcnt);\r\n                securec_check(rc, \"\", \"\");\r\n                data += sizeof(TransactionId) * snap->subxcnt;\r\n            }\r\n            break;\r\n        }\r\n        case REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID:\r\n            /* ReorderBufferChange contains everything important */\r\n            break;\r\n        case REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID:\r\n            /* ReorderBufferChange contains everything important */\r\n            break;\r\n    }\r\n\r\n    ondisk->size = sz;\r\n\r\n    if ((Size)(write(fd, rb->outbuf, ondisk->size)) != ondisk->size) {\r\n        (void)CloseTransientFile(fd);\r\n        ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not write to xid %lu's data file: %m\", txn->xid)));\r\n    }\r\n\r\n    Assert(ondisk->change.action == change->action);\r\n}",
		"comment":"/*\r\n * Serialize individual change to disk.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferSerializeChange"
	},
	"ReorderBufferSerializeReserve":{
		"body":"static void ReorderBufferSerializeReserve(ReorderBuffer* rb, Size sz)\r\n{\r\n    if (!rb->outbufsize) {\r\n        rb->outbuf = (char*)MemoryContextAlloc(rb->context, sz);\r\n        rb->outbufsize = sz;\r\n    } else if (rb->outbufsize < sz) {\r\n        rb->outbuf = (char*)repalloc(rb->outbuf, sz);\r\n        rb->outbufsize = sz;\r\n    }\r\n}",
		"comment":"/*\r\n * ---------------------------------------\r\n * Disk serialization support\r\n * ---------------------------------------\r\n *\r\n *\r\n * Ensure the IO buffer is >= sz.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferSerializeReserve"
	},
	"ReorderBufferSerializeTXN":{
		"body":"static void ReorderBufferSerializeTXN(ReorderBuffer* rb, ReorderBufferTXN* txn)\r\n{\r\n    dlist_iter subtxn_i;\r\n    dlist_mutable_iter change_i;\r\n    int fd = -1;\r\n    XLogSegNo curOpenSegNo = 0;\r\n\r\n    Size spilled = 0;\r\n    char path[MAXPGPATH];\r\n    int nRet = 0;\r\n\r\n    if (!RecoveryInProgress()) {\r\n        ereport(DEBUG2, (errmsg(\"spill %u changes in tx %lu to disk\", (uint32)txn->nentries_mem, txn->xid)));\r\n    }\r\n\r\n    /* do the same to all child TXs */\r\n    if (&txn->subtxns == NULL) {\r\n        ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"txn->subtxns is illegal point\")));\r\n    }\r\n    dlist_foreach(subtxn_i, &txn->subtxns)\r\n    {\r\n        ReorderBufferTXN* subtxn = NULL;\r\n\r\n        subtxn = dlist_container(ReorderBufferTXN, node, subtxn_i.cur);\r\n        ReorderBufferSerializeTXN(rb, subtxn);\r\n    }\r\n\r\n    /* serialize changestream */\r\n    dlist_foreach_modify(change_i, &txn->changes)\r\n    {\r\n        ReorderBufferChange* change = NULL;\r\n\r\n        change = dlist_container(ReorderBufferChange, node, change_i.cur);\r\n        /*\r\n         * store in segment in which it belongs by start lsn, don't split over\r\n         * multiple segments tho\r\n         */\r\n        if (fd == -1 || !((change->lsn) / XLogSegSize == curOpenSegNo)) {\r\n            XLogRecPtr recptr;\r\n\r\n            if (fd != -1) {\r\n                (void)CloseTransientFile(fd);\r\n            }\r\n            curOpenSegNo = (change->lsn) / XLogSegSize;\r\n\r\n            recptr = (curOpenSegNo * XLogSegSize);\r\n\r\n            /*\r\n             * No need to care about TLIs here, only used during a single run,\r\n             * so each LSN only maps to a specific WAL record.\r\n             */\r\n            nRet = sprintf_s(path,\r\n                MAXPGPATH,\r\n                \"pg_replslot/%s/snap/xid-%lu-lsn-%X-%X.snap\",\r\n                NameStr(t_thrd.slot_cxt.MyReplicationSlot->data.name),\r\n                txn->xid,\r\n                (uint32)(recptr >> 32),\r\n                (uint32)recptr);\r\n            securec_check_ss(nRet, \"\", \"\");\r\n            /* open segment, create it if necessary */\r\n            fd = OpenTransientFile(path, O_CREAT | O_WRONLY | O_APPEND | PG_BINARY, S_IRUSR | S_IWUSR);\r\n            if (fd < 0) {\r\n                ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not open file \\\"%s\\\": %m\", path)));\r\n            }\r\n        }\r\n\r\n        ReorderBufferSerializeChange(rb, txn, fd, change);\r\n        dlist_delete(&change->node);\r\n        ReorderBufferReturnChange(rb, change);\r\n\r\n        spilled++;\r\n    }\r\n\r\n    Assert(spilled == txn->nentries_mem);\r\n    Assert(dlist_is_empty(&txn->changes));\r\n    txn->nentries_mem = 0;\r\n    txn->serialized = true;\r\n\r\n    if (fd != -1) {\r\n        (void)CloseTransientFile(fd);\r\n    }\r\n}",
		"comment":"/*\r\n * Spill data of a large transaction (and its subtransactions) to disk.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferSerializeTXN"
	},
	"ReorderBufferSetBaseSnapshot":{
		"body":"void ReorderBufferSetBaseSnapshot(ReorderBuffer* rb, TransactionId xid, XLogRecPtr lsn, Snapshot snap)\r\n{\r\n    ReorderBufferTXN* txn = NULL;\r\n    bool is_new = false;\r\n    AssertArg(snap != NULL);\r\n\r\n    /*\r\n     * Fetch the transaction to operate on.  If we know it's a subtransaction,\r\n     * operate on its top-level transaction instead.\r\n     */\r\n    txn = ReorderBufferTXNByXid(rb, xid, true, &is_new, lsn, true);\r\n    if (txn->is_known_as_subxact)\r\n        txn = ReorderBufferTXNByXid(rb, txn->toplevel_xid, false, NULL, InvalidXLogRecPtr, false);\r\n    if (txn == NULL)\r\n        ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"can not found txn which xid = %lu\", xid)));\r\n    Assert(txn->base_snapshot == NULL);\r\n\r\n    txn->base_snapshot = snap;\r\n    txn->base_snapshot_lsn = lsn;\r\n    dlist_push_tail(&rb->txns_by_base_snapshot_lsn, &txn->base_snapshot_node);\r\n\r\n    AssertTXNLsnOrder(rb);\r\n}",
		"comment":"/*\r\n * Set up the transaction's base snapshot.\r\n *\r\n * If we know that xid is a subtransaction, set the base snapshot on the\r\n * top-level transaction instead.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferSetBaseSnapshot"
	},
	"ReorderBufferSetRestartPoint":{
		"body":"void ReorderBufferSetRestartPoint(ReorderBuffer* rb, XLogRecPtr ptr)\r\n{\r\n    rb->current_restart_decoding_lsn = ptr;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferSetRestartPoint"
	},
	"ReorderBufferTXNByXid":{
		"body":"static ReorderBufferTXN* ReorderBufferTXNByXid(\r\n    ReorderBuffer* rb, TransactionId xid, bool create, bool* is_new, XLogRecPtr lsn, bool create_as_top)\r\n{\r\n    ReorderBufferTXN* txn = NULL;\r\n    ReorderBufferTXNByIdEnt* ent = NULL;\r\n    bool found = false;\r\n\r\n    Assert(TransactionIdIsValid(xid));\r\n\r\n    /*\r\n     * Check the one-entry lookup cache first\r\n     */\r\n    if (TransactionIdIsValid(rb->by_txn_last_xid) && rb->by_txn_last_xid == xid) {\r\n        txn = rb->by_txn_last_txn;\r\n\r\n        if (txn != NULL) {\r\n            /* found it, and it's valid */\r\n            if (is_new != NULL) {\r\n                *is_new = false;\r\n            }\r\n            return txn;\r\n        }\r\n\r\n        /*\r\n         * cached as non-existant, and asked not to create? Then nothing else\r\n         * to do.\r\n         */\r\n        if (!create) {\r\n            return NULL;\r\n        }\r\n        /* otherwise fall through to create it */\r\n    }\r\n\r\n    /*\r\n     * If the cache wasn't hit or it yielded an \"does-not-exist\" and we want\r\n     * to create an entry.\r\n     *\r\n     * search the lookup table \r\n     */\r\n    ent = (ReorderBufferTXNByIdEnt*)hash_search(rb->by_txn, (void*)&xid, create ? HASH_ENTER : HASH_FIND, &found);\r\n    if (found) {\r\n        txn = ent->txn;\r\n    } else if (create) {\r\n        /* initialize the new entry, if creation was requested */\r\n        Assert(ent != NULL);\r\n        Assert(lsn != InvalidXLogRecPtr);\r\n\r\n        ent->txn = ReorderBufferGetTXN(rb);\r\n        ent->txn->xid = xid;\r\n        txn = ent->txn;\r\n        txn->first_lsn = lsn;\r\n        txn->restart_decoding_lsn = rb->current_restart_decoding_lsn;\r\n\r\n        if (create_as_top) {\r\n            dlist_push_tail(&rb->toplevel_by_lsn, &txn->node);\r\n            AssertTXNLsnOrder(rb);\r\n        }\r\n    } else {\r\n        txn = NULL; /* not found and not asked to create */\r\n    }\r\n\r\n    /* update cache */\r\n    rb->by_txn_last_xid = xid;\r\n    rb->by_txn_last_txn = txn;\r\n\r\n    if (is_new != NULL) {\r\n        *is_new = !found;\r\n    }\r\n\r\n    return txn;\r\n}",
		"comment":"/*\r\n * Return the ReorderBufferTXN from the given buffer, specified by Xid.\r\n * If create is true, and a transaction doesn't already exist, create it\r\n * (with the given LSN, and as top transaction if that's specified);\r\n * when this happens, is_new is set to true.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferTXNByXid"
	},
	"ReorderBufferToastAppendChunk":{
		"body":"static void ReorderBufferToastAppendChunk(\r\n    ReorderBuffer* rb, ReorderBufferTXN* txn, Relation relation, ReorderBufferChange* change)\r\n{\r\n    ReorderBufferToastEnt* ent = NULL;\r\n    ReorderBufferTupleBuf* newtup = NULL;\r\n    bool found = false;\r\n    int32 chunksize = 0;\r\n    bool isnull = false;\r\n    Pointer chunk = NULL;\r\n    TupleDesc desc = RelationGetDescr(relation);\r\n    Oid chunk_id = InvalidOid;\r\n    Oid chunk_seq = InvalidOid;\r\n\r\n    if (txn->toast_hash == NULL) {\r\n        ReorderBufferToastInitHash(rb, txn);\r\n    }\r\n\r\n    Assert(IsToastRelation(relation));\r\n\r\n    newtup = change->data.tp.newtuple;\r\n    chunk_id = DatumGetObjectId(fastgetattr(&newtup->tuple, 1, desc, &isnull));\r\n    Assert(!isnull);\r\n    chunk_seq = DatumGetInt32(fastgetattr(&newtup->tuple, 2, desc, &isnull));\r\n    Assert(!isnull);\r\n\r\n    ent = (ReorderBufferToastEnt*)hash_search(txn->toast_hash, (void*)&chunk_id, HASH_ENTER, &found);\r\n\r\n    if (!found) {\r\n        Assert(ent->chunk_id == chunk_id);\r\n        ent->num_chunks = 0;\r\n        ent->last_chunk_seq = 0;\r\n        ent->size = 0;\r\n        ent->reconstructed = NULL;\r\n        dlist_init(&ent->chunks);\r\n\r\n        if (chunk_seq != 0) {\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\r\n                    errmsg(\"got sequence entry %u for toast chunk %u instead of seq 0\", chunk_seq, chunk_id)));\r\n        }\r\n    } else if (found && chunk_seq != (Oid)ent->last_chunk_seq + 1) {\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\r\n                errmsg(\"got sequence entry %u for toast chunk %u instead of seq %d\",\r\n                    chunk_seq,\r\n                    chunk_id,\r\n                    ent->last_chunk_seq + 1)));\r\n    }\r\n\r\n    chunk = DatumGetPointer(fastgetattr(&newtup->tuple, 3, desc, &isnull));\r\n    Assert(!isnull);\r\n    if (isnull) {\r\n        ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"fail to get toast chunk\")));\r\n    }\r\n\r\n    /* calculate size so we can allocate the right size at once later */\r\n    if (!VARATT_IS_EXTENDED(chunk)) {\r\n        chunksize = VARSIZE(chunk) - VARHDRSZ;\r\n    } else if (VARATT_IS_SHORT(chunk)) {\r\n        /* could happen due to heap_form_tuple doing its thing */\r\n        chunksize = VARSIZE_SHORT(chunk) - VARHDRSZ_SHORT;\r\n    } else {\r\n        ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"unexpected type of toast chunk\")));\r\n    }\r\n\r\n    ent->size += chunksize;\r\n    ent->last_chunk_seq = chunk_seq;\r\n    ent->num_chunks++;\r\n    dlist_push_tail(&ent->chunks, &change->node);\r\n}",
		"comment":"/*\r\n * Per toast-chunk handling for toast reconstruction\r\n *\r\n * Appends a toast chunk so we can reconstruct it when the tuple \"owning\" the\r\n * toasted Datum comes along.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferToastAppendChunk"
	},
	"ReorderBufferToastInitHash":{
		"body":"static void ReorderBufferToastInitHash(ReorderBuffer* rb, ReorderBufferTXN* txn)\r\n{\r\n    HASHCTL hash_ctl;\r\n    int rc = 0;\r\n    Assert(txn->toast_hash == NULL);\r\n\r\n    rc = memset_s(&hash_ctl, sizeof(hash_ctl), 0, sizeof(hash_ctl));\r\n    securec_check(rc, \"\", \"\");\r\n\r\n    hash_ctl.keysize = sizeof(Oid);\r\n    hash_ctl.entrysize = sizeof(ReorderBufferToastEnt);\r\n    hash_ctl.hash = tag_hash;\r\n    hash_ctl.hcxt = rb->context;\r\n    txn->toast_hash = hash_create(\"ReorderBufferToastHash\", 5, &hash_ctl, HASH_ELEM | HASH_FUNCTION | HASH_CONTEXT);\r\n}",
		"comment":"/* ---------------------------------------\r\n * toast reassembly support\r\n * ---------------------------------------\r\n *\r\n *\r\n * Initialize per tuple toast reconstruction support.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferToastInitHash"
	},
	"ReorderBufferToastReplace":{
		"body":"static void ReorderBufferToastReplace(ReorderBuffer* rb, ReorderBufferTXN* txn, Relation relation,\r\n    ReorderBufferChange* change, Oid partationReltoastrelid)\r\n{\r\n    TupleDesc desc = NULL;\r\n    int natt = 0;\r\n    Datum* attrs = NULL;\r\n    bool* isnull = NULL;\r\n    bool* free = NULL;\r\n    HeapTuple tmphtup = NULL;\r\n    Relation toast_rel = NULL;\r\n    TupleDesc toast_desc = NULL;\r\n    MemoryContext oldcontext = NULL;\r\n    ReorderBufferTupleBuf* newtup = NULL;\r\n    const int toast_index = 3; /* toast index in tuple is 3 */\r\n    int rc = 0;\r\n    /* no toast tuples changed */\r\n    if (txn->toast_hash == NULL)\r\n        return;\r\n\r\n    oldcontext = MemoryContextSwitchTo(rb->context);\r\n\r\n    /* we should only have toast tuples in an INSERT or UPDATE */\r\n    Assert(change->data.tp.newtuple);\r\n\r\n    desc = RelationGetDescr(relation);\r\n    if (relation->rd_rel->reltoastrelid != InvalidOid)\r\n        toast_rel = RelationIdGetRelation(relation->rd_rel->reltoastrelid);\r\n    else\r\n        toast_rel = RelationIdGetRelation(partationReltoastrelid);\r\n    if (toast_rel == NULL) {\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_LOGICAL_DECODE_ERROR), errmodule(MOD_MEM), errmsg(\"toast_rel should not be NULL!\")));\r\n    }\r\n    toast_desc = RelationGetDescr(toast_rel);\r\n\r\n    /* should we allocate from stack instead? */\r\n    attrs = (Datum*)palloc0(sizeof(Datum) * desc->natts);\r\n    isnull = (bool*)palloc0(sizeof(bool) * desc->natts);\r\n    free = (bool*)palloc0(sizeof(bool) * desc->natts);\r\n\r\n    newtup = change->data.tp.newtuple;\r\n\r\n    heap_deform_tuple(&newtup->tuple, desc, attrs, isnull);\r\n\r\n    for (natt = 0; natt < desc->natts; natt++) {\r\n        Form_pg_attribute attr = desc->attrs[natt];\r\n        ReorderBufferToastEnt* ent = NULL;\r\n        struct varlena* varlena = NULL;\r\n\r\n        /* va_rawsize is the size of the original datum -- including header */\r\n        struct varatt_external toast_pointer;\r\n        struct varatt_indirect redirect_pointer;\r\n        struct varlena* new_datum = NULL;\r\n        struct varlena* reconstructed = NULL;\r\n        dlist_iter it;\r\n        Size data_done = 0;\r\n        int2 bucketid;\r\n\r\n        /* system columns aren't toasted */\r\n        if (attr->attnum < 0)\r\n            continue;\r\n\r\n        if (attr->attisdropped)\r\n            continue;\r\n\r\n        /* not a varlena datatype */\r\n        if (attr->attlen != -1)\r\n            continue;\r\n\r\n        /* no data */\r\n        if (isnull[natt])\r\n            continue;\r\n\r\n        /* ok, we know we have a toast datum */\r\n        varlena = (struct varlena*)DatumGetPointer(attrs[natt]);\r\n        /* no need to do anything if the tuple isn't external */\r\n        if (!VARATT_IS_EXTERNAL(varlena))\r\n            continue;\r\n\r\n        VARATT_EXTERNAL_GET_POINTER_B(toast_pointer, varlena, bucketid);\r\n\r\n        /*\r\n         * Check whether the toast tuple changed, replace if so.\r\n         */\r\n        ent = (ReorderBufferToastEnt*)hash_search(txn->toast_hash, (void*)&toast_pointer.va_valueid, HASH_FIND, NULL);\r\n        if (ent == NULL)\r\n            continue;\r\n\r\n        new_datum = (struct varlena*)palloc0(INDIRECT_POINTER_SIZE);\r\n\r\n        free[natt] = true;\r\n\r\n        reconstructed = (struct varlena*)palloc0(toast_pointer.va_rawsize);\r\n\r\n        ent->reconstructed = reconstructed;\r\n\r\n        /* stitch toast tuple back together from its parts */\r\n        dlist_foreach(it, &ent->chunks)\r\n        {\r\n            bool isnul = false;\r\n            ReorderBufferChange* cchange = NULL;\r\n            ReorderBufferTupleBuf* ctup = NULL;\r\n            Pointer chunk = NULL;\r\n\r\n            cchange = dlist_container(ReorderBufferChange, node, it.cur);\r\n            ctup = cchange->data.tp.newtuple;\r\n            chunk = DatumGetPointer(fastgetattr(&ctup->tuple, toast_index, toast_desc, &isnul));\r\n\r\n            Assert(!isnul);\r\n            Assert(!VARATT_IS_EXTERNAL(chunk));\r\n            Assert(!VARATT_IS_SHORT(chunk));\r\n            if (chunk == NULL)\r\n                continue;\r\n            rc = memcpy_s(VARDATA(reconstructed) + data_done,\r\n                VARSIZE(chunk) - VARHDRSZ,\r\n                VARDATA(chunk),\r\n                VARSIZE(chunk) - VARHDRSZ);\r\n            securec_check(rc, \"\", \"\");\r\n            data_done += VARSIZE(chunk) - VARHDRSZ;\r\n        }\r\n        Assert(data_done == (Size)toast_pointer.va_extsize);\r\n\r\n        /* make sure its marked as compressed or not */\r\n        if (VARATT_EXTERNAL_IS_COMPRESSED(toast_pointer))\r\n            SET_VARSIZE_COMPRESSED(reconstructed, data_done + VARHDRSZ);\r\n        else\r\n            SET_VARSIZE(reconstructed, data_done + VARHDRSZ);\r\n\r\n        rc = memset_s(&redirect_pointer, sizeof(redirect_pointer), 0, sizeof(redirect_pointer));\r\n        securec_check(rc, \"\", \"\");\r\n        redirect_pointer.pointer = reconstructed;\r\n\r\n        SET_VARTAG_EXTERNAL(new_datum, VARTAG_INDIRECT);\r\n        rc = memcpy_s(\r\n            VARDATA_EXTERNAL(new_datum), sizeof(redirect_pointer), &redirect_pointer, sizeof(redirect_pointer));\r\n        securec_check(rc, \"\", \"\");\r\n\r\n        attrs[natt] = PointerGetDatum(new_datum);\r\n    }\r\n\r\n    /*\r\n     * Build tuple in separate memory & copy tuple back into the tuplebuf\r\n     * passed to the output plugin. We can't directly heap_fill_tuple() into\r\n     * the tuplebuf because attrs[] will point back into the current content.\r\n     */\r\n    tmphtup = heap_form_tuple(desc, attrs, isnull);\r\n    Assert(newtup->tuple.t_len <= MaxHeapTupleSize);\r\n    Assert(ReorderBufferTupleBufData(newtup) == newtup->tuple.t_data);\r\n\r\n    rc = memcpy_s(newtup->tuple.t_data, newtup->alloc_tuple_size, tmphtup->t_data, tmphtup->t_len);\r\n    securec_check(rc, \"\", \"\");\r\n    newtup->tuple.t_len = tmphtup->t_len;\r\n\r\n    /*\r\n     * free resources we won't further need, more persistent stuff will be\r\n     * free'd in ReorderBufferToastReset().\r\n     */\r\n    RelationClose(toast_rel);\r\n    pfree(tmphtup);\r\n    tmphtup = NULL;\r\n    for (natt = 0; natt < desc->natts; natt++) {\r\n        if (free[natt]) {\r\n            pfree(DatumGetPointer(attrs[natt]));\r\n        }\r\n    }\r\n    pfree(attrs);\r\n    attrs = NULL;\r\n    pfree(free);\r\n    free = NULL;\r\n    pfree(isnull);\r\n    isnull = NULL;\r\n\r\n    (void)MemoryContextSwitchTo(oldcontext);\r\n}",
		"comment":"/*\r\n * Rejigger change->newtuple to point to in-memory toast tuples instead to\r\n * on-disk toast tuples that may not longer exist (think DROP TABLE or VACUUM).\r\n *\r\n * We cannot replace unchanged toast tuples though, so those will still point\r\n * to on-disk toast data.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferToastReplace"
	},
	"ReorderBufferToastReset":{
		"body":"static void ReorderBufferToastReset(ReorderBuffer* rb, ReorderBufferTXN* txn)\r\n{\r\n    HASH_SEQ_STATUS hstat;\r\n    ReorderBufferToastEnt* ent = NULL;\r\n\r\n    if (txn->toast_hash == NULL) {\r\n        return;\r\n    }\r\n\r\n    /* sequentially walk over the hash and free everything */\r\n    hash_seq_init(&hstat, txn->toast_hash);\r\n    while ((ent = (ReorderBufferToastEnt*)hash_seq_search(&hstat)) != NULL) {\r\n        dlist_mutable_iter it;\r\n\r\n        if (ent->reconstructed != NULL) {\r\n            pfree(ent->reconstructed);\r\n            ent->reconstructed = NULL;\r\n        }\r\n\r\n        dlist_foreach_modify(it, &ent->chunks)\r\n        {\r\n            ReorderBufferChange* change = dlist_container(ReorderBufferChange, node, it.cur);\r\n\r\n            dlist_delete(&change->node);\r\n            ReorderBufferReturnChange(rb, change);\r\n        }\r\n    }\r\n\r\n    hash_destroy(txn->toast_hash);\r\n    txn->toast_hash = NULL;\r\n}",
		"comment":"/*\r\n * Free all resources allocated for toast reconstruction.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferToastReset"
	},
	"ReorderBufferTransferSnapToParent":{
		"body":"static void ReorderBufferTransferSnapToParent(ReorderBufferTXN* txn, ReorderBufferTXN* subtxn)\r\n{\r\n    Assert(subtxn->toplevel_xid == txn->xid);\r\n\r\n    if (subtxn->base_snapshot != NULL) {\r\n        if (txn->base_snapshot == NULL || subtxn->base_snapshot_lsn < txn->base_snapshot_lsn) {\r\n            /*\r\n             * If the toplevel transaction already has a base snapshot but\r\n             * it's newer than the subxact's, purge it.\r\n             */\r\n            if (txn->base_snapshot != NULL) {\r\n                SnapBuildSnapDecRefcount(txn->base_snapshot);\r\n                dlist_delete(&txn->base_snapshot_node);\r\n            }\r\n\r\n            /*\r\n             * The snapshot is now the top transaction's; transfer it, and\r\n             * adjust the list position of the top transaction in the list by\r\n             * moving it to where the subtransaction is.\r\n             */\r\n            txn->base_snapshot = subtxn->base_snapshot;\r\n            txn->base_snapshot_lsn = subtxn->base_snapshot_lsn;\r\n            dlist_insert_before(&subtxn->base_snapshot_node, &txn->base_snapshot_node);\r\n\r\n            /*\r\n             * The subtransaction doesn't have a snapshot anymore (so it\r\n             * mustn't be in the list.)\r\n             */\r\n            subtxn->base_snapshot = NULL;\r\n            subtxn->base_snapshot_lsn = InvalidXLogRecPtr;\r\n            dlist_delete(&subtxn->base_snapshot_node);\r\n        } else {\r\n            /* Base snap of toplevel is fine, so subxact's is not needed */\r\n            SnapBuildSnapDecRefcount(subtxn->base_snapshot);\r\n            dlist_delete(&subtxn->base_snapshot_node);\r\n            subtxn->base_snapshot = NULL;\r\n            subtxn->base_snapshot_lsn = InvalidXLogRecPtr;\r\n        }\r\n    }\r\n}",
		"comment":"/*\r\n * ReorderBufferTransferSnapToParent\r\n *     Transfer base snapshot from subtxn to top-level txn, if needed\r\n *\r\n * This is done if the top-level txn doesn't have a base snapshot, or if the\r\n * subtxn's base snapshot has an earlier LSN than the top-level txn's base\r\n * snapshot's LSN.  This can happen if there are no changes in the toplevel\r\n * txn but there are some in the subtxn, or the first change in subtxn has\r\n * earlier LSN than first change in the top-level txn and we learned about\r\n * their kinship only now.\r\n *\r\n * The subtransaction's snapshot is cleared regardless of the transfer\r\n * happening, since it's not needed anymore in either case.\r\n *\r\n * We do this as soon as we become aware of their kinship, to avoid queueing\r\n * extra snapshots to txns known-as-subtxns -- only top-level txns will\r\n * receive further snapshots.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferTransferSnapToParent"
	},
	"ReorderBufferXidHasBaseSnapshot":{
		"body":"bool ReorderBufferXidHasBaseSnapshot(ReorderBuffer* rb, TransactionId xid)\r\n{\r\n    ReorderBufferTXN* txn = NULL;\r\n\r\n    txn = ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr, false);\r\n    /* transaction isn't known yet, ergo no snapshot */\r\n    if (txn == NULL)\r\n        return false;\r\n\r\n    /* a known subtxn? operate on top-level txn instead */\r\n    if (txn->is_known_as_subxact) {\r\n        txn = ReorderBufferTXNByXid(rb, txn->toplevel_xid, false, NULL, InvalidXLogRecPtr, false);\r\n        if (txn == NULL) {\r\n            return false;\r\n        }\r\n    }\r\n    return txn->base_snapshot != NULL;\r\n}",
		"comment":"/*\r\n * ReorderBufferXidHasBaseSnapshot\r\n *     Have we already set the base snapshot for the given txn/subtxn?\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferXidHasBaseSnapshot"
	},
	"ReorderBufferXidHasCatalogChanges":{
		"body":"bool ReorderBufferXidHasCatalogChanges(ReorderBuffer* rb, TransactionId xid)\r\n{\r\n    ReorderBufferTXN* txn = NULL;\r\n\r\n    txn = ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr, false);\r\n    if (txn == NULL)\r\n        return false;\r\n\r\n    return txn->has_catalog_changes;\r\n}",
		"comment":"/*\r\n * Query whether a transaction is already *known* to contain catalog\r\n * changes. This can be wrong until directly before the commit!\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferXidHasCatalogChanges"
	},
	"ReorderBufferXidSetCatalogChanges":{
		"body":"void ReorderBufferXidSetCatalogChanges(ReorderBuffer* rb, TransactionId xid, XLogRecPtr lsn)\r\n{\r\n    ReorderBufferTXN* txn = NULL;\r\n\r\n    /* When the thirdly parameter 'create' is true, the ret value must not be NULL. */\r\n    txn = ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true);\r\n    Assert(txn != NULL);\r\n    txn->has_catalog_changes = true;\r\n}",
		"comment":"/*\r\n * Mark a transaction as containing catalog changes\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ReorderBufferXidSetCatalogChanges"
	},
	"ResolveCminCmaxDuringDecoding":{
		"body":"bool ResolveCminCmaxDuringDecoding(\r\n    HTAB* tuplecid_data, Snapshot snapshot, HeapTuple htup, Buffer buffer, CommandId* cmin, CommandId* cmax)\r\n{\r\n    ReorderBufferTupleCidKey key;\r\n    ReorderBufferTupleCidEnt* ent = NULL;\r\n    ForkNumber forkno = InvalidForkNumber;\r\n    BlockNumber blockno = InvalidBlockNumber;\r\n    bool updated_mapping = false;\r\n    int rc = 0;\r\n    /* be careful about padding */\r\n    rc = memset_s(&key, sizeof(key), 0, sizeof(key));\r\n    securec_check(rc, \"\", \"\");\r\n\r\n    Assert(!BufferIsLocal(buffer));\r\n\r\n    /*\r\n     * get relfilenode from the buffer, no convenient way to access it other\r\n     * than that.\r\n     */\r\n    BufferGetTag(buffer, &key.relnode, &forkno, &blockno);\r\n\r\n    /* tuples can only be in the main fork */\r\n    Assert(forkno == MAIN_FORKNUM);\r\n    Assert(blockno == ItemPointerGetBlockNumber(&htup->t_self));\r\n\r\n    ItemPointerCopy(&htup->t_self, &key.tid);\r\n\r\nrestart:\r\n    ent = (ReorderBufferTupleCidEnt*)hash_search(tuplecid_data, (void*)&key, HASH_FIND, NULL);\r\n\r\n    /*\r\n     * failed to find a mapping, check whether the table was rewritten and\r\n     * apply mapping if so, but only do that once - there can be no new\r\n     * mappings while we are in here since we have to hold a lock on the\r\n     * relation.\r\n     */\r\n    if (ent == NULL && !updated_mapping) {\r\n        UpdateLogicalMappings(tuplecid_data, htup->t_tableOid, snapshot);\r\n        /* now check but don't update for a mapping again */\r\n        updated_mapping = true;\r\n        goto restart;\r\n    } else if (ent == NULL)\r\n        return false;\r\n\r\n    if (cmin != NULL)\r\n        *cmin = ent->cmin;\r\n    if (cmax != NULL)\r\n        *cmax = ent->cmax;\r\n    return true;\r\n}",
		"comment":"/*\r\n * Lookup cmin/cmax of a tuple, during logical decoding where we can't rely on\r\n * combocids.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"ResolveCminCmaxDuringDecoding"
	},
	"StartupReorderBuffer":{
		"body":"void StartupReorderBuffer(void)\r\n{\r\n    DIR* logical_dir = NULL;\r\n    struct dirent* logical_de = NULL;\r\n\r\n    DIR* spill_dir = NULL;\r\n    struct dirent* spill_de = NULL;\r\n    int rc = 0;\r\n    logical_dir = AllocateDir(\"pg_replslot\");\r\n    while ((logical_de = ReadDir(logical_dir, \"pg_replslot\")) != NULL) {\r\n        struct stat statbuf;\r\n        char path[MAXPGPATH];\r\n\r\n        if (strcmp(logical_de->d_name, \".\") == 0 || strcmp(logical_de->d_name, \"..\") == 0)\r\n            continue;\r\n\r\n        /* if it cannot be a slot, skip the directory */\r\n        if (!ReplicationSlotValidateName(logical_de->d_name, DEBUG2))\r\n            continue;\r\n\r\n        /*\r\n         * ok, has to be a surviving logical slot, iterate and delete\r\n         * everythign starting with xid-*\r\n         */\r\n        rc = sprintf_s(path, sizeof(path), \"pg_replslot/%s\", logical_de->d_name);\r\n        securec_check_ss(rc, \"\", \"\");\r\n        /* we're only creating directories here, skip if it's not our's */\r\n        if (lstat(path, &statbuf) == 0 && !S_ISDIR(statbuf.st_mode))\r\n            continue;\r\n\r\n        spill_dir = AllocateDir(path);\r\n        while ((spill_de = ReadDir(spill_dir, path)) != NULL) {\r\n            if (strcmp(spill_de->d_name, \".\") == 0 || strcmp(spill_de->d_name, \"..\") == 0)\r\n                continue;\r\n\r\n            /* only look at names that can be ours */\r\n            if (strncmp(spill_de->d_name, \"xid\", 3) == 0) {\r\n                rc = sprintf_s(path, sizeof(path), \"pg_replslot/%s/%s\", logical_de->d_name, spill_de->d_name);\r\n                securec_check_ss(rc, \"\", \"\");\r\n                if (unlink(path) != 0)\r\n                    ereport(PANIC, (errcode_for_file_access(), errmsg(\"could not unlink file \\\"%s\\\": %m\", path)));\r\n            }\r\n        }\r\n        (void)FreeDir(spill_dir);\r\n    }\r\n    (void)FreeDir(logical_dir);\r\n}",
		"comment":"/*\r\n * Delete all data spilled to disk after we've restarted/crashed. It will be\r\n * recreated when the respective slots are reused.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"StartupReorderBuffer"
	},
	"TransactionIdInArray":{
		"body":"static bool TransactionIdInArray(TransactionId xid, TransactionId* xip, Size num)\r\n{\r\n    return bsearch(&xid, xip, num, sizeof(TransactionId), xidComparator) != NULL;\r\n}",
		"comment":"/*\r\n * Check whether the TransactionOId 'xid' is in the pre-sorted array 'xip'.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"TransactionIdInArray"
	},
	"UpdateLogicalMappings":{
		"body":"static void UpdateLogicalMappings(HTAB* tuplecid_data, Oid relid, Snapshot snapshot)\r\n{\r\n    DIR* mapping_dir = NULL;\r\n    struct dirent* mapping_de = NULL;\r\n    List* files = NIL;\r\n    ListCell* file = NULL;\r\n    RewriteMappingFile** files_a = NULL;\r\n    int off = 0;\r\n    Oid dboid = IsSharedRelation(relid) ? InvalidOid : u_sess->proc_cxt.MyDatabaseId;\r\n    int rc = 0;\r\n    mapping_dir = AllocateDir(\"pg_llog/mappings\");\r\n    while ((mapping_de = ReadDir(mapping_dir, \"pg_llog/mappings\")) != NULL) {\r\n        Oid f_dboid;\r\n        Oid f_relid;\r\n        TransactionId f_mapped_xid;\r\n        TransactionId f_create_xid;\r\n        XLogRecPtr f_lsn;\r\n        uint32 f_hi, f_lo;\r\n        RewriteMappingFile* f = 0;\r\n\r\n        if (strcmp(mapping_de->d_name, \".\") == 0 || strcmp(mapping_de->d_name, \"..\") == 0) {\r\n            continue;\r\n        }\r\n\r\n        /* Ignore files that aren't ours */\r\n        if (strncmp(mapping_de->d_name, \"map-\", 4) != 0) {\r\n            continue;\r\n        }\r\n\r\n        if (sscanf_s(mapping_de->d_name, LOGICAL_REWRITE_FORMAT, &f_dboid, &f_relid, &f_hi, &f_lo, &f_mapped_xid,\r\n            &f_create_xid) != 6) {\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"could not parse fname %s\", mapping_de->d_name)));\r\n        }\r\n\r\n        f_lsn = (((uint64)f_hi) << 32) + f_lo;\r\n\r\n        /* mapping for another database */\r\n        if (f_dboid != dboid)\r\n            continue;\r\n\r\n        /* mapping for another relation */\r\n        if (f_relid != relid)\r\n            continue;\r\n\r\n        /* did the creating transaction abort? */\r\n        if (!TransactionIdDidCommit(f_create_xid))\r\n            continue;\r\n\r\n        /* not for our transaction */\r\n        if (!TransactionIdInArray(f_mapped_xid, snapshot->subxip, snapshot->subxcnt))\r\n            continue;\r\n\r\n        /* ok, relevant, queue for apply */\r\n        f = (RewriteMappingFile*)palloc(sizeof(RewriteMappingFile));\r\n        f->lsn = f_lsn;\r\n        rc = strcpy_s(f->fname, MAXPGPATH, mapping_de->d_name);\r\n        securec_check(rc, \"\", \"\");\r\n        files = lappend(files, f);\r\n    }\r\n    (void)FreeDir(mapping_dir);\r\n\r\n    /* build array we can easily sort */\r\n    files_a = (RewriteMappingFile**)palloc(list_length(files) * sizeof(RewriteMappingFile*));\r\n    off = 0;\r\n    foreach (file, files) {\r\n        files_a[off++] = (RewriteMappingFile*)lfirst(file);\r\n    }\r\n\r\n    /* sort files so we apply them in LSN order */\r\n    qsort(files_a, list_length(files), sizeof(RewriteMappingFile*), file_sort_by_lsn);\r\n\r\n    for (off = 0; off < list_length(files); off++) {\r\n        RewriteMappingFile* f = files_a[off];\r\n        if (!RecoveryInProgress())\r\n            ereport(DEBUG1, (errmsg(\"applying mapping: %s in %lu\", f->fname, snapshot->subxip[0])));\r\n        ApplyLogicalMappingFile(tuplecid_data, relid, f->fname);\r\n        pfree(f);\r\n        f = NULL;\r\n    }\r\n}",
		"comment":"/*\r\n * Apply any existing logical remapping files if there are any targeted at our\r\n * transaction for relid.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"UpdateLogicalMappings"
	},
	"file_sort_by_lsn":{
		"body":"static int file_sort_by_lsn(const void* a_p, const void* b_p)\r\n{\r\n    RewriteMappingFile* a = *(RewriteMappingFile**)a_p;\r\n    RewriteMappingFile* b = *(RewriteMappingFile**)b_p;\r\n\r\n    if (XLByteLT(a->lsn, b->lsn))\r\n        return -1;\r\n    else if (XLByteLT(b->lsn, a->lsn))\r\n        return 1;\r\n    return 0;\r\n}",
		"comment":"/*\r\n * qsort() comparator for sorting RewriteMappingFiles in LSN order.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\reorderbuffer.cpp",
		"name":"file_sort_by_lsn"
	}
}