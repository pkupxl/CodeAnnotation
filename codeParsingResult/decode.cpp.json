{
	"DecodeAbort":{
		"body":"static void DecodeAbort(\r\n    LogicalDecodingContext* ctx, XLogRecPtr lsn, TransactionId xid, TransactionId* sub_xids, int nsubxacts)\r\n{\r\n    int i;\r\n\r\n    for (i = 0; i < nsubxacts; i++) {\r\n        ReorderBufferAbort(ctx->reorder, *sub_xids, lsn);\r\n        sub_xids++;\r\n    }\r\n\r\n    ReorderBufferAbort(ctx->reorder, xid, lsn);\r\n}",
		"comment":"/*\r\n * Get the data from the various forms of abort records and pass it on to\r\n * snapbuild.c and reorderbuffer.c\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\decode.cpp",
		"name":"DecodeAbort"
	},
	"DecodeCommit":{
		"body":"static void DecodeCommit(LogicalDecodingContext* ctx, XLogRecordBuffer* buf, TransactionId xid, CommitSeqNo csn,\r\n    Oid dboid, TimestampTz commit_time, int nsubxacts, TransactionId* sub_xids, int ninval_msgs,\r\n    SharedInvalidationMessage* msgs)\r\n{\r\n    int i;\r\n    XLogRecPtr origin_id = XLogRecGetOrigin(buf->record);\r\n\r\n    /*\r\n     * Process invalidation messages, even if we're not interested in the\r\n     * transaction's contents, since the various caches need to always be\r\n     * consistent.\r\n     */\r\n    if (ninval_msgs > 0) {\r\n        if (!ctx->fast_forward)\r\n            ReorderBufferAddInvalidations(ctx->reorder, xid, buf->origptr, ninval_msgs, msgs);\r\n        ReorderBufferXidSetCatalogChanges(ctx->reorder, xid, buf->origptr);\r\n    }\r\n\r\n    SnapBuildCommitTxn(ctx->snapshot_builder, buf->origptr, xid, nsubxacts, sub_xids);\r\n\r\n    /* ----\r\n     * Check whether we are interested in this specific transaction, and tell\r\n     * the reorderbuffer to forget the content of the (sub-)transactions\r\n     * if not.\r\n     *\r\n     * There basically two reasons we might not be interested in this\r\n     * transaction:\r\n     * 1) We might not be interested in decoding transactions up to this\r\n     *	LSN. This can happen because we previously decoded it and now just\r\n     *	are restarting or if we haven't assembled a consistent snapshot yet.\r\n     * 2) The transaction happened in another database.\r\n     *\r\n     * 4) We are doing fast-forwarding\r\n\r\n     * We can't just use ReorderBufferAbort() here, because we need to execute\r\n     * the transaction's invalidations.  This currently won't be needed if\r\n     * we're just skipping over the transaction because currently we only do\r\n     * so during startup, to get to the first transaction the client needs. As\r\n     * we have reset the catalog caches before starting to read WAL, and we\r\n     * haven't yet touched any catalogs, there can't be anything to invalidate.\r\n     * But if we're \"forgetting\" this commit because it's it happened in\r\n     * another database, the invalidations might be important, because they\r\n     * could be for shared catalogs and we might have loaded data into the\r\n     * relevant syscaches.\r\n     * ---\r\n     */\r\n    if (SnapBuildXactNeedsSkip(ctx->snapshot_builder, buf->origptr) ||\r\n        (dboid != InvalidOid && dboid != ctx->slot->data.database) || ctx->fast_forward ||\r\n        FilterByOrigin(ctx, origin_id)) {\r\n        for (i = 0; i < nsubxacts; i++) {\r\n            ReorderBufferForget(ctx->reorder, *sub_xids, buf->origptr);\r\n            sub_xids++;\r\n        }\r\n        ReorderBufferForget(ctx->reorder, xid, buf->origptr);\r\n\r\n        return;\r\n    }\r\n\r\n    /* tell the reorderbuffer about the surviving subtransactions */\r\n    for (i = 0; i < nsubxacts; i++) {\r\n        ReorderBufferCommitChild(ctx->reorder, xid, *sub_xids, buf->origptr, buf->endptr);\r\n        sub_xids++;\r\n    }\r\n\r\n    /* replay actions of all transaction + subtransactions in order */\r\n    ReorderBufferCommit(ctx->reorder, xid, buf->origptr, buf->endptr, origin_id, csn, commit_time);\r\n}",
		"comment":"/*\r\n * Consolidated commit record handling between the different form of commit\r\n * records.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\decode.cpp",
		"name":"DecodeCommit"
	},
	"DecodeDelete":{
		"body":"static void DecodeDelete(LogicalDecodingContext* ctx, XLogRecordBuffer* buf)\r\n{\r\n    XLogReaderState* r = buf->record;\r\n    xl_heap_delete* xlrec = NULL;\r\n    ReorderBufferChange* change = NULL;\r\n    RelFileNode target_node;\r\n    int rc = 0;\r\n    xlrec = (xl_heap_delete*)GetXlrec(r);\r\n\r\n    /* only interested in our database */\r\n    XLogRecGetBlockTag(r, 0, &target_node, NULL, NULL);\r\n    if (target_node.dbNode != ctx->slot->data.database)\r\n        return;\r\n    /* output plugin doesn't look for this origin, no need to queue */\r\n    if (FilterByOrigin(ctx, XLogRecGetOrigin(r)))\r\n        return;\r\n\r\n    Size datalen = XLogRecGetDataLen(r) - SizeOfHeapDelete;\r\n    if (datalen == 0 && !AllocSizeIsValid(datalen)) {\r\n        ereport(WARNING, (errmsg(\"tuplelen is invalid(%lu), tuplelen, don't decode it\", datalen)));\r\n        return;\r\n    }\r\n    change = ReorderBufferGetChange(ctx->reorder);\r\n    change->action = REORDER_BUFFER_CHANGE_DELETE;\r\n    change->origin_id = XLogRecGetOrigin(r);\r\n    rc = memcpy_s(&change->data.tp.relnode, sizeof(RelFileNode), &target_node, sizeof(RelFileNode));\r\n    securec_check(rc, \"\", \"\");\r\n\r\n    /* old primary key stored */\r\n    if (xlrec->flags & XLOG_HEAP_CONTAINS_OLD) {\r\n        Assert(XLogRecGetDataLen(r) > (SizeOfHeapDelete + SizeOfHeapHeader));\r\n        change->data.tp.oldtuple = ReorderBufferGetTupleBuf(ctx->reorder, datalen);\r\n\r\n        DecodeXLogTuple((char*)xlrec + SizeOfHeapDelete, datalen, change->data.tp.oldtuple);\r\n    }\r\n    change->data.tp.clear_toast_afterwards = true;\r\n\r\n    ReorderBufferQueueChange(ctx->reorder, XLogRecGetXid(r), buf->origptr, change);\r\n}",
		"comment":"/*\r\n * Parse XLOG_HEAP_DELETE from wal into proper tuplebufs.\r\n *\r\n * Deletes can possibly contain the old primary key.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\decode.cpp",
		"name":"DecodeDelete"
	},
	"DecodeHeap2Op":{
		"body":"static void DecodeHeap2Op(LogicalDecodingContext* ctx, XLogRecordBuffer* buf)\r\n{\r\n    uint8 info = XLogRecGetInfo(buf->record) & XLOG_HEAP_OPMASK;\r\n    TransactionId xid = XLogRecGetXid(buf->record);\r\n    SnapBuild* builder = ctx->snapshot_builder;\r\n\r\n    ReorderBufferProcessXid(ctx->reorder, xid, buf->origptr);\r\n\r\n    /*\r\n     * If we don't have snapshot or we are just fast-forwarding, there is no\r\n     * point in decoding changes.\r\n     */\r\n    if (SnapBuildCurrentState(builder) < SNAPBUILD_FULL_SNAPSHOT || ctx->fast_forward)\r\n        return;\r\n\r\n    switch (info) {\r\n        case XLOG_HEAP2_MULTI_INSERT:\r\n            if (!ctx->fast_forward && SnapBuildProcessChange(builder, xid, buf->origptr))\r\n                DecodeMultiInsert(ctx, buf);\r\n            break;\r\n        case XLOG_HEAP2_FREEZE:\r\n            /*\r\n             * Although these records only exist to serve the needs of logical\r\n             * decoding, all the work happens as part of crash or archive\r\n             * recovery, so we don't need to do anything here.\r\n             */\r\n            break;\r\n        /*\r\n         * Everything else here is just low level physical stuff we're\r\n         * not interested in.\r\n         */\r\n        case XLOG_HEAP2_CLEAN:\r\n        case XLOG_HEAP2_CLEANUP_INFO:\r\n        case XLOG_HEAP2_VISIBLE:\r\n        case XLOG_HEAP2_LOGICAL_NEWPAGE:\r\n        case XLOG_HEAP2_BCM:\r\n        case XLOG_HEAP2_PAGE_UPGRADE:\r\n\r\n            break;\r\n        default:\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_UNRECOGNIZED_NODE_TYPE), errmsg(\"unexpected RM_HEAP2_ID record type: %u\", info)));\r\n    }\r\n}",
		"comment":"/*\r\n * Handle rmgr HEAP2_ID records for DecodeRecordIntoReorderBuffer().\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\decode.cpp",
		"name":"DecodeHeap2Op"
	},
	"DecodeHeap3Op":{
		"body":"static void DecodeHeap3Op(LogicalDecodingContext* ctx, XLogRecordBuffer* buf)\r\n{\r\n    uint8 info = XLogRecGetInfo(buf->record) & XLOG_HEAP_OPMASK;\r\n    TransactionId xid = XLogRecGetXid(buf->record);\r\n    SnapBuild* builder = ctx->snapshot_builder;\r\n\r\n    ReorderBufferProcessXid(ctx->reorder, xid, buf->origptr);\r\n\r\n    /*\r\n     * If we don't have snapshot or we are just fast-forwarding, there is no\r\n     * point in decoding changes.\r\n     */\r\n    if (SnapBuildCurrentState(builder) < SNAPBUILD_FULL_SNAPSHOT || ctx->fast_forward)\r\n        return;\r\n\r\n    switch (info) {\r\n        case XLOG_HEAP3_NEW_CID: {\r\n            xl_heap_new_cid* xlrec = NULL;\r\n            int bucket_id = 0;\r\n            xlrec = (xl_heap_new_cid*)buf->record_data;\r\n            bucket_id = XLogRecGetBucketId(buf->record);\r\n            SnapBuildProcessNewCid(builder, xid, buf->origptr, xlrec, bucket_id);\r\n\r\n            break;\r\n        }\r\n        case XLOG_HEAP3_REWRITE:\r\n            break;\r\n        default:\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_UNRECOGNIZED_NODE_TYPE), errmsg(\"unexpected RM_HEAP3_ID record type: %u\", info)));\r\n    }\r\n}",
		"comment":"/*\r\n * Handle rmgr HEAP2_ID records for DecodeRecordIntoReorderBuffer().\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\decode.cpp",
		"name":"DecodeHeap3Op"
	},
	"DecodeHeapOp":{
		"body":"static void DecodeHeapOp(LogicalDecodingContext* ctx, XLogRecordBuffer* buf)\r\n{\r\n    uint8 info = XLogRecGetInfo(buf->record) & XLOG_HEAP_OPMASK;\r\n    TransactionId xid = XLogRecGetXid(buf->record);\r\n    SnapBuild* builder = ctx->snapshot_builder;\r\n\r\n    ReorderBufferProcessXid(ctx->reorder, xid, buf->origptr);\r\n\r\n    /*\r\n     * If we don't have snapshot or we are just fast-forwarding, there is no\r\n     * point in decoding data changes.\r\n     */\r\n    if (SnapBuildCurrentState(builder) < SNAPBUILD_FULL_SNAPSHOT || ctx->fast_forward)\r\n        return;\r\n\r\n    switch (info) {\r\n        case XLOG_HEAP_INSERT:\r\n            if (SnapBuildProcessChange(builder, xid, buf->origptr))\r\n                DecodeInsert(ctx, buf);\r\n            break;\r\n\r\n        /*\r\n         * Treat HOT update as normal updates. There is no useful\r\n         * information in the fact that we could make it a HOT update\r\n         * locally and the WAL layout is compatible.\r\n         */\r\n        case XLOG_HEAP_HOT_UPDATE:\r\n        case XLOG_HEAP_UPDATE:\r\n            if (SnapBuildProcessChange(builder, xid, buf->origptr))\r\n                DecodeUpdate(ctx, buf);\r\n            break;\r\n\r\n        case XLOG_HEAP_DELETE:\r\n            if (SnapBuildProcessChange(builder, xid, buf->origptr))\r\n                DecodeDelete(ctx, buf);\r\n            break;\r\n\r\n        case XLOG_HEAP_NEWPAGE:\r\n            /*\r\n             * This is only used in places like indexams and CLUSTER which\r\n             * don't contain changes relevant for logical replication.\r\n             */\r\n            break;\r\n\r\n        case XLOG_HEAP_INPLACE:\r\n            /*\r\n             * Inplace updates are only ever performed on catalog tuples and\r\n             * can, per definition, not change tuple visibility.  Since we\r\n             * don't decode catalog tuples, we're not interested in the\r\n             * record's contents.\r\n             *\r\n             * In-place updates can be used either by XID-bearing transactions\r\n             * (e.g.  in CREATE INDEX CONCURRENTLY) or by XID-less\r\n             * transactions (e.g.  VACUUM).  In the former case, the commit\r\n             * record will include cache invalidations, so we mark the\r\n             * transaction as catalog modifying here. Currently that's\r\n             * redundant because the commit will do that as well, but once we\r\n             * support decoding in-progress relations, this will be important.\r\n             */\r\n            if (!TransactionIdIsValid(xid))\r\n                break;\r\n\r\n            SnapBuildProcessChange(builder, xid, buf->origptr);\r\n            ReorderBufferXidSetCatalogChanges(ctx->reorder, xid, buf->origptr);\r\n            break;\r\n\r\n        case XLOG_HEAP_LOCK:\r\n            /* we don't care about row level locks for now */\r\n            break;\r\n\r\n        case XLOG_HEAP_BASE_SHIFT:\r\n            break;\r\n\r\n        default:\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_UNRECOGNIZED_NODE_TYPE), errmsg(\"unexpected RM_HEAP_ID record type: %u\", info)));\r\n            break;\r\n    }\r\n}",
		"comment":"/*\r\n * Handle rmgr HEAP_ID records for DecodeRecordIntoReorderBuffer().\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\decode.cpp",
		"name":"DecodeHeapOp"
	},
	"DecodeInsert":{
		"body":"static void DecodeInsert(LogicalDecodingContext* ctx, XLogRecordBuffer* buf)\r\n{\r\n    XLogReaderState* r = buf->record;\r\n    xl_heap_insert* xlrec = NULL;\r\n    ReorderBufferChange* change = NULL;\r\n    RelFileNode target_node;\r\n    xlrec = (xl_heap_insert*)GetXlrec(r);\r\n    int rc = 0;\r\n    /* only interested in our database */\r\n    Size tuplelen;\r\n    char* tupledata = XLogRecGetBlockData(r, 0, &tuplelen);\r\n    if (tuplelen == 0 && !AllocSizeIsValid(tuplelen)) {\r\n        ereport(WARNING, (errmsg(\"tuplelen is invalid(%lu), tuplelen, don't decode it\", tuplelen)));\r\n        return;\r\n    }\r\n    XLogRecGetBlockTag(r, 0, &target_node, NULL, NULL);\r\n    if (target_node.dbNode != ctx->slot->data.database)\r\n        return;\r\n    /* output plugin doesn't look for this origin, no need to queue */\r\n    if (FilterByOrigin(ctx, XLogRecGetOrigin(r)))\r\n        return;\r\n\r\n    change = ReorderBufferGetChange(ctx->reorder);\r\n    change->action = REORDER_BUFFER_CHANGE_INSERT;\r\n    change->origin_id = XLogRecGetOrigin(r);\r\n    rc = memcpy_s(&change->data.tp.relnode, sizeof(RelFileNode), &target_node, sizeof(RelFileNode));\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n\r\n    if (xlrec->flags & XLOG_HEAP_CONTAINS_NEW_TUPLE) {\r\n        change->data.tp.newtuple = ReorderBufferGetTupleBuf(ctx->reorder, tuplelen);\r\n\r\n        DecodeXLogTuple(tupledata, tuplelen, change->data.tp.newtuple);\r\n    }\r\n\r\n    change->data.tp.clear_toast_afterwards = true;\r\n\r\n    ReorderBufferQueueChange(ctx->reorder, XLogRecGetXid(r), buf->origptr, change);\r\n}",
		"comment":"/*\r\n * Parse XLOG_HEAP_INSERT (not MULTI_INSERT!) records into tuplebufs.\r\n *\r\n * Deletes can contain the new tuple.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\decode.cpp",
		"name":"DecodeInsert"
	},
	"DecodeMultiInsert":{
		"body":"static void DecodeMultiInsert(LogicalDecodingContext* ctx, XLogRecordBuffer* buf)\r\n{\r\n    XLogReaderState* r = buf->record;\r\n    xl_heap_multi_insert* xlrec = NULL;\r\n    int i = 0;\r\n    char* data = NULL;\r\n    char* tupledata = NULL;\r\n    Size tuplelen = 0;\r\n    RelFileNode rnode;\r\n    int rc = 0;\r\n    xlrec = (xl_heap_multi_insert*)GetXlrec(r);\r\n    if (xlrec->isCompressed)\r\n        return;\r\n    /* only interested in our database */\r\n    XLogRecGetBlockTag(r, 0, &rnode, NULL, NULL);\r\n    if (rnode.dbNode != ctx->slot->data.database)\r\n        return;\r\n    /* output plugin doesn't look for this origin, no need to queue */\r\n    if (FilterByOrigin(ctx, XLogRecGetOrigin(r)))\r\n        return;\r\n\r\n    tupledata = XLogRecGetBlockData(r, 0, &tuplelen);\r\n    data = tupledata;\r\n    for (i = 0; i < xlrec->ntuples; i++) {\r\n        ReorderBufferChange* change = NULL;\r\n        xl_multi_insert_tuple* xlhdr = NULL;\r\n        int datalen = 0;\r\n        ReorderBufferTupleBuf* tuple = NULL;\r\n\r\n        change = ReorderBufferGetChange(ctx->reorder);\r\n        change->action = REORDER_BUFFER_CHANGE_INSERT;\r\n        change->origin_id = XLogRecGetOrigin(r);\r\n        rc = memcpy_s(&change->data.tp.relnode, sizeof(RelFileNode), &rnode, sizeof(RelFileNode));\r\n        securec_check(rc, \"\", \"\");\r\n\r\n        /*\r\n         * CONTAINS_NEW_TUPLE will always be set currently as multi_insert\r\n         * isn't used for catalogs, but better be future proof.\r\n         *\r\n         * We decode the tuple in pretty much the same way as DecodeXLogTuple,\r\n         * but since the layout is slightly different, we can't use it here.\r\n         */\r\n        if (xlrec->flags & XLOG_HEAP_CONTAINS_NEW_TUPLE) {\r\n            HeapTupleHeader header;\r\n            xlhdr = (xl_multi_insert_tuple*)data;\r\n            data = ((char*)xlhdr) + SizeOfMultiInsertTuple;\r\n            datalen = xlhdr->datalen;\r\n            if (datalen != 0 && AllocSizeIsValid((uint)datalen)) {\r\n                change->data.tp.newtuple = ReorderBufferGetTupleBuf(ctx->reorder, datalen);\r\n                tuple = change->data.tp.newtuple;\r\n                header = tuple->tuple.t_data;\r\n\r\n                /* not a disk based tuple */\r\n                ItemPointerSetInvalid(&tuple->tuple.t_self);\r\n\r\n                /*\r\n                 * We can only figure this out after reassembling the\r\n                 * transactions.\r\n                 */\r\n                tuple->tuple.t_tableOid = InvalidOid;\r\n                tuple->tuple.t_bucketId = InvalidBktId;\r\n                tuple->tuple.t_len = datalen + SizeofHeapTupleHeader;\r\n\r\n                rc = memset_s(header, SizeofHeapTupleHeader, 0, SizeofHeapTupleHeader);\r\n                securec_check(rc, \"\", \"\");\r\n                rc = memcpy_s((char*)tuple->tuple.t_data + SizeofHeapTupleHeader, datalen, (char*)data, datalen);\r\n                securec_check(rc, \"\", \"\");\r\n\r\n                header->t_infomask = xlhdr->t_infomask;\r\n                header->t_infomask2 = xlhdr->t_infomask2;\r\n                header->t_hoff = xlhdr->t_hoff;\r\n            } else {\r\n                ereport(WARNING, (errmsg(\"tuplelen is invalid(%d), tuplelen, don't decode it\", datalen)));\r\n                return;\r\n            }\r\n            data += datalen;\r\n        }\r\n\r\n        /*\r\n         * Reset toast reassembly state only after the last row in the last\r\n         * xl_multi_insert_tuple record emitted by one heap_multi_insert()\r\n         * call.\r\n         */\r\n        if ((xlrec->flags & XLOG_HEAP_LAST_MULTI_INSERT) && ((i + 1) == xlrec->ntuples)) {\r\n            change->data.tp.clear_toast_afterwards = true;\r\n        } else {\r\n            change->data.tp.clear_toast_afterwards = false;\r\n        }\r\n\r\n        ReorderBufferQueueChange(ctx->reorder, XLogRecGetXid(r), buf->origptr, change);\r\n    }\r\n}",
		"comment":"/*\r\n * Decode XLOG_HEAP2_MULTI_INSERT_insert record into multiple tuplebufs.\r\n *\r\n * Currently MULTI_INSERT will always contain the full tuples.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\decode.cpp",
		"name":"DecodeMultiInsert"
	},
	"DecodeStandbyOp":{
		"body":"static void DecodeStandbyOp(LogicalDecodingContext* ctx, XLogRecordBuffer* buf)\r\n{\r\n    SnapBuild* builder = ctx->snapshot_builder;\r\n    XLogReaderState* r = buf->record;\r\n    uint8 info = XLogRecGetInfo(r) & ~XLR_INFO_MASK;\r\n    XLogRecPtr lsn = buf->endptr;\r\n\r\n    ReorderBufferProcessXid(ctx->reorder, XLogRecGetXid(r), buf->origptr);\r\n\r\n    switch (info) {\r\n        case XLOG_RUNNING_XACTS: {\r\n            xl_running_xacts* running = (xl_running_xacts*)buf->record_data;\r\n            SnapBuildProcessRunningXacts(builder, buf->origptr, running);\r\n            /*\r\n             * Abort all transactions that we keep track of, that are\r\n             * older than the record's oldestRunningXid. This is the most\r\n             * convenient spot for doing so since, in contrast to shutdown\r\n             * or end-of-recovery checkpoints, we have information about\r\n             * all running transactions which includes prepared ones,\r\n             * while shutdown checkpoints just know that no non-prepared\r\n             * transactions are in progress.\r\n             */\r\n            ReorderBufferAbortOld(ctx->reorder, running->oldestRunningXid, lsn);\r\n        } break;\r\n        case XLOG_STANDBY_LOCK:\r\n        case XLOG_STANDBY_CSN:\r\n        case XLOG_STANDBY_CSN_COMMITTING:\r\n        case XLOG_STANDBY_CSN_ABORTED:\r\n            break;\r\n        default:\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_UNRECOGNIZED_NODE_TYPE), errmsg(\"unexpected RM_STANDBY_ID record type: %u\", info)));\r\n    }\r\n}",
		"comment":"/*\r\n * Handle rmgr STANDBY_ID records for DecodeRecordIntoReorderBuffer().\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\decode.cpp",
		"name":"DecodeStandbyOp"
	},
	"DecodeUpdate":{
		"body":"static void DecodeUpdate(LogicalDecodingContext* ctx, XLogRecordBuffer* buf)\r\n{\r\n    XLogReaderState* r = buf->record;\r\n    xl_heap_update* xlrec = NULL;\r\n    ReorderBufferChange* change = NULL;\r\n    RelFileNode target_node;\r\n    xlrec = (xl_heap_update*)GetXlrec(r);\r\n    int rc = 0;\r\n    XLogRecGetBlockTag(r, 0, &target_node, NULL, NULL);\r\n    /* only interested in our database */\r\n    if (target_node.dbNode != ctx->slot->data.database)\r\n        return;\r\n    Size datalen_new;\r\n    Size tuplelen_new;\r\n    char* data_new = NULL;\r\n    data_new = XLogRecGetBlockData(r, 0, &datalen_new);\r\n    tuplelen_new = datalen_new - SizeOfHeapHeader;\r\n    if (tuplelen_new == 0 && !AllocSizeIsValid(tuplelen_new)) {\r\n        ereport(WARNING, (errmsg(\"tuplelen is invalid(%lu), tuplelen, don't decode it\", tuplelen_new)));\r\n        return;\r\n    }\r\n    Size datalen_old;\r\n    Size tuplelen_old;\r\n    char* data_old = NULL;\r\n\r\n    /* adapt 64 xid, if this tuple is the first tuple of a new page */\r\n    bool is_init = (XLogRecGetInfo(r) & XLOG_HEAP_INIT_PAGE) != 0;\r\n    /* caution, remaining data in record is not aligned */\r\n    data_old = (char*)xlrec + SizeOfHeapUpdate;\r\n    if (is_init) {\r\n        datalen_old = XLogRecGetDataLen(r) - SizeOfHeapUpdate - sizeof(TransactionId);\r\n    } else {\r\n        datalen_old = XLogRecGetDataLen(r) - SizeOfHeapUpdate;\r\n    }\r\n    tuplelen_old = datalen_old - SizeOfHeapHeader;\r\n    if (tuplelen_old == 0 && !AllocSizeIsValid(tuplelen_old)) {\r\n        ereport(WARNING, (errmsg(\"tuplelen is invalid(%lu), tuplelen, don't decode it\", tuplelen_old)));\r\n        return;\r\n    }\r\n\r\n    /* output plugin doesn't look for this origin, no need to queue */\r\n    if (FilterByOrigin(ctx, XLogRecGetOrigin(r)))\r\n        return;\r\n\r\n    change = ReorderBufferGetChange(ctx->reorder);\r\n    change->action = REORDER_BUFFER_CHANGE_UPDATE;\r\n    change->origin_id = XLogRecGetOrigin(r);\r\n    rc = memcpy_s(&change->data.tp.relnode, sizeof(RelFileNode), &target_node, sizeof(RelFileNode));\r\n    securec_check(rc, \"\", \"\");\r\n    if (xlrec->flags & XLOG_HEAP_CONTAINS_NEW_TUPLE) {\r\n        change->data.tp.newtuple = ReorderBufferGetTupleBuf(ctx->reorder, tuplelen_new);\r\n        DecodeXLogTuple(data_new, datalen_new, change->data.tp.newtuple);\r\n    }\r\n    if (xlrec->flags & XLOG_HEAP_CONTAINS_OLD) {\r\n        change->data.tp.oldtuple = ReorderBufferGetTupleBuf(ctx->reorder, tuplelen_old);\r\n\r\n        DecodeXLogTuple(data_old, datalen_old, change->data.tp.oldtuple);\r\n    }\r\n\r\n    change->data.tp.clear_toast_afterwards = true;\r\n\r\n    ReorderBufferQueueChange(ctx->reorder, XLogRecGetXid(r), buf->origptr, change);\r\n}",
		"comment":"/*\r\n * Parse XLOG_HEAP_UPDATE and XLOG_HEAP_HOT_UPDATE, which have the same layout\r\n * in the record, from wal into proper tuplebufs.\r\n *\r\n * Updates can possibly contain a new tuple and the old primary key.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\decode.cpp",
		"name":"DecodeUpdate"
	},
	"DecodeXLogOp":{
		"body":"static void DecodeXLogOp(LogicalDecodingContext* ctx, XLogRecordBuffer* buf)\r\n{\r\n    SnapBuild* builder = ctx->snapshot_builder;\r\n    XLogReaderState* r = buf->record;\r\n    uint8 info = XLogRecGetInfo(r) & ~XLR_INFO_MASK;\r\n\r\n    ReorderBufferProcessXid(ctx->reorder, XLogRecGetXid(buf->record), buf->origptr);\r\n\r\n    switch (info) {\r\n        /* this is also used in END_OF_RECOVERY checkpoints */\r\n        case XLOG_CHECKPOINT_SHUTDOWN:\r\n        case XLOG_END_OF_RECOVERY:\r\n            SnapBuildSerializationPoint(builder, buf->origptr);\r\n            break;\r\n        case XLOG_CHECKPOINT_ONLINE:\r\n            /*\r\n             * a RUNNING_XACTS record will have been logged near to this, we\r\n             * can restart from there.\r\n             */\r\n            break;\r\n        case XLOG_NOOP:\r\n        case XLOG_NEXTOID:\r\n        case XLOG_SWITCH:\r\n        case XLOG_BACKUP_END:\r\n        case XLOG_PARAMETER_CHANGE:\r\n        case XLOG_RESTORE_POINT:\r\n        case XLOG_FPW_CHANGE:\r\n        case XLOG_FPI_FOR_HINT:\r\n        case XLOG_FPI:\r\n            break;\r\n        default:\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_UNRECOGNIZED_NODE_TYPE), errmsg(\"unexpected RM_XLOG_ID record type: %u\", info)));\r\n    }\r\n}",
		"comment":"/*\r\n * Handle rmgr XLOG_ID records for DecodeRecordIntoReorderBuffer().\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\decode.cpp",
		"name":"DecodeXLogOp"
	},
	"DecodeXLogTuple":{
		"body":"static void DecodeXLogTuple(const char* data, Size len, ReorderBufferTupleBuf* tuple)\r\n{\r\n    xl_heap_header xlhdr;\r\n    int datalen = len - SizeOfHeapHeader;\r\n    HeapTupleHeader header;\r\n    int rc = 0;\r\n    Assert(datalen >= 0);\r\n\r\n    tuple->tuple.t_len = datalen + SizeofHeapTupleHeader;\r\n    header = tuple->tuple.t_data;\r\n\r\n    /* not a disk based tuple */\r\n    ItemPointerSetInvalid(&tuple->tuple.t_self);\r\n\r\n    /* we can only figure this out after reassembling the transactions */\r\n    tuple->tuple.t_tableOid = InvalidOid;\r\n    tuple->tuple.t_bucketId = InvalidBktId;\r\n\r\n    /* data is not stored aligned, copy to aligned storage */\r\n    rc = memcpy_s((char*)&xlhdr, SizeOfHeapHeader, data, SizeOfHeapHeader);\r\n    securec_check(rc, \"\", \"\");\r\n    rc = memset_s(header, SizeofHeapTupleHeader, 0, SizeofHeapTupleHeader);\r\n    securec_check(rc, \"\", \"\");\r\n    rc = memcpy_s(((char*)tuple->tuple.t_data) + SizeofHeapTupleHeader, datalen, data + SizeOfHeapHeader, datalen);\r\n    securec_check(rc, \"\", \"\");\r\n\r\n    header->t_infomask = xlhdr.t_infomask;\r\n    header->t_infomask2 = xlhdr.t_infomask2;\r\n    header->t_hoff = xlhdr.t_hoff;\r\n}",
		"comment":"/*\r\n * Read a HeapTuple as WAL logged by heap_insert, heap_update and heap_delete\r\n * (but not by heap_multi_insert) into a tuplebuf.\r\n *\r\n * The size 'len' and the pointer 'data' in the record need to be\r\n * computed outside as they are record specific.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\decode.cpp",
		"name":"DecodeXLogTuple"
	},
	"DecodeXactOp":{
		"body":"static void DecodeXactOp(LogicalDecodingContext* ctx, XLogRecordBuffer* buf)\r\n{\r\n    SnapBuild* builder = ctx->snapshot_builder;\r\n    ReorderBuffer* reorder = ctx->reorder;\r\n    XLogReaderState* r = buf->record;\r\n    uint8 info = XLogRecGetInfo(r) & ~XLR_INFO_MASK;\r\n    /*\r\n     * No point in doing anything yet, data could not be decoded anyway. It's\r\n     * ok not to call ReorderBufferProcessXid() in that case, except in the\r\n     * assignment case there'll not be any later records with the same xid;\r\n     * and in the assignment case we'll not decode those xacts.\r\n     */\r\n    if (SnapBuildCurrentState(builder) < SNAPBUILD_FULL_SNAPSHOT)\r\n        return;\r\n\r\n    switch (info) {\r\n        case XLOG_XACT_COMMIT: {\r\n            xl_xact_commit* xlrec = NULL;\r\n            TransactionId* subxacts = NULL;\r\n            SharedInvalidationMessage* invals = NULL;\r\n\r\n            xlrec = (xl_xact_commit*)buf->record_data;\r\n\r\n            subxacts = (TransactionId*)&(xlrec->xnodes[xlrec->nrels]);\r\n            invals = (SharedInvalidationMessage*)&(subxacts[xlrec->nsubxacts]);\r\n\r\n            DecodeCommit(ctx,\r\n                buf,\r\n                XLogRecGetXid(r),\r\n                xlrec->csn,\r\n                xlrec->dbId,\r\n                xlrec->xact_time,\r\n                xlrec->nsubxacts,\r\n                subxacts,\r\n                xlrec->nmsgs,\r\n                invals);\r\n\r\n            break;\r\n        }\r\n        case XLOG_XACT_COMMIT_PREPARED: {\r\n            xl_xact_commit_prepared* prec = NULL;\r\n            xl_xact_commit* xlrec = NULL;\r\n            TransactionId* subxacts = NULL;\r\n            SharedInvalidationMessage* invals = NULL;\r\n\r\n            /* Prepared commits contain a normal commit record... */\r\n            prec = (xl_xact_commit_prepared*)buf->record_data;\r\n            xlrec = &prec->crec;\r\n\r\n            subxacts = (TransactionId*)&(xlrec->xnodes[xlrec->nrels]);\r\n            invals = (SharedInvalidationMessage*)&(subxacts[xlrec->nsubxacts]);\r\n\r\n            DecodeCommit(\r\n                ctx, buf, prec->xid, xlrec->csn, xlrec->dbId, xlrec->xact_time, xlrec->nsubxacts, subxacts,\r\n                xlrec->nmsgs, invals);\r\n\r\n            break;\r\n        }\r\n        case XLOG_XACT_COMMIT_COMPACT: {\r\n            xl_xact_commit_compact* xlrec = NULL;\r\n\r\n            xlrec = (xl_xact_commit_compact*)buf->record_data;\r\n\r\n            DecodeCommit(\r\n                ctx, buf, XLogRecGetXid(r), xlrec->csn, InvalidOid, xlrec->xact_time, xlrec->nsubxacts, xlrec->subxacts,\r\n                0, NULL);\r\n            break;\r\n        }\r\n        case XLOG_XACT_ABORT: {\r\n            xl_xact_abort* xlrec = NULL;\r\n            TransactionId* sub_xids = NULL;\r\n\r\n            xlrec = (xl_xact_abort*)buf->record_data;\r\n\r\n            sub_xids = (TransactionId*)&(xlrec->xnodes[xlrec->nrels]);\r\n\r\n            DecodeAbort(ctx, buf->origptr, XLogRecGetXid(r), sub_xids, xlrec->nsubxacts);\r\n            break;\r\n        }\r\n        case XLOG_XACT_ABORT_PREPARED: {\r\n            xl_xact_abort_prepared* prec = NULL;\r\n            xl_xact_abort* xlrec = NULL;\r\n            TransactionId* sub_xids = NULL;\r\n\r\n            /* prepared abort contain a normal commit abort... */\r\n            prec = (xl_xact_abort_prepared*)buf->record_data;\r\n            xlrec = &prec->arec;\r\n\r\n            sub_xids = (TransactionId*)&(xlrec->xnodes[xlrec->nrels]);\r\n\r\n            /* r->xl_xid is committed in a separate record */\r\n            DecodeAbort(ctx, buf->origptr, prec->xid, sub_xids, xlrec->nsubxacts);\r\n            break;\r\n        }\r\n        case XLOG_XACT_ASSIGNMENT: {\r\n            xl_xact_assignment* xlrec = NULL;\r\n            int i;\r\n            TransactionId* sub_xid = NULL;\r\n\r\n            xlrec = (xl_xact_assignment*)buf->record_data;\r\n\r\n            sub_xid = &xlrec->xsub[0];\r\n\r\n            for (i = 0; i < xlrec->nsubxacts; i++) {\r\n                ReorderBufferAssignChild(reorder, xlrec->xtop, *(sub_xid++), buf->origptr);\r\n            }\r\n            break;\r\n        }\r\n        case XLOG_XACT_PREPARE:\r\n            /*\r\n             * Currently decoding ignores PREPARE TRANSACTION and will just\r\n             * decode the transaction when the COMMIT PREPARED is sent or\r\n             * throw away the transaction's contents when a ROLLBACK PREPARED\r\n             * is received. In the future we could add code to expose prepared\r\n             * transactions in the changestream allowing for a kind of\r\n             * distributed 2PC.\r\n             */\r\n            ReorderBufferProcessXid(reorder, XLogRecGetXid(r), buf->origptr);\r\n            break;\r\n        default:\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_UNRECOGNIZED_NODE_TYPE), errmsg(\"unexpected RM_XACT_ID record type: %u\", info)));\r\n    }\r\n}",
		"comment":"/*\r\n * Handle rmgr XACT_ID records for DecodeRecordIntoReorderBuffer().\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\decode.cpp",
		"name":"DecodeXactOp"
	},
	"FilterByOrigin":{
		"body":"static inline bool FilterByOrigin(LogicalDecodingContext* ctx, RepOriginId origin_id)\r\n{\r\n    if (ctx->callbacks.filter_by_origin_cb == NULL)\r\n        return false;\r\n\r\n    return filter_by_origin_cb_wrapper(ctx, origin_id);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\decode.cpp",
		"name":"FilterByOrigin"
	},
	"GetXlrec":{
		"body":"Pointer GetXlrec(XLogReaderState* record)\r\n{\r\n    Pointer rec_data;\r\n    bool isinit = (XLogRecGetInfo(record) & XLOG_HEAP_INIT_PAGE) != 0;\r\n\r\n    rec_data = (Pointer)XLogRecGetData(record);\r\n    if (isinit) {\r\n        rec_data += sizeof(TransactionId);\r\n    }\r\n    return rec_data;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\decode.cpp",
		"name":"GetXlrec"
	},
	"LogicalDecodingProcessRecord":{
		"body":"void LogicalDecodingProcessRecord(LogicalDecodingContext* ctx, XLogReaderState* record)\r\n{\r\n    XLogRecordBuffer buf = {0, 0, NULL, NULL};\r\n\r\n    buf.origptr = ctx->reader->ReadRecPtr;\r\n    buf.endptr = ctx->reader->EndRecPtr;\r\n    buf.record = record;\r\n    buf.record_data = GetXlrec(record);\r\n\r\n    /* cast so we get a warning when new rmgrs are added */\r\n    switch ((RmgrIds)XLogRecGetRmid(record)) {\r\n        /*\r\n         * Rmgrs we care about for logical decoding. Add new rmgrs in\r\n         * rmgrlist.h's order.\r\n         */\r\n        case RM_XLOG_ID:\r\n            DecodeXLogOp(ctx, &buf);\r\n            break;\r\n\r\n        case RM_XACT_ID:\r\n            DecodeXactOp(ctx, &buf);\r\n            break;\r\n\r\n        case RM_STANDBY_ID:\r\n            DecodeStandbyOp(ctx, &buf);\r\n            break;\r\n\r\n        case RM_HEAP2_ID:\r\n            DecodeHeap2Op(ctx, &buf);\r\n            break;\r\n\r\n        case RM_HEAP_ID:\r\n            DecodeHeapOp(ctx, &buf);\r\n            break;\r\n        /*\r\n         * Rmgrs irrelevant for logical decoding; they describe stuff not\r\n         * represented in logical decoding. Add new rmgrs in rmgrlist.h's\r\n         * order.\r\n         */\r\n        case RM_SMGR_ID:\r\n            break;\r\n        case RM_CLOG_ID:\r\n            break;\r\n        case RM_DBASE_ID:\r\n            break;\r\n        case RM_TBLSPC_ID:\r\n            break;\r\n        case RM_MULTIXACT_ID:\r\n            break;\r\n        case RM_RELMAP_ID:\r\n            break;\r\n        case RM_BTREE_ID:\r\n            break;\r\n        case RM_HASH_ID:\r\n            break;\r\n        case RM_GIN_ID:\r\n            break;\r\n        case RM_GIST_ID:\r\n            break;\r\n        case RM_SEQ_ID:\r\n            break;\r\n        case RM_SPGIST_ID:\r\n            break;\r\n        case RM_SLOT_ID:\r\n            break;\r\n#ifdef ENABLE_MULTIPLE_NODES\r\n        case RM_BARRIER_ID:\r\n            break;\r\n#endif\r\n        case RM_HEAP3_ID:\r\n            DecodeHeap3Op(ctx, &buf);\r\n            break;\r\n        default:\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_UNRECOGNIZED_NODE_TYPE),\r\n                    errmsg(\"unexpected rmgr_id: %d\", (RmgrIds)XLogRecGetRmid(buf.record))));\r\n    }\r\n}",
		"comment":"/*\r\n * Take every XLogReadRecord()ed record and perform the actions required to\r\n * decode it using the output plugin already setup in the logical decoding\r\n * context.\r\n *\r\n * We also support the ability to fast forward thru records, skipping some\r\n * record types completely - see individual record types for details.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\decode.cpp",
		"name":"LogicalDecodingProcessRecord"
	}
}