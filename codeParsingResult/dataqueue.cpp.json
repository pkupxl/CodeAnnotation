{
	"AtAbort_RelationSync":{
		"body":"void AtAbort_RelationSync(void)\r\n{\r\n    HASH_SEQ_STATUS status;\r\n    heap_sync_rel* hentry = NULL;\r\n    Relation rel;\r\n\r\n    if (t_thrd.dataqueue_cxt.heap_sync_rel_tab != NULL) {\r\n        hash_seq_init(&status, t_thrd.dataqueue_cxt.heap_sync_rel_tab);\r\n        while ((hentry = (heap_sync_rel*)hash_seq_search(&status)) != NULL) {\r\n            rel = relation_open(hentry->key.rd_id, NoLock);\r\n            /*\r\n             * Here we don't try to lock related partition, partition would not be deleted during aborting\r\n             * because we still hold RowExclusiveLock. If we try to lock again, something bad may happen.\r\n             * Scene for example:\r\n             *      1. error when 'copy from' : errept\r\n             *      2. AbortTransaction\r\n             *      3. we try to open partition with AccessShareLock\r\n             *      4. fail to palloc when we build locallock->owner during calling LockAcquire\r\n             *      5. errept and AbortTransaction again\r\n             *      6. we try to access locallock->owner but it's NULL, so we get Segmentation fault.\r\n             */\r\n            heap_sync(rel, NoLock);\r\n            relation_close(rel, NoLock);\r\n\r\n            hash_search(t_thrd.dataqueue_cxt.heap_sync_rel_tab, (void*)&hentry->key, HASH_REMOVE, NULL);\r\n        }\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"AtAbort_RelationSync"
	},
	"AtCommit_RelationSync":{
		"body":"void AtCommit_RelationSync(void)\r\n{\r\n    if (t_thrd.dataqueue_cxt.heap_sync_rel_tab != NULL &&\r\n        hash_get_num_entries(t_thrd.dataqueue_cxt.heap_sync_rel_tab) > 0) {\r\n        ereport(PANIC, (errmsg(\"heap sync hash table not cleaned, num of entries:%ld\",\r\n            hash_get_num_entries(t_thrd.dataqueue_cxt.heap_sync_rel_tab))));\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"AtCommit_RelationSync"
	},
	"BCMArrayDropAllBlocks":{
		"body":"void BCMArrayDropAllBlocks(const RelFileNode& dropnode)\r\n{\r\n    BCMArrayDropBlock(0, t_thrd.dataqueue_cxt.BCMElementArrayIndex1, dropnode);\r\n    BCMArrayDropBlock(BCMElementArrayLenHalf, t_thrd.dataqueue_cxt.BCMElementArrayIndex2, dropnode);\r\n}",
		"comment":"/*\r\n * Drop all invaild dropnode block at bcm element array.\r\n * First drop the first half part, then drop the end half part.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"BCMArrayDropAllBlocks"
	},
	"BCMArrayDropBlock":{
		"body":"static void BCMArrayDropBlock(uint32 first, uint32 end, const RelFileNode& dropnode)\r\n{\r\n    while (first < end) {\r\n        if (!t_thrd.dataqueue_cxt.BCMElementArray[first].is_vaild) {\r\n            first++;\r\n            continue;\r\n        }\r\n\r\n        RelFileNode tmp_node;\r\n        int bucket_id = GETBUCKETID(t_thrd.dataqueue_cxt.BCMElementArray[first].attid);\r\n        RelFileNodeCopy(tmp_node, t_thrd.dataqueue_cxt.BCMElementArray[first].rnode, bucket_id);\r\n\r\n        if (RelFileNodeEquals(dropnode, tmp_node))\r\n            t_thrd.dataqueue_cxt.BCMElementArray[first].is_vaild = false;\r\n\r\n        first++;\r\n    }\r\n}",
		"comment":"/*\r\n * Invaild the dropnode relfilenode block in the bcm element array\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"BCMArrayDropBlock"
	},
	"BCMArrayIsEmpty":{
		"body":"bool BCMArrayIsEmpty(void)\r\n{\r\n    return (t_thrd.dataqueue_cxt.BCMElementArrayIndex1 == 0 &&\r\n            t_thrd.dataqueue_cxt.BCMElementArrayIndex2 == BCMElementArrayLenHalf);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"BCMArrayIsEmpty"
	},
	"ClearBCMArray":{
		"body":"void ClearBCMArray(void)\r\n{\r\n    pg_memory_barrier();\r\n    /* If no data send to dummystandby, we will clear the BCM status */\r\n    if (t_thrd.dataqueue_cxt.save_send_dummy_count == send_dummy_count) {\r\n        ClearBCMStatus(0, t_thrd.dataqueue_cxt.BCMElementArrayIndex1);\r\n        ClearBCMStatus(BCMElementArrayLenHalf, t_thrd.dataqueue_cxt.BCMElementArrayIndex2);\r\n    }\r\n\r\n    /* After clear, set the array to empty. */\r\n    ResetBCMArray();\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"ClearBCMArray"
	},
	"ClearBCMStatus":{
		"body":"static void ClearBCMStatus(uint32 first, uint32 end)\r\n{\r\n    RelFileNode curnode = InvalidRelFileNode;\r\n    RelFileNode prevnode = InvalidRelFileNode;\r\n    BlockNumber blockNum;\r\n    Buffer bcmbuffer;\r\n    Relation relation = NULL;\r\n    BCMElementData bcmhdr;\r\n\r\n    while (first < end) {\r\n        bcmhdr = t_thrd.dataqueue_cxt.BCMElementArray[first];\r\n        RelFileNodeCopy(curnode, bcmhdr.rnode, GETBUCKETID(bcmhdr.attid));\r\n        blockNum = bcmhdr.blocknum;\r\n\r\n        if (!bcmhdr.is_vaild) {\r\n            first++;\r\n            continue;\r\n        }\r\n\r\n        if (memcmp(&prevnode, &curnode, sizeof(RelFileNode)) != 0) {\r\n            prevnode = curnode;\r\n\r\n            if (relation) {\r\n                FreeFakeRelcacheEntry(relation);\r\n                relation = NULL;\r\n            }\r\n            relation = CreateFakeRelcacheEntry(prevnode);\r\n        }\r\n        Assert(relation != NULL);\r\n\r\n        if (relation == NULL) {\r\n            ereport(ERROR,\r\n                (errmsg(\"Invalid relation while clearing BCM status: rnode[%u,%u,%u], blocknum[%u], \"\r\n                        \"pageoffset[%lu], size[%u], attid[%d]\",\r\n                    bcmhdr.rnode.spcNode,\r\n                    bcmhdr.rnode.dbNode,\r\n                    bcmhdr.rnode.relNode,\r\n                    bcmhdr.blocknum,\r\n                    bcmhdr.offset,\r\n                    bcmhdr.data_size,\r\n                    (int)GETATTID((uint32)bcmhdr.attid))));\r\n        }\r\n\r\n        ereport(DEBUG5,\r\n            (errmsg(\"clear BCM status: rnode[%u,%u,%u], blocknum[%u], \"\r\n                    \"pageoffset[%lu], size[%u], attid[%d]\",\r\n                bcmhdr.rnode.spcNode,\r\n                bcmhdr.rnode.dbNode,\r\n                bcmhdr.rnode.relNode,\r\n                bcmhdr.blocknum,\r\n                bcmhdr.offset,\r\n                bcmhdr.data_size,\r\n                (int)GETATTID((uint32)bcmhdr.attid))));\r\n\r\n        if (bcmhdr.type == ROW_STORE) {\r\n            Buffer buffer;\r\n            Page page;\r\n\r\n            /* Set BCM status */\r\n            BCM_pin(relation, blockNum, &bcmbuffer);\r\n            LockBuffer(bcmbuffer, BUFFER_LOCK_EXCLUSIVE);\r\n            BCMSetStatusBit(relation, blockNum, bcmbuffer, SYNCED);\r\n            UnlockReleaseBuffer(bcmbuffer);\r\n\r\n            /* clear the logical page flag */\r\n            buffer = ReadBuffer(relation, blockNum);\r\n            AssertEreport(BufferIsValid(buffer), MOD_FUNCTION, \"buffer should not be zero\");\r\n            LockBuffer(buffer, BUFFER_LOCK_SHARE);\r\n            page = (Page)BufferGetPage(buffer);\r\n            if (PageIsLogical(page)) {\r\n                PageClearLogical(page);\r\n                MarkBufferDirty(buffer);\r\n            }\r\n            UnlockReleaseBuffer(buffer);\r\n        } else {\r\n            BlockNumber curBcmBlock = 0;\r\n            BlockNumber nextBcmBlock = 0;\r\n            uint64 cuSliceOffset = 0;\r\n            uint64 cuBlock = 0;\r\n            int cuUnitCount = (bcmhdr.data_size / ALIGNOF_CUSIZE);\r\n\r\n            /* read current bcm block */\r\n            cuSliceOffset = bcmhdr.offset;\r\n            curBcmBlock = CSTORE_OFFSET_TO_BCMBLOCK(cuSliceOffset);\r\n            nextBcmBlock = curBcmBlock;\r\n            BCM_CStore_pin(relation, (int)GETATTID((uint32)bcmhdr.attid), cuSliceOffset, &bcmbuffer);\r\n            LockBuffer(bcmbuffer, BUFFER_LOCK_EXCLUSIVE);\r\n\r\n            do {\r\n                /* deal with bcm block switch */\r\n                if (nextBcmBlock != curBcmBlock) {\r\n                    curBcmBlock = nextBcmBlock;\r\n\r\n                    /* release last bcm block and read in the next one */\r\n                    UnlockReleaseBuffer(bcmbuffer);\r\n\r\n                    BCM_CStore_pin(relation, (int)GETATTID((uint32)bcmhdr.attid), cuSliceOffset, &bcmbuffer);\r\n                    LockBuffer(bcmbuffer, BUFFER_LOCK_EXCLUSIVE);\r\n                }\r\n\r\n                cuBlock = CSTORE_OFFSET_TO_CSTOREBLOCK(cuSliceOffset);\r\n                BCMSetStatusBit(relation, cuBlock, bcmbuffer, SYNCED, (int)GETATTID((uint32)bcmhdr.attid));\r\n\r\n                cuSliceOffset += ALIGNOF_CUSIZE;\r\n                nextBcmBlock = CSTORE_OFFSET_TO_BCMBLOCK(cuSliceOffset);\r\n            } while (cuSliceOffset < bcmhdr.offset + (uint64)bcmhdr.data_size);\r\n\r\n            UnlockReleaseBuffer(bcmbuffer);\r\n\r\n            /* record one log_cu_bcm xlog */\r\n            BCMLogCU(relation, bcmhdr.offset, (int)GETATTID((uint32)bcmhdr.attid), SYNCED, cuUnitCount);\r\n\r\n            if (u_sess->attr.attr_storage.HaModuleDebug) {\r\n                ereport(LOG,\r\n                    (errmsg(\"HA-ClearBCMStatus: rnode %u/%u/%u, col %u, blockno %lu \"\r\n                            \"cuUnitCount %u, status  %u\",\r\n                        relation->rd_node.spcNode,\r\n                        relation->rd_node.dbNode,\r\n                        relation->rd_node.relNode,\r\n                        GETATTID((uint)bcmhdr.attid),\r\n                        bcmhdr.offset / ALIGNOF_CUSIZE,\r\n                        bcmhdr.data_size / ALIGNOF_CUSIZE,\r\n                        SYNCED)));\r\n            }\r\n        }\r\n        first++;\r\n    }\r\n\r\n    if (relation)\r\n        FreeFakeRelcacheEntry(relation);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"ClearBCMStatus"
	},
	"DataQueueIsEmpty":{
		"body":"bool DataQueueIsEmpty(DataQueueData* data_queue)\r\n{\r\n    DataQueuePtr queue_tail1 = (DataQueuePtr){0, 0};\r\n    DataQueuePtr queue_head2 = (DataQueuePtr){0, 0};\r\n    DataQueuePtr queue_tail2 = (DataQueuePtr){0, 0};\r\n    bool isEmpty = false;\r\n\r\n    if (data_queue == NULL)\r\n        return true; /* nothing to do */\r\n\r\n    /* Keep the queue size and page start location. */\r\n    SpinLockAcquire(&data_queue->use_mutex);\r\n    queue_tail1 = data_queue->use_tail1;\r\n    queue_head2 = data_queue->use_head2;\r\n    queue_tail2 = data_queue->use_tail2;\r\n    SpinLockRelease(&data_queue->use_mutex);\r\n\r\n    if (!DataQueuePtrIsInvalid(queue_tail1) || !DQByteEQ(queue_head2, queue_tail2))\r\n        isEmpty = false;\r\n    else\r\n        isEmpty = true;\r\n\r\n    return isEmpty;\r\n}",
		"comment":"/*\r\n * Is the given data queue data already empty or not?\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"DataQueueIsEmpty"
	},
	"DataQueueShmemSize":{
		"body":"Size DataQueueShmemSize(void)\r\n{\r\n    Size size = 0;\r\n\r\n    /* Don't need allocate SHM in single node mode */\r\n    // if(!IS_SINGLE_NODE)\r\n    {\r\n        Assert(g_instance.attr.attr_storage.DataQueueBufSize > 0);\r\n\r\n        /* DataQueue */\r\n        size = sizeof(DataQueueData);\r\n        /* extra alignment padding for DataQueue I/O buffers */\r\n        size = add_size(size, ALIGNOF_BUFFER);\r\n        /* and the buffers themselves */\r\n        size = add_size(size, g_instance.attr.attr_storage.DataQueueBufSize * 1024);\r\n    }\r\n\r\n    return size;\r\n}",
		"comment":"/*\r\n * Initialization of shared memory for DataQueueBuffer\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"DataQueueShmemSize"
	},
	"DataSenderQueueShmemInit":{
		"body":"void DataSenderQueueShmemInit(void)\r\n{\r\n    /* The number of buffers in a page of DataSenderQueue is 1024. */\r\n    const int buffernum = 1024;\r\n    /* Allocate SHM in non-single node or dummy standby mode */\r\n    if (!IS_SINGLE_NODE || IS_DN_DUMMY_STANDYS_MODE()) {\r\n        bool foundDataQueue = false;\r\n        char* allocptr = NULL;\r\n        errno_t rc = 0;\r\n\r\n        t_thrd.dataqueue_cxt.DataSenderQueue =\r\n            (DataQueueData*)ShmemInitStruct(\"Data Sender Queue\", DataQueueShmemSize(), &foundDataQueue);\r\n\r\n        if (foundDataQueue) {\r\n            return;\r\n        }\r\n\r\n        rc = memset_s(t_thrd.dataqueue_cxt.DataSenderQueue, sizeof(DataQueueData), 0, sizeof(DataQueueData));\r\n        securec_check_c(rc, \"\", \"\");\r\n\r\n        allocptr = ((char*)t_thrd.dataqueue_cxt.DataSenderQueue) + sizeof(DataQueueData);\r\n\r\n        /*\r\n         * Align the start of the page buffers to an ALIGNOF_XLOG_BUFFER boundary.\r\n         */\r\n        allocptr = (char*)TYPEALIGN(ALIGNOF_BUFFER, allocptr);\r\n        t_thrd.dataqueue_cxt.DataSenderQueue->pages = allocptr;\r\n        rc = memset_s(t_thrd.dataqueue_cxt.DataSenderQueue->pages,\r\n            (INT2SIZET(g_instance.attr.attr_storage.DataQueueBufSize)) * buffernum,\r\n            0,\r\n            (INT2SIZET(g_instance.attr.attr_storage.DataQueueBufSize)) * buffernum);\r\n        securec_check_c(rc, \"\", \"\");\r\n\r\n        /*\r\n         * Do basic initialization of DataQueue shared data.\r\n         */\r\n        t_thrd.dataqueue_cxt.DataSenderQueue->size =\r\n            g_instance.attr.attr_storage.DataQueueBufSize * buffernum; /* unit: Bytes */\r\n        SpinLockInit(&t_thrd.dataqueue_cxt.DataSenderQueue->use_mutex);\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"DataSenderQueueShmemInit"
	},
	"DataWriterQueueShmemInit":{
		"body":"void DataWriterQueueShmemInit(void)\r\n{\r\n    /* Allocate SHM in non-single node or dummy standby mode */\r\n    if (!IS_SINGLE_NODE || IS_DN_DUMMY_STANDYS_MODE()) {\r\n        bool foundDataQueue = false;\r\n        char* allocptr = NULL;\r\n        errno_t rc = 0;\r\n\r\n        t_thrd.dataqueue_cxt.DataWriterQueue =\r\n            (DataQueueData*)ShmemInitStruct(\"Data Writer Queue\", DataQueueShmemSize(), &foundDataQueue);\r\n\r\n        if (foundDataQueue) {\r\n            return;\r\n        }\r\n\r\n        rc = memset_s(t_thrd.dataqueue_cxt.DataWriterQueue, sizeof(DataQueueData), 0, sizeof(DataQueueData));\r\n        securec_check_c(rc, \"\", \"\");\r\n\r\n        allocptr = ((char*)t_thrd.dataqueue_cxt.DataWriterQueue) + sizeof(DataQueueData);\r\n\r\n        /*\r\n         * Align the start of the page buffers to an ALIGNOF_XLOG_BUFFER boundary.\r\n         */\r\n        allocptr = (char*)TYPEALIGN(ALIGNOF_BUFFER, allocptr);\r\n        t_thrd.dataqueue_cxt.DataWriterQueue->pages = allocptr;\r\n        rc = memset_s(t_thrd.dataqueue_cxt.DataWriterQueue->pages,\r\n            INT2SIZET(g_instance.attr.attr_storage.DataQueueBufSize) * 1024,\r\n            0,\r\n            INT2SIZET(g_instance.attr.attr_storage.DataQueueBufSize) * 1024);\r\n        securec_check_c(rc, \"\", \"\");\r\n\r\n        /*\r\n         * Do basic initialization of DataQueue shared data.\r\n         */\r\n        t_thrd.dataqueue_cxt.DataWriterQueue->size =\r\n            g_instance.attr.attr_storage.DataQueueBufSize * 1024; /* unit: Bytes */\r\n        SpinLockInit(&t_thrd.dataqueue_cxt.DataWriterQueue->use_mutex);\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"DataWriterQueueShmemInit"
	},
	"GetFromDataQueue":{
		"body":"uint32 GetFromDataQueue(char *&buf, int bufsize, DataQueuePtr &startptr, DataQueuePtr &endptr, bool amIWriter,\r\n    DataQueueData *data_queue)\r\n{\r\n    /* get the total_len of the send data */\r\n    uint32 page_len = 0;\r\n    uint32 mem_len = 0;\r\n    int buf_max_len = bufsize;\r\n    bool ChangeFromRightToLeft = false;\r\n    DataQueuePtr current_tail2 = {0, 0};\r\n\r\n    /* when enable_mix_replication open, only amIWriter == true is allowed */\r\n    if (amIWriter == false && g_instance.attr.attr_storage.enable_mix_replication) {\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_AMBIGUOUS_PARAMETER), errmsg(\"we should be a writer when enable_mix_replication is on\")));\r\n    }\r\n\r\n    SpinLockAcquire(&data_queue->use_mutex);\r\n\r\n    /* When DataSender restart, its sendposition = 0 */\r\n    if (DataQueuePtrIsInvalid(startptr)) {\r\n        startptr = data_queue->use_head2;\r\n    }\r\n\r\n    /* Right side sent done, turn to Left side */\r\n    if (DQByteEQ(data_queue->use_head2, data_queue->use_tail2)) {\r\n        /* I am the slowest Data Sender to trigger the ChangeFromRightToLeft */\r\n        if (DataQueuePtrIsInvalid(data_queue->use_tail1)) {\r\n            /* Sender Queue is empty */\r\n            SpinLockRelease(&data_queue->use_mutex);\r\n            return 0;\r\n        } else {\r\n            ChangeFromRightToLeft = true;\r\n        }\r\n    } else {\r\n        Assert(DQByteLT(data_queue->use_head2, data_queue->use_tail2));\r\n\r\n        if (DQByteLE(data_queue->use_tail2, startptr)) {\r\n            /* I am a faster Data Sender */\r\n            SpinLockRelease(&data_queue->use_mutex);\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    if (ChangeFromRightToLeft) {\r\n        /* Change header2/tail2 pointer to Left side */\r\n        data_queue->use_head2.queueid++;\r\n        data_queue->use_head2.queueoff = 0;\r\n        data_queue->use_tail2 = data_queue->use_tail1;\r\n        data_queue->use_tail1.queueoff = 0;\r\n        Assert(data_queue->use_head2.queueid == data_queue->use_tail2.queueid);\r\n\r\n        SpinLockRelease(&data_queue->use_mutex);\r\n\r\n        /*\r\n         * when datareceiver or datasender is started, update the position in DataRcv or DataSndCtl\r\n         * when enable_mix_replication is on, only update local_write_pos in WalRcv\r\n         */\r\n        if (!g_instance.attr.attr_storage.enable_mix_replication) {\r\n            if (amIWriter) {\r\n                UpdateDataWritePosition();\r\n            } else {\r\n                UpdateDataSendPosition();\r\n            }\r\n        } else {\r\n            UpdateWalDataWritePosition();\r\n        }\r\n\r\n        startptr = data_queue->use_head2;\r\n\r\n        SpinLockAcquire(&data_queue->use_mutex);\r\n    }\r\n\r\n    endptr = startptr;\r\n    current_tail2 = data_queue->use_tail2;\r\n    SpinLockRelease(&data_queue->use_mutex);\r\n\r\n    LWLockAcquire(DataSyncRepLock, LW_EXCLUSIVE);\r\n\r\n    Assert(current_tail2.queueoff > startptr.queueoff);\r\n\r\n    /* if dataqueue < bufsize , copy all dataqueue to bufsize */\r\n    if (current_tail2.queueoff - startptr.queueoff <= (uint32)bufsize) {\r\n        endptr = current_tail2;\r\n    } else {\r\n        while (bufsize >= 0) {\r\n            page_len = *(uint32*)(data_queue->pages + endptr.queueoff);\r\n            endptr.queueoff += page_len;\r\n            bufsize -= page_len;\r\n        }\r\n        endptr.queueoff -= page_len;\r\n\r\n        Assert(DQByteLE(endptr, current_tail2) && DQByteLT(startptr, endptr));\r\n    }\r\n\r\n    mem_len = endptr.queueoff - startptr.queueoff;\r\n\r\n    if (amIWriter) {\r\n        /* get the position to be written. */\r\n        buf = data_queue->pages + startptr.queueoff;\r\n    } else {\r\n        errno_t errorno = EOK;\r\n        /* copy data to buf for sending to datareceiver */\r\n        errorno = memcpy_s(buf, buf_max_len, data_queue->pages + startptr.queueoff, mem_len);\r\n        securec_check(errorno, \"\", \"\");\r\n    }\r\n\r\n    LWLockRelease(DataSyncRepLock);\r\n\r\n    if (u_sess->attr.attr_storage.HaModuleDebug) {\r\n        ereport(LOG,\r\n            (errmsg(\"HA-GetFromDataQueue: start %u/%u, end %u/%u, head2 %u/%u, tail1 %u/%u, tail2 %u/%u\",\r\n                startptr.queueid,\r\n                startptr.queueoff,\r\n                endptr.queueid,\r\n                endptr.queueoff,\r\n                data_queue->use_head2.queueid,\r\n                data_queue->use_head2.queueoff,\r\n                data_queue->use_tail1.queueid,\r\n                data_queue->use_tail1.queueoff,\r\n                data_queue->use_tail2.queueid,\r\n                data_queue->use_tail2.queueoff)));\r\n    }\r\n\r\n    return mem_len;\r\n}",
		"comment":"/*\r\n * retrun copied size, used in three situations below:\r\n * 1. walsender send data, between use_head2 and use_tail2, controlled by WalSndCtl\r\n *     when multi walsenders exist;\r\n * 2. when wal and data is written by walwriter and datawriter separately, used by datawriter to fetch what\r\n *     is pushed into DataWriterQueue by datareceiver\r\n * 3. when enable_mix_replication is on, fetch both wal log and data from DataWriterQueue\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"GetFromDataQueue"
	},
	"HeapSyncHashCreate":{
		"body":"static void HeapSyncHashCreate(void)\r\n{\r\n    /* if no the hash table we will create it */\r\n    if (t_thrd.dataqueue_cxt.heap_sync_rel_tab == NULL) {\r\n        HASHCTL ctl;\r\n        errno_t rc = 0;\r\n        rc = memset_s(&ctl, sizeof(ctl), 0, sizeof(ctl));\r\n        securec_check(rc, \"\", \"\");\r\n        ctl.keysize = sizeof(heap_sync_rel_key);\r\n        ctl.entrysize = sizeof(heap_sync_rel);\r\n        ctl.hash = tag_hash;\r\n        t_thrd.dataqueue_cxt.heap_sync_rel_tab =\r\n            hash_create(\"heap sync rel table\", 100, &ctl, HASH_ELEM | HASH_FUNCTION);\r\n    } else\r\n        return;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"HeapSyncHashCreate"
	},
	"HeapSyncHashSearch":{
		"body":"void HeapSyncHashSearch(Oid rd_id, HASHACTION action)\r\n{\r\n    heap_sync_rel_key key;\r\n    errno_t rc = 0;\r\n    rc = memset_s(&key, sizeof(heap_sync_rel_key), 0, sizeof(heap_sync_rel_key));\r\n    securec_check(rc, \"\", \"\");\r\n    key.rd_id = rd_id;\r\n\r\n    if (t_thrd.dataqueue_cxt.heap_sync_rel_tab == NULL)\r\n        HeapSyncHashCreate();\r\n\r\n    hash_search(t_thrd.dataqueue_cxt.heap_sync_rel_tab, (void*)&key, action, NULL);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"HeapSyncHashSearch"
	},
	"PallocBCMBCMElementArray":{
		"body":"void PallocBCMBCMElementArray(void)\r\n{\r\n    if (t_thrd.dataqueue_cxt.BCMElementArray == NULL) {\r\n        MemoryContext oldcxt = NULL;\r\n\r\n        oldcxt = MemoryContextSwitchTo(t_thrd.top_mem_cxt);\r\n        t_thrd.dataqueue_cxt.BCMElementArray = (BCMElement)palloc0(BCMElementArrayLen * sizeof(BCMElementData));\r\n        MemoryContextSwitchTo(oldcxt);\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"PallocBCMBCMElementArray"
	},
	"PopFromDataQueue":{
		"body":"void PopFromDataQueue(const DataQueuePtr& position, DataQueueData* data_queue)\r\n{\r\n    SpinLockAcquire(&data_queue->use_mutex);\r\n    if ((position.queueid == data_queue->use_tail2.queueid) && DQByteLE(position, data_queue->use_tail2)) {\r\n        data_queue->use_head2.queueoff = position.queueoff;\r\n    }\r\n    SpinLockRelease(&data_queue->use_mutex);\r\n\r\n    return;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"PopFromDataQueue"
	},
	"PushToBCMElementArray":{
		"body":"static void PushToBCMElementArray(const RelFileNode& rnode, BlockNumber blockNum, StorageEngine type, uint32 data_len,\r\n    int attid, uint64 offset, const DataQueuePtr& queueoffset)\r\n{\r\n    uint32 array_index = 0;\r\n    uint32& index1 = t_thrd.dataqueue_cxt.BCMElementArrayIndex1;\r\n    uint32& index2 = t_thrd.dataqueue_cxt.BCMElementArrayIndex2;\r\n    volatile DataSndCtlData* datasndctl = t_thrd.datasender_cxt.DataSndCtl;\r\n    errno_t rc = EOK;\r\n\r\n    /* Initialize BCMElementArray */\r\n    if (t_thrd.dataqueue_cxt.BCMElementArray == NULL) {\r\n        MemoryContext oldcxt = NULL;\r\n\r\n        oldcxt = MemoryContextSwitchTo(t_thrd.top_mem_cxt);\r\n        t_thrd.dataqueue_cxt.BCMElementArray = (BCMElement)palloc0(BCMElementArrayLen * sizeof(BCMElementData));\r\n        MemoryContextSwitchTo(oldcxt);\r\n    }\r\n\r\n    /*\r\n     * First to push to the first half of array, or push to the second\r\n     * half of array\r\n     */\r\n    if (index1 < BCMElementArrayLenHalf) {\r\n        array_index = index1++;\r\n        rc = memcpy_s(\r\n            t_thrd.dataqueue_cxt.BCMElementArrayOffset1, sizeof(DataQueuePtr), &queueoffset, sizeof(DataQueuePtr));\r\n        securec_check(rc, \"\", \"\");\r\n\r\n        /*\r\n         * when the array is full,\r\n         * if primary send data to dummystandby, the send_dummy_count will increase,\r\n         * then the save_send_dummy_count != send_dummy_count, we will not clear\r\n         * the bcm file, and set array to empty.\r\n         * if save_send_dummy_count == send_dummy_count, we will clear the second half of array,\r\n         * and set the index2 = BCMElementArrayLenHalf.\r\n         */\r\n        if (index1 == BCMElementArrayLenHalf && index2 == BCMElementArrayLen) {\r\n            /*\r\n             * we should wait the second half data has been send to the standby,\r\n             * then clear the BCMArray.\r\n             */\r\n            while (DQByteLT(datasndctl->queue_offset, *t_thrd.dataqueue_cxt.BCMElementArrayOffset2)) {\r\n                /*\r\n                 * Check interrupts before we get in sleep, and we can not use\r\n                 * CHECK_FOR_INTERRUPTS because we have hold the page lwlock.\r\n                 */\r\n                if (IsDataReplInterruptted())\r\n                    ereport(ERROR, (errcode(ERRCODE_DATA_CORRUPTED), errmsg(\"Insert BCM Info to be interrupted.\")));\r\n\r\n                CatchupShutdownIfNoDataSender();\r\n                pg_usleep(1000L); /* 1ms */\r\n            }\r\n\r\n            pg_memory_barrier();\r\n            if (t_thrd.dataqueue_cxt.save_send_dummy_count == send_dummy_count) {\r\n                ClearBCMStatus(BCMElementArrayLenHalf, BCMElementArrayLen);\r\n            } else {\r\n                index1 = 0;\r\n            }\r\n            index2 = BCMElementArrayLenHalf;\r\n        }\r\n    } else {\r\n        Assert(index1 == BCMElementArrayLenHalf);\r\n\r\n        array_index = index2++;\r\n        rc = memcpy_s(\r\n            t_thrd.dataqueue_cxt.BCMElementArrayOffset2, sizeof(DataQueuePtr), &queueoffset, sizeof(DataQueuePtr));\r\n        securec_check(rc, \"\", \"\");\r\n\r\n        /* array is full */\r\n        if (index2 == BCMElementArrayLen) {\r\n            /*\r\n             * we should wait the first half data has been send to the standby,\r\n             * then clear the BCMArray.\r\n             */\r\n            while (DQByteLT(datasndctl->queue_offset, *t_thrd.dataqueue_cxt.BCMElementArrayOffset1)) {\r\n                if (IsDataReplInterruptted())\r\n                    ereport(ERROR, (errcode(ERRCODE_DATA_CORRUPTED), errmsg(\"Insert BCM Info to be interrupted.\")));\r\n\r\n                CatchupShutdownIfNoDataSender();\r\n                pg_usleep(1000L); /* 1ms */\r\n            }\r\n\r\n            if (t_thrd.dataqueue_cxt.save_send_dummy_count == send_dummy_count)\r\n                ClearBCMStatus(0, BCMElementArrayLenHalf);\r\n            else\r\n                index2 = BCMElementArrayLenHalf;\r\n            index1 = 0;\r\n        }\r\n    }\r\n\r\n    Assert(index2 >= BCMElementArrayLenHalf);\r\n    Assert(array_index < BCMElementArrayLen);\r\n\r\n    if ((index2 < BCMElementArrayLenHalf) || (array_index >= BCMElementArrayLen))\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_DATA_CORRUPTED),\r\n                errmsg(\"The got BCM Array index is corrupt: index1 %u index2 %u array_index %u \"\r\n                       \"BCMElementArrayOffset1 %X/%X BCMElementArrayOffset2 %X/%X\",\r\n                    index1,\r\n                    index2,\r\n                    array_index,\r\n                    t_thrd.dataqueue_cxt.BCMElementArrayOffset1->queueid,\r\n                    t_thrd.dataqueue_cxt.BCMElementArrayOffset1->queueoff,\r\n                    t_thrd.dataqueue_cxt.BCMElementArrayOffset2->queueid,\r\n                    t_thrd.dataqueue_cxt.BCMElementArrayOffset2->queueoff)));\r\n\r\n    RelFileNodeRelCopy(t_thrd.dataqueue_cxt.BCMElementArray[array_index].rnode, rnode);\r\n\r\n    t_thrd.dataqueue_cxt.BCMElementArray[array_index].blocknum = blockNum;\r\n    t_thrd.dataqueue_cxt.BCMElementArray[array_index].attid =\r\n        (int)((uint32)attid | ((uint32)(rnode.bucketNode + 1) << 16));\r\n    t_thrd.dataqueue_cxt.BCMElementArray[array_index].type = type;\r\n    t_thrd.dataqueue_cxt.BCMElementArray[array_index].offset = offset;\r\n    t_thrd.dataqueue_cxt.BCMElementArray[array_index].data_size = data_len;\r\n    t_thrd.dataqueue_cxt.BCMElementArray[array_index].is_vaild = true;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"PushToBCMElementArray"
	},
	"PushToSenderQueue":{
		"body":"DataQueuePtr PushToSenderQueue(const RelFileNode& rnode, BlockNumber blockNum, StorageEngine type, const char* mem,\r\n    uint32 data_len, int attid, uint64 offset)\r\n{\r\n    uint32 total_len;\r\n    uint32 buffer_size = g_instance.attr.attr_storage.DataQueueBufSize * 1024; /* unit: Bytes */\r\n    uint32 freespace_head = 0;\r\n    uint32 data_header_len = sizeof(DataElementHeaderData);\r\n    uint32 time_count = 1;\r\n    DataQueuePtr invalidPtr = (DataQueuePtr){0, 0};\r\n    DataElementHeaderData data_header;\r\n    errno_t errorno = EOK;\r\n\r\n    if (!u_sess->attr.attr_storage.enable_stream_replication ||\r\n        t_thrd.postmaster_cxt.HaShmData->current_mode == NORMAL_MODE)\r\n        return invalidPtr;\r\n\r\n    /* the array is empty, Initialize the save_send_dummy_count */\r\n    if (t_thrd.dataqueue_cxt.BCMElementArrayIndex1 == 0 &&\r\n        t_thrd.dataqueue_cxt.BCMElementArrayIndex2 == BCMElementArrayLenHalf) {\r\n        pg_memory_barrier();\r\n        t_thrd.dataqueue_cxt.save_send_dummy_count = send_dummy_count;\r\n    }\r\n\r\n    Assert(mem != NULL && data_len > 0);\r\n\r\n    /* structure the data_header. */\r\n    RelFileNodeRelCopy(data_header.rnode, rnode);\r\n    data_header.blocknum = blockNum;\r\n    data_header.attid = (int)((uint32)attid | ((uint32)(rnode.bucketNode + 1) << 16));\r\n    data_header.type = type;\r\n    data_header.data_size = data_len;\r\n\r\n    if (type == ROW_STORE)\r\n        data_header.offset = BLCKSZ * (blockNum % ((BlockNumber)RELSEG_SIZE));\r\n    else if (type == COLUMN_STORE)\r\n        data_header.offset = offset;\r\n\r\n    data_header.ref_rec_ptr = InvalidXLogRecPtr;\r\n\r\n    /* total_len + header_len + data_len */\r\n    total_len = sizeof(uint32) + data_header_len + data_len;\r\n\r\n#ifdef DATA_DEBUG\r\n    /* caculate the data page crc */\r\n    INIT_CRC32(data_header.data_crc);\r\n    COMP_CRC32(data_header.data_crc, mem, data_len);\r\n    FIN_CRC32(data_header.data_crc);\r\n#endif\r\n\r\n    /* get enough buffer */\r\n    do {\r\n        LWLockAcquire(DataSyncRepLock, LW_SHARED);\r\n\r\n        SpinLockAcquire(&t_thrd.dataqueue_cxt.DataSenderQueue->use_mutex);\r\n\r\n        if (buffer_size - t_thrd.dataqueue_cxt.DataSenderQueue->use_tail2.queueoff > total_len &&\r\n            DataQueuePtrIsInvalid(t_thrd.dataqueue_cxt.DataSenderQueue->use_tail1)) {\r\n            /* update use_tail2 */\r\n            freespace_head = t_thrd.dataqueue_cxt.DataSenderQueue->use_tail2.queueoff;\r\n            DQByteAdvance(t_thrd.dataqueue_cxt.DataSenderQueue->use_tail2, total_len);\r\n            data_header.queue_offset = t_thrd.dataqueue_cxt.DataSenderQueue->use_tail2;\r\n            SpinLockRelease(&t_thrd.dataqueue_cxt.DataSenderQueue->use_mutex);\r\n            break;\r\n        } else if ((t_thrd.dataqueue_cxt.DataSenderQueue->use_head2.queueoff -\r\n                       t_thrd.dataqueue_cxt.DataSenderQueue->use_tail1.queueoff) > total_len) {\r\n            /* update use_tail1 */\r\n            freespace_head = t_thrd.dataqueue_cxt.DataSenderQueue->use_tail1.queueoff;\r\n            if (DataQueuePtrIsInvalid(t_thrd.dataqueue_cxt.DataSenderQueue->use_tail1))\r\n                t_thrd.dataqueue_cxt.DataSenderQueue->use_tail1.queueid++;\r\n            DQByteAdvance(t_thrd.dataqueue_cxt.DataSenderQueue->use_tail1, total_len);\r\n            data_header.queue_offset = t_thrd.dataqueue_cxt.DataSenderQueue->use_tail1;\r\n            SpinLockRelease(&t_thrd.dataqueue_cxt.DataSenderQueue->use_mutex);\r\n            break;\r\n        }\r\n\r\n        SpinLockRelease(&t_thrd.dataqueue_cxt.DataSenderQueue->use_mutex);\r\n\r\n        /* print the log every 10s */\r\n        if (time_count % 10000 == 0)\r\n            ereport(LOG, (errmsg(\"can not get enough freespace for page to be sent\")));\r\n        LWLockRelease(DataSyncRepLock);\r\n\r\n        if (g_instance.attr.attr_storage.max_wal_senders > 0) {\r\n            if (t_thrd.walsender_cxt.WalSndCtl->sync_master_standalone) {\r\n                ereport(LOG,\r\n                    (errmsg(\"failed to push rnode %u/%u/%u blockno %u into data-queue becuase sync_master_standalone \"\r\n                            \"is false.\"\r\n                            \" attid %d, pageoffset2blockno %lu, size %u\",\r\n                        rnode.spcNode,\r\n                        rnode.dbNode,\r\n                        rnode.relNode,\r\n                        blockNum,\r\n                        attid,\r\n                        offset / BLCKSZ,\r\n                        data_len)));\r\n                return invalidPtr;\r\n            } else\r\n                DataSndWakeup();\r\n        }\r\n\r\n        /*\r\n         * Check interrupts before we get in sleep, and we can not use\r\n         * CHECK_FOR_INTERRUPTS because we have hold the page lwlock.\r\n         */\r\n        if (IsDataReplInterruptted()) {\r\n            ereport(LOG,\r\n                (errmsg(\"failed to push rnode %u/%u/%u blockno %u into data-queue becuase InterruptPending is true and\"\r\n                        \" datasender is not in progress. attid %d, pageoffset2blockno %lu, size %u\",\r\n                    rnode.spcNode,\r\n                    rnode.dbNode,\r\n                    rnode.relNode,\r\n                    blockNum,\r\n                    attid,\r\n                    offset / BLCKSZ,\r\n                    data_len)));\r\n            return invalidPtr;\r\n        }\r\n\r\n        /* wait for 1ms */\r\n        CatchupShutdownIfNoDataSender();\r\n        WaitState oldStatus = pgstat_report_waitstatus(STATE_WAIT_DATASYNC_QUEUE);\r\n        pg_usleep(1000L);\r\n        time_count++;\r\n        (void)pgstat_report_waitstatus(oldStatus);\r\n    } while (true);\r\n\r\n    // copy data to buffer\r\n    // 0. total_len\r\n    // 1. data header\r\n    // 2. data\r\n    errorno = memcpy_s(t_thrd.dataqueue_cxt.DataSenderQueue->pages + freespace_head,\r\n        g_instance.attr.attr_storage.DataQueueBufSize * 1024 - freespace_head,\r\n        &total_len,\r\n        sizeof(uint32));\r\n    securec_check(errorno, \"\", \"\");\r\n    freespace_head += sizeof(uint32);\r\n\r\n    errorno = memcpy_s(t_thrd.dataqueue_cxt.DataSenderQueue->pages + freespace_head,\r\n        g_instance.attr.attr_storage.DataQueueBufSize * 1024 - freespace_head,\r\n        &data_header,\r\n        data_header_len);\r\n    securec_check(errorno, \"\", \"\");\r\n    freespace_head += data_header_len;\r\n\r\n    errorno = memcpy_s(t_thrd.dataqueue_cxt.DataSenderQueue->pages + freespace_head,\r\n        g_instance.attr.attr_storage.DataQueueBufSize * 1024 - freespace_head,\r\n        mem,\r\n        data_len);\r\n    securec_check(errorno, \"\", \"\");\r\n\r\n    LWLockRelease(DataSyncRepLock);\r\n\r\n    /*\r\n     * Put the header of page to the array, if the array will be full, to clear\r\n     * a part of array\r\n     */\r\n    PushToBCMElementArray(rnode, blockNum, type, data_len, attid, offset, data_header.queue_offset);\r\n\r\n    Assert(!DataQueuePtrIsInvalid(data_header.queue_offset));\r\n\r\n    /* return the offset of DataSenderQueue */\r\n    return data_header.queue_offset;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"PushToSenderQueue"
	},
	"PushToWriterQueue":{
		"body":"DataQueuePtr PushToWriterQueue(const char* mem, uint32 mem_len)\r\n{\r\n    uint32 buffer_size = g_instance.attr.attr_storage.DataQueueBufSize * 1024; /* unit: Bytes */\r\n    uint32 freespace_head = 0;\r\n    DataQueuePtr current_offset = (DataQueuePtr){0, 0};\r\n    uint32 time_count = 1;\r\n    ThreadId writerPid = 0;\r\n    errno_t errorno = EOK;\r\n\r\n    /* get enough buffer */\r\n    do {\r\n        LWLockAcquire(DataSyncRepLock, LW_SHARED);\r\n\r\n        SpinLockAcquire(&t_thrd.dataqueue_cxt.DataWriterQueue->use_mutex);\r\n\r\n        if (buffer_size - t_thrd.dataqueue_cxt.DataWriterQueue->use_tail2.queueoff >= mem_len &&\r\n            DataQueuePtrIsInvalid(t_thrd.dataqueue_cxt.DataWriterQueue->use_tail1)) {\r\n            /* update use_tail2 */\r\n            freespace_head = t_thrd.dataqueue_cxt.DataWriterQueue->use_tail2.queueoff;\r\n            DQByteAdvance(t_thrd.dataqueue_cxt.DataWriterQueue->use_tail2, mem_len);\r\n            current_offset = t_thrd.dataqueue_cxt.DataWriterQueue->use_tail2;\r\n            SpinLockRelease(&t_thrd.dataqueue_cxt.DataWriterQueue->use_mutex);\r\n            break;\r\n        } else if ((t_thrd.dataqueue_cxt.DataWriterQueue->use_head2.queueoff -\r\n                       t_thrd.dataqueue_cxt.DataWriterQueue->use_tail1.queueoff) >= mem_len) {\r\n            /* update use_tail1 */\r\n            freespace_head = t_thrd.dataqueue_cxt.DataWriterQueue->use_tail1.queueoff;\r\n            if (DataQueuePtrIsInvalid(t_thrd.dataqueue_cxt.DataWriterQueue->use_tail1))\r\n                t_thrd.dataqueue_cxt.DataWriterQueue->use_tail1.queueid++;\r\n            DQByteAdvance(t_thrd.dataqueue_cxt.DataWriterQueue->use_tail1, mem_len);\r\n            current_offset = t_thrd.dataqueue_cxt.DataWriterQueue->use_tail1;\r\n            SpinLockRelease(&t_thrd.dataqueue_cxt.DataWriterQueue->use_mutex);\r\n            break;\r\n        }\r\n\r\n        SpinLockRelease(&t_thrd.dataqueue_cxt.DataWriterQueue->use_mutex);\r\n        LWLockRelease(DataSyncRepLock);\r\n\r\n        /* print the log every 10s */\r\n        if (time_count % 1000 == 0)\r\n            ereport(LOG, (errmsg(\"can not get enough freespace for page to be write\")));\r\n\r\n        /* when datawriter and datareceiver is started, wake up DataRcvWriter */\r\n        if (!g_instance.attr.attr_storage.enable_mix_replication) {\r\n            volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n            ProcessDataRcvInterrupts();\r\n            SpinLockAcquire(&datarcv->mutex);\r\n            writerPid = datarcv->writerPid;\r\n            SpinLockRelease(&datarcv->mutex);\r\n            if (writerPid != 0) {\r\n                WakeupDataRcvWriter();\r\n                /* Keepalived with primary when waiting flush wal data */\r\n                DataRcvSendReply(false, false);\r\n                /* sleep 10ms */\r\n                pg_usleep(10000L);\r\n                time_count++;\r\n            } else\r\n                DataRcvDataCleanup();\r\n        } else { /* when there is only walrcv and walwriter, wake up WalRcvWriter */\r\n            volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n            ProcessWalRcvInterrupts();\r\n            SpinLockAcquire(&walrcv->mutex);\r\n            writerPid = walrcv->writerPid;\r\n            SpinLockRelease(&walrcv->mutex);\r\n            if (writerPid != 0) {\r\n                wakeupWalRcvWriter();\r\n                /* Keepalived with primary when waiting flush wal data */\r\n                XLogWalRcvSendReply(false, false);\r\n                /* sleep 10ms */\r\n                pg_usleep(10000L);\r\n                time_count++;\r\n            } else\r\n                walRcvDataCleanup();\r\n        }\r\n    } while (true);\r\n\r\n    /* copy data to buffer */\r\n    errorno = memcpy_s(t_thrd.dataqueue_cxt.DataWriterQueue->pages + freespace_head,\r\n        g_instance.attr.attr_storage.DataQueueBufSize * 1024 - freespace_head,\r\n        mem,\r\n        mem_len);\r\n    securec_check(errorno, \"\", \"\");\r\n    LWLockRelease(DataSyncRepLock);\r\n\r\n    if (u_sess->attr.attr_storage.HaModuleDebug) {\r\n        ereport(LOG,\r\n            (errmsg(\"HA-PushToWriterQueue done: data size %u, from %u to %u/%u\",\r\n                mem_len,\r\n                freespace_head,\r\n                current_offset.queueid,\r\n                current_offset.queueoff)));\r\n    }\r\n\r\n    /* Return the offset of  data queue */\r\n    return current_offset;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"PushToWriterQueue"
	},
	"ResetBCMArray":{
		"body":"void ResetBCMArray(void)\r\n{\r\n    t_thrd.dataqueue_cxt.BCMElementArrayIndex1 = 0;\r\n    t_thrd.dataqueue_cxt.BCMElementArrayIndex2 = BCMElementArrayLenHalf;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"ResetBCMArray"
	},
	"ResetDataQueue":{
		"body":"void ResetDataQueue(DataQueueData* data_queue)\r\n{\r\n    DataQueuePtr invalidptr = (DataQueuePtr){0, 0};\r\n    DataQueuePtr queue_tail1 = (DataQueuePtr){0, 0};\r\n    DataQueuePtr queue_head2 = (DataQueuePtr){0, 0};\r\n    DataQueuePtr queue_tail2 = (DataQueuePtr){0, 0};\r\n\r\n    if (data_queue == NULL)\r\n        return; /* nothing to do */\r\n\r\n    /* Keep the queue size and page start location. */\r\n    SpinLockAcquire(&data_queue->use_mutex);\r\n    queue_tail1 = data_queue->use_tail1;\r\n    queue_head2 = data_queue->use_head2;\r\n    queue_tail2 = data_queue->use_tail2;\r\n    data_queue->use_tail1 = invalidptr;\r\n    data_queue->use_head2 = invalidptr;\r\n    data_queue->use_tail2 = invalidptr;\r\n    SpinLockRelease(&data_queue->use_mutex);\r\n\r\n    if (!DataQueuePtrIsInvalid(queue_tail1) || !DQByteEQ(queue_head2, queue_tail2))\r\n        ereport(WARNING,\r\n            (errmsg(\"data remained in reset data queue: tail1:%u/%u,head2:%u/%u,tail2:%u/%u\",\r\n                queue_tail1.queueid,\r\n                queue_tail1.queueoff,\r\n                queue_head2.queueid,\r\n                queue_head2.queueoff,\r\n                queue_tail2.queueid,\r\n                queue_tail2.queueoff)));\r\n}",
		"comment":"/*\r\n * Reset the given data queue data.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"ResetDataQueue"
	},
	"UpdateDataSendPosition":{
		"body":"static void UpdateDataSendPosition(void)\r\n{\r\n    int i = 0;\r\n\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_wal_senders; i++) {\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile DataSnd* datasnd = &t_thrd.datasender_cxt.DataSndCtl->datasnds[i];\r\n\r\n        SpinLockAcquire(&datasnd->mutex);\r\n\r\n        if (datasnd->pid != 0) {\r\n            datasnd->sendPosition.queueid++;\r\n            datasnd->sendPosition.queueoff = 0;\r\n        }\r\n\r\n        SpinLockRelease(&datasnd->mutex);\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"UpdateDataSendPosition"
	},
	"UpdateDataWritePosition":{
		"body":"static void UpdateDataWritePosition(void)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n\r\n    SpinLockAcquire(&datarcv->mutex);\r\n\r\n    if (datarcv->pid != 0) {\r\n        datarcv->localWritePosition.queueid++;\r\n        datarcv->localWritePosition.queueoff = 0;\r\n    }\r\n\r\n    SpinLockRelease(&datarcv->mutex);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"UpdateDataWritePosition"
	},
	"UpdateWalDataWritePosition":{
		"body":"static void UpdateWalDataWritePosition(void)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n\r\n    if (walrcv->pid != 0) {\r\n        walrcv->local_write_pos.queueid++;\r\n        walrcv->local_write_pos.queueoff = 0;\r\n    }\r\n\r\n    SpinLockRelease(&walrcv->mutex);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\dataqueue.cpp",
		"name":"UpdateWalDataWritePosition"
	}
}