{
	"DataRcvDataCleanup":{
		"body":"void DataRcvDataCleanup(void)\r\n{\r\n    /*\r\n     * Cleanup the data writer queue rather than do a last write because the data\r\n     * may distribute on the both sides of data write queue. In this scenario, an\r\n     * attempt to write the data write queue would leave the left data queue data\r\n     * which may cause data loss especially during standby failover process.\r\n     */\r\n    if (!dummyStandbyMode)\r\n        while (DataRcvWrite() > 0)\r\n            ;\r\n}",
		"comment":"/*\r\n * Clean up data in receive queue.\r\n * This function should be called on thread exit.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"DataRcvDataCleanup"
	},
	"DataRcvDie":{
		"body":"static void DataRcvDie(int code, Datum arg)\r\n{\r\n    /* Use volatile pointer to prevent code rearrangement */\r\n    volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n\r\n    /*\r\n     * Shutdown DataRcvWriter thread, clear the data receive buffer.\r\n     * Ensure that all pages received are flushed to disk.\r\n     */\r\n    ShutDownDataRcvWriter();\r\n\r\n    /*\r\n     * Clean up the data writer queue, then reset the writer queue. In most\r\n     * scenarios, we should not force to reset it especially when there are remained\r\n     * data in data queue which were left by datarcv writer when database directory\r\n     * was not ready.\r\n     * We use the catchup process in primary to avoid data loss in forcing reset.\r\n     * When the data receiver starts up again, the primary will catchup the data which\r\n     * wasn't received by standby include the data received but not feeded back.\r\n     * If the current data receiver was connected to secondary during failover, the data\r\n     * forced reset would be cleaned up in secondary until caughtup between primary\r\n     * and standby.\r\n     */\r\n    DataRcvDataCleanup();\r\n    ResetDataQueue(t_thrd.dataqueue_cxt.DataWriterQueue);\r\n\r\n    SpinLockAcquire(&datarcv->mutex);\r\n    Assert(datarcv->dataRcvState == DATARCV_RUNNING || datarcv->dataRcvState == DATARCV_STOPPING);\r\n    Assert(datarcv->pid == t_thrd.proc_cxt.MyProcPid);\r\n    datarcv->dataRcvState = DATARCV_STOPPED;\r\n    datarcv->pid = 0;\r\n    datarcv->isRuning = false;\r\n    datarcv->receivePosition.queueid = 0;\r\n    datarcv->receivePosition.queueoff = 0;\r\n    SpinLockRelease(&datarcv->mutex);\r\n\r\n    /* Terminate the connection gracefully. */\r\n    DataRcvStreamDisconnect();\r\n\r\n    if (t_thrd.datareceiver_cxt.recvBuf != NULL) {\r\n        PQfreemem(t_thrd.datareceiver_cxt.recvBuf);\r\n        t_thrd.datareceiver_cxt.recvBuf = NULL;\r\n    }\r\n\r\n    ereport(LOG, (errmsg(\"datareceiver thread shut down\")));\r\n}",
		"comment":"/*\r\n * Mark us as STOPPED in shared memory at exit.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"DataRcvDie"
	},
	"DataRcvInProgress":{
		"body":"bool DataRcvInProgress(void)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n    DataRcvState state;\r\n    pg_time_t startTime;\r\n\r\n    SpinLockAcquire(&datarcv->mutex);\r\n\r\n    state = datarcv->dataRcvState;\r\n    startTime = datarcv->startTime;\r\n\r\n    SpinLockRelease(&datarcv->mutex);\r\n\r\n    /*\r\n     * If it has taken too long for walreceiver to start up, give up. Setting\r\n     * the state to STOPPED ensures that if walreceiver later does start up\r\n     * after all, it will see that it's not supposed to be running and die\r\n     * without doing anything.\r\n     */\r\n    if (state == DATARCV_STARTING) {\r\n        pg_time_t now = (pg_time_t)time(NULL);\r\n        if ((now - startTime) > DATARCV_STARTUP_TIMEOUT) {\r\n            SpinLockAcquire(&datarcv->mutex);\r\n\r\n            if (datarcv->dataRcvState == DATARCV_STARTING)\r\n                state = datarcv->dataRcvState = DATARCV_STOPPED;\r\n\r\n            SpinLockRelease(&datarcv->mutex);\r\n            ereport(WARNING, (errmsg(\"shut down datareceiver due to start up timeout.\")));\r\n        }\r\n    }\r\n\r\n    if (state != DATARCV_STOPPED)\r\n        return true;\r\n    else\r\n        return false;\r\n}",
		"comment":"/* Is datareceiver in progress (or starting up)? */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"DataRcvInProgress"
	},
	"DataRcvProcessMsg":{
		"body":"static void DataRcvProcessMsg(unsigned char type, char* buf, Size len)\r\n{\r\n    errno_t errorno = EOK;\r\n    switch (type) {\r\n        case 'b': { /* search files for bcm */\r\n            if (dummyStandbyMode) {\r\n                ereport(LOG, (errmsg(\"Received incremental searching bcm message\")));\r\n                ParseDummyFile();\r\n                break;\r\n            }\r\n        }\r\n        // lint -fallthrough\r\n        case 'd': /* Data page */\r\n        {\r\n            DataPageMessageHeader msghdr;\r\n\r\n            if (len < sizeof(DataPageMessageHeader))\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_PROTOCOL_VIOLATION),\r\n                        errmsg_internal(\"invalid data page message received from primary\")));\r\n            /* memcpy is required here for alignment reasons */\r\n            errorno = memcpy_s(&msghdr, sizeof(DataPageMessageHeader), buf, sizeof(DataPageMessageHeader));\r\n            securec_check(errorno, \"\", \"\");\r\n            ProcessDataHeaderMessage(&msghdr);\r\n\r\n            buf += sizeof(DataPageMessageHeader);\r\n            len -= sizeof(DataPageMessageHeader);\r\n\r\n            volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n\r\n            if (datarcv->conn_target != REPCONNTARGET_DUMMYSTANDBY) {\r\n                DQByteAdvance(msghdr.dataStart, len);\r\n                if (!DQByteEQ(msghdr.dataStart, msghdr.dataEnd))\r\n                    ereport(PANIC,\r\n                        (errcode(ERRCODE_PROTOCOL_VIOLATION),\r\n                            errmsg(\"invalid message header, maybe the parameter of\"\r\n                                   \" \\\"data_replicate_buffer_size\\\" on the master has been changed\"),\r\n                            errhint(\"You might need to restart the instance.\")));\r\n            } else if (unlikely(!DataQueuePtrIsInvalid(msghdr.dataEnd))) {\r\n                ereport(PANIC, (errcode(ERRCODE_PROTOCOL_VIOLATION), errmsg(\"invalid message end\")));\r\n            }\r\n            DataRcvReceive(buf, len);\r\n            break;\r\n        }\r\n\r\n        case 'k': /* Keepalive */\r\n        {\r\n            DataSndKeepaliveMessage keepalive;\r\n\r\n            if (len != sizeof(DataSndKeepaliveMessage))\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_PROTOCOL_VIOLATION),\r\n                        errmsg_internal(\"invalid keepalive message received from primary\")));\r\n            /* memcpy is required here for alignment reasons */\r\n            errorno = memcpy_s(&keepalive, sizeof(DataSndKeepaliveMessage), buf, sizeof(DataSndKeepaliveMessage));\r\n            securec_check(errorno, \"\", \"\");\r\n            ProcessKeepaliveMessage(&keepalive);\r\n\r\n            /* If the primary requested a reply, send one immediately */\r\n            if (keepalive.replyRequested)\r\n                DataRcvSendReply(true, false);\r\n            break;\r\n        }\r\n        case 'e': /* end data */\r\n        {\r\n            EndDataMessage endDataMessage;\r\n\r\n            if (len != sizeof(EndDataMessage))\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_PROTOCOL_VIOLATION),\r\n                        errmsg_internal(\"invalid EndDataMessage message received from Secondary Standby\")));\r\n            /* memcpy is required here for alignment reasons */\r\n            errorno = memcpy_s(&endDataMessage, sizeof(EndDataMessage), buf, sizeof(EndDataMessage));\r\n            securec_check(errorno, \"\", \"\");\r\n            ProcessEndDataMessage(&endDataMessage);\r\n            break;\r\n        }\r\n        case 'x': /* rm data */\r\n        {\r\n            RmDataMessage rmDataMessage;\r\n\r\n            if (len != sizeof(RmDataMessage))\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_PROTOCOL_VIOLATION),\r\n                        errmsg_internal(\"invalid RmData message received from primary\")));\r\n            /* memcpy is required here for alignment reasons */\r\n            errorno = memcpy_s(&rmDataMessage, sizeof(RmDataMessage), buf, sizeof(RmDataMessage));\r\n            securec_check(errorno, \"\", \"\");\r\n            ProcessRmDataMessage(&rmDataMessage);\r\n            break;\r\n        }\r\n        default:\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_PROTOCOL_VIOLATION),\r\n                    errmsg_internal(\"invalid data replication message type %d\", type)));\r\n    }\r\n}",
		"comment":"/*\r\n * Accept the message from replication stream, and process it.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"DataRcvProcessMsg"
	},
	"DataRcvQuickDieHandler":{
		"body":"static void DataRcvQuickDieHandler(SIGNAL_ARGS)\r\n{\r\n    gs_signal_setmask(&t_thrd.libpq_cxt.BlockSig, NULL);\r\n\r\n    /*\r\n     * We DO NOT want to run proc_exit() callbacks -- we're here because\r\n     * shared memory may be corrupted, so we don't want to try to clean up our\r\n     * transaction.  Just nail the windows shut and get out of town.  Now that\r\n     * there's an atexit callback to prevent third-party code from breaking\r\n     * things by calling exit() directly, we have to reset the callbacks\r\n     * explicitly to make this work as intended.\r\n     */\r\n    on_exit_reset();\r\n\r\n    /*\r\n     * Note we do exit(2) not exit(0).	This is to force the postmaster into a\r\n     * system reset cycle if some idiot DBA sends a manual SIGQUIT to a random\r\n     * backend.  This is necessary precisely because we don't clean up our\r\n     * shared memory state.  (The \"dead man switch\" mechanism in pmsignal.c\r\n     * should ensure the postmaster sees this as a crash, too, but no harm in\r\n     * being doubly sure.)\r\n     */\r\n    exit(2);\r\n}",
		"comment":"/*\r\n * DataRcvQuickDieHandler() occurs when signalled SIGQUIT by the postmaster.\r\n *\r\n * Some backend has bought the farm, so we need to stop what we're doing and\r\n * exit.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"DataRcvQuickDieHandler"
	},
	"DataRcvReceive":{
		"body":"static void DataRcvReceive(char* buf, Size nbytes)\r\n{\r\n    BlockNumber cursegno = InvalidBlockNumber;\r\n    DataElementHeaderData dataelemheader;\r\n    /* buf unit */\r\n    uint32 currentlen = 0;\r\n    int headerlen = sizeof(DataElementHeaderData);\r\n    errno_t rc = 0;\r\n#ifdef DATA_DEBUG\r\n    pg_crc32 crc;\r\n#endif\r\n\r\n    while (nbytes >= sizeof(uint32) + sizeof(DataElementHeaderData)) {\r\n        rc = memcpy_s((void*)&currentlen, sizeof(uint32), buf, sizeof(uint32));\r\n        securec_check(rc, \"\", \"\");\r\n        buf += sizeof(uint32);\r\n\r\n        rc = memcpy_s((void*)&dataelemheader, headerlen, buf, headerlen);\r\n        securec_check(rc, \"\", \"\");\r\n        buf += headerlen;\r\n        if (u_sess->attr.attr_storage.HaModuleDebug) {\r\n            ereport(LOG,\r\n                (errmsg(\"DataRcvReceive element info: %u, %u, %u, %u  \",\r\n                    dataelemheader.rnode.dbNode,\r\n                    dataelemheader.rnode.spcNode,\r\n                    dataelemheader.rnode.relNode,\r\n                    GETATTID((uint)dataelemheader.attid))));\r\n        }\r\n\r\n        cursegno = dataelemheader.blocknum / ((BlockNumber)RELSEG_SIZE);\r\n\r\n        if (currentlen != (sizeof(uint32) + (uint32)headerlen + (uint32)dataelemheader.data_size)) {\r\n            ereport(ERROR,\r\n                (errmsg(\"Current length is illegal, the dataRcvReceiveelement info is : %u, %u, %u, %d  \",\r\n                    dataelemheader.rnode.dbNode,\r\n                    dataelemheader.rnode.spcNode,\r\n                    dataelemheader.rnode.relNode,\r\n                    GETATTID(dataelemheader.attid))));\r\n        }\r\n\r\n        if (u_sess->attr.attr_storage.HaModuleDebug) {\r\n            /* now BLCKSZ is equal to ALIGNOF_CUSIZE, so either one is used */\r\n            ereport(LOG,\r\n                (errmsg(\"HA-DataRcvReceive: rnode %u/%u/%u, blockno %u, segno %u, \"\r\n                        \"pageoffset2blockno %lu, size %u, queueoffset %u/%u\",\r\n                    dataelemheader.rnode.spcNode,\r\n                    dataelemheader.rnode.dbNode,\r\n                    dataelemheader.rnode.relNode,\r\n                    dataelemheader.blocknum,\r\n                    cursegno,\r\n                    dataelemheader.offset / BLCKSZ,\r\n                    dataelemheader.data_size,\r\n                    dataelemheader.queue_offset.queueid,\r\n                    dataelemheader.queue_offset.queueoff)));\r\n        }\r\n\r\n        /* Add hearbeat */\r\n        DataRcvSendReply(false, false);\r\n\r\n#ifdef DATA_DEBUG\r\n        INIT_CRC32(crc);\r\n        COMP_CRC32(crc, buf, dataelemheader.data_size);\r\n        FIN_CRC32(crc);\r\n\r\n        if (!EQ_CRC32(dataelemheader.data_crc, crc)) {\r\n            ereport(PANIC,\r\n                (errmsg(\"received incorrect data page checksum at: \"\r\n                        \"rnode[%u,%u,%u], blockno[%u], segno[%u], \"\r\n                        \"pageoffset[%u], size[%u], queueoffset[%u/%u]\",\r\n                    dataelemheader.rnode.spcNode,\r\n                    dataelemheader.rnode.dbNode,\r\n                    dataelemheader.rnode.relNode,\r\n                    dataelemheader.blocknum,\r\n                    cursegno,\r\n                    dataelemheader.offset,\r\n                    dataelemheader.data_size,\r\n                    dataelemheader.queue_offset.queueid,\r\n                    dataelemheader.queue_offset.queueoff)));\r\n        }\r\n#endif\r\n\r\n        /* Push the holl data element with head into writer queue. */\r\n        (void)PushToWriterQueue(buf - sizeof(uint32) - headerlen, currentlen);\r\n\r\n        buf += dataelemheader.data_size;\r\n        nbytes -= currentlen;\r\n\r\n        WakeupDataRcvWriter();\r\n    }\r\n    Assert(nbytes == 0);\r\n\r\n    WakeupDataRcvWriter();\r\n}",
		"comment":"/*\r\n * Receive data from remote server, then push to writer queue.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"DataRcvReceive"
	},
	"DataRcvSendReply":{
		"body":"void DataRcvSendReply(bool force, bool requestReply)\r\n{\r\n    volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n    char buf[sizeof(StandbyDataReplyMessage) + 1] = {0};\r\n    TimestampTz now;\r\n    DataQueuePtr receivePosition;\r\n    errno_t errorno = EOK;\r\n\r\n    /*\r\n     * If the user doesn't want status to be reported to the master, be sure\r\n     * to exit before doing anything at all.\r\n     */\r\n    if (!force && u_sess->attr.attr_storage.wal_receiver_status_interval <= 0)\r\n        return;\r\n\r\n    /* Get current timestamp. */\r\n    now = GetCurrentTimestamp();\r\n\r\n    SpinLockAcquire(&datarcv->mutex);\r\n    receivePosition.queueid = datarcv->receivePosition.queueid;\r\n    receivePosition.queueoff = datarcv->receivePosition.queueoff;\r\n    SpinLockRelease(&datarcv->mutex);\r\n\r\n    if (!force && (DQByteEQ(t_thrd.datareceiver_cxt.reply_message->receivePosition, receivePosition)) &&\r\n        !(TimestampDifferenceExceeds(t_thrd.datareceiver_cxt.reply_message->sendTime, now,\r\n        u_sess->attr.attr_storage.wal_receiver_status_interval * 1000) ||\r\n        TimestampDifferenceExceeds(now, t_thrd.datareceiver_cxt.reply_message->sendTime,\r\n        u_sess->attr.attr_storage.wal_receiver_status_interval * 1000))) {\r\n        return;\r\n    }\r\n\r\n    /* Construct a new message */\r\n    t_thrd.datareceiver_cxt.reply_message->receivePosition = receivePosition;\r\n    t_thrd.datareceiver_cxt.reply_message->sendTime = now;\r\n    t_thrd.datareceiver_cxt.reply_message->replyRequested = requestReply;\r\n\r\n    ereport(DEBUG2,\r\n        (errmsg(\"sending data receive queue position %u/%u\",\r\n            t_thrd.datareceiver_cxt.reply_message->receivePosition.queueid,\r\n            t_thrd.datareceiver_cxt.reply_message->receivePosition.queueoff)));\r\n\r\n    /* Prepend with the message type and send it. */\r\n    buf[0] = 'r';\r\n    errorno = memcpy_s(&buf[1],\r\n        sizeof(StandbyDataReplyMessage),\r\n        t_thrd.datareceiver_cxt.reply_message,\r\n        sizeof(StandbyDataReplyMessage));\r\n    securec_check(errorno, \"\", \"\");\r\n    DataRcvStreamSend(buf, sizeof(StandbyDataReplyMessage) + 1);\r\n}",
		"comment":"/*\r\n * Send reply message to primary, indicating our current received positions.\r\n *\r\n * If 'force' is not true, the message is not sent unless enough time has\r\n * passed since last status update to reach wal_receiver_status_internal (or\r\n * if u_sess->attr.attr_storage.wal_receiver_status_interval is disabled altogether).\r\n *\r\n * If 'requestReply' is true, requests the server to reply immediately upon receiving\r\n * this message. This is used for heartbearts, when approaching u_sess->attr.attr_storage.wal_receiver_timeout.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"DataRcvSendReply"
	},
	"DataRcvShmemInit":{
		"body":"void DataRcvShmemInit(void)\r\n{\r\n    bool found = false;\r\n    errno_t rc = 0;\r\n\r\n    t_thrd.datareceiver_cxt.DataRcv = (DataRcvData*)ShmemInitStruct(\"Data Receiver Ctl\", DataRcvShmemSize(), &found);\r\n\r\n    if (!found) {\r\n        /* First time through, so initialize */\r\n        rc = memset_s(t_thrd.datareceiver_cxt.DataRcv, DataRcvShmemSize(), 0, DataRcvShmemSize());\r\n        securec_check(rc, \"\", \"\");\r\n        SpinLockInit(&t_thrd.datareceiver_cxt.DataRcv->mutex);\r\n    }\r\n}",
		"comment":"/* Allocate and initialize datareceiver-related shared memory */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"DataRcvShmemInit"
	},
	"DataRcvShmemSize":{
		"body":"Size DataRcvShmemSize(void)\r\n{\r\n    Size size = 0;\r\n\r\n    size = add_size(size, sizeof(DataRcvData));\r\n\r\n    return size;\r\n}",
		"comment":"/* Report shared memory space needed by DataRcvShmemInit */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"DataRcvShmemSize"
	},
	"DataRcvShutdownHandler":{
		"body":"static void DataRcvShutdownHandler(SIGNAL_ARGS)\r\n{\r\n    t_thrd.datareceiver_cxt.got_SIGTERM = true;\r\n\r\n    /* cancel the wait for database directory */\r\n    t_thrd.int_cxt.ProcDiePending = true;\r\n}",
		"comment":"/* SIGTERM: set flag for main loop, or shutdown immediately if safe */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"DataRcvShutdownHandler"
	},
	"DataRcvSigHupHandler":{
		"body":"static void DataRcvSigHupHandler(SIGNAL_ARGS)\r\n{\r\n    t_thrd.datareceiver_cxt.got_SIGHUP = true;\r\n}",
		"comment":"/* SIGHUP: set flag to re-read config file at next convenient time */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"DataRcvSigHupHandler"
	},
	"DataRcvStreamConnect":{
		"body":"static void DataRcvStreamConnect(char* conninfo)\r\n{\r\n    char conninfo_repl[MAXCONNINFO + 75] = {0};\r\n\r\n    char* primary_sysid = NULL;\r\n    char standby_sysid[32];\r\n    TimeLineID primary_tli;\r\n    TimeLineID standby_tli;\r\n    PGresult* res = NULL;\r\n    ServerMode primary_mode;\r\n    int rc = EOK;\r\n\r\n    /*\r\n     * Connect the primary server in data replication.\r\n     */\r\n    if (dummyStandbyMode) {\r\n        rc = snprintf_s(conninfo_repl,\r\n            sizeof(conninfo_repl),\r\n            sizeof(conninfo_repl) - 1,\r\n            \"%s dbname=replication replication=data \"\r\n            \"fallback_application_name=dummystandby \"\r\n            \"connect_timeout=%d\",\r\n            conninfo,\r\n            u_sess->attr.attr_storage.wal_receiver_connect_timeout);\r\n    } else {\r\n        rc = snprintf_s(conninfo_repl,\r\n            sizeof(conninfo_repl),\r\n            sizeof(conninfo_repl) - 1,\r\n            \"%s dbname=replication replication=data \"\r\n            \"fallback_application_name=%s \"\r\n            \"connect_timeout=%d\",\r\n            conninfo,\r\n            (u_sess->attr.attr_common.application_name && strlen(u_sess->attr.attr_common.application_name) > 0)\r\n                ? u_sess->attr.attr_common.application_name\r\n                : \"datareceiver\",\r\n            u_sess->attr.attr_storage.wal_receiver_connect_timeout);\r\n    }\r\n    securec_check_ss(rc, \"\", \"\");\r\n\r\n    ereport(LOG, (errmsg(\"data streaming replication connecting to primary :%s\", conninfo_repl)));\r\n\r\n    t_thrd.datareceiver_cxt.dataStreamingConn = PQconnectdb(conninfo_repl);\r\n    if (PQstatus(t_thrd.datareceiver_cxt.dataStreamingConn) != CONNECTION_OK)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_CONNECTION_TIMED_OUT),\r\n                errmsg(\"data receiver could not connect to the primary server: %s\",\r\n                    PQerrorMessage(t_thrd.datareceiver_cxt.dataStreamingConn))));\r\n    ereport(LOG, (errmsg(\"data streaming replication connected to primary :%s success.\", conninfo)));\r\n\r\n    if (!dummyStandbyMode) {\r\n        /*  FUTURE CASE:: need some consistence check */\r\n        if (!t_thrd.datareceiver_cxt.AmDataReceiverForDummyStandby) {\r\n            res = PQexec(t_thrd.datareceiver_cxt.dataStreamingConn, \"IDENTIFY_MODE\");\r\n            if (PQresultStatus(res) != PGRES_TUPLES_OK) {\r\n                PQclear(res);\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_INVALID_STATUS),\r\n                        errmsg(\"could not receive the ongoing mode infomation from \"\r\n                               \"the primary server: %s\",\r\n                            PQerrorMessage(t_thrd.datareceiver_cxt.dataStreamingConn))));\r\n            }\r\n            if (PQnfields(res) != 1 || PQntuples(res) != 1) {\r\n                int ntuples = PQntuples(res);\r\n                int nfields = PQnfields(res);\r\n\r\n                PQclear(res);\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_INVALID_STATUS),\r\n                        errmsg(\"invalid response from primary server\"),\r\n                        errdetail(\"Expected 1 tuple with 1 fields, got %d tuples with %d fields.\", ntuples, nfields)));\r\n            }\r\n            primary_mode = (ServerMode)pg_strtoint32(PQgetvalue(res, 0, 0));\r\n            if (primary_mode != PRIMARY_MODE) {\r\n                PQclear(res);\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_INVALID_STATUS),\r\n                        errmsg(\"the mode of the remote server must be primary, current is %s\",\r\n                            wal_get_role_string(primary_mode))));\r\n            }\r\n            PQclear(res);\r\n        }\r\n\r\n        /*\r\n         * Identify system\r\n         */\r\n        res = PQexec(t_thrd.datareceiver_cxt.dataStreamingConn, \"IDENTIFY_SYSTEM\");\r\n        if (PQresultStatus(res) != PGRES_TUPLES_OK) {\r\n            PQclear(res);\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_INVALID_STATUS),\r\n                    errmsg(\"could not receive database system identifier and timeline ID from \"\r\n                           \"the primary server: %s\",\r\n                        PQerrorMessage(t_thrd.datareceiver_cxt.dataStreamingConn))));\r\n        }\r\n        if (PQnfields(res) < 2 || PQntuples(res) != 1) {\r\n            int ntuples = PQntuples(res);\r\n            int nfields = PQnfields(res);\r\n\r\n            PQclear(res);\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_INVALID_STATUS),\r\n                    errmsg(\"invalid response from primary server\"),\r\n                    errdetail(\r\n                        \"Could not identify system: got %d rows and %d fields, expected %d rows and %d or more fields.\",\r\n                        ntuples,\r\n                        nfields,\r\n                        2,\r\n                        1)));\r\n        }\r\n        primary_sysid = PQgetvalue(res, 0, 0);\r\n        primary_tli = pg_strtoint32(PQgetvalue(res, 0, 1));\r\n\r\n        /*\r\n         * Confirm that the system identifier of the primary is the same as ours.\r\n         */\r\n        rc = snprintf_s(\r\n            standby_sysid, sizeof(standby_sysid), sizeof(standby_sysid) - 1, UINT64_FORMAT, GetSystemIdentifier());\r\n        securec_check_ss(rc, \"\", \"\");\r\n\r\n        if (strcmp(primary_sysid, standby_sysid) != 0) {\r\n            primary_sysid = pstrdup(primary_sysid);\r\n            PQclear(res);\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_INVALID_STATUS),\r\n                    errmsg(\"database system identifier differs between the primary and standby\"),\r\n                    errdetail(\"The primary's identifier is %s, the standby's identifier is %s.\",\r\n                        primary_sysid,\r\n                        standby_sysid)));\r\n        }\r\n        /*\r\n         * Confirm that the current timeline of the primary is the same as the\r\n         * recovery target timeline.\r\n         */\r\n        standby_tli = GetRecoveryTargetTLI();\r\n        PQclear(res);\r\n\r\n        if (primary_tli != standby_tli) {\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_INVALID_STATUS),\r\n                    errmsg(\"timeline %u of the primary does not match recovery target timeline %u\",\r\n                        primary_tli,\r\n                        standby_tli)));\r\n        }\r\n        t_thrd.xlog_cxt.ThisTimeLineID = primary_tli;\r\n    }\r\n    /*\r\n     * Start data replication.\r\n     */\r\n    res = PQexec(t_thrd.datareceiver_cxt.dataStreamingConn, \"START_REPLICATION DATA\");\r\n    if (PQresultStatus(res) != PGRES_COPY_BOTH) {\r\n        PQclear(res);\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INVALID_STATUS),\r\n                errmsg(\r\n                    \"could not start DATA streaming: %s\", PQerrorMessage(t_thrd.datareceiver_cxt.dataStreamingConn))));\r\n    }\r\n    PQclear(res);\r\n\r\n    ereport(LOG, (errmsg(\"data streaming replication successfully connected to primary.\")));\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"DataRcvStreamConnect"
	},
	"DataRcvStreamDisconnect":{
		"body":"static void DataRcvStreamDisconnect(void)\r\n{\r\n    PQfinish(t_thrd.datareceiver_cxt.dataStreamingConn);\r\n    t_thrd.datareceiver_cxt.dataStreamingConn = NULL;\r\n}",
		"comment":"/*\r\n * Disconnect connection to primary, if any.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"DataRcvStreamDisconnect"
	},
	"DataRcvStreamReceive":{
		"body":"static bool DataRcvStreamReceive(int timeout, unsigned char* type, char** buffer, int* len)\r\n{\r\n    int rawlen;\r\n\r\n    if (t_thrd.datareceiver_cxt.recvBuf != NULL) {\r\n        PQfreemem(t_thrd.datareceiver_cxt.recvBuf);\r\n    }\r\n    t_thrd.datareceiver_cxt.recvBuf = NULL;\r\n\r\n    /* Try to receive a CopyData message */\r\n    rawlen = PQgetCopyData(t_thrd.datareceiver_cxt.dataStreamingConn, &t_thrd.datareceiver_cxt.recvBuf, 1);\r\n    if (rawlen == 0) {\r\n        /*\r\n         * No data available yet. If the caller requested to block, wait for\r\n         * more data to arrive.\r\n         */\r\n        if (timeout > 0) {\r\n            if (!DataRcvStreamSelect(timeout)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (PQconsumeInput(t_thrd.datareceiver_cxt.dataStreamingConn) == 0) {\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_INVALID_STATUS),\r\n                    errmsg(\"could not receive data from DATA stream: %s\",\r\n                        PQerrorMessage(t_thrd.datareceiver_cxt.dataStreamingConn))));\r\n        }\r\n\r\n        /* Now that we've consumed some input, try again */\r\n        rawlen = PQgetCopyData(t_thrd.datareceiver_cxt.dataStreamingConn, &t_thrd.datareceiver_cxt.recvBuf, 1);\r\n        if (rawlen == 0) {\r\n            return false;\r\n        }\r\n    }\r\n    if (rawlen == -1) { /* end-of-streaming or error */\r\n        PGresult* res = NULL;\r\n\r\n        res = PQgetResult(t_thrd.datareceiver_cxt.dataStreamingConn);\r\n        if (PQresultStatus(res) == PGRES_COMMAND_OK || PQresultStatus(res) == PGRES_COPY_IN) {\r\n            PQclear(res);\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_INVALID_STATUS),\r\n                    errmsg(\"data replication terminated by primary server :%s\",\r\n                        PQerrorMessage(t_thrd.datareceiver_cxt.dataStreamingConn))));\r\n        } else {\r\n            PQclear(res);\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_INVALID_STATUS),\r\n                    errmsg(\"could not receive data from DATA stream: %s\",\r\n                        PQerrorMessage(t_thrd.datareceiver_cxt.dataStreamingConn))));\r\n        }\r\n    }\r\n    if (rawlen < -1) {\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INVALID_STATUS),\r\n                errmsg(\"could not receive data from DATA stream: %s\",\r\n                    PQerrorMessage(t_thrd.datareceiver_cxt.dataStreamingConn))));\r\n    }\r\n\r\n    /* Return received messages to caller */\r\n    *type = *((unsigned char*)t_thrd.datareceiver_cxt.recvBuf);\r\n    *buffer = t_thrd.datareceiver_cxt.recvBuf + sizeof(*type);\r\n    *len = rawlen - sizeof(*type);\r\n    return true;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"DataRcvStreamReceive"
	},
	"DataRcvStreamSelect":{
		"body":"static bool DataRcvStreamSelect(int timeout_ms)\r\n{\r\n    int ret;\r\n\r\n    Assert(t_thrd.datareceiver_cxt.dataStreamingConn != NULL);\r\n    if (PQsocket(t_thrd.datareceiver_cxt.dataStreamingConn) < 0) {\r\n        ereport(ERROR, (errcode_for_socket_access(), errmsg(\"socket not open\")));\r\n    }\r\n\r\n    /* We use poll(2) if available, otherwise select(2) */\r\n    {\r\n#ifdef HAVE_POLL\r\n        struct pollfd input_fd;\r\n\r\n        input_fd.fd = PQsocket(t_thrd.datareceiver_cxt.dataStreamingConn);\r\n        input_fd.events = POLLIN | POLLERR;\r\n        input_fd.revents = 0;\r\n\r\n        ret = poll(&input_fd, 1, timeout_ms);\r\n#else  /* !HAVE_POLL */\r\n\r\n        fd_set input_mask;\r\n        struct timeval timeout;\r\n        struct timeval* ptr_timeout = NULL;\r\n\r\n        FD_ZERO(&input_mask);\r\n        FD_SET(PQsocket(t_thrd.datareceiver_cxt.dataStreamingConn), &input_mask);\r\n\r\n        if (timeout_ms < 0) {\r\n            ptr_timeout = NULL;\r\n        } else {\r\n            timeout.tv_sec = timeout_ms / 1000;\r\n            timeout.tv_usec = (timeout_ms % 1000) * 1000;\r\n            ptr_timeout = &timeout;\r\n        }\r\n\r\n        ret = select(PQsocket(t_thrd.datareceiver_cxt.dataStreamingConn) + 1, &input_mask, NULL, NULL, ptr_timeout);\r\n#endif /* HAVE_POLL */\r\n    }\r\n\r\n    if (ret == 0 || (ret < 0 && errno == EINTR)) {\r\n        return false;\r\n    }\r\n    if (ret < 0) {\r\n        ereport(ERROR, (errcode_for_socket_access(), errmsg(\"select() failed: %m\")));\r\n    }\r\n    return true;\r\n}",
		"comment":"/*\r\n * Wait until we can read DATA stream, or timeout.\r\n *\r\n * Returns true if data has become available for reading, false if timed out\r\n * or interrupted by signal.\r\n *\r\n * This is based on pqSocketCheck.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"DataRcvStreamSelect"
	},
	"DataRcvStreamSend":{
		"body":"static void DataRcvStreamSend(const char* buffer, int nbytes)\r\n{\r\n    if (PQputCopyData(t_thrd.datareceiver_cxt.dataStreamingConn, buffer, nbytes) <= 0 ||\r\n        PQflush(t_thrd.datareceiver_cxt.dataStreamingConn)) {\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INVALID_STATUS),\r\n                errmsg(\"could not send data to DATA stream: %s\",\r\n                    PQerrorMessage(t_thrd.datareceiver_cxt.dataStreamingConn))));\r\n    }\r\n}",
		"comment":"/*\r\n * Send a message to DATA stream.\r\n * ereports on error.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"DataRcvStreamSend"
	},
	"DataRcvStreamSendFiles":{
		"body":"static void DataRcvStreamSendFiles(const char* buffer, int nbytes)\r\n{\r\n    if (PQputCopyData(t_thrd.datareceiver_cxt.dataStreamingConn, buffer, nbytes) <= 0 ||\r\n        PQflush(t_thrd.datareceiver_cxt.dataStreamingConn))\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INVALID_STATUS),\r\n                errmsg(\"could not send data to DATA stream: %s\",\r\n                    PQerrorMessage(t_thrd.datareceiver_cxt.dataStreamingConn))));\r\n}",
		"comment":"/*\r\n * Send a message to DATA stream.\r\n * ereports on error.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"DataRcvStreamSendFiles"
	},
	"DataReceiverMain":{
		"body":"void DataReceiverMain(void)\r\n{\r\n    char conninfo[MAXCONNINFO];\r\n    TimestampTz last_recv_timestamp;\r\n    bool ping_sent = false;\r\n    volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n    errno_t rc = 0;\r\n\r\n    t_thrd.xlog_cxt.InRecovery = true;\r\n\r\n    AssertEreport(datarcv != nullptr, MOD_FUNCTION, \"datarcv should not be null\");\r\n\r\n    ereport(LOG, (errmsg(\"datareceiver thread started\")));\r\n    /*\r\n     * Mark datareceiver as running in shared memory.\r\n     *\r\n     * Do this as early as possible, so that if we fail later on, we'll set\r\n     * state to STOPPED. If we die before this, the startup process will keep\r\n     * waiting for us to start up, until it times out.\r\n     */\r\n    SpinLockAcquire(&datarcv->mutex);\r\n    AssertEreport(datarcv->pid == 0, MOD_FUNCTION, \"datarcv pid should be zero\");\r\n    switch (datarcv->dataRcvState) {\r\n        case DATARCV_STOPPING:\r\n            /* If we've already been requested to stop, don't start up. */\r\n            datarcv->dataRcvState = DATARCV_STOPPED;\r\n            // lint -fallthrough\r\n        case DATARCV_STOPPED:\r\n            SpinLockRelease(&datarcv->mutex);\r\n            ereport(WARNING, (errmsg(\"datareceiver requested to stop when starting up.\")));\r\n            proc_exit(1);\r\n            break;\r\n\r\n        case DATARCV_STARTING:\r\n            /* The usual case */\r\n            break;\r\n\r\n        case DATARCV_RUNNING:\r\n            /* Shouldn't happen */\r\n            ereport(PANIC, (errmsg(\"datareceiver still running according to shared memory state\")));\r\n    }\r\n    /* Advertise our PID so that the startup process can kill us */\r\n    datarcv->pid = t_thrd.proc_cxt.MyProcPid;\r\n#ifndef WIN32\r\n    datarcv->lwpId = syscall(SYS_gettid);\r\n#else\r\n    datarcv->lwpId = (int)t_thrd.proc_cxt.MyProcPid;\r\n#endif\r\n    datarcv->isRuning = false;\r\n    datarcv->dataRcvState = DATARCV_RUNNING;\r\n\r\n    /* Fetch information required to start streaming */\r\n    rc = strncpy_s(conninfo, MAXCONNINFO, (char*)datarcv->conninfo, MAXCONNINFO - 1);\r\n    securec_check(rc, \"\", \"\");\r\n\r\n    /* Initialise to a sanish value */\r\n    datarcv->lastMsgSendTime = datarcv->lastMsgReceiptTime = GetCurrentTimestamp();\r\n    t_thrd.datareceiver_cxt.AmDataReceiverForDummyStandby =\r\n        (datarcv->conn_target == REPCONNTARGET_DUMMYSTANDBY) ? true : false;\r\n    SpinLockRelease(&datarcv->mutex);\r\n\r\n    /* Arrange to clean up at datareceiver exit */\r\n    on_shmem_exit(DataRcvDie, 0);\r\n\r\n    /* Reset some signals that are accepted by postmaster but not here */\r\n    (void)gspqsignal(SIGHUP, DataRcvSigHupHandler); /* set flag to read config file */\r\n    (void)gspqsignal(SIGINT, SIG_IGN);\r\n    (void)gspqsignal(SIGTERM, DataRcvShutdownHandler); /* request shutdown */\r\n    (void)gspqsignal(SIGQUIT, DataRcvQuickDieHandler); /* hard crash time */\r\n    (void)gspqsignal(SIGALRM, SIG_IGN);\r\n    (void)gspqsignal(SIGPIPE, SIG_IGN);\r\n    (void)gspqsignal(SIGUSR1, SIG_IGN);\r\n    (void)gspqsignal(SIGUSR2, SIG_IGN);\r\n\r\n    /* Reset some signals that are accepted by postmaster but not here */\r\n    (void)gspqsignal(SIGCHLD, SIG_DFL);\r\n    (void)gspqsignal(SIGTTIN, SIG_DFL);\r\n    (void)gspqsignal(SIGTTOU, SIG_DFL);\r\n    (void)gspqsignal(SIGCONT, SIG_DFL);\r\n    (void)gspqsignal(SIGWINCH, SIG_DFL);\r\n\r\n    /* We allow SIGQUIT (quickdie) at all times */\r\n    sigdelset(&t_thrd.libpq_cxt.BlockSig, SIGQUIT);\r\n\r\n    /*\r\n     * Create a resource owner to keep track of our resources (not clear that\r\n     * we need this, but may as well have one).\r\n     */\r\n    t_thrd.utils_cxt.CurrentResourceOwner = ResourceOwnerCreate(NULL, \"Data Receiver\");\r\n\r\n    /* Unblock signals (they were blocked when the postmaster forked us) */\r\n    gs_signal_setmask(&t_thrd.libpq_cxt.UnBlockSig, NULL);\r\n    (void)gs_signal_unblock_sigusr2();\r\n\r\n    /* Establish the connection to the primary for the replication data streaming */\r\n    EnableDataRcvImmediateExit();\r\n    DataRcvStreamConnect(conninfo);\r\n    DisableDataRcvImmediateExit();\r\n\r\n    ereport(LOG, (errmsg(\"DataReceiverMain streaming begin\")));\r\n\r\n    if (GetDataRcvDummyStandbySyncPercent() == SYNC_DUMMY_STANDBY_END) {\r\n        Assert(t_thrd.datareceiver_cxt.AmDataReceiverForDummyStandby == true);\r\n        /* thread exit */\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_DATA_EXCEPTION), errmsg(\"terminating datareceiver due to Secondary Standby has no data\")));\r\n    }\r\n\r\n    rc = memset_s(\r\n        t_thrd.datareceiver_cxt.reply_message, sizeof(StandbyDataReplyMessage), 0, sizeof(StandbyDataReplyMessage));\r\n    securec_check(rc, \"\", \"\");\r\n\r\n    last_recv_timestamp = GetCurrentTimestamp();\r\n    ping_sent = false;\r\n\r\n    SpinLockAcquire(&datarcv->mutex);\r\n    datarcv->isRuning = true;\r\n    datarcv->sendPosition.queueid = datarcv->receivePosition.queueid = datarcv->localWritePosition.queueid = 0;\r\n    datarcv->sendPosition.queueoff = datarcv->receivePosition.queueoff = datarcv->localWritePosition.queueoff = 0;\r\n    SpinLockRelease(&datarcv->mutex);\r\n\r\n    /* Loop until end-of-streaming or error */\r\n    for (;;) {\r\n        unsigned char type;\r\n        char* buf = NULL;\r\n        int len = 0;\r\n\r\n        /*\r\n         * Emergency bailout if postmaster has died.  This is to avoid the\r\n         * necessity for manual cleanup of all postmaster children.\r\n         */\r\n        if (!PostmasterIsAlive())\r\n            gs_thread_exit(1);\r\n\r\n        /*\r\n         * Exit datareceiver if we're not in recovery. This should not happen,\r\n         * but cross-check the status here.\r\n         */\r\n        if (!RecoveryInProgress())\r\n            ereport(FATAL, (errmsg(\"cannot continue DATA streaming, recovery has already ended\")));\r\n\r\n        /* Process any requests or signals received recently */\r\n        ProcessDataRcvInterrupts();\r\n\r\n        if (t_thrd.datareceiver_cxt.got_SIGHUP) {\r\n            t_thrd.datareceiver_cxt.got_SIGHUP = false;\r\n            ProcessConfigFile(PGC_SIGHUP);\r\n        }\r\n\r\n        if (!DataRcvWriterInProgress())\r\n            ereport(FATAL, (errmsg(\"terminating datareceiver process due to the death of datarcvwriter\")));\r\n\r\n        /* Wait a while for data to arrive */\r\n        if (DataRcvStreamReceive(NAPTIME_PER_CYCLE, &type, &buf, &len)) {\r\n            last_recv_timestamp = GetCurrentTimestamp();\r\n            ping_sent = false;\r\n            /* Accept the received data, and process it */\r\n            DataRcvProcessMsg(type, buf, len);\r\n\r\n            /* Receive any more data we can without sleeping */\r\n            while (DataRcvStreamReceive(0, &type, &buf, &len)) {\r\n                last_recv_timestamp = GetCurrentTimestamp();\r\n                DataRcvProcessMsg(type, buf, len);\r\n            }\r\n\r\n            /* Let the master know that we received some data. */\r\n            DataRcvSendReply(false, false);\r\n        } else {\r\n            DataReceiverPing(&ping_sent, &last_recv_timestamp);\r\n        }\r\n    }\r\n}",
		"comment":"/* Main entry point for datareceiver process */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"DataReceiverMain"
	},
	"DataReceiverPing":{
		"body":"void DataReceiverPing(bool* ping_ptr, TimestampTz* last_recv_timestamp_ptr)\r\n{\r\n    /*\r\n     * We didn't receive anything new. If we haven't heard anything\r\n     * from the server for more than wal_receiver_timeout / 2,\r\n     * ping the server. Also, if it's been longer than\r\n     * wal_receiver_status_interval since the last update we sent,\r\n     * send a status update to the master anyway, to report any\r\n     * progress in applying WAL.\r\n     */\r\n    bool requestReply = false;\r\n\r\n    /*\r\n     * Check if time since last receive from master has reached the\r\n     * configured limit.\r\n     */\r\n    if (u_sess->attr.attr_storage.wal_receiver_timeout > 0) {\r\n        TimestampTz nowtime = GetCurrentTimestamp();\r\n        TimestampTz timeout = 0;\r\n\r\n        timeout = TimestampTzPlusMilliseconds(\r\n            *last_recv_timestamp_ptr, u_sess->attr.attr_storage.wal_receiver_timeout / 2);\r\n\r\n        /*\r\n         * We didn't receive anything new, for half of receiver\r\n         * replication timeout. Ping the server.\r\n         */\r\n        if (nowtime >= timeout) {\r\n            if (!(*ping_ptr)) {\r\n                requestReply = true;\r\n                *ping_ptr = true;\r\n                *last_recv_timestamp_ptr = nowtime;\r\n            } else {\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_ADMIN_SHUTDOWN), errmsg(\"terminating datareceiver due to timeout\")));\r\n            }\r\n        }\r\n    }\r\n    DataRcvSendReply(requestReply, requestReply);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"DataReceiverPing"
	},
	"DisableDataRcvImmediateExit":{
		"body":"static void DisableDataRcvImmediateExit(void)\r\n{\r\n    t_thrd.datareceiver_cxt.DataRcvImmediateInterruptOK = false;\r\n    ProcessDataRcvInterrupts();\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"DisableDataRcvImmediateExit"
	},
	"EnableDataRcvImmediateExit":{
		"body":"static void EnableDataRcvImmediateExit(void)\r\n{\r\n    t_thrd.datareceiver_cxt.DataRcvImmediateInterruptOK = true;\r\n    ProcessDataRcvInterrupts();\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"EnableDataRcvImmediateExit"
	},
	"GetDataRcvDummyStandbySyncPercent":{
		"body":"int GetDataRcvDummyStandbySyncPercent(void)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n    int percent = 0;\r\n\r\n    SpinLockAcquire(&datarcv->mutex);\r\n    percent = datarcv->dummyStandbySyncPercent;\r\n    SpinLockRelease(&datarcv->mutex);\r\n\r\n    return percent;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"GetDataRcvDummyStandbySyncPercent"
	},
	"InitDummyFileNum":{
		"body":"static void InitDummyFileNum(uint32* readFileNum, uint32* writerFileNum)\r\n{\r\n    /* Get the read_file_num and  writer_file_num stored in dummy */\r\n    DIR* dir = NULL;\r\n    struct dirent* de = NULL;\r\n    int maxNumFile = 0;\r\n    int minNumFile = 0;\r\n    char* dirPath = DUMMY_STANDBY_DATADIR;\r\n\r\n    /* open the dir of base/dummy_standby */\r\n    errno = 0;\r\n    dir = AllocateDir(dirPath);\r\n    if (dir == NULL && errno == ENOENT) {\r\n        if (mkdir(dirPath, S_IRWXU) < 0) {\r\n            /* Failure other than not exists */\r\n            ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not create directory \\\"%s\\\": %m\", dirPath)));\r\n        }\r\n        dir = AllocateDir(dirPath);\r\n    }\r\n    if (dir == NULL) {\r\n        ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not open directory \\\"%s\\\": %m\", dirPath)));\r\n        return;\r\n    }\r\n\r\n    /* loop for reading the file name of base/dummy_standby */\r\n    while ((de = ReadDir(dir, dirPath)) != NULL) {\r\n        /* Skip special stuff */\r\n        if (strcmp(de->d_name, \".\") == 0 || strcmp(de->d_name, \"..\") == 0)\r\n            continue;\r\n        minNumFile = atoi(de->d_name);\r\n        break;\r\n    }\r\n\r\n    FreeDir(dir);\r\n    dir = AllocateDir(dirPath);\r\n\r\n    /* loop aims to read the file name of base/dummy_standby and get the nums */\r\n    while ((de = ReadDir(dir, dirPath)) != NULL) {\r\n        /* Skip special stuff */\r\n        if (strcmp(de->d_name, \".\") == 0 || strcmp(de->d_name, \"..\") == 0)\r\n            continue;\r\n\r\n        /* search the max num file */\r\n        maxNumFile = Max(atoi(de->d_name), maxNumFile);\r\n        minNumFile = Min(atoi(de->d_name), minNumFile);\r\n        ereport(DEBUG5,\r\n            (errmsg(\"InitDummyDataNum de->d_name=%s;   max_num_path=%d; min_num_file=%d.\",\r\n                de->d_name,\r\n                maxNumFile,\r\n                minNumFile)));\r\n    }\r\n\r\n    *writerFileNum = maxNumFile;\r\n    *readFileNum = minNumFile;\r\n    FreeDir(dir);\r\n    ereport(LOG, (errmsg(\"read files starting serial number:%u\", *readFileNum)));\r\n    ereport(LOG, (errmsg(\"read files ending serial number:%u\", *writerFileNum)));\r\n}",
		"comment":"/*\r\n * Get dummy file numbers\r\n * including the total file numbers. and start serial number\r\n * writer_file_num : total file number\r\n * read_file_num   : start serial number\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"InitDummyFileNum"
	},
	"ParseDataHeader":{
		"body":"static int ParseDataHeader(HTAB* relFileNodeTab, char* bufPtr, uint32 nbytes)\r\n{\r\n    uint32 currentLen = 0;\r\n    int bufferSize = 0;\r\n    int headerLen = sizeof(DataElementHeaderData);\r\n    DataElementHeaderData dataInfo;\r\n    RelFileNodeKey* elementKey = NULL;\r\n    RelFileNodeKeyEntry* rel = NULL;\r\n    bool found = false;\r\n    errno_t errorno = EOK;\r\n    while (nbytes > 0) {\r\n        /* parse total_len for this slice of data */\r\n        errorno = memcpy_s(&currentLen, sizeof(uint32), bufPtr, sizeof(uint32));\r\n        securec_check(errorno, \"\", \"\");\r\n        bufPtr += sizeof(uint32);\r\n        /* parse data element header, and skip the payload then parse next one */\r\n        errorno = memcpy_s((void*)&dataInfo, headerLen, bufPtr, headerLen);\r\n        securec_check(errorno, \"\", \"\");\r\n        bufPtr += headerLen;\r\n\r\n        elementKey = (RelFileNodeKey*)palloc(sizeof(RelFileNodeKey));\r\n        /* Fill the key during this read */\r\n        RelFileNodeCopy(elementKey->relfilenode, dataInfo.rnode, GETBUCKETID(dataInfo.attid));\r\n        elementKey->columnid = (int)GETATTID((uint)dataInfo.attid);\r\n\r\n        if (u_sess->attr.attr_storage.HaModuleDebug) {\r\n            ereport(LOG,\r\n                (errmsg(\"Parse each relfilenode or CU info: dbNode %u, spcNode %u, relNode %u, columnid %d  \",\r\n                    elementKey->relfilenode.dbNode,\r\n                    elementKey->relfilenode.spcNode,\r\n                    elementKey->relfilenode.relNode,\r\n                    elementKey->columnid)));\r\n        }\r\n        /* Hash table used for removing duplicated files */\r\n        rel = (RelFileNodeKeyEntry*)hash_search(relFileNodeTab, elementKey, HASH_ENTER, &found);\r\n\r\n        if (!found) {\r\n            rel->number = 1;\r\n            bufferSize += sizeof(RelFileNodeKey);\r\n            pfree(elementKey);\r\n        } else {\r\n            found = false;\r\n            pfree(elementKey);\r\n        }\r\n        nbytes -= currentLen;\r\n        bufPtr += dataInfo.data_size;\r\n    }\r\n    return bufferSize;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"ParseDataHeader"
	},
	"ParseDummyFile":{
		"body":"static void ParseDummyFile()\r\n{\r\n    /* Hash indicates */\r\n    HTAB* relFileNodeTab = NULL;\r\n    errno_t rc;\r\n    /* Total size we need to palloc the buffer */\r\n    int bufferSize = 0;\r\n    char* replyBcmFileListInfo = NULL;\r\n    /* Page info init */\r\n    uint32 readFileNum = 1;\r\n    uint32 writerFileNum = 0;\r\n\r\n    Assert(dummyStandbyMode);\r\n\r\n    HASHCTL ctl;\r\n    rc = memset_s(&ctl, sizeof(ctl), 0, sizeof(ctl));\r\n    securec_check(rc, \"\", \"\");\r\n    ctl.keysize = sizeof(RelFileNodeKey);\r\n    ctl.entrysize = sizeof(RelFileNodeKeyEntry);\r\n    ctl.hash = tag_hash;\r\n    relFileNodeTab = hash_create(\"relfilenode table\", 1024, &ctl, HASH_ELEM | HASH_FUNCTION);\r\n\r\n    /* Init dummy file data */\r\n    InitDummyFileNum(&readFileNum, &writerFileNum);\r\n    /* Parse each dummy file and get the bcm file list info, then put them into hashtable */\r\n    while (readFileNum <= writerFileNum) {\r\n        ReadDummyFile(relFileNodeTab, readFileNum, &bufferSize);\r\n        /* add heartbeat after every file is scanned */\r\n        DataRcvSendReply(false, false);\r\n        readFileNum++;\r\n    }\r\n\r\n    /* Send all data at once */\r\n    replyBcmFileListInfo = (char*)palloc(bufferSize + 1);\r\n    replyBcmFileListInfo[0] = 'x';\r\n    char* tempPtr = replyBcmFileListInfo + 1;\r\n\r\n    HASH_SEQ_STATUS hash_seq;\r\n    hash_seq_init(&hash_seq, relFileNodeTab);\r\n    RelFileNodeKeyEntry* entry = NULL;\r\n\r\n    while ((entry = (RelFileNodeKeyEntry*)hash_seq_search(&hash_seq)) != NULL) {\r\n        rc = memcpy_s(tempPtr, sizeof(RelFileNodeKey), &(entry->key), sizeof(RelFileNodeKey));\r\n        securec_check(rc, \"\", \"\");\r\n        tempPtr += sizeof(RelFileNodeKey);\r\n    }\r\n    ereport(LOG, (errmsg(\"total bcm file list info buffer size we send is : %d\", bufferSize)));\r\n    DataRcvStreamSendFiles(replyBcmFileListInfo, bufferSize + 1);\r\n\r\n    tempPtr = NULL;\r\n    hash_destroy(relFileNodeTab);\r\n    pfree(replyBcmFileListInfo);\r\n    ereport(LOG, (errmsg(\"read files serial number now is : %u\", readFileNum)));\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"ParseDummyFile"
	},
	"ProcessDataHeaderMessage":{
		"body":"static void ProcessDataHeaderMessage(DataPageMessageHeader* msghdr)\r\n{\r\n    /* Use volatile pointer to prevent code rearrangement */\r\n    volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n    TimestampTz lastMsgReceiptTime = GetCurrentTimestamp();\r\n\r\n    /* Update shared-memory status */\r\n    SpinLockAcquire(&datarcv->mutex);\r\n    datarcv->sendPosition.queueid = msghdr->dataEnd.queueid;\r\n    datarcv->sendPosition.queueoff = msghdr->dataEnd.queueoff;\r\n    datarcv->lastMsgSendTime = msghdr->sendTime;\r\n    datarcv->lastMsgReceiptTime = lastMsgReceiptTime;\r\n    SpinLockRelease(&datarcv->mutex);\r\n\r\n    /* Update the catchup flag */\r\n    data_catchup = msghdr->catchup;\r\n\r\n    if (log_min_messages <= DEBUG2) {\r\n        MakeDebugLog(msghdr->sendTime, lastMsgReceiptTime, \"data receive data header data sendtime %s receipttime %s\");\r\n    }\r\n}",
		"comment":"/*\r\n * Process dataHeaderMessage received from sender\r\n * message type is 'd'.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"ProcessDataHeaderMessage"
	},
	"ProcessDataRcvInterrupts":{
		"body":"void ProcessDataRcvInterrupts(void)\r\n{\r\n    /*\r\n     * Although datareceiver interrupt handling doesn't use the same scheme as\r\n     * regular backends, call CHECK_FOR_INTERRUPTS() to make sure we receive\r\n     * any incoming signals on Win32.\r\n     */\r\n    CHECK_FOR_INTERRUPTS();\r\n\r\n    if (t_thrd.datareceiver_cxt.got_SIGTERM) {\r\n        t_thrd.datareceiver_cxt.DataRcvImmediateInterruptOK = false;\r\n        ereport(FATAL,\r\n            (errcode(ERRCODE_ADMIN_SHUTDOWN), errmsg(\"terminating datareceiver process due to administrator command\")));\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"ProcessDataRcvInterrupts"
	},
	"ProcessEndDataMessage":{
		"body":"static void ProcessEndDataMessage(EndDataMessage* endDataMessage)\r\n{\r\n    ereport(dummyStandbyMode ? DEBUG2 : LOG, (errmsg(\"sync Secondary Standby data done\")));\r\n\r\n    if (endDataMessage->percent == SYNC_DUMMY_STANDBY_END) {\r\n        /*\r\n         * We have received all the data in secondary and pushed them to the\r\n         * data writer queue. If the data receiver writer thread is online, shut\r\n         * down it even if there are remained data whose database directory is\r\n         * not ready.\r\n         * If the data receiver writer is offline, the data remained in data writer\r\n         * queue would be handled during datarcvdie.\r\n         */\r\n        ShutDownDataRcvWriter();\r\n\r\n        /*\r\n         * Maybe, some xlog records were not transferred to secondary when standby\r\n         * is offline but the corresponding data have transferred to secondary already\r\n         * especially tablespace data. After we received the end message from\r\n         * secondary, the wal receiver is probably still working and startup is still\r\n         * replaying.\r\n         *\r\n         * We set the sync percent to end directly here, the startup thread would shut\r\n         * down the data receiver and wal receiver after received all the xlog records.\r\n         * And during the shutting down, we do a last cleanup to write the remained\r\n         * data in data writer queue.\r\n         */\r\n        SetDataRcvDummyStandbySyncPercent(SYNC_DUMMY_STANDBY_END);\r\n    }\r\n}",
		"comment":"/*\r\n * Process RmDataMessage received from (primary? and dummystandby?) sender,\r\n * message type is 'e'. Refence searchBCMFiles\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"ProcessEndDataMessage"
	},
	"ProcessKeepaliveMessage":{
		"body":"static void ProcessKeepaliveMessage(DataSndKeepaliveMessage* keepalive)\r\n{\r\n    /* Use volatile pointer to prevent code rearrangement */\r\n    volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n    TimestampTz lastMsgReceiptTime = GetCurrentTimestamp();\r\n\r\n    /* Update shared-memory status */\r\n    SpinLockAcquire(&datarcv->mutex);\r\n    datarcv->sendPosition.queueid = keepalive->sendPosition.queueid;\r\n    datarcv->sendPosition.queueoff = keepalive->sendPosition.queueoff;\r\n    datarcv->lastMsgSendTime = keepalive->sendTime;\r\n    datarcv->lastMsgReceiptTime = lastMsgReceiptTime;\r\n    SpinLockRelease(&datarcv->mutex);\r\n\r\n    data_catchup = keepalive->catchup;\r\n\r\n    if (log_min_messages <= DEBUG2) {\r\n        MakeDebugLog(keepalive->sendTime, lastMsgReceiptTime, \"data receive keepalive data sendtime %s receipttime %s\");\r\n    }\r\n}",
		"comment":"/*\r\n * Process ProcessKeepaliveMessage received from datasender,\r\n * message type is 'k'.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"ProcessKeepaliveMessage"
	},
	"ProcessRmData":{
		"body":"static void ProcessRmData(void)\r\n{\r\n    DIR* dir = NULL;\r\n    struct dirent* de = NULL;\r\n    char data_path[MAXPGPATH] = {0};\r\n    int nRet = 0;\r\n\r\n    nRet = snprintf_s(\r\n        data_path, sizeof(data_path), MAXPGPATH - 1, \"%s/%s\", t_thrd.proc_cxt.DataDir, DUMMY_STANDBY_DATADIR);\r\n    securec_check_ss(nRet, \"\", \"\");\r\n\r\n    dir = AllocateDir(data_path);\r\n    while ((de = ReadDir(dir, data_path)) != NULL) {\r\n        if (strcmp(de->d_name, \".\") == 0 || strcmp(de->d_name, \"..\") == 0)\r\n            continue;\r\n\r\n        char path[MAXPGPATH] = {0};\r\n        nRet = snprintf_s(path, sizeof(path), MAXPGPATH - 1, \"%s/%s\", data_path, de->d_name);\r\n        securec_check_ss(nRet, \"\", \"\");\r\n\r\n        unlink(path);\r\n    }\r\n    FreeDir(dir);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"ProcessRmData"
	},
	"ProcessRmDataMessage":{
		"body":"static void ProcessRmDataMessage(RmDataMessage* rmDataMessage)\r\n{\r\n    volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n\r\n    /* check command source */\r\n    if (rmDataMessage->peer_role != PRIMARY_MODE) {\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_CASE_NOT_FOUND),\r\n                errmsg(\"rm data comand is not from primary, peer_role=%d\", rmDataMessage->peer_role)));\r\n    }\r\n\r\n    ereport(DEBUG2, (errmsg(\"received rm data message\")));\r\n\r\n    SpinLockAcquire(&datarcv->mutex);\r\n    datarcv->sendPosition.queueid = 0;\r\n    datarcv->sendPosition.queueoff = 0;\r\n    datarcv->receivePosition.queueid = 0;\r\n    datarcv->receivePosition.queueoff = 0;\r\n    SpinLockRelease(&datarcv->mutex);\r\n\r\n    while (true) {\r\n        if (!dummy_data_writer_use_file) {\r\n            CloseDataFile();\r\n            break;\r\n        } else {\r\n            pg_usleep(100000); /* sleep 0.1 s */\r\n        }\r\n    }\r\n\r\n    ProcessRmData();\r\n}",
		"comment":"/*\r\n * Process RmDataMessage received from primary sender, message type is 'x'.\r\n * Refence searchBCMFiles\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"ProcessRmDataMessage"
	},
	"ReadDummyFile":{
		"body":"static void ReadDummyFile(HTAB* relFileNodeTab, uint32 readFileNum, int* bufferSize)\r\n{\r\n    uint32 nbytes = 0;\r\n    int nRet = 0;\r\n    char path[MAXPGPATH] = {0};\r\n    FILE* readFileFd = NULL;\r\n    TimestampTz lastDummyPingTime;\r\n    /* record ping time when we are searching */\r\n    lastDummyPingTime = GetCurrentTimestamp();\r\n    /* get the file path */\r\n    nRet = snprintf_s(path, sizeof(path), MAXPGPATH - 1, \"base/dummy_standby/%u\", readFileNum);\r\n    securec_check_ss(nRet, \"\", \"\");\r\n\r\n    ereport(DEBUG5, (errmsg(\"DataSendReadData path=%s\", path)));\r\n\r\n    /* open the file */\r\n    readFileFd = fopen(path, \"rb\");\r\n    if (readFileFd == NULL) {\r\n        ereport(WARNING, (errcode_for_file_access(), errmsg(\"could not open data file \\\"%s\\\": %m\", path)));\r\n        return;\r\n    }\r\n\r\n    while (true) {\r\n        /*\r\n         * OK to read the data:\r\n         * 1. first, read nbytes of the FD;\r\n         */\r\n        if (!ReadDummySlice(readFileFd, (char*)&nbytes, (uint32)sizeof(nbytes), path)) {\r\n            /*\r\n             * if we receive the eof when reading nbytes, the file maybe\r\n             * interrupted when writting. So we break and return to read the next file.\r\n             */\r\n            ereport(LOG, (errmsg(\"step1: data file num %u, read file fd %d\", readFileNum, readFileFd->_fileno)));\r\n            break;\r\n        }\r\n        char* elementBuf = NULL;\r\n        elementBuf = (char*)palloc(nbytes);\r\n        /*\r\n         * 2. then, read the data which according to nbytes;\r\n         */\r\n        if (!ReadDummySlice(readFileFd, elementBuf, nbytes, path)) {\r\n            ereport(LOG, (errmsg(\"step2: data file num %u, read file fd %d\", readFileNum, readFileFd->_fileno)));\r\n            pfree(elementBuf);\r\n            break;\r\n        }\r\n        *bufferSize += ParseDataHeader(relFileNodeTab, elementBuf, nbytes);\r\n        TimestampTz now;\r\n        now = GetCurrentTimestamp();\r\n        if (TimestampDifferenceExceeds(lastDummyPingTime, now, 1000)) {\r\n            /* add heartbeat per 1 second */\r\n            DataRcvSendReply(false, false);\r\n            lastDummyPingTime = now;\r\n        }\r\n        pfree(elementBuf);\r\n    }\r\n    fclose(readFileFd);\r\n    return;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"ReadDummyFile"
	},
	"ReadDummySlice":{
		"body":"static bool ReadDummySlice(FILE* readFileFd, char* buf, uint32 length, char* path)\r\n{\r\n    uint32 readBytes = 0;\r\n    readBytes = fread(buf, 1, length, readFileFd);\r\n    if (readBytes != length) {\r\n        if (ferror(readFileFd)) {\r\n            fclose(readFileFd);\r\n            ereport(FATAL,\r\n                (errcode_for_file_access(),\r\n                    errmsg(\"could not read to data file slice %s \"\r\n                           \"length %u: %m\",\r\n                        path,\r\n                        length)));\r\n        }\r\n        if (feof(readFileFd)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"ReadDummySlice"
	},
	"RequestDataStreaming":{
		"body":"void RequestDataStreaming(const char* conninfo, ReplConnTarget conn_target)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n    pg_time_t now = (pg_time_t)time(NULL);\r\n    errno_t retcode = EOK;\r\n\r\n    /* (Single node && multi standby mode) doesn't need datareceiver */\r\n    if (IS_SINGLE_NODE && !IS_DN_DUMMY_STANDYS_MODE())\r\n        return;\r\n\r\n    SpinLockAcquire(&datarcv->mutex);\r\n\r\n    /* It better be stopped before we try to restart it */\r\n    Assert(datarcv->dataRcvState == DATARCV_STOPPED);\r\n\r\n    if (conninfo != NULL) {\r\n        retcode = strncpy_s((char*)datarcv->conninfo, MAXCONNINFO, conninfo, MAXCONNINFO - 1);\r\n        securec_check(retcode, \"\", \"\");\r\n    } else {\r\n        SpinLockRelease(&datarcv->mutex);\r\n        SetDataRcvConninfo(conn_target);\r\n        SpinLockAcquire(&datarcv->mutex);\r\n    }\r\n\r\n    datarcv->dataRcvState = DATARCV_STARTING;\r\n    datarcv->startTime = now;\r\n\r\n    SpinLockRelease(&datarcv->mutex);\r\n\r\n    SendPostmasterSignal(PMSIGNAL_START_DATARECEIVER);\r\n}",
		"comment":"/*\r\n * Request postmaster to start datareceiver.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"RequestDataStreaming"
	},
	"SetDataRcvConninfo":{
		"body":"static void SetDataRcvConninfo(ReplConnTarget conn_target)\r\n{\r\n    volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n    ReplConnInfo* replConnArray = NULL;\r\n\r\n    /* 1. if we are in primary, standby, dummystandby mode. */\r\n    if ((t_thrd.postmaster_cxt.ReplConnArray[1] == NULL && conn_target == REPCONNTARGET_PRIMARY) ||\r\n        (t_thrd.postmaster_cxt.ReplConnArray[2] == NULL && conn_target == REPCONNTARGET_DUMMYSTANDBY)) {\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_CONFIG_FILE_ERROR),\r\n                errmsg(\"no replication connection config information.\"),\r\n                errhint(\"please check your configuration in postgresql.conf.\")));\r\n    }\r\n\r\n    /* 2. get conninfo array */\r\n    if (IS_DN_DUMMY_STANDYS_MODE()) {\r\n        if (conn_target == REPCONNTARGET_DUMMYSTANDBY) {\r\n            ereport(LOG, (errmsg(\"data receiver get replconninfo[2] to connect dummystandby.\")));\r\n            t_thrd.datareceiver_cxt.DataReplFlag = 2;\r\n        }\r\n\r\n        if (conn_target == REPCONNTARGET_PRIMARY) {\r\n            ereport(LOG, (errmsg(\"data receiver get replconninfo[1] to connect primary.\")));\r\n            t_thrd.datareceiver_cxt.DataReplFlag = 1;\r\n        }\r\n    }\r\n\r\n    replConnArray = GetRepConnArray(&t_thrd.datareceiver_cxt.DataReplFlag);\r\n    if (replConnArray != NULL) {\r\n        int rc = EOK;\r\n\r\n        SpinLockAcquire(&datarcv->mutex);\r\n        rc = snprintf_s((char*)datarcv->conninfo,\r\n            MAXCONNINFO,\r\n            MAXCONNINFO - 1,\r\n            \"host=%s port=%d localhost=%s localport=%d\",\r\n            replConnArray->remotehost,\r\n            replConnArray->remoteport,\r\n            replConnArray->localhost,\r\n            replConnArray->localport);\r\n\r\n        securec_check_ss(rc, \"\", \"\");\r\n        datarcv->conninfo[MAXCONNINFO - 1] = '\\0';\r\n        datarcv->conn_target = conn_target;\r\n        SpinLockRelease(&datarcv->mutex);\r\n\r\n        ereport(DEBUG5, (errmsg(\"get datarcv conninfo%d=%s\", t_thrd.datareceiver_cxt.DataReplFlag, datarcv->conninfo)));\r\n        t_thrd.datareceiver_cxt.DataReplFlag++;\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"SetDataRcvConninfo"
	},
	"SetDataRcvDummyStandbySyncPercent":{
		"body":"void SetDataRcvDummyStandbySyncPercent(int percent)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n\r\n    SpinLockAcquire(&datarcv->mutex);\r\n    datarcv->dummyStandbySyncPercent = percent;\r\n    SpinLockRelease(&datarcv->mutex);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"SetDataRcvDummyStandbySyncPercent"
	},
	"ShutDownDataRcvWriter":{
		"body":"static void ShutDownDataRcvWriter(void)\r\n{\r\n    /* Use volatile pointer to prevent code rearrangement */\r\n    volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n    ThreadId writerPid;\r\n    int i = 1;\r\n\r\n    SpinLockAcquire(&datarcv->mutex);\r\n    writerPid = datarcv->writerPid;\r\n    SpinLockRelease(&datarcv->mutex);\r\n\r\n    if (writerPid != 0)\r\n        (void)gs_signal_send(writerPid, SIGTERM);\r\n\r\n    ereport(LOG, (errmsg(\"waiting datarcvwriter: %lu terminate\", writerPid)));\r\n\r\n    while (writerPid) {\r\n        pg_usleep(10000L);  // sleep 0.01s\r\n\r\n        SpinLockAcquire(&datarcv->mutex);\r\n        writerPid = datarcv->writerPid;\r\n        SpinLockRelease(&datarcv->mutex);\r\n\r\n        if ((writerPid != 0) && (i % 2000 == 0)) {\r\n            if (gs_signal_send(writerPid, SIGTERM) != 0) {\r\n                ereport(WARNING, (errmsg(\"datarcvwriter:%lu may be terminated\", writerPid)));\r\n                break;\r\n            }\r\n            i = 1;\r\n        }\r\n        i++;\r\n    }\r\n}",
		"comment":"/*\r\n * Wait data receiver writer shut down.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"ShutDownDataRcvWriter"
	},
	"ShutdownDataRcv":{
		"body":"void ShutdownDataRcv(void)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n    ThreadId datarcvpid = 0;\r\n    int i = 1;\r\n\r\n    /*\r\n     * Request datareceiver to stop. Walreceiver will switch to WALRCV_STOPPED\r\n     * mode once it's finished, and will also request postmaster to not\r\n     * restart itself.\r\n     */\r\n    SpinLockAcquire(&datarcv->mutex);\r\n    switch (datarcv->dataRcvState) {\r\n        case DATARCV_STOPPED:\r\n            break;\r\n        case DATARCV_STARTING:\r\n            datarcv->dataRcvState = DATARCV_STOPPED;\r\n            break;\r\n        case DATARCV_RUNNING:\r\n            datarcv->dataRcvState = DATARCV_STOPPING;\r\n            // lint -fallthrough\r\n        case DATARCV_STOPPING:\r\n            datarcvpid = datarcv->pid;\r\n            break;\r\n    }\r\n    SpinLockRelease(&datarcv->mutex);\r\n\r\n    ereport(LOG, (errmsg(\"startup shut down datareceiver.\")));\r\n    /*\r\n     * Signal datareceiver process if it was still running.\r\n     */\r\n    if (datarcvpid != 0)\r\n        (void)gs_signal_send(datarcvpid, SIGTERM);\r\n\r\n    /*\r\n     * Wait for datareceiver to acknowledge its death by setting state to\r\n     * DATARCV_STOPPED.\r\n     */\r\n    while (DataRcvInProgress()) {\r\n        /*\r\n         * This possibly-long loop needs to handle interrupts of startup\r\n         * process.\r\n         */\r\n        HandleStartupProcInterrupts();\r\n        pg_usleep(100000); /* 100ms */\r\n\r\n        SpinLockAcquire(&datarcv->mutex);\r\n        datarcvpid = datarcv->pid;\r\n        SpinLockRelease(&datarcv->mutex);\r\n\r\n        if ((datarcvpid != 0) && (i % 2000 == 0)) {\r\n            (void)gs_signal_send(datarcvpid, SIGTERM);\r\n            i = 1;\r\n        }\r\n        i++;\r\n    }\r\n}",
		"comment":"/*\r\n * Stop datareceiver (if running) and wait for it to die.\r\n * Executed by the Startup process.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"ShutdownDataRcv"
	},
	"WakeupDataRcvWriter":{
		"body":"void WakeupDataRcvWriter(void)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile DataRcvData* datarcv = t_thrd.datareceiver_cxt.DataRcv;\r\n    SpinLockAcquire(&datarcv->mutex);\r\n    if (datarcv->datarcvWriterLatch != NULL)\r\n        SetLatch(datarcv->datarcvWriterLatch);\r\n    SpinLockRelease(&datarcv->mutex);\r\n\r\n    ProcessDataRcvInterrupts();\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\datareceiver.cpp",
		"name":"WakeupDataRcvWriter"
	}
}