{
	"GetAllLogicalSlot":{
		"body":"Size GetAllLogicalSlot(LogicalPersistentData *&LogicalSlot)\r\n{\r\n    int i;\r\n    int NumLogicalSlot = 0;\r\n    Size size;\r\n    /* Search for the named slot and mark it active if we find it. */\r\n    (void)LWLockAcquire(ReplicationSlotAllocationLock, LW_SHARED);\r\n    (void)LWLockAcquire(ReplicationSlotControlLock, LW_SHARED);\r\n    (void)LWLockAcquire(LogicalReplicationSlotPersistentDataLock, LW_SHARED);\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_replication_slots; i++) {\r\n        ReplicationSlot* s = &t_thrd.slot_cxt.ReplicationSlotCtl->replication_slots[i];\r\n\r\n        if (s->in_use && s->data.database != InvalidOid && s->data.persistency == RS_PERSISTENT) {\r\n            NumLogicalSlot++;\r\n        }\r\n    }\r\n    size = offsetof(LogicalPersistentData, replication_slots) + NumLogicalSlot * sizeof(ReplicationSlotPersistentData);\r\n    LogicalSlot = (LogicalPersistentData*)palloc(size);\r\n    LogicalSlot->SlotNum = NumLogicalSlot;\r\n\r\n    ReplicationSlotPersistentData* slotPoint = &LogicalSlot->replication_slots[0];\r\n    for (i = 0; i < g_instance.attr.attr_storage.max_replication_slots; i++) {\r\n        ReplicationSlot* s = &t_thrd.slot_cxt.ReplicationSlotCtl->replication_slots[i];\r\n\r\n        if (s->in_use && s->data.database != InvalidOid && s->data.persistency == RS_PERSISTENT) {\r\n            errno_t ret = memcpy_s(\r\n                slotPoint, sizeof(ReplicationSlotPersistentData), &s->data, sizeof(ReplicationSlotPersistentData));\r\n            securec_check(ret, \"\", \"\");\r\n            slotPoint += 1;\r\n        }\r\n    }\r\n\r\n    LWLockRelease(LogicalReplicationSlotPersistentDataLock);\r\n    LWLockRelease(ReplicationSlotControlLock);\r\n    LWLockRelease(ReplicationSlotAllocationLock);\r\n\r\n    return size;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"GetAllLogicalSlot"
	},
	"LogCheckSlot":{
		"body":"void LogCheckSlot()\r\n{\r\n    XLogRecPtr recptr;\r\n    Size size;\r\n    LogicalPersistentData* LogicalSlot = NULL;\r\n    size = GetAllLogicalSlot(LogicalSlot);\r\n\r\n    if (!u_sess->attr.attr_sql.enable_slot_log || !PMstateIsRun())\r\n        return;\r\n    START_CRIT_SECTION();\r\n\r\n    XLogBeginInsert();\r\n    XLogRegisterData((char*)LogicalSlot, size);\r\n\r\n    recptr = XLogInsert(RM_SLOT_ID, XLOG_SLOT_CHECK);\r\n    XLogFlush(recptr);\r\n    if (g_instance.attr.attr_storage.max_wal_senders > 0)\r\n        WalSndWakeup();\r\n\r\n    END_CRIT_SECTION();\r\n\r\n    if (u_sess->attr.attr_storage.guc_synchronous_commit > SYNCHRONOUS_COMMIT_LOCAL_FLUSH) {\r\n        SyncRepWaitForLSN(recptr);\r\n        g_instance.comm_cxt.localinfo_cxt.set_term = true;\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"LogCheckSlot"
	},
	"LogicalSlotCheck":{
		"body":"void LogicalSlotCheck(LogicalPersistentData* LogicalSlot)\r\n{\r\n    LogicalSlotCheckDelete(LogicalSlot);\r\n    LogicalSlotCheckAdd(LogicalSlot);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"LogicalSlotCheck"
	},
	"LogicalSlotCheckAdd":{
		"body":"void LogicalSlotCheckAdd(LogicalPersistentData* logicalSlot)\r\n{\r\n    for (int i = 0; i < logicalSlot->SlotNum; i++) {\r\n        if (!ReplicationSlotFind(logicalSlot->replication_slots[i].name.data)) {\r\n            redo_slot_create(&logicalSlot->replication_slots[i]);\r\n        }\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"LogicalSlotCheckAdd"
	},
	"LogicalSlotCheckDelete":{
		"body":"void LogicalSlotCheckDelete(const LogicalPersistentData* LogicalSlot)\r\n{\r\n    int DeleteNum = 0;\r\n    char SlotName[g_instance.attr.attr_storage.max_replication_slots][NAMEDATALEN];\r\n    LWLockAcquire(ReplicationSlotControlLock, LW_SHARED);\r\n    for (int i = 0; i < g_instance.attr.attr_storage.max_replication_slots; i++) {\r\n        ReplicationSlot* s = &t_thrd.slot_cxt.ReplicationSlotCtl->replication_slots[i];\r\n        if (s->in_use && s->data.database != InvalidOid) {\r\n            bool shouldDelete = true;\r\n            for (int j = 0; j < LogicalSlot->SlotNum; j++) {\r\n                if (strcmp(NameStr(s->data.name), NameStr(LogicalSlot->replication_slots[j].name)) == 0) {\r\n                    shouldDelete = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (shouldDelete == true) {\r\n                errno_t ret = memcpy_s(SlotName[DeleteNum], NAMEDATALEN, NameStr(s->data.name), NAMEDATALEN);\r\n                securec_check(ret, \"\", \"\");\r\n                DeleteNum++;\r\n            }\r\n        }\r\n    }\r\n    LWLockRelease(ReplicationSlotControlLock);\r\n    for (int i = 0; i < DeleteNum; i++) {\r\n        ReplicationSlotDrop(SlotName[i]);\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"LogicalSlotCheckDelete"
	},
	"create_logical_replication_slot":{
		"body":"void create_logical_replication_slot(const Name name, Name plugin, bool isDummyStandby, Oid databaseId,\r\n    NameData* databaseName, char* str_tmp_lsn, int str_length)\r\n{\r\n    LogicalDecodingContext* ctx = NULL;\r\n    CheckLogicalDecodingRequirements(databaseId);\r\n    int rc = 0;\r\n    char* fullname = NULL;\r\n    fullname = expand_dynamic_library_name(NameStr(*plugin));\r\n\r\n    Assert(!t_thrd.slot_cxt.MyReplicationSlot);\r\n\r\n    if (RecoveryInProgress() == true)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\r\n                errmsg(\"cannot create replication slot when recovery is in progress\")));\r\n\r\n    /* Load the shared library, unless we already did */\r\n    (void)internal_load_library(fullname);\r\n\r\n    /*\r\n     * Acquire a logical decoding slot, this will check for conflicting\r\n     * names.\r\n     */\r\n    ReplicationSlotCreate(NameStr(*name), RS_EPHEMERAL, isDummyStandby, databaseId, InvalidXLogRecPtr);\r\n\r\n    /*\r\n     * Create logical decoding context, to build the initial snapshot.\r\n     */\r\n    ctx = CreateInitDecodingContext(NameStr(*plugin),\r\n        NIL,\r\n        false, /* do not build snapshot */\r\n        logical_read_local_xlog_page,\r\n        NULL,\r\n        NULL);\r\n    /* build initial snapshot, might take a while */\r\n    if (ctx != NULL) {\r\n        DecodingContextFindStartpoint(ctx);\r\n    }\r\n    if (databaseName != NULL) {\r\n        rc = snprintf_s(\r\n            databaseName->data, NAMEDATALEN, NAMEDATALEN - 1, \"%s\", t_thrd.slot_cxt.MyReplicationSlot->data.name.data);\r\n        securec_check_ss(rc, \"\\0\", \"\\0\");\r\n    }\r\n    if (str_tmp_lsn != NULL) {\r\n        rc = snprintf_s(str_tmp_lsn,\r\n            str_length,\r\n            str_length - 1,\r\n            \"%X/%X\",\r\n            (uint32)(t_thrd.slot_cxt.MyReplicationSlot->data.confirmed_flush >> 32),\r\n            (uint32)t_thrd.slot_cxt.MyReplicationSlot->data.confirmed_flush);\r\n        securec_check_ss(rc, \"\\0\", \"\\0\");\r\n    }\r\n\r\n    /* don't need the decoding context anymore */\r\n    if (ctx != NULL) {\r\n        FreeDecodingContext(ctx);\r\n    }\r\n    /* ok, slot is now fully created, mark it as persistent */\r\n    ReplicationSlotPersist();\r\n    log_slot_create(&t_thrd.slot_cxt.MyReplicationSlot->data);\r\n    ReplicationSlotRelease();\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"create_logical_replication_slot"
	},
	"get_in_use_slot_number":{
		"body":"int get_in_use_slot_number()\r\n{\r\n    int SlotCount = 0;\r\n    LWLockAcquire(ReplicationSlotControlLock, LW_SHARED);\r\n    for (int i = 0; i < g_instance.attr.attr_storage.max_replication_slots; i++) {\r\n        ReplicationSlot* s = &t_thrd.slot_cxt.ReplicationSlotCtl->replication_slots[i];\r\n        if (s->in_use) {\r\n            SlotCount++;\r\n        }\r\n    }\r\n    LWLockRelease(ReplicationSlotControlLock);\r\n    return SlotCount;\r\n}",
		"comment":"/*\r\n * Get the current number of slots in use\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"get_in_use_slot_number"
	},
	"log_slot_advance":{
		"body":"void log_slot_advance(const ReplicationSlotPersistentData* slotInfo)\r\n{\r\n    if (!u_sess->attr.attr_sql.enable_slot_log || !PMstateIsRun()) {\r\n        return;\r\n    }\r\n\r\n    xl_slot_header xlrec;\r\n    XLogRecPtr Ptr;\r\n    int rc =\r\n        memcpy_s(&xlrec.data, sizeof(ReplicationSlotPersistentData), slotInfo, sizeof(ReplicationSlotPersistentData));\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n    START_CRIT_SECTION();\r\n\r\n    XLogBeginInsert();\r\n    XLogRegisterData((char*)&xlrec, SizeOfSlotHeader);\r\n\r\n    Ptr = XLogInsert(RM_SLOT_ID, XLOG_SLOT_ADVANCE);\r\n    XLogFlush(Ptr);\r\n    if (g_instance.attr.attr_storage.max_wal_senders > 0)\r\n        WalSndWakeup();\r\n    END_CRIT_SECTION();\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"log_slot_advance"
	},
	"log_slot_create":{
		"body":"void log_slot_create(const ReplicationSlotPersistentData* slotInfo)\r\n{\r\n    if (!u_sess->attr.attr_sql.enable_slot_log || !PMstateIsRun()) {\r\n        return;\r\n    }\r\n\r\n    xl_slot_header xlrec;\r\n    XLogRecPtr recptr;\r\n    int rc =\r\n        memcpy_s(&xlrec.data, sizeof(ReplicationSlotPersistentData), slotInfo, sizeof(ReplicationSlotPersistentData));\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n    START_CRIT_SECTION();\r\n\r\n    XLogBeginInsert();\r\n    XLogRegisterData((char*)&xlrec, SizeOfSlotHeader);\r\n\r\n    recptr = XLogInsert(RM_SLOT_ID, XLOG_SLOT_CREATE);\r\n    XLogFlush(recptr);\r\n    if (g_instance.attr.attr_storage.max_wal_senders > 0)\r\n        WalSndWakeup();\r\n\r\n    END_CRIT_SECTION();\r\n\r\n    if (u_sess->attr.attr_storage.guc_synchronous_commit > SYNCHRONOUS_COMMIT_LOCAL_FLUSH)\r\n        SyncRepWaitForLSN(recptr);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"log_slot_create"
	},
	"log_slot_drop":{
		"body":"void log_slot_drop(const char* name)\r\n{\r\n    if (!u_sess->attr.attr_sql.enable_slot_log || !PMstateIsRun())\r\n        return;\r\n    XLogRecPtr Ptr;\r\n    xl_slot_header xlrec;\r\n\r\n    int rc = memcpy_s(xlrec.data.name.data, NAMEDATALEN, name, NAMEDATALEN);\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n    START_CRIT_SECTION();\r\n    XLogBeginInsert();\r\n    XLogRegisterData((char*)&xlrec, SizeOfSlotHeader);\r\n\r\n    Ptr = XLogInsert(RM_SLOT_ID, XLOG_SLOT_DROP);\r\n    XLogFlush(Ptr);\r\n    if (g_instance.attr.attr_storage.max_wal_senders > 0)\r\n        WalSndWakeup();\r\n    END_CRIT_SECTION();\r\n    if (u_sess->attr.attr_storage.guc_synchronous_commit > SYNCHRONOUS_COMMIT_LOCAL_FLUSH)\r\n        SyncRepWaitForLSN(Ptr);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"log_slot_drop"
	},
	"pg_create_logical_replication_slot":{
		"body":"Datum pg_create_logical_replication_slot(PG_FUNCTION_ARGS)\r\n{\r\n    Name name = PG_GETARG_NAME(0);\r\n    Name plugin = PG_GETARG_NAME(1);\r\n    errno_t rc = EOK;\r\n\r\n    TupleDesc tupdesc;\r\n    HeapTuple tuple;\r\n    Datum result;\r\n    const int TUPLE_FIELDS = 2;\r\n    Datum values[TUPLE_FIELDS];\r\n    bool nulls[TUPLE_FIELDS];\r\n    char* str_tmp_lsn = NULL;\r\n    NameData databaseName;\r\n\r\n    (void)ValidateName(NameStr(*name));\r\n    (void)ValidateName(NameStr(*plugin));\r\n    str_tmp_lsn = (char*)palloc0(128);\r\n\r\n    check_permissions();\r\n    if (RecoveryInProgress())\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"Standby mode doesn't support create logical slot\")));\r\n    if (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\r\n        ereport(ERROR, (errcode(ERRCODE_DATATYPE_MISMATCH), errmsg(\"return type must be a row type\")));\r\n\r\n    create_logical_replication_slot(\r\n        name, plugin, false, u_sess->proc_cxt.MyDatabaseId, &databaseName, str_tmp_lsn, 128);\r\n\r\n    values[0] = CStringGetTextDatum(NameStr(databaseName));\r\n    values[1] = CStringGetTextDatum(str_tmp_lsn);\r\n    pfree(str_tmp_lsn);\r\n    str_tmp_lsn = NULL;\r\n    rc = memset_s(nulls, sizeof(nulls), 0, sizeof(nulls));\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n\r\n    tuple = heap_form_tuple(tupdesc, values, nulls);\r\n    result = HeapTupleGetDatum(tuple);\r\n    PG_RETURN_DATUM(result);\r\n}",
		"comment":"/*\r\n * SQL function for creating a new logical replication slot.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"pg_create_logical_replication_slot"
	},
	"pg_create_physical_replication_slot":{
		"body":"Datum pg_create_physical_replication_slot(PG_FUNCTION_ARGS)\r\n{\r\n    Name name = PG_GETARG_NAME(0);\r\n    bool isDummyStandby = PG_GETARG_BOOL(1);\r\n    const int TUPLE_FIELDS = 2;\r\n    Datum values[TUPLE_FIELDS];\r\n    bool nulls[TUPLE_FIELDS];\r\n    TupleDesc tupdesc;\r\n    HeapTuple tuple;\r\n    Datum result;\r\n\r\n    check_permissions();\r\n\r\n    CheckSlotRequirements();\r\n\r\n    if (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE) {\r\n        ereport(ERROR, (errcode(ERRCODE_DATATYPE_MISMATCH), errmsg(\"return type must be a row type\")));\r\n    }\r\n    /* acquire replication slot, this will check for conflicting names */\r\n    ReplicationSlotCreate(NameStr(*name), RS_PERSISTENT, isDummyStandby, InvalidOid, InvalidXLogRecPtr);\r\n\r\n    values[0] = CStringGetTextDatum(NameStr(t_thrd.slot_cxt.MyReplicationSlot->data.name));\r\n\r\n    nulls[0] = false;\r\n    nulls[1] = true;\r\n\r\n    tuple = heap_form_tuple(tupdesc, values, nulls);\r\n    result = HeapTupleGetDatum(tuple);\r\n\r\n    ReplicationSlotRelease();\r\n\r\n    PG_RETURN_DATUM(result);\r\n}",
		"comment":"/*\r\n * SQL function for creating a new physical (streaming replication)\r\n * replication slot.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"pg_create_physical_replication_slot"
	},
	"pg_drop_replication_slot":{
		"body":"Datum pg_drop_replication_slot(PG_FUNCTION_ARGS)\r\n{\r\n    Name name = PG_GETARG_NAME(0);\r\n\r\n    (void)ValidateName(NameStr(*name));\r\n\r\n    check_permissions();\r\n\r\n    CheckSlotRequirements();\r\n\r\n    ReplicationSlotDrop(NameStr(*name));\r\n\r\n    PG_RETURN_VOID();\r\n}",
		"comment":"/*\r\n * SQL function for dropping a replication slot.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"pg_drop_replication_slot"
	},
	"pg_get_replication_slot_name":{
		"body":"Datum pg_get_replication_slot_name(PG_FUNCTION_ARGS)\r\n{\r\n    char* slotname = NULL;\r\n    slotname = get_my_slot_name();\r\n    text* t = cstring_to_text(slotname);\r\n    pfree(slotname);\r\n    slotname = NULL;\r\n    PG_RETURN_TEXT_P(t);\r\n}",
		"comment":"/*\r\n * pg_get_cur_replication_slot_name - SQL SRF showing replication slot name.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"pg_get_replication_slot_name"
	},
	"pg_get_replication_slots":{
		"body":"Datum pg_get_replication_slots(PG_FUNCTION_ARGS)\r\n{\r\n#define PG_GET_REPLICATION_SLOTS_COLS 9\r\n    ReturnSetInfo* rsinfo = (ReturnSetInfo*)fcinfo->resultinfo;\r\n    TupleDesc tupdesc;\r\n    Tuplestorestate* tupstore = NULL;\r\n    MemoryContext per_query_ctx;\r\n    MemoryContext oldcontext;\r\n    int slotno;\r\n    errno_t rc = EOK;\r\n    int nRet = 0;\r\n\r\n    /* check to see if caller supports us returning a tuplestore */\r\n    if (rsinfo == NULL || !IsA(rsinfo, ReturnSetInfo))\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\r\n                errmsg(\"set-valued function called in context that cannot accept a set\")));\r\n    if (!(rsinfo->allowedModes & SFRM_Materialize))\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\r\n                errmsg(\"materialize mode required, but it is not \"\r\n                       \"allowed in this context\")));\r\n\r\n    /* Build a tuple descriptor for our result type */\r\n    if (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\r\n        ereport(ERROR, (errcode(ERRCODE_DATATYPE_MISMATCH), errmsg(\"return type must be a row type\")));\r\n\r\n    /*\r\n     * We don't require any special permission to see this function's data\r\n     * because nothing should be sensitive. The most critical being the slot\r\n     * name, which shouldn't contain anything particularly sensitive.\r\n     */\r\n    per_query_ctx = rsinfo->econtext->ecxt_per_query_memory;\r\n    oldcontext = MemoryContextSwitchTo(per_query_ctx);\r\n\r\n    tupstore = tuplestore_begin_heap(true, false, u_sess->attr.attr_memory.work_mem);\r\n    rsinfo->returnMode = SFRM_Materialize;\r\n    rsinfo->setResult = tupstore;\r\n    rsinfo->setDesc = tupdesc;\r\n\r\n    (void)MemoryContextSwitchTo(oldcontext);\r\n\r\n    for (slotno = 0; slotno < g_instance.attr.attr_storage.max_replication_slots; slotno++) {\r\n        ReplicationSlot* slot = &t_thrd.slot_cxt.ReplicationSlotCtl->replication_slots[slotno];\r\n        Datum values[PG_GET_REPLICATION_SLOTS_COLS];\r\n        bool nulls[PG_GET_REPLICATION_SLOTS_COLS];\r\n\r\n        TransactionId xmin;\r\n        TransactionId catalog_xmin;\r\n        XLogRecPtr restart_lsn;\r\n        bool active = false;\r\n        bool isDummyStandby = false;\r\n        Oid database;\r\n        const char* slot_name = NULL;\r\n\r\n        char restart_lsn_s[MAXFNAMELEN];\r\n        const char* plugin = NULL;\r\n        int i;\r\n\r\n        SpinLockAcquire(&slot->mutex);\r\n        if (!slot->in_use) {\r\n            SpinLockRelease(&slot->mutex);\r\n            continue;\r\n        } else {\r\n            xmin = slot->data.xmin;\r\n            catalog_xmin = slot->data.catalog_xmin;\r\n            database = slot->data.database;\r\n            restart_lsn = slot->data.restart_lsn;\r\n            slot_name = pstrdup(NameStr(slot->data.name));\r\n\r\n            plugin = pstrdup(NameStr(slot->data.plugin));\r\n            active = slot->active;\r\n            isDummyStandby = slot->data.isDummyStandby;\r\n        }\r\n        SpinLockRelease(&slot->mutex);\r\n\r\n        rc = memset_s(nulls, sizeof(nulls), 0, sizeof(nulls));\r\n        securec_check(rc, \"\\0\", \"\\0\");\r\n\r\n        nRet = snprintf_s(restart_lsn_s,\r\n            sizeof(restart_lsn_s),\r\n            sizeof(restart_lsn_s) - 1,\r\n            \"%X/%X\",\r\n            (uint32)(restart_lsn >> 32),\r\n            (uint32)restart_lsn);\r\n        securec_check_ss(nRet, \"\\0\", \"\\0\");\r\n\r\n        i = 0;\r\n        values[i++] = CStringGetTextDatum(slot_name);\r\n        if (database == InvalidOid)\r\n            nulls[i++] = true;\r\n        else\r\n            values[i++] = CStringGetTextDatum(plugin);\r\n        if (database == InvalidOid)\r\n            values[i++] = CStringGetTextDatum(\"physical\");\r\n        else\r\n            values[i++] = CStringGetTextDatum(\"logical\");\r\n        values[i++] = database;\r\n        values[i++] = BoolGetDatum(active);\r\n        if (xmin != InvalidTransactionId)\r\n            values[i++] = TransactionIdGetDatum(xmin);\r\n        else\r\n            nulls[i++] = true;\r\n        if (catalog_xmin != InvalidTransactionId)\r\n            values[i++] = TransactionIdGetDatum(catalog_xmin);\r\n        else\r\n            nulls[i++] = true;\r\n        if (!XLByteEQ(restart_lsn, InvalidXLogRecPtr))\r\n            values[i++] = CStringGetTextDatum(restart_lsn_s);\r\n        else\r\n            nulls[i++] = true;\r\n\r\n        values[i++] = BoolGetDatum(isDummyStandby);\r\n\r\n        tuplestore_putvalues(tupstore, tupdesc, values, nulls);\r\n    }\r\n\r\n    tuplestore_donestoring(tupstore);\r\n\r\n    return (Datum)0;\r\n}",
		"comment":"/*\r\n * pg_get_replication_slots - SQL SRF showing active replication slots.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"pg_get_replication_slots"
	},
	"pg_logical_replication_slot_advance":{
		"body":"static XLogRecPtr pg_logical_replication_slot_advance(XLogRecPtr moveto)\r\n{\r\n    LogicalDecodingContext* ctx = NULL;\r\n    ResourceOwner old_resowner = t_thrd.utils_cxt.CurrentResourceOwner;\r\n    XLogRecPtr startlsn = t_thrd.slot_cxt.MyReplicationSlot->data.restart_lsn;\r\n    XLogRecPtr retlsn = t_thrd.slot_cxt.MyReplicationSlot->data.confirmed_flush;\r\n\r\n    PG_TRY();\r\n    {\r\n        /* restart at slot's confirmed_flush */\r\n        ctx = CreateDecodingContext(InvalidXLogRecPtr, NIL, true, logical_read_local_xlog_page, NULL, NULL);\r\n\r\n        t_thrd.utils_cxt.CurrentResourceOwner =\r\n            ResourceOwnerCreate(t_thrd.utils_cxt.CurrentResourceOwner, \"logical decoding\");\r\n\r\n        /* invalidate non-timetravel entries */\r\n        if (!RecoveryInProgress())\r\n            InvalidateSystemCaches();\r\n\r\n        /* Decode until we run out of records */\r\n        while ((!XLByteEQ(startlsn, InvalidXLogRecPtr) && XLByteLT(startlsn, moveto)) ||\r\n               (!XLByteEQ(ctx->reader->EndRecPtr, InvalidXLogRecPtr) && XLByteLT(ctx->reader->EndRecPtr, moveto))) {\r\n            XLogRecord* record = NULL;\r\n            char* errm = NULL;\r\n\r\n            record = XLogReadRecord(ctx->reader, startlsn, &errm);\r\n\r\n            if (errm != NULL)\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_LOGICAL_DECODE_ERROR),\r\n                        errmsg(\"Stopped to parse any valid XLog Record at %X/%X: %s.\",\r\n                            (uint32)(ctx->reader->EndRecPtr >> 32),\r\n                            (uint32)ctx->reader->EndRecPtr,\r\n                            errm)));\r\n\r\n            /*\r\n             * Now that we've set up the xlog reader state, subsequent calls\r\n             * pass InvalidXLogRecPtr to say \"continue from last record\"\r\n             */\r\n            startlsn = InvalidXLogRecPtr;\r\n\r\n            /*\r\n             * The {begin_txn,change,commit_txn}_wrapper callbacks above will\r\n             * store the description into our tuplestore.\r\n             */\r\n            if (record != NULL)\r\n                LogicalDecodingProcessRecord(ctx, ctx->reader);\r\n\r\n            /* Stop once the moving point wanted by caller has been reached */\r\n            if (XLByteLE(moveto, ctx->reader->EndRecPtr))\r\n                break;\r\n\r\n            CHECK_FOR_INTERRUPTS();\r\n        }\r\n        t_thrd.utils_cxt.CurrentResourceOwner = old_resowner;\r\n\r\n        if (!XLByteEQ(ctx->reader->EndRecPtr, InvalidXLogRecPtr)) {\r\n            LogicalConfirmReceivedLocation(moveto);\r\n\r\n            /*\r\n             * If only the confirmed_flush_lsn has changed the slot won't get\r\n             * marked as dirty by the above. Callers on the walsender\r\n             * interface are expected to keep track of their own progress and\r\n             * don't need it written out. But SQL-interface users cannot\r\n             * specify their own start positions and it's harder for them to\r\n             * keep track of their progress, so we should make more of an\r\n             * effort to save it for them.\r\n             *\r\n             * Dirty the slot so it's written out at the next checkpoint.\r\n             * We'll still lose its position on crash, as documented, but it's\r\n             * better than always losing the position even on clean restart.\r\n             */\r\n            ReplicationSlotMarkDirty();\r\n        }\r\n\r\n        retlsn = t_thrd.slot_cxt.MyReplicationSlot->data.confirmed_flush;\r\n\r\n        /* free context, call shutdown callback */\r\n        FreeDecodingContext(ctx);\r\n\r\n        if (!RecoveryInProgress())\r\n            InvalidateSystemCaches();\r\n    }\r\n    PG_CATCH();\r\n    {\r\n        /* clear all timetravel entries */\r\n        if (!RecoveryInProgress())\r\n            InvalidateSystemCaches();\r\n\r\n        PG_RE_THROW();\r\n    }\r\n    PG_END_TRY();\r\n\r\n    return retlsn;\r\n}",
		"comment":"/*\r\n * Helper function for advancing logical replication slot forward.\r\n * The slot's restart_lsn is used as start point for reading records,\r\n * while confirmed_lsn is used as base point for the decoding context.\r\n * The LSN position to move to is checked by doing a per-record scan and\r\n * logical decoding which makes sure that confirmed_lsn is updated to a\r\n * LSN which allows the future slot consumer to get consistent logical\r\n * changes.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"pg_logical_replication_slot_advance"
	},
	"pg_physical_replication_slot_advance":{
		"body":"static XLogRecPtr pg_physical_replication_slot_advance(XLogRecPtr moveto)\r\n{\r\n    XLogRecPtr startlsn = t_thrd.slot_cxt.MyReplicationSlot->data.restart_lsn;\r\n    XLogRecPtr retlsn = startlsn;\r\n\r\n    if (XLByteLT(startlsn, moveto)) {\r\n        SpinLockAcquire(&t_thrd.slot_cxt.MyReplicationSlot->mutex);\r\n        t_thrd.slot_cxt.MyReplicationSlot->data.restart_lsn = moveto;\r\n        SpinLockRelease(&t_thrd.slot_cxt.MyReplicationSlot->mutex);\r\n        retlsn = moveto;\r\n    }\r\n\r\n    return retlsn;\r\n}",
		"comment":"/*\r\n * Helper function for advancing physical replication slot forward.\r\n * The LSN position to move to is compared simply to the slot's\r\n * restart_lsn, knowing that any position older than that would be\r\n * removed by successive checkpoints.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"pg_physical_replication_slot_advance"
	},
	"pg_replication_slot_advance":{
		"body":"Datum pg_replication_slot_advance(PG_FUNCTION_ARGS)\r\n{\r\n    Name slotname = PG_GETARG_NAME(0);\r\n    XLogRecPtr moveto;\r\n    TupleDesc tupdesc;\r\n    HeapTuple tuple;\r\n    Datum values[2];\r\n    bool nulls[2];\r\n    Datum result;\r\n    NameData database;\r\n    char EndLsn[NAMEDATALEN];\r\n    (void)ValidateName(NameStr(*slotname));\r\n    if (RecoveryInProgress()) {\r\n        ereport(ERROR, (errcode(ERRCODE_INVALID_OPERATION), errmsg(\"couldn't advance in recovery\")));\r\n    }\r\n    if (PG_ARGISNULL(1)) {\r\n        if (!RecoveryInProgress())\r\n            moveto = GetFlushRecPtr();\r\n        else\r\n            moveto = GetXLogReplayRecPtr(NULL);\r\n    } else {\r\n        const char* str_upto_lsn = TextDatumGetCString(PG_GETARG_DATUM(1));\r\n        (void)ValidateName(str_upto_lsn);\r\n        if (!AssignLsn(&moveto, str_upto_lsn)) {\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\r\n                    errmsg(\"invalid input syntax for type lsn: \\\"%s\\\" \"\r\n                           \"of start_lsn\",\r\n                        str_upto_lsn)));\r\n        }\r\n    }\r\n\r\n    /* Build a tuple descriptor for our result type */\r\n    if (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\r\n        ereport(ERROR, (errcode(ERRCODE_DATATYPE_MISMATCH), errmsg(\"return type must be a row type\")));\r\n\r\n    check_permissions();\r\n    CheckLogicalDecodingRequirements(u_sess->proc_cxt.MyDatabaseId);\r\n    slot_advance(slotname, moveto, database, EndLsn);\r\n    values[0] = NameGetDatum(&database);\r\n    nulls[0] = false;\r\n    values[1] = CStringGetTextDatum(EndLsn);\r\n    nulls[1] = false;\r\n    tuple = heap_form_tuple(tupdesc, values, nulls);\r\n\r\n    result = HeapTupleGetDatum(tuple);\r\n\r\n    PG_RETURN_DATUM(result);\r\n}",
		"comment":"/*\r\n * SQL function for moving the position in a replication slot.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"pg_replication_slot_advance"
	},
	"redo_slot_advance":{
		"body":"void redo_slot_advance(const ReplicationSlotPersistentData* slotInfo)\r\n{\r\n    errno_t rc;\r\n\r\n    Assert(!t_thrd.slot_cxt.MyReplicationSlot);\r\n\r\n    /* Acquire the slot so we \"own\" it */\r\n    ReplicationSlotAcquire(NameStr(slotInfo->name), false);\r\n    rc = memcpy_s(&t_thrd.slot_cxt.MyReplicationSlot->data,\r\n        sizeof(ReplicationSlotPersistentData),\r\n        slotInfo,\r\n        sizeof(ReplicationSlotPersistentData));\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n    t_thrd.slot_cxt.MyReplicationSlot->effective_xmin = slotInfo->xmin;\r\n    t_thrd.slot_cxt.MyReplicationSlot->effective_catalog_xmin = slotInfo->catalog_xmin;\r\n    ReplicationSlotMarkDirty();\r\n    ReplicationSlotsComputeRequiredXmin(false);\r\n    ReplicationSlotsComputeRequiredLSN(NULL);\r\n    ReplicationSlotSave();\r\n    ReplicationSlotRelease();\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"redo_slot_advance"
	},
	"redo_slot_create":{
		"body":"void redo_slot_create(const ReplicationSlotPersistentData* slotInfo)\r\n{\r\n    Assert(!t_thrd.slot_cxt.MyReplicationSlot);\r\n\r\n    /*\r\n     * Acquire a logical decoding slot, this will check for conflicting\r\n     * names.\r\n     */\r\n    ReplicationSlotCreate(\r\n        NameStr(slotInfo->name), RS_EPHEMERAL, slotInfo->isDummyStandby, slotInfo->database, InvalidXLogRecPtr);\r\n    int rc = memcpy_s(&t_thrd.slot_cxt.MyReplicationSlot->data,\r\n        sizeof(ReplicationSlotPersistentData),\r\n        slotInfo,\r\n        sizeof(ReplicationSlotPersistentData));\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n    t_thrd.slot_cxt.MyReplicationSlot->effective_xmin = t_thrd.slot_cxt.MyReplicationSlot->data.xmin;\r\n    t_thrd.slot_cxt.MyReplicationSlot->effective_catalog_xmin = t_thrd.slot_cxt.MyReplicationSlot->data.catalog_xmin;\r\n    /* ok, slot is now fully created, mark it as persistent */\r\n    ReplicationSlotMarkDirty();\r\n    ReplicationSlotsComputeRequiredXmin(false);\r\n    ReplicationSlotsComputeRequiredLSN(NULL);\r\n    ReplicationSlotSave();\r\n    ReplicationSlotRelease();\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"redo_slot_create"
	},
	"slot_advance":{
		"body":"void slot_advance(const Name slotname, XLogRecPtr moveto, const NameData database, char* EndLsn)\r\n{\r\n    XLogRecPtr endlsn;\r\n    XLogRecPtr minlsn;\r\n    errno_t rc;\r\n    int ret = 0;\r\n\r\n    Assert(!t_thrd.slot_cxt.MyReplicationSlot);\r\n\r\n    /*\r\n     * We can't move slot past what's been flushed/replayed so clamp the\r\n     * target possition accordingly.\r\n     */\r\n    if (!RecoveryInProgress()) {\r\n        XLogRecPtr FlushRecPtr = GetFlushRecPtr();\r\n        if (XLByteLT(FlushRecPtr, moveto))\r\n            moveto = FlushRecPtr;\r\n    } else {\r\n        XLogRecPtr XLogReplayRecPtr = GetXLogReplayRecPtr(&t_thrd.xlog_cxt.ThisTimeLineID);\r\n        if (XLByteLT(XLogReplayRecPtr, moveto))\r\n            moveto = XLogReplayRecPtr;\r\n    }\r\n\r\n    if (XLogRecPtrIsInvalid(moveto))\r\n        ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg(\"invalid target wal lsn\")));\r\n\r\n    /* Acquire the slot so we \"own\" it */\r\n    ReplicationSlotAcquire(NameStr(*slotname), false);\r\n\r\n    /*\r\n     * Check if the slot is not moving backwards.  Physical slots rely simply\r\n     * on restart_lsn as a minimum point, while logical slots have confirmed\r\n     * consumption up to confirmed_lsn, meaning that in both cases data older\r\n     * than that is not available anymore.\r\n     */\r\n    if (OidIsValid(t_thrd.slot_cxt.MyReplicationSlot->data.database))\r\n        minlsn = t_thrd.slot_cxt.MyReplicationSlot->data.confirmed_flush;\r\n    else\r\n        minlsn = t_thrd.slot_cxt.MyReplicationSlot->data.restart_lsn;\r\n\r\n    if (XLByteLT(moveto, minlsn)) {\r\n        if (RecoveryInProgress()) {\r\n            ReplicationSlotRelease();\r\n            return;\r\n        }\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\r\n                errmsg(\"cannot move slot to %X/%X, minimum is %X/%X\",\r\n                    (uint32)(moveto >> 32),\r\n                    (uint32)moveto,\r\n                    (uint32)(minlsn >> 32),\r\n                    (uint32)(minlsn))));\r\n    }\r\n\r\n    /* Do the actual slot update, depending on the slot type */\r\n    if (OidIsValid(t_thrd.slot_cxt.MyReplicationSlot->data.database))\r\n        endlsn = pg_logical_replication_slot_advance(moveto);\r\n    else\r\n        endlsn = pg_physical_replication_slot_advance(moveto);\r\n    moveto = t_thrd.slot_cxt.MyReplicationSlot->data.confirmed_flush;\r\n    rc = memcpy_s((char*)database.data, NAMEDATALEN, t_thrd.slot_cxt.MyReplicationSlot->data.name.data, NAMEDATALEN);\r\n    securec_check_c(rc, \"\\0\", \"\\0\");\r\n\r\n    /* Update the on disk state when lsn was updated. */\r\n    if (XLogRecPtrIsInvalid(endlsn)) {\r\n        ReplicationSlotMarkDirty();\r\n        ReplicationSlotsComputeRequiredXmin(false);\r\n        ReplicationSlotsComputeRequiredLSN(NULL);\r\n        ReplicationSlotSave();\r\n    }\r\n    if (!RecoveryInProgress())\r\n        log_slot_advance(&t_thrd.slot_cxt.MyReplicationSlot->data);\r\n    ReplicationSlotRelease();\r\n\r\n    /* Return the reached position. */\r\n    ret = snprintf_s(EndLsn, NAMEDATALEN, NAMEDATALEN - 1, \"%x/%x\", (uint32)(endlsn >> 32), (uint32)endlsn);\r\n    securec_check_ss(ret, \"\\0\", \"\\0\");\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"slot_advance"
	},
	"slot_redo":{
		"body":"void slot_redo(XLogReaderState* record)\r\n{\r\n    uint8 info = XLogRecGetInfo(record) & ~XLR_INFO_MASK;\r\n    xl_slot_header* xlrec = (xl_slot_header*)XLogRecGetData(record);\r\n    LogicalPersistentData* LogicalSlot = (LogicalPersistentData*)XLogRecGetData(record);\r\n\r\n    /* Backup blocks are not used in xlog records */\r\n    Assert(!XLogRecHasAnyBlockRefs(record));\r\n    switch (info) {\r\n        /*\r\n         * Rmgrs we care about for logical decoding. Add new rmgrs in\r\n         * rmgrlist.h's order.\r\n         */\r\n        case XLOG_SLOT_CREATE:\r\n            if (!ReplicationSlotFind(xlrec->data.name.data)) {\r\n                /*\r\n                 * If the current slot number of the standby machine is equal to max_replication_slots,\r\n                 * and this is the redo log of type XLOG_SLOT_CREATE,\r\n                 * the program directly breaks and no longer executes.\r\n                 * Because this XLOG must be a historical log, and there must be a xlog of type XLOG_SLOT_DROP after it.\r\n                 */\r\n                int SlotCount = get_in_use_slot_number();\r\n                if (AllSlotInUse(SlotCount, g_instance.attr.attr_storage.max_replication_slots)) {\r\n                    break;\r\n                } else {\r\n                    redo_slot_create(&xlrec->data);\r\n                }\r\n            }\r\n            break;\r\n        case XLOG_SLOT_ADVANCE:\r\n            if (ReplicationSlotFind(xlrec->data.name.data))\r\n                redo_slot_advance(&xlrec->data);\r\n            else\r\n                redo_slot_create(&xlrec->data);\r\n            break;\r\n        case XLOG_SLOT_DROP:\r\n            if (ReplicationSlotFind(xlrec->data.name.data))\r\n                ReplicationSlotDrop(NameStr(xlrec->data.name));\r\n            break;\r\n        case XLOG_SLOT_CHECK:\r\n            LogicalSlotCheck(LogicalSlot);\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"slot_redo"
	},
	"write_term_log":{
		"body":"void write_term_log(uint32 term)\r\n{\r\n    XLogRecPtr recptr;\r\n    START_CRIT_SECTION();\r\n\r\n    XLogBeginInsert();\r\n    XLogRegisterData((char*)&term, sizeof(uint32));\r\n\r\n    recptr = XLogInsert(RM_SLOT_ID, XLOG_TERM_LOG);\r\n    XLogFlush(recptr);\r\n    if (g_instance.attr.attr_storage.max_wal_senders > 0) {\r\n        WalSndWakeup();\r\n    }\r\n    END_CRIT_SECTION();\r\n\r\n    if (u_sess->attr.attr_storage.guc_synchronous_commit > SYNCHRONOUS_COMMIT_LOCAL_FLUSH) {\r\n        SyncRepWaitForLSN(recptr);\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\slotfuncs.cpp",
		"name":"write_term_log"
	}
}