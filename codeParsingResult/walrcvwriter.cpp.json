{
	"CloseWSDataFileOnDummyStandby":{
		"body":"void CloseWSDataFileOnDummyStandby(void)\r\n{\r\n    close(ws_dummy_data_writer_file_fd);\r\n    ws_dummy_data_writer_file_fd = -1;\r\n    ws_dummy_data_writer_file_offset = 0;\r\n}",
		"comment":"/*\r\n * close data fd for rm data file\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walrcvwriter.cpp",
		"name":"CloseWSDataFileOnDummyStandby"
	},
	"InitWSDataNumOnDummyStandby":{
		"body":"void InitWSDataNumOnDummyStandby(void)\r\n{\r\n    DIR* dir = NULL;\r\n    struct dirent* de = NULL;\r\n    int max_num_file = 0;\r\n    int min_num_file = 0;\r\n    char* dirpath = DUMMY_STANDBY_DATADIR;\r\n\r\n    /* open the dir of base/dummy_standby */\r\n    errno = 0;\r\n    dir = AllocateDir(dirpath);\r\n    if (dir == NULL && errno == ENOENT) {\r\n        if (mkdir(dirpath, S_IRWXU) < 0) {\r\n            /* Failure other than not exists */\r\n            ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not create directory \\\"%s\\\": %m\", dirpath)));\r\n        }\r\n        dir = AllocateDir(dirpath);\r\n    }\r\n    if (dir == NULL) {\r\n        ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not open directory \\\"%s\\\": %m\", dirpath)));\r\n        return;\r\n    }\r\n\r\n    /* loop read the file name of base/dummy_standby */\r\n    while ((de = ReadDir(dir, dirpath)) != NULL) {\r\n        /* Skip special stuff */\r\n        if (strcmp(de->d_name, \".\") == 0 || strcmp(de->d_name, \"..\") == 0)\r\n            continue;\r\n\r\n        min_num_file = atoi(de->d_name);\r\n        break;\r\n    }\r\n\r\n    FreeDir(dir);\r\n    dir = AllocateDir(dirpath);\r\n\r\n    /* loop read the file name of base/dummy_standby */\r\n    while ((de = ReadDir(dir, dirpath)) != NULL) {\r\n        /* Skip special stuff */\r\n        if (strcmp(de->d_name, \".\") == 0 || strcmp(de->d_name, \"..\") == 0)\r\n            continue;\r\n\r\n        /* search the max num file */\r\n        max_num_file = Max(atoi(de->d_name), max_num_file);\r\n        min_num_file = Min(atoi(de->d_name), min_num_file);\r\n        ereport(DEBUG5,\r\n            (errmsg(\"InitDummyDataNum de->d_name=%s;   max_num_path=%d; min_num_file=%d.\",\r\n                de->d_name,\r\n                max_num_file,\r\n                min_num_file)));\r\n    }\r\n\r\n    t_thrd.walsender_cxt.ws_dummy_data_read_file_num = min_num_file;\r\n    t_thrd.walrcvwriter_cxt.ws_dummy_data_writer_file_num = max_num_file;\r\n    FreeDir(dir);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walrcvwriter.cpp",
		"name":"InitWSDataNumOnDummyStandby"
	},
	"SetWalRcvWriterPID":{
		"body":"void SetWalRcvWriterPID(ThreadId tid)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    walrcv->writerPid = tid;\r\n    SpinLockRelease(&walrcv->mutex);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walrcvwriter.cpp",
		"name":"SetWalRcvWriterPID"
	},
	"ShutdownWalRcvWriter":{
		"body":"static void ShutdownWalRcvWriter(int code, Datum arg)\r\n{\r\n    /* clear WriterPid */\r\n    emptyWalRcvWriterLatch();\r\n}",
		"comment":"/*\r\n * Called when the WalRcvWriterMain is ending.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walrcvwriter.cpp",
		"name":"ShutdownWalRcvWriter"
	},
	"WSDataRcvWriteOnDummyStandby":{
		"body":"static void WSDataRcvWriteOnDummyStandby(const char* buf, uint32 nbytes)\r\n{\r\n    ws_dummy_data_writer_use_file = true;\r\n    WSDataWriteOnDummyStandby(buf, (uint32)nbytes);\r\n    ws_dummy_data_writer_use_file = false;\r\n}",
		"comment":"/*\r\n * Write data to disk of DummyStandby.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walrcvwriter.cpp",
		"name":"WSDataRcvWriteOnDummyStandby"
	},
	"WSDataWriteOnDummyStandby":{
		"body":"static void WSDataWriteOnDummyStandby(const char* buf, uint32 nbytes)\r\n{\r\n    ssize_t write_len = -1;\r\n    char path[MAXPGPATH] = {0};\r\n    int nRet = 0;\r\n\r\n    /*\r\n     * get  the file num to store:\r\n     *  1. If MAX_DUMMY_DATA_FILE <= wal_data_writer_file_offset, open\r\n     *     the next file to store\r\n     *  2. If the current file can not store the nbytes, discard the current file space,\r\n     *     open the next file to store.\r\n     */\r\n    if (ws_dummy_data_writer_file_offset >= MAX_DUMMY_DATA_FILE ||\r\n        (MAX_DUMMY_DATA_FILE - ws_dummy_data_writer_file_offset < (uint32)(nbytes + sizeof(nbytes)))) {\r\n        ereport(DEBUG2, (errmsg(\"data file num %u\", t_thrd.walrcvwriter_cxt.ws_dummy_data_writer_file_num)));\r\n        t_thrd.walrcvwriter_cxt.ws_dummy_data_writer_file_num++;\r\n        ws_dummy_data_writer_file_offset = 0;\r\n\r\n        if (ws_dummy_data_writer_file_fd >= 0) {\r\n            close(ws_dummy_data_writer_file_fd);\r\n            ws_dummy_data_writer_file_fd = -1;\r\n        }\r\n    }\r\n\r\n    /* open the file */\r\n    if (ws_dummy_data_writer_file_fd < 0) {\r\n        /* get the file path */\r\n        nRet = snprintf_s(path,\r\n            sizeof(path),\r\n            MAXPGPATH - 1,\r\n            \"base/dummy_standby/%u\",\r\n            t_thrd.walrcvwriter_cxt.ws_dummy_data_writer_file_num);\r\n        securec_check_ss_c(nRet, \"\\0\", \"\\0\");\r\n\r\n        ws_dummy_data_writer_file_fd = open(path, O_RDWR | O_CREAT | PG_BINARY, S_IRUSR | S_IWUSR);\r\n        if (ws_dummy_data_writer_file_fd < 0)\r\n            ereport(PANIC,\r\n                (errcode_for_file_access(),\r\n                    errmsg(\"could not create data file \\\"%s\\\", dummy_data_writer_file_fd=%d: %m\",\r\n                        path,\r\n                        ws_dummy_data_writer_file_fd)));\r\n    }\r\n\r\n    errno = 0;\r\n    /* OK to write the data */\r\n    write_len = write(ws_dummy_data_writer_file_fd, &nbytes, sizeof(uint32));\r\n    if (write_len < (ssize_t)sizeof(uint32)) {\r\n        /* if write didn't set errno, assume no disk space */\r\n        if (errno == 0) {\r\n            errno = ENOSPC;\r\n        }\r\n        ereport(PANIC, (errcode_for_file_access(),\r\n            errmsg(\"could not write to data file %s buffer len %u, length %u: %m\", path, nbytes, nbytes)));\r\n    }\r\n\r\n    errno = 0;\r\n    write_len = write(ws_dummy_data_writer_file_fd, buf, nbytes);\r\n    if (write_len < nbytes) {\r\n        /* if write didn't set errno, assume no disk space */\r\n        if (errno == 0)\r\n            errno = ENOSPC;\r\n        ereport(PANIC,\r\n            (errcode_for_file_access(),\r\n                errmsg(\"could not write to data file %s \"\r\n                       \"at offset %u, length %u: %m\",\r\n                    path,\r\n                    (uint32)ws_dummy_data_writer_file_offset,\r\n                    nbytes)));\r\n    }\r\n\r\n    ws_dummy_data_writer_file_offset = ws_dummy_data_writer_file_offset + nbytes + sizeof(nbytes);\r\n\r\n    ereport(u_sess->attr.attr_storage.HaModuleDebug ? LOG : DEBUG2,\r\n        (errmsg(\"the dummy data write info: writer_file_num %u %u bytes\",\r\n            t_thrd.walrcvwriter_cxt.ws_dummy_data_writer_file_num,\r\n            nbytes)));\r\n\r\n    /* use fdatasync to make sure the received data to flush the disk */\r\n    if (pg_fdatasync(ws_dummy_data_writer_file_fd) != 0)\r\n        ereport(PANIC,\r\n            (errcode_for_file_access(),\r\n                errmsg(\"could not fdatasync data file num %u, fd %d: %m\",\r\n                    t_thrd.walrcvwriter_cxt.ws_dummy_data_writer_file_num,\r\n                    ws_dummy_data_writer_file_fd)));\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walrcvwriter.cpp",
		"name":"WSDataWriteOnDummyStandby"
	},
	"WSWalRcvWrite":{
		"body":"int WSWalRcvWrite(WalRcvCtlBlock* walrcb, char* buf, Size nbytes, XLogRecPtr start_ptr)\r\n{\r\n    if (walrcb == NULL) {\r\n        ereport(NOTICE, (errmsg(\"have nothing of the wal receiver wal block info.\")));\r\n        return 0;\r\n    }\r\n\r\n    START_CRIT_SECTION();\r\n    LWLockAcquire(WALWriteLock, LW_EXCLUSIVE);\r\n\r\n    XLogWalRcvWrite(walrcb, buf, nbytes, start_ptr);\r\n\r\n    LWLockRelease(WALWriteLock);\r\n    END_CRIT_SECTION();\r\n\r\n    return nbytes;\r\n}",
		"comment":"/*\r\n * The main difference between walRcvWrite() and WSWalRcvWrite() is that\r\n * for walRcvWrite() the wal source is from the walrcb and for WSWalRcvWrite()\r\n * the wal source is from the wal write queue.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walrcvwriter.cpp",
		"name":"WSWalRcvWrite"
	},
	"WalDataRcvWrite":{
		"body":"int WalDataRcvWrite()\r\n{\r\n    /* Use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    char* writeBuf = NULL;\r\n    char* cur_buf = NULL;\r\n    uint32 left_nbytes = 0;\r\n    uint32 get_queue_nbytes = 0;\r\n    uint32 remainbytes = 0;\r\n    uint32 cur_data_nbytes = 0;\r\n    DataQueuePtr start_pos = {0, 0};\r\n    DataQueuePtr end_pos = {0, 0};\r\n    WalRcvCtlBlock* walrcb = getCurrentWalRcvCtlBlock();\r\n    errno_t errorno = EOK;\r\n    XLogRecPtr recptr = InvalidXLogRecPtr;\r\n    char data_flag;\r\n\r\n    if (!g_instance.attr.attr_storage.enable_mix_replication)\r\n        return walRcvWrite(walrcb);\r\n    else if (!t_thrd.xlog_cxt.InRecovery)\r\n        t_thrd.xlog_cxt.InRecovery = true;\r\n\r\n    /* avoid concurrent WalDataRcvWrite by WalRcvWriteLock */\r\n    START_CRIT_SECTION();\r\n    LWLockAcquire(RcvWriteLock, LW_EXCLUSIVE);\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    start_pos.queueid = walrcv->local_write_pos.queueid;\r\n    start_pos.queueoff = walrcv->local_write_pos.queueoff;\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    get_queue_nbytes = GetFromDataQueue(writeBuf,\r\n        g_instance.attr.attr_storage.DataQueueBufSize * 1024,\r\n        start_pos,\r\n        end_pos,\r\n        true,\r\n        t_thrd.dataqueue_cxt.DataWriterQueue);\r\n    if (get_queue_nbytes == 0) {\r\n        LWLockRelease(RcvWriteLock);\r\n        END_CRIT_SECTION();\r\n        return 0;\r\n    }\r\n\r\n    cur_buf = writeBuf;\r\n    left_nbytes = get_queue_nbytes;\r\n\r\n    while (left_nbytes > 0) {\r\n        errorno = memcpy_s(&cur_data_nbytes, sizeof(uint32), cur_buf, sizeof(uint32));\r\n        securec_check(errorno, \"\\0\", \"\\0\");\r\n        data_flag = *(cur_buf + sizeof(uint32));\r\n\r\n        switch (data_flag) {\r\n            case 'w':\r\n                Assert(cur_data_nbytes > (sizeof(uint32) + 1 + sizeof(XLogRecPtr)));\r\n                errorno = memcpy_s(&recptr, sizeof(XLogRecPtr), cur_buf + sizeof(uint32) + 1, sizeof(XLogRecPtr));\r\n                securec_check(errorno, \"\\0\", \"\\0\");\r\n                Assert(!XLogRecPtrIsInvalid(recptr));\r\n\r\n                (void)WSWalRcvWrite(walrcb,\r\n                    cur_buf + sizeof(uint32) + 1 + sizeof(XLogRecPtr),\r\n                    cur_data_nbytes - (sizeof(uint32) + 1 + sizeof(XLogRecPtr)),\r\n                    recptr);\r\n\r\n                break;\r\n            case 'd':\r\n                if (u_sess->attr.attr_storage.HaModuleDebug)\r\n                    WSDataRcvCheck(cur_buf, cur_data_nbytes);\r\n\r\n                /* Write data. */\r\n                if (dummyStandbyMode)\r\n                    WSDataRcvWriteOnDummyStandby(cur_buf, cur_data_nbytes);\r\n                else {\r\n                    /* skip the data message prefix (total_len + 'd' + start_ptr + end_ptr)\r\n                     *\r\n                     * 1. total_len has already been parsed as cur_data_nbytes\r\n                     */\r\n                    cur_buf += sizeof(uint32);\r\n                    /* 2. check and skip tag 'd' */\r\n                    Assert(cur_buf[0] == 'd');\r\n                    cur_buf += 1;\r\n                    /* 3. skip the start_ptr and end_ptr */\r\n                    cur_buf += sizeof(XLogRecPtr) * 2;\r\n                    /* 4. calculate the post-proccess cur_data_nbytes */\r\n                    cur_data_nbytes -= WS_DATA_MSG_PREFIX_LEN;\r\n                    left_nbytes -= WS_DATA_MSG_PREFIX_LEN;\r\n\r\n                    remainbytes = DoDataWrite(cur_buf, cur_data_nbytes);\r\n                    Assert(remainbytes == 0);\r\n                    cur_data_nbytes -= remainbytes;\r\n                }\r\n                /* Close all open files */\r\n                smgrcloseall();\r\n                break;\r\n            default:\r\n                Assert(false);\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg(\"unexpected wal data type %c\", data_flag)));\r\n                break;\r\n        }\r\n\r\n        cur_buf += cur_data_nbytes;\r\n        left_nbytes -= cur_data_nbytes;\r\n    }\r\n    Assert(left_nbytes == 0);\r\n\r\n    /* Update share memory from the the next operation. */\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    walrcv->local_write_pos.queueid = start_pos.queueid;\r\n    walrcv->local_write_pos.queueoff = start_pos.queueoff;\r\n    DQByteAdvance(walrcv->local_write_pos, get_queue_nbytes);\r\n    SpinLockRelease(&walrcv->mutex);\r\n\r\n    PopFromDataQueue(((WalRcvData*)walrcv)->local_write_pos, t_thrd.dataqueue_cxt.DataWriterQueue);\r\n\r\n    LWLockRelease(RcvWriteLock);\r\n    END_CRIT_SECTION();\r\n\r\n    return (int)get_queue_nbytes;\r\n}",
		"comment":"/*\r\n * Write all the wal data to disk.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walrcvwriter.cpp",
		"name":"WalDataRcvWrite"
	},
	"WalRcvWriterInProgress":{
		"body":"bool WalRcvWriterInProgress(void)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    if (walrcv->writerPid == 0) {\r\n        SpinLockRelease(&walrcv->mutex);\r\n        return false;\r\n    }\r\n    SpinLockRelease(&walrcv->mutex);\r\n    return true;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walrcvwriter.cpp",
		"name":"WalRcvWriterInProgress"
	},
	"WalRcvXLogClose":{
		"body":"void WalRcvXLogClose(void)\r\n{\r\n    LWLockAcquire(WALWriteLock, LW_EXCLUSIVE);\r\n\r\n    if (recvFile >= 0) {\r\n        /*\r\n         * XLOG segment files will be re-read by recovery in startup\r\n         * process soon, so we don't advise the OS to release cache\r\n         * pages associated with the file like XLogFileClose() does.\r\n         */\r\n        if (close(recvFile) != 0)\r\n            ereport(PANIC,\r\n                (errcode_for_file_access(),\r\n                    errmsg(\r\n                        \"could not close log file %s: %m\", XLogFileNameP(t_thrd.xlog_cxt.ThisTimeLineID, recvSegNo))));\r\n    }\r\n    recvFile = -1;\r\n\r\n    LWLockRelease(WALWriteLock);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walrcvwriter.cpp",
		"name":"WalRcvXLogClose"
	},
	"XLogWalRcvWrite":{
		"body":"static void XLogWalRcvWrite(WalRcvCtlBlock* walrcb, char* buf, Size nbytes, XLogRecPtr recptr)\r\n{\r\n    int startoff;\r\n    int byteswritten;\r\n    int nRetCode = 0;\r\n    Size write_bytes = nbytes;\r\n\r\n    while (nbytes > 0) {\r\n        int segbytes;\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n\r\n        if (recvFile < 0 || !XLByteInSeg(recptr, recvSegNo)) {\r\n            bool use_existent = false;\r\n\r\n            /*\r\n             * fsync() and close current file before we switch to next one. We\r\n             * would otherwise have to reopen this file to fsync it later\r\n             */\r\n            if (recvFile >= 0) {\r\n                char xlogfname[MAXFNAMELEN];\r\n\r\n                /*\r\n                 * XLOG segment files will be re-read by recovery in startup\r\n                 * process soon, so we don't advise the OS to release cache\r\n                 * pages associated with the file like XLogFileClose() does.\r\n                 */\r\n                if (close(recvFile) != 0)\r\n                    ereport(PANIC,\r\n                        (errcode_for_file_access(),\r\n                            errmsg(\"could not close log file %s: %m\",\r\n                                XLogFileNameP(t_thrd.xlog_cxt.ThisTimeLineID, recvSegNo))));\r\n\r\n                /*\r\n                 * Create .done file forcibly to prevent the restored segment from\r\n                 * being archived again later.\r\n                 */\r\n                XLogFileName(xlogfname, recvFileTLI, recvSegNo);\r\n                XLogArchiveForceDone(xlogfname);\r\n            }\r\n            recvFile = -1;\r\n\r\n            /* Create/use new log file */\r\n            XLByteToSeg(recptr, recvSegNo);\r\n            use_existent = true;\r\n            recvFile = XLogFileInit(recvSegNo, &use_existent, true);\r\n            recvFileTLI = t_thrd.xlog_cxt.ThisTimeLineID;\r\n            recvOff = 0;\r\n        }\r\n\r\n        /* Calculate the start offset of the received logs */\r\n        startoff = recptr % XLogSegSize;\r\n\r\n        if (startoff + nbytes > XLogSegSize)\r\n            segbytes = XLogSegSize - startoff;\r\n        else\r\n            segbytes = nbytes;\r\n\r\n        /* Need to seek in the file? */\r\n        if (recvOff != (uint32)startoff) {\r\n            if (lseek(recvFile, (off_t)startoff, SEEK_SET) < 0)\r\n                ereport(PANIC,\r\n                    (errcode_for_file_access(),\r\n                        errmsg(\"could not seek in log file %s to offset %d: %m\",\r\n                            XLogFileNameP(t_thrd.xlog_cxt.ThisTimeLineID, recvSegNo),\r\n                            startoff)));\r\n            recvOff = startoff;\r\n        }\r\n\r\n        /* OK to write the logs */\r\n        errno = 0;\r\n\r\n        byteswritten = write(recvFile, buf, segbytes);\r\n        if (byteswritten <= 0) {\r\n            /* if write didn't set errno, assume no disk space */\r\n            if (errno == 0)\r\n                errno = ENOSPC;\r\n            ereport(PANIC,\r\n                (errcode_for_file_access(),\r\n                    errmsg(\"could not write to log file %s at offset %u, length %lu: %m\",\r\n                        XLogFileNameP(t_thrd.xlog_cxt.ThisTimeLineID, recvSegNo),\r\n                        recvOff,\r\n                        INT2ULONG(segbytes))));\r\n        }\r\n        if (unlikely(recvOff == (uint32)0 && segbytes >= (int)sizeof(XLogPageHeaderData) &&\r\n            ((XLogPageHeader)buf)->xlp_magic == XLOG_PAGE_MAGIC &&\r\n            (recvSegNo * XLogSegSize) != ((XLogPageHeader)buf)->xlp_pageaddr)) {\r\n            ereport(PANIC, (errmsg(\"invalid page addr, seg addr:%lu, buf page addr:%lu\",\r\n                recvSegNo * XLogSegSize, ((XLogPageHeader)buf)->xlp_pageaddr)));\r\n        }\r\n        /* Update state for write */\r\n        XLByteAdvance(recptr, byteswritten);\r\n\r\n        recvOff += byteswritten;\r\n        nbytes -= byteswritten;\r\n        buf += byteswritten;\r\n\r\n        issue_xlog_fsync(recvFile, recvSegNo);\r\n\r\n        t_thrd.walrcvwriter_cxt.walStreamWrite = recptr;\r\n\r\n        SpinLockAcquire(&walrcb->mutex);\r\n        walrcb->writePtr = walrcb->flushPtr = recptr;\r\n        SpinLockRelease(&walrcb->mutex);\r\n\r\n        /* Update shared-memory status */\r\n        SpinLockAcquire(&walrcv->mutex);\r\n        if (XLByteLT(walrcv->receivedUpto, t_thrd.walrcvwriter_cxt.walStreamWrite)) {\r\n            walrcv->latestChunkStart = walrcv->receivedUpto;\r\n            walrcv->receivedUpto = t_thrd.walrcvwriter_cxt.walStreamWrite;\r\n        }\r\n        SpinLockRelease(&walrcv->mutex);\r\n\r\n        /* Signal the startup process and walsender that new WAL has arrived */\r\n        WakeupRecovery();\r\n        if (AllowCascadeReplication())\r\n            WalSndWakeup();\r\n\r\n        /* Report XLOG streaming progress in PS display */\r\n        if (u_sess->attr.attr_common.update_process_title) {\r\n            char activitymsg[50];\r\n            nRetCode = snprintf_s(activitymsg,\r\n                sizeof(activitymsg),\r\n                sizeof(activitymsg) - 1,\r\n                \"walrcvwriter streaming %X/%X\",\r\n                (uint32)(t_thrd.walrcvwriter_cxt.walStreamWrite >> 32),\r\n                (uint32)t_thrd.walrcvwriter_cxt.walStreamWrite);\r\n            securec_check_ss(nRetCode, \"\\0\", \"\\0\");\r\n            set_ps_display(activitymsg, false);\r\n        }\r\n\r\n        ereport(DEBUG2,\r\n            (errmsg(\"write xlog done: start %X/%X %lu bytes\", (uint32)(recptr >> 32), (uint32)recptr, write_bytes)));\r\n    }\r\n}",
		"comment":"/*\r\n * Write XLOG data to disk.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walrcvwriter.cpp",
		"name":"XLogWalRcvWrite"
	},
	"emptyWalRcvWriterLatch":{
		"body":"static void emptyWalRcvWriterLatch(void)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    walrcv->walrcvWriterLatch = NULL;\r\n    walrcv->writerPid = 0;\r\n    SpinLockRelease(&walrcv->mutex);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walrcvwriter.cpp",
		"name":"emptyWalRcvWriterLatch"
	},
	"getCurrentWalRcvCtlBlock":{
		"body":"WalRcvCtlBlock* getCurrentWalRcvCtlBlock(void)\r\n{\r\n    WalRcvCtlBlock* walrcb = NULL;\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    walrcb = walrcv->walRcvCtlBlock;\r\n    SpinLockRelease(&walrcv->mutex);\r\n    return walrcb;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walrcvwriter.cpp",
		"name":"getCurrentWalRcvCtlBlock"
	},
	"reqShutdownHandler":{
		"body":"static void reqShutdownHandler(SIGNAL_ARGS)\r\n{\r\n    int saveErrno = errno;\r\n\r\n    t_thrd.walrcvwriter_cxt.shutdownRequested = true;\r\n    if (t_thrd.proc) {\r\n        SetLatch(&t_thrd.proc->procLatch);\r\n    }\r\n\r\n    errno = saveErrno;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walrcvwriter.cpp",
		"name":"reqShutdownHandler"
	},
	"setWalRcvWriterLatch":{
		"body":"static void setWalRcvWriterLatch(void)\r\n{\r\n    /* use volatile pointer to prevent code rearrangement */\r\n    volatile WalRcvData* walrcv = t_thrd.walreceiverfuncs_cxt.WalRcv;\r\n    SpinLockAcquire(&walrcv->mutex);\r\n    walrcv->walrcvWriterLatch = &t_thrd.proc->procLatch;\r\n    walrcv->writerPid = t_thrd.proc_cxt.MyProcPid;\r\n    SpinLockRelease(&walrcv->mutex);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walrcvwriter.cpp",
		"name":"setWalRcvWriterLatch"
	},
	"walRcvWrite":{
		"body":"int walRcvWrite(WalRcvCtlBlock* walrcb)\r\n{\r\n    int64 walfreeoffset;\r\n    int64 walwriteoffset;\r\n    char* walrecvbuf = NULL;\r\n    XLogRecPtr startptr;\r\n    int64 recBufferSize = g_instance.attr.attr_storage.WalReceiverBufSize * 1024;\r\n    int nbytes = 0;\r\n\r\n    if (walrcb == NULL)\r\n        return 0;\r\n\r\n    START_CRIT_SECTION();\r\n\r\n    LWLockAcquire(WALWriteLock, LW_EXCLUSIVE);\r\n    SpinLockAcquire(&walrcb->mutex);\r\n\r\n    if (walrcb->walFreeOffset == walrcb->walWriteOffset) {\r\n        if ((IsExtremeRtoReadWorkerRunning()) && (walrcb->walFreeOffset !=  walrcb->walReadOffset))\r\n        {\r\n            nbytes = 1;\r\n        }\r\n\r\n        SpinLockRelease(&walrcb->mutex);\r\n        LWLockRelease(WALWriteLock);\r\n\r\n        END_CRIT_SECTION();\r\n\r\n        return nbytes;\r\n    }\r\n    walfreeoffset = walrcb->walFreeOffset;\r\n    walwriteoffset = walrcb->walWriteOffset;\r\n    walrecvbuf = walrcb->walReceiverBuffer;\r\n    startptr = walrcb->walStart;\r\n    SpinLockRelease(&walrcb->mutex);\r\n\r\n    nbytes = (walfreeoffset < walwriteoffset) ? (recBufferSize - walwriteoffset) : (walfreeoffset - walwriteoffset);\r\n\r\n    XLogWalRcvWrite(walrcb, walrecvbuf + walwriteoffset, nbytes, startptr);\r\n    XLByteAdvance(startptr, nbytes);\r\n    ereport(\r\n        DEBUG5, (errmsg(\"walRcvWrite: write len:%d, at %u,%X\", nbytes, (uint32)(startptr >> 32), (uint32)startptr)));\r\n\r\n    SpinLockAcquire(&walrcb->mutex);\r\n    walrcb->walWriteOffset += nbytes;\r\n    walrcb->walStart = startptr;\r\n    if (IsExtremeRedo()) {\r\n        if (walrcb->walReadOffset == recBufferSize) {\r\n            walrcb->walReadOffset = 0;\r\n        }\r\n        if (walrcb->walFreeOffset == recBufferSize && walrcb->walReadOffset > 0) {\r\n            walrcb->walFreeOffset = 0;\r\n        }\r\n        if (walrcb->walWriteOffset == recBufferSize && (walrcb->walFreeOffset != recBufferSize)) {\r\n            walrcb->walWriteOffset = 0;\r\n            \r\n        }\r\n    } else {\r\n        if (walrcb->walWriteOffset == recBufferSize) {\r\n        walrcb->walWriteOffset = 0;\r\n        if (walrcb->walFreeOffset == recBufferSize)\r\n            walrcb->walFreeOffset = 0;\r\n        }\r\n    }\r\n    walfreeoffset = walrcb->walFreeOffset;\r\n    walwriteoffset = walrcb->walWriteOffset;\r\n    SpinLockRelease(&walrcb->mutex);\r\n\r\n    ereport(DEBUG5,\r\n        (errmsg(\"walRcvWrite: nbytes(%d),walfreeoffset(%ld),walwriteoffset(%ld),startptr(%u:%u)\",\r\n            nbytes,\r\n            walfreeoffset,\r\n            walwriteoffset,\r\n            (uint32)(startptr >> 32),\r\n            (uint32)startptr)));\r\n\r\n    LWLockRelease(WALWriteLock);\r\n\r\n    END_CRIT_SECTION();\r\n    /* the max lsn to be replayed */\r\n    g_instance.comm_cxt.predo_cxt.redoPf.local_max_lsn = startptr;\r\n    return nbytes;\r\n}",
		"comment":"/*\r\n * Flush the log to disk.\r\n *\r\n * If we're in the midst of dying, it's unwise to do anything that might throw\r\n * an error, so we skip sending a reply in that case.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walrcvwriter.cpp",
		"name":"walRcvWrite"
	},
	"walrcvWriterMain":{
		"body":"void walrcvWriterMain(void)\r\n{\r\n    sigjmp_buf localSigjmpBuf;\r\n    sigset_t oldSigMask;\r\n    MemoryContext walrcvWriterContext;\r\n\r\n    ereport(LOG, (errmsg(\"walrcvwriter thread started\")));\r\n    /*\r\n     * Reset some signals that are accepted by postmaster but not here\r\n     */\r\n    (void)gspqsignal(SIGHUP, walrcvWriterSigHupHandler);\r\n    (void)gspqsignal(SIGINT, SIG_IGN);\r\n    (void)gspqsignal(SIGTERM, reqShutdownHandler);\r\n    (void)gspqsignal(SIGQUIT, walrcvWriterQuickDie); /* hard crash time */\r\n    (void)gspqsignal(SIGALRM, SIG_IGN);\r\n    (void)gspqsignal(SIGPIPE, SIG_IGN);\r\n    (void)gspqsignal(SIGUSR1, SIG_IGN);\r\n    (void)gspqsignal(SIGUSR2, SIG_IGN);\r\n\r\n    /*\r\n     * Reset some signals that are accepted by postmaster but not here\r\n     */\r\n    (void)gspqsignal(SIGCHLD, SIG_DFL);\r\n    (void)gspqsignal(SIGTTIN, SIG_DFL);\r\n    (void)gspqsignal(SIGTTOU, SIG_DFL);\r\n    (void)gspqsignal(SIGCONT, SIG_DFL);\r\n    (void)gspqsignal(SIGWINCH, SIG_DFL);\r\n\r\n    /* We allow SIGQUIT (quickdie) at all times */\r\n    (void)sigdelset(&t_thrd.libpq_cxt.BlockSig, SIGQUIT);\r\n\r\n    on_shmem_exit(ShutdownWalRcvWriter, 0);\r\n\r\n    /*\r\n     * Create a resource owner to keep track of our resources (currently only\r\n     * buffer pins).\r\n     */\r\n    t_thrd.utils_cxt.CurrentResourceOwner = ResourceOwnerCreate(NULL, \"WalReceive Writer\");\r\n\r\n    /*\r\n     * Create a memory context that we will do all our work in.  We do this so\r\n     * that we can reset the context during error recovery and thereby avoid\r\n     * possible memory leaks.  Formerly this code just ran in\r\n     * t_thrd.top_mem_cxt, but resetting that would be a really bad idea.\r\n     */\r\n    walrcvWriterContext = AllocSetContextCreate(t_thrd.top_mem_cxt,\r\n        \"WalReceive Writer\",\r\n        ALLOCSET_DEFAULT_MINSIZE,\r\n        ALLOCSET_DEFAULT_INITSIZE,\r\n        ALLOCSET_DEFAULT_MAXSIZE);\r\n    (void)MemoryContextSwitchTo(walrcvWriterContext);\r\n\r\n    /* init the dummy standby data num to write */\r\n    if (dummyStandbyMode) {\r\n        InitWSDataNumOnDummyStandby();\r\n        t_thrd.walrcvwriter_cxt.ws_dummy_data_writer_file_num++;\r\n        ws_dummy_data_writer_file_offset = 0;\r\n    }\r\n\r\n    /*\r\n     * If an exception is encountered, processing resumes here.\r\n     *\r\n     * See notes in postgres.c about the design of this coding.\r\n     */\r\n    int curTryCounter = 0;\r\n    int* oldTryCounter = nullptr;\r\n    if (sigsetjmp(localSigjmpBuf, 1) != 0) {\r\n        gstrace_tryblock_exit(true, oldTryCounter);\r\n\r\n        // We need restore the signal mask of current thread\r\n        //\r\n        pthread_sigmask(SIG_SETMASK, &oldSigMask, NULL);\r\n\r\n        /* Since not using PG_TRY, must reset error stack by hand */\r\n        t_thrd.log_cxt.error_context_stack = NULL;\r\n\r\n        /* Prevent interrupts while cleaning up */\r\n        HOLD_INTERRUPTS();\r\n\r\n        /* Report the error to the server log */\r\n        EmitErrorReport();\r\n\r\n        /* abort async io, must before LWlock release */\r\n        AbortAsyncListIO();\r\n\r\n        /*\r\n         * These operations are really just a minimal subset of\r\n         * AbortTransaction().  We don't have very many resources to worry\r\n         * about in pagewriter, but we do have LWLocks, buffers, and temp files.\r\n         */\r\n        LWLockReleaseAll();\r\n        AbortBufferIO();\r\n        UnlockBuffers();\r\n        /* buffer pins are released here: */\r\n        ResourceOwnerRelease(t_thrd.utils_cxt.CurrentResourceOwner, RESOURCE_RELEASE_BEFORE_LOCKS, false, true);\r\n        /* we needn't bother with the other ResourceOwnerRelease phases */\r\n        AtEOXact_Buffers(false);\r\n        AtEOXact_Files();\r\n        AtEOXact_HashTables(false);\r\n\r\n        /*\r\n         * Now return to normal top-level context and clear ErrorContext for\r\n         * next time.\r\n         */\r\n        (void)MemoryContextSwitchTo(walrcvWriterContext);\r\n        FlushErrorState();\r\n\r\n        /* Flush any leaked data in the top-level context */\r\n        MemoryContextResetAndDeleteChildren(walrcvWriterContext);\r\n\r\n        /* Now we can allow interrupts again */\r\n        RESUME_INTERRUPTS();\r\n\r\n        /*\r\n         * Sleep at least 1 second after any error.  A write error is likely\r\n         * to be repeated, and we don't want to be filling the error logs as\r\n         * fast as we can.\r\n         */\r\n        pg_usleep(1000000L);\r\n\r\n        /*\r\n         * Close all open files after any error.  This is helpful on Windows,\r\n         * where holding deleted files open causes various strange errors.\r\n         * It's not clear we need it elsewhere, but shouldn't hurt.\r\n         */\r\n        smgrcloseall();\r\n    }\r\n    oldTryCounter = gstrace_tryblock_entry(&curTryCounter);\r\n\r\n    /* We can now handle ereport(ERROR) */\r\n    t_thrd.log_cxt.PG_exception_stack = &localSigjmpBuf;\r\n\r\n    /*\r\n     * Unblock signals (they were blocked when the postmaster forked us)\r\n     */\r\n    gs_signal_setmask(&t_thrd.libpq_cxt.UnBlockSig, NULL);\r\n    (void)gs_signal_unblock_sigusr2();\r\n\r\n    /*\r\n     * Use the recovery target timeline ID during recovery\r\n     */\r\n    if (!RecoveryInProgress())\r\n        ereport(FATAL, (errmsg(\"cannot continue WAL streaming, recovery has already ended\")));\r\n\r\n    t_thrd.xlog_cxt.ThisTimeLineID = GetRecoveryTargetTLI();\r\n\r\n    /*\r\n     * register procLatch to walrcv shared memory\r\n     */\r\n    setWalRcvWriterLatch();\r\n\r\n    t_thrd.walrcvwriter_cxt.walStreamWrite = GetXLogReplayRecPtr(NULL);\r\n\r\n    /*\r\n     * Loop forever\r\n     */\r\n    for (;;) {\r\n        int rc;\r\n\r\n        /* Clear any already-pending wakeups */\r\n        ResetLatch(&t_thrd.proc->procLatch);\r\n\r\n        if (t_thrd.walrcvwriter_cxt.gotSIGHUP) {\r\n            t_thrd.walrcvwriter_cxt.gotSIGHUP = false;\r\n            ProcessConfigFile(PGC_SIGHUP);\r\n        }\r\n\r\n        while (!t_thrd.walrcvwriter_cxt.shutdownRequested && WalDataRcvWrite() > 0)\r\n            ;\r\n\r\n        if (t_thrd.walrcvwriter_cxt.shutdownRequested) {\r\n            ereport(LOG, (errmsg(\"walrcvwriter thread shut down\")));\r\n            /*\r\n             * From here on, elog(ERROR) should end with exit(1), not send\r\n             * control back to the sigsetjmp block above\r\n             */\r\n            u_sess->attr.attr_common.ExitOnAnyError = true;\r\n            /* Normal exit from the pagewriter is here */\r\n            proc_exit(0); /* done */\r\n        }\r\n\r\n        rc = WaitLatch(&t_thrd.proc->procLatch, WL_LATCH_SET | WL_TIMEOUT | WL_POSTMASTER_DEATH, (long)1000 /* ms */);\r\n        if (rc & WL_POSTMASTER_DEATH) {\r\n            ereport(LOG, (errmsg(\"walrcvwriter thread shut down with code 1\")));\r\n            gs_thread_exit(1);\r\n        }\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walrcvwriter.cpp",
		"name":"walrcvWriterMain"
	},
	"walrcvWriterQuickDie":{
		"body":"static void walrcvWriterQuickDie(SIGNAL_ARGS)\r\n{\r\n    gs_signal_setmask(&t_thrd.libpq_cxt.BlockSig, NULL);\r\n\r\n    /*\r\n     * We DO NOT want to run proc_exit() callbacks -- we're here because\r\n     * shared memory may be corrupted, so we don't want to try to clean up our\r\n     * transaction.  Just nail the windows shut and get out of town.  Now that\r\n     * there's an atexit callback to prevent third-party code from breaking\r\n     * things by calling exit() directly, we have to reset the callbacks\r\n     * explicitly to make this work as intended.\r\n     */\r\n    on_exit_reset();\r\n\r\n    /*\r\n     * Note we do exit(2) not exit(0).    This is to force the postmaster into a\r\n     * system reset cycle if some idiot DBA sends a manual SIGQUIT to a random\r\n     * backend.  This is necessary precisely because we don't clean up our\r\n     * shared memory state.  (The \"dead man switch\" mechanism in pmsignal.c\r\n     * should ensure the postmaster sees this as a crash, too, but no harm in\r\n     * being doubly sure.)\r\n     */\r\n    gs_thread_exit(2);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walrcvwriter.cpp",
		"name":"walrcvWriterQuickDie"
	},
	"walrcvWriterSigHupHandler":{
		"body":"static void walrcvWriterSigHupHandler(SIGNAL_ARGS)\r\n{\r\n    int saveErrno = errno;\r\n\r\n    t_thrd.walrcvwriter_cxt.gotSIGHUP = true;\r\n    if (t_thrd.proc) {\r\n        SetLatch(&t_thrd.proc->procLatch);\r\n    }\r\n\r\n    errno = saveErrno;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\walrcvwriter.cpp",
		"name":"walrcvWriterSigHupHandler"
	}
}