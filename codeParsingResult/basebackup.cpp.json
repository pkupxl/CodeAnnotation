{
	"PerformMotCheckpointFetch":{
		"body":"void PerformMotCheckpointFetch()\r\n{\r\n    char* chkptDir = NULL;\r\n    char* workingDir = NULL;\r\n    char fullChkptDir[MAXPGPATH] = {0};\r\n    char ctrlFilePath[MAXPGPATH] = {0};\r\n    char cwd[MAXPGPATH] = {0};\r\n    const char* motControlFile = \"mot.ctrl\";\r\n    uint64_t id = 0;\r\n    int rc = 0;\r\n\r\n    MOTCheckpointFetchLock();\r\n    PG_ENSURE_ERROR_CLEANUP(mot_checkpoint_fetch_cleanup, (Datum)0);\r\n    {\r\n        id = MOTCheckpointGetId();\r\n        if (id == 0) {\r\n            break; /* no checkpoint exists */\r\n        }\r\n\r\n        if (getcwd(cwd, sizeof(cwd)) == NULL) {\r\n            ereport(ERROR,\r\n                    (errcode_for_file_access(),\r\n                        errmsg(\"could not get current work dir : %m\")));\r\n        }\r\n\r\n        chkptDir = MOTCheckpointFetchDirName();\r\n        if (chkptDir == NULL) {\r\n            ereport(ERROR,\r\n                    (errcode_for_file_access(),\r\n                        errmsg(\"could not get mot checkpoint dir : %m\")));\r\n        }\r\n\r\n        workingDir = MOTCheckpointFetchWorkingDir();\r\n        if (workingDir == NULL) {\r\n            ereport(ERROR,\r\n                    (errcode_for_file_access(),\r\n                        errmsg(\"could not get mot checkpoint working dir : %m\")));\r\n        }\r\n\r\n        if (strncmp(cwd, workingDir, strlen(workingDir) - 1) == 0) {\r\n            /* checkpoint resides on the working dir (default) */\r\n            rc = snprintf_s(fullChkptDir, sizeof(fullChkptDir), sizeof(fullChkptDir) - 1, \"./%s\", chkptDir);\r\n            securec_check_ss(rc, \"\", \"\");\r\n            rc = snprintf_s(ctrlFilePath, sizeof(ctrlFilePath), sizeof(ctrlFilePath) - 1, \"./%s\", motControlFile);\r\n            securec_check_ss(rc, \"\", \"\");\r\n        } else {\r\n            /* checkpoint directory is elsewhere */\r\n            rc = snprintf_s(\r\n                fullChkptDir, sizeof(fullChkptDir), sizeof(fullChkptDir) - 1, \"//%s%s\", workingDir, chkptDir);\r\n            securec_check_ss(rc, \"\", \"\");\r\n            rc = snprintf_s(\r\n                ctrlFilePath, sizeof(ctrlFilePath), sizeof(ctrlFilePath) - 1, \"//%s%s\", workingDir, motControlFile);\r\n            securec_check_ss(rc, \"\", \"\");\r\n        }\r\n        securec_check_ss(rc, \"\", \"\");\r\n        pfree(chkptDir);\r\n        pfree(workingDir);\r\n\r\n        /* send mot header */\r\n        SendMotCheckpointHeader(fullChkptDir);\r\n        if (chkptDir != NULL) {\r\n            StringInfoData buf;\r\n\r\n            /* send mot.ctrl file */\r\n            pq_beginmessage(&buf, 'H');\r\n            pq_sendbyte(&buf, 0);  /* overall format */\r\n            pq_sendint16(&buf, 0); /* natts */\r\n            pq_endmessage_noblock(&buf);\r\n\r\n            struct stat statbuf;\r\n            if (lstat(ctrlFilePath, &statbuf) != 0) {\r\n                ereport(ERROR,\r\n                    (errcode_for_file_access(),\r\n                        errmsg(\"could not stat mot control file \\\"%s\\\": %m\", ctrlFilePath)));\r\n            }\r\n\r\n            sendFile((char*)ctrlFilePath, (char*)ctrlFilePath, &statbuf, false);\r\n\r\n            /* send the checkpoint dir */\r\n            sendDir(fullChkptDir, 1, false, NIL, false);\r\n\r\n            /* CopyDone */\r\n            pq_putemptymessage_noblock('c');\r\n        }\r\n    }\r\n    PG_END_ENSURE_ERROR_CLEANUP(mot_checkpoint_fetch_cleanup, (Datum)0);\r\n    mot_checkpoint_fetch_cleanup(0, (Datum)0);\r\n}",
		"comment":"/*\r\n * Sends the current checkpoint to the client.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"PerformMotCheckpointFetch"
	},
	"SendBackupHeader":{
		"body":"static void SendBackupHeader(List* tablespaces)\r\n{\r\n    StringInfoData buf;\r\n    ListCell* lc = NULL;\r\n\r\n    /* Construct and send the directory information */\r\n    pq_beginmessage(&buf, 'T'); /* RowDescription */\r\n    pq_sendint16(&buf, 4);      /* 4 fields */\r\n\r\n    /* First field - spcoid */\r\n    pq_sendstring(&buf, \"spcoid\");\r\n    pq_sendint32(&buf, 0);      /* table oid */\r\n    pq_sendint16(&buf, 0);      /* attnum */\r\n    pq_sendint32(&buf, OIDOID); /* type oid */\r\n    pq_sendint16(&buf, 4);      /* typlen */\r\n    pq_sendint32(&buf, 0);      /* typmod */\r\n    pq_sendint16(&buf, 0);      /* format code */\r\n\r\n    /* Second field - spcpath */\r\n    pq_sendstring(&buf, \"spclocation\");\r\n    pq_sendint32(&buf, 0);\r\n    pq_sendint16(&buf, 0);\r\n    pq_sendint32(&buf, TEXTOID);\r\n    pq_sendint16(&buf, UINT16_MAX);\r\n    pq_sendint32(&buf, 0);\r\n    pq_sendint16(&buf, 0);\r\n\r\n    /* Third field - size */\r\n    pq_sendstring(&buf, \"size\");\r\n    pq_sendint32(&buf, 0);\r\n    pq_sendint16(&buf, 0);\r\n    pq_sendint32(&buf, INT8OID);\r\n    pq_sendint16(&buf, 8);\r\n    pq_sendint32(&buf, 0);\r\n    pq_sendint16(&buf, 0);\r\n\r\n    /* Third field - size */\r\n    pq_sendstring(&buf, \"relative\");\r\n    pq_sendint32(&buf, 0);\r\n    pq_sendint16(&buf, 0);\r\n    pq_sendint32(&buf, INT8OID);\r\n    pq_sendint16(&buf, 8);\r\n    pq_sendint32(&buf, 0);\r\n    pq_sendint16(&buf, 0);\r\n\r\n    pq_endmessage_noblock(&buf);\r\n\r\n    foreach (lc, tablespaces) {\r\n        tablespaceinfo* ti = (tablespaceinfo*)lfirst(lc);\r\n\r\n        /* Send one datarow message */\r\n        pq_beginmessage(&buf, 'D');\r\n        pq_sendint16(&buf, 4); /* number of columns */\r\n        if (ti->path == NULL) {\r\n            /* Length = -1 ==> NULL */\r\n            pq_sendint32(&buf, UINT32_MAX);\r\n            pq_sendint32(&buf, UINT32_MAX);\r\n        } else {\r\n            pq_sendint32(&buf, strlen(ti->oid)); /* length */\r\n            pq_sendbytes(&buf, ti->oid, strlen(ti->oid));\r\n\r\n            char* path = ti->path;\r\n            if (ti->relativePath) {\r\n                path = ti->relativePath;\r\n                Assert(strlen(path) != strlen(ti->path));\r\n            }\r\n            pq_sendint32(&buf, strlen(path)); /* length */\r\n            pq_sendbytes(&buf, path, strlen(path));\r\n        }\r\n        if (ti->size >= 0)\r\n            send_int8_string(&buf, ti->size / 1024);\r\n        else\r\n            pq_sendint32(&buf, UINT32_MAX); /* NULL */\r\n\r\n        /* send last column: relativePath flag */\r\n        if (ti->relativePath)\r\n            send_int8_string(&buf, 1);\r\n        else\r\n            pq_sendint32(&buf, UINT32_MAX); /* NULL */\r\n\r\n        pq_endmessage_noblock(&buf);\r\n    }\r\n\r\n    /* Send a CommandComplete message */\r\n    pq_puttextmessage_noblock('C', \"SELECT\");\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"SendBackupHeader"
	},
	"SendBaseBackup":{
		"body":"void SendBaseBackup(BaseBackupCmd* cmd)\r\n{\r\n    DIR* dir = NULL;\r\n    MemoryContext backup_context;\r\n    MemoryContext old_context;\r\n    basebackup_options opt;\r\n\r\n    parse_basebackup_options(cmd->options, &opt);\r\n\r\n    backup_context = AllocSetContextCreate(CurrentMemoryContext,\r\n        \"Streaming base backup context\",\r\n        ALLOCSET_DEFAULT_MINSIZE,\r\n        ALLOCSET_DEFAULT_INITSIZE,\r\n        ALLOCSET_DEFAULT_MAXSIZE);\r\n    old_context = MemoryContextSwitchTo(backup_context);\r\n\r\n    WalSndSetState(WALSNDSTATE_BACKUP);\r\n\r\n    if (u_sess->attr.attr_common.update_process_title) {\r\n        char activitymsg[50];\r\n        int rc = 0;\r\n\r\n        rc = snprintf_s(activitymsg, sizeof(activitymsg), sizeof(activitymsg) - 1, \"sending backup \\\"%s\\\"\", opt.label);\r\n        securec_check_ss(rc, \"\", \"\");\r\n\r\n        set_ps_display(activitymsg, false);\r\n    }\r\n\r\n    /* Make sure we can open the directory with tablespaces in it */\r\n    dir = AllocateDir(\"pg_tblspc\");\r\n    if (dir == NULL) {\r\n        ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not open directory \\\"%s\\\": %m\", \"pg_tblspc\")));\r\n        return;\r\n    }\r\n\r\n    /* read xlog location ,if xlog is a link ,send the link to client */\r\n    send_xlog_location();\r\n\r\n    perform_base_backup(&opt, dir);\r\n\r\n    FreeDir(dir);\r\n\r\n    MemoryContextSwitchTo(old_context);\r\n    MemoryContextDelete(backup_context);\r\n}",
		"comment":"/*\r\n * SendBaseBackup() - send a complete base backup.\r\n *\r\n * The function will put the system into backup mode like pg_start_backup()\r\n * does, so that the backup is consistent even though we read directly from\r\n * the filesystem, bypassing the buffer cache.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"SendBaseBackup"
	},
	"SendMotCheckpointHeader":{
		"body":"static void SendMotCheckpointHeader(const char* path)\r\n{\r\n    StringInfoData buf;\r\n\r\n    /* Construct and send the directory information */\r\n    pq_beginmessage(&buf, 'T'); /* RowDescription */\r\n    pq_sendint16(&buf, 1);      /* nfields */\r\n\r\n    /* First field - checkpoint path */\r\n    pq_sendstring(&buf, \"chkptloc\");\r\n    pq_sendint32(&buf, 0);\r\n    pq_sendint16(&buf, 0);\r\n    pq_sendint32(&buf, TEXTOID);\r\n    pq_sendint16(&buf, UINT16_MAX);\r\n    pq_sendint32(&buf, 0);\r\n    pq_sendint16(&buf, 0);\r\n    pq_endmessage_noblock(&buf);\r\n\r\n    if (path != NULL) {\r\n        /* Send one datarow message */\r\n        pq_beginmessage(&buf, 'D');\r\n        pq_sendint16(&buf, 1); /* number of columns */\r\n        pq_sendint32(&buf, strlen(path)); /* length */\r\n        pq_sendbytes(&buf, path, strlen(path));\r\n        pq_endmessage_noblock(&buf);\r\n    }\r\n\r\n    /* Send a CommandComplete message */\r\n    pq_puttextmessage_noblock('C', \"SELECT\");\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"SendMotCheckpointHeader"
	},
	"SendXlogRecPtrResult":{
		"body":"static void SendXlogRecPtrResult(XLogRecPtr ptr)\r\n{\r\n    StringInfoData buf;\r\n    char str[MAXFNAMELEN];\r\n    int nRet = 0;\r\n\r\n    nRet = snprintf_s(str, MAXFNAMELEN, MAXFNAMELEN - 1, \"%X/%X\", (uint32)(ptr >> 32), (uint32)ptr);\r\n    securec_check_ss(nRet, \"\", \"\");\r\n\r\n    pq_beginmessage(&buf, 'T'); /* RowDescription */\r\n    pq_sendint16(&buf, 1);      /* 1 field */\r\n\r\n    /* Field header */\r\n    pq_sendstring(&buf, \"recptr\");\r\n    pq_sendint32(&buf, 0);       /* table oid */\r\n    pq_sendint16(&buf, 0);       /* attnum */\r\n    pq_sendint32(&buf, TEXTOID); /* type oid */\r\n    pq_sendint16(&buf, UINT16_MAX);\r\n    pq_sendint32(&buf, 0);\r\n    pq_sendint16(&buf, 0);\r\n    pq_endmessage_noblock(&buf);\r\n\r\n    /* Data row */\r\n    pq_beginmessage(&buf, 'D');\r\n    pq_sendint16(&buf, 1);           /* number of columns */\r\n    pq_sendint32(&buf, strlen(str)); /* length */\r\n    pq_sendbytes(&buf, str, strlen(str));\r\n    pq_endmessage_noblock(&buf);\r\n\r\n    /* Send a CommandComplete message */\r\n    pq_puttextmessage_noblock('C', \"SELECT\");\r\n}",
		"comment":"/*\r\n * Send a single resultset containing just a single\r\n * XlogRecPtr record (in text format)\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"SendXlogRecPtrResult"
	},
	"_tarWriteHeader":{
		"body":"static void _tarWriteHeader(const char* filename, const char* linktarget, struct stat* statbuf)\r\n{\r\n    char h[BUILD_PATH_LEN];\r\n    errno_t rc = EOK;\r\n    int nRet = 0;\r\n    /*\r\n     * Note: most of the fields in a tar header are not supposed to be\r\n     * null-terminated.  We use sprintf, which will write a null after the\r\n     * required bytes; that null goes into the first byte of the next field.\r\n     * This is okay as long as we fill the fields in order.\r\n     */\r\n    rc = memset_s(h, sizeof(h), 0, sizeof(h));\r\n    securec_check(rc, \"\", \"\");\r\n\r\n    /* Name 1024 */\r\n    nRet = sprintf_s(&h[0], BUILD_PATH_LEN, \"%.1023s\", filename);\r\n    securec_check_ss(nRet, \"\", \"\");\r\n\r\n    if (linktarget != NULL || S_ISDIR(statbuf->st_mode)) {\r\n        /*\r\n         * We only support symbolic links to directories, and this is\r\n         * indicated in the tar format by adding a slash at the end of the\r\n         * name, the same as for regular directories.\r\n         */\r\n        h[strlen(filename)] = '/';\r\n        h[strlen(filename) + 1] = '\\0';\r\n    }\r\n\r\n    /* Mode 8 */\r\n    nRet = sprintf_s(&h[1024], BUILD_PATH_LEN - 1024, \"%07o \", statbuf->st_mode);\r\n    securec_check_ss(nRet, \"\", \"\");\r\n\r\n    /* File size 12 - 11 digits, 1 space, no NUL */\r\n    if (linktarget != NULL || S_ISDIR(statbuf->st_mode))\r\n        /* Symbolic link or directory has size zero */\r\n        print_val(&h[1048], 0, 8, 11);\r\n    else\r\n        print_val(&h[1048], statbuf->st_size, 8, 11);\r\n\r\n    if (linktarget != NULL) {\r\n        /* Type - Symbolic link */\r\n        if (0 == strncmp(linktarget, t_thrd.proc_cxt.DataDir, strlen(t_thrd.proc_cxt.DataDir))) {\r\n            /* Symbolic link for relative location tablespace. */\r\n            nRet = sprintf_s(&h[1080], BUILD_PATH_LEN - 1080, \"3\");\r\n            securec_check_ss(nRet, \"\", \"\");\r\n\r\n            nRet =\r\n                sprintf_s(&h[1081], BUILD_PATH_LEN - 1081, \"%.1023s\", linktarget + strlen(t_thrd.proc_cxt.DataDir) + 1);\r\n            securec_check_ss(nRet, \"\", \"\");\r\n        } else {\r\n            nRet = sprintf_s(&h[1080], BUILD_PATH_LEN - 1080, \"2\");\r\n            securec_check_ss(nRet, \"\", \"\");\r\n\r\n            nRet = sprintf_s(&h[1081], BUILD_PATH_LEN - 1081, \"%.1023s\", linktarget);\r\n            securec_check_ss(nRet, \"\", \"\");\r\n        }\r\n    } else if (S_ISDIR(statbuf->st_mode)) {\r\n        /* Type - directory */\r\n        nRet = sprintf_s(&h[1080], BUILD_PATH_LEN - 1080, \"5\");\r\n        securec_check_ss(nRet, \"\", \"\");\r\n    } else {\r\n        /* Type - regular file */\r\n        nRet = sprintf_s(&h[1080], BUILD_PATH_LEN - 1080, \"0\");\r\n        securec_check_ss(nRet, \"\", \"\");\r\n    }\r\n\r\n    /* Link tag 100 (NULL) */\r\n    /* Now send the completed header. */\r\n    (void)pq_putmessage_noblock('d', h, BUILD_PATH_LEN);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"_tarWriteHeader"
	},
	"base_backup_cleanup":{
		"body":"static void base_backup_cleanup(int code, Datum arg)\r\n{\r\n    do_pg_abort_backup();\r\n}",
		"comment":"/*\r\n * Called when ERROR or FATAL happens in perform_base_backup() after\r\n * we have started the backup - make sure we end it!\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"base_backup_cleanup"
	},
	"check_abs_tblspac_path":{
		"body":"bool check_abs_tblspac_path(const char* fname, int* segNo)\r\n{\r\n    char buf[FILE_NAME_MAX_LEN] = {0};\r\n    RelFileNode rnode;\r\n    int columnid = 0;\r\n    int nmatch;\r\n\r\n    rnode.spcNode = InvalidOid;\r\n    rnode.dbNode = InvalidOid;\r\n    rnode.relNode = InvalidOid;\r\n    nmatch = sscanf_s(fname,\r\n        \"PG_9.2_201611171_%[^/]/%u/%u_C%d.%u\",\r\n        buf,\r\n        sizeof(buf),\r\n        &rnode.dbNode,\r\n        &rnode.relNode,\r\n        &columnid,\r\n        segNo);\r\n    if (nmatch == MATCH_SIX) {\r\n        return false;\r\n    }\r\n    nmatch = sscanf_s(fname, \"PG_9.2_201611171_%[^/]/%u/%u_b%d.%u\",\r\n                buf, sizeof(buf), &rnode.dbNode, &rnode.relNode, &rnode.bucketNode, segNo);\r\n    if (nmatch == MATCH_FIVE || nmatch == MATCH_SIX) {\r\n        return true;\r\n    }\r\n\r\n    nmatch = sscanf_s(fname, \"PG_9.2_201611171_%[^/]/%u/%u_b%d_fsm.%u\",\r\n                buf, sizeof(buf), &rnode.dbNode, &rnode.relNode, &rnode.bucketNode, segNo);\r\n    if (nmatch == MATCH_FIVE || nmatch == MATCH_SIX) {\r\n        return true;\r\n    }\r\n\r\n    nmatch = sscanf_s(fname, \"PG_9.2_201611171_%[^/]/%u/%u_b%d_vm.%u\",\r\n                buf, sizeof(buf), &rnode.dbNode, &rnode.relNode, &rnode.bucketNode, segNo);\r\n    if (nmatch == MATCH_FIVE || nmatch == MATCH_SIX) {\r\n        return true;\r\n    }\r\n\r\n    nmatch = sscanf_s(fname, \"PG_9.2_201611171_%[^/]/%u/%u.%u\", buf, sizeof(buf), &rnode.dbNode, &rnode.relNode, segNo);\r\n    if (nmatch == MATCH_FOUR || nmatch == MATCH_FIVE) {\r\n        return true;\r\n    }\r\n\r\n    nmatch =\r\n        sscanf_s(fname, \"PG_9.2_201611171_%[^/]/%u/%u_fsm.%u\", buf, sizeof(buf), &rnode.dbNode, &rnode.relNode, segNo);\r\n    if (nmatch == MATCH_FOUR || nmatch == MATCH_FIVE) {\r\n        return true;\r\n    }\r\n\r\n    nmatch =\r\n        sscanf_s(fname, \"PG_9.2_201611171_%[^/]/%u/%u_vm.%u\", buf, sizeof(buf), &rnode.dbNode, &rnode.relNode, segNo);\r\n    if (nmatch == MATCH_FOUR || nmatch == MATCH_FIVE) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"check_abs_tblspac_path"
	},
	"check_base_path":{
		"body":"bool check_base_path(const char* fname, int* segNo)\r\n{\r\n    RelFileNode rnode;\r\n    int columnid = 0;\r\n    int nmatch;\r\n\r\n    rnode.spcNode = InvalidOid;\r\n    rnode.dbNode = InvalidOid;\r\n    rnode.relNode = InvalidOid;\r\n\r\n    nmatch = sscanf_s(fname, \"base/%u/%u_C%d.%u\", &rnode.dbNode, &rnode.relNode, &columnid, segNo);\r\n    if (nmatch == MATCH_FOUR) {\r\n        return false;\r\n    }\r\n    nmatch = sscanf_s(fname, \"base/%u/%u_b%d.%u\",\r\n                    &rnode.dbNode, &rnode.relNode, &rnode.bucketNode, segNo);\r\n    if (nmatch == MATCH_THREE || nmatch == MATCH_FOUR) {\r\n        return true;\r\n    }\r\n\r\n    nmatch = sscanf_s(fname, \"base/%u/%u_b%d_vm.%u\",\r\n                    &rnode.dbNode, &rnode.relNode, &rnode.bucketNode, segNo);\r\n    if (nmatch == MATCH_THREE || nmatch == MATCH_FOUR) {\r\n        return true;\r\n    }\r\n    nmatch = sscanf_s(fname, \"base/%u/%u_b%d_fsm.%u\",\r\n                    &rnode.dbNode, &rnode.relNode, &rnode.bucketNode, segNo);\r\n    if (nmatch == MATCH_THREE || nmatch == MATCH_FOUR) {\r\n        return true;\r\n    }\r\n\r\n    nmatch = sscanf_s(fname, \"base/%u/%u.%u\", &rnode.dbNode, &rnode.relNode, segNo);\r\n    if (nmatch == MATCH_TWO || nmatch == MATCH_THREE) {\r\n        return true;\r\n    }\r\n\r\n    nmatch = sscanf_s(fname, \"base/%u/%u_vm.%u\", &rnode.dbNode, &rnode.relNode, segNo);\r\n    if (nmatch == MATCH_TWO || nmatch == MATCH_THREE) {\r\n        return true;\r\n    }\r\n    nmatch = sscanf_s(fname, \"base/%u/%u_fsm.%u\", &rnode.dbNode, &rnode.relNode, segNo);\r\n    if (nmatch == MATCH_TWO || nmatch == MATCH_THREE) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"check_base_path"
	},
	"check_rel_tblspac_path":{
		"body":"bool check_rel_tblspac_path(const char* fname, int* segNo)\r\n{\r\n    char buf[FILE_NAME_MAX_LEN] = {0};\r\n    RelFileNode rnode;\r\n    int columnid = 0;\r\n    int nmatch;\r\n\r\n    rnode.spcNode = InvalidOid;\r\n    rnode.dbNode = InvalidOid;\r\n    rnode.relNode = InvalidOid;\r\n    nmatch = sscanf_s(fname,\r\n        \"pg_tblspc/%u/%[^/]/%u/%u_C%d.%u\",\r\n        &rnode.spcNode,\r\n        buf,\r\n        sizeof(buf),\r\n        &rnode.dbNode,\r\n        &rnode.relNode,\r\n        &columnid,\r\n        segNo);\r\n    if (nmatch == MATCH_SIX) {\r\n        return false;\r\n    }\r\n\r\n    nmatch = sscanf_s(fname, \"pg_tblspc/%u/%[^/]/%u/%u_b%d.%u\",\r\n                 &rnode.spcNode, buf, sizeof(buf), &rnode.dbNode, &rnode.relNode, &rnode.bucketNode, segNo);\r\n    if (nmatch == MATCH_FIVE || nmatch == MATCH_SIX) {\r\n        return true;\r\n    }\r\n    \r\n    nmatch = sscanf_s(fname, \"pg_tblspc/%u/%[^/]/%u/%u_b%d_fsm.%u\",\r\n                &rnode.spcNode, buf, sizeof(buf), &rnode.dbNode, &rnode.relNode, &rnode.bucketNode, segNo);\r\n    if (nmatch == MATCH_FIVE || nmatch == MATCH_SIX) {\r\n        return true;\r\n    }\r\n    \r\n    nmatch = sscanf_s(fname, \"pg_tblspc/%u/%[^/]/%u/%u_b%d_vm.%u\",\r\n                &rnode.spcNode, buf, sizeof(buf), &rnode.dbNode, &rnode.relNode, &rnode.bucketNode, segNo);\r\n    if (nmatch == MATCH_FIVE || nmatch == MATCH_SIX) {\r\n        return true;\r\n    }\r\n\r\n    nmatch = sscanf_s(\r\n        fname, \"pg_tblspc/%u/%[^/]/%u/%u.%u\", &rnode.spcNode, buf, sizeof(buf), &rnode.dbNode, &rnode.relNode, segNo);\r\n    if (nmatch == MATCH_FOUR || nmatch == MATCH_FIVE) {\r\n        return true;\r\n    }\r\n\r\n    nmatch = sscanf_s(fname,\r\n        \"pg_tblspc/%u/%[^/]/%u/%u_fsm.%u\",\r\n        &rnode.spcNode,\r\n        buf,\r\n        sizeof(buf),\r\n        &rnode.dbNode,\r\n        &rnode.relNode,\r\n        segNo);\r\n    if (nmatch == MATCH_FOUR || nmatch == MATCH_FIVE) {\r\n        return true;\r\n    }\r\n\r\n    nmatch = sscanf_s(fname,\r\n        \"pg_tblspc/%u/%[^/]/%u/%u_vm.%u\",\r\n        &rnode.spcNode,\r\n        buf,\r\n        sizeof(buf),\r\n        &rnode.dbNode,\r\n        &rnode.relNode,\r\n        segNo);\r\n    if (nmatch == MATCH_FOUR || nmatch == MATCH_FIVE) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"check_rel_tblspac_path"
	},
	"is_row_data_file":{
		"body":"bool is_row_data_file(const char* path, int* segNo)\r\n{\r\n    char* fname = NULL;\r\n    RelFileNode rnode;\r\n    int nmatch = 0;\r\n\r\n    rnode.spcNode = InvalidOid;\r\n    rnode.dbNode = InvalidOid;\r\n    rnode.relNode = InvalidOid;\r\n\r\n    if (strstr(path, \"global/\") == NULL && strstr(path, \"base/\") == NULL && strstr(path, \"pg_tblspc/\") == NULL &&\r\n        strstr(path, \"PG_9.2_201611171\") == NULL) {\r\n        return false;\r\n    }\r\n\r\n    if ((fname = strstr((char*)path, \"global/\")) != NULL) {\r\n        nmatch = sscanf_s(fname, \"global/%u.%u\", &rnode.relNode, segNo);\r\n        if (nmatch == MATCH_ONE || nmatch == MATCH_TWO) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    } else if ((fname = strstr((char*)path, \"base/\")) != NULL) {\r\n        return check_base_path(fname, segNo);\r\n    } else if ((fname = strstr((char*)path, \"pg_tblspc/\")) != NULL) {\r\n        return check_rel_tblspac_path(fname, segNo);\r\n    } else if ((fname = strstr((char*)path, \"PG_9.2_201611171\")) != NULL) {\r\n        return check_abs_tblspac_path(fname, segNo);\r\n    }\r\n    return false;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"is_row_data_file"
	},
	"mot_checkpoint_fetch_cleanup":{
		"body":"static void mot_checkpoint_fetch_cleanup(int code, Datum arg)\r\n{\r\n    MOTCheckpointFetchUnlock();\r\n}",
		"comment":"/*\r\n * Called when ERROR or FATAL happens in PerformMotCheckpointFetch() after\r\n * we have started the operation - make sure we end it!\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"mot_checkpoint_fetch_cleanup"
	},
	"parse_basebackup_options":{
		"body":"static void parse_basebackup_options(List* options, basebackup_options* opt)\r\n{\r\n    ListCell* lopt = NULL;\r\n    bool o_label = false;\r\n    bool o_progress = false;\r\n    bool o_fast = false;\r\n    bool o_nowait = false;\r\n    bool o_wal = false;\r\n    errno_t rc = 0;\r\n\r\n    rc = memset_s(opt, sizeof(*opt), 0, sizeof(*opt));\r\n    securec_check(rc, \"\", \"\");\r\n    foreach (lopt, options) {\r\n        DefElem* defel = (DefElem*)lfirst(lopt);\r\n\r\n        if (strcmp(defel->defname, \"label\") == 0) {\r\n            if (o_label)\r\n                ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg(\"duplicate option \\\"%s\\\"\", defel->defname)));\r\n            opt->label = strVal(defel->arg);\r\n            o_label = true;\r\n        } else if (strcmp(defel->defname, \"progress\") == 0) {\r\n            if (o_progress)\r\n                ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg(\"duplicate option \\\"%s\\\"\", defel->defname)));\r\n            opt->progress = true;\r\n            o_progress = true;\r\n        } else if (strcmp(defel->defname, \"fast\") == 0) {\r\n            if (o_fast)\r\n                ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg(\"duplicate option \\\"%s\\\"\", defel->defname)));\r\n            opt->fastcheckpoint = true;\r\n            o_fast = true;\r\n        } else if (strcmp(defel->defname, \"nowait\") == 0) {\r\n            if (o_nowait)\r\n                ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg(\"duplicate option \\\"%s\\\"\", defel->defname)));\r\n            opt->nowait = true;\r\n            o_nowait = true;\r\n        } else if (strcmp(defel->defname, \"wal\") == 0) {\r\n            if (o_wal)\r\n                ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg(\"duplicate option \\\"%s\\\"\", defel->defname)));\r\n            opt->includewal = true;\r\n            o_wal = true;\r\n        } else\r\n            ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg(\"option \\\"%s\\\" not recognized\", defel->defname)));\r\n    }\r\n    if (opt->label == NULL)\r\n        opt->label = \"base backup\";\r\n}",
		"comment":"/*\r\n * Parse the base backup options passed down by the parser\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"parse_basebackup_options"
	},
	"perform_base_backup":{
		"body":"static void perform_base_backup(basebackup_options* opt, DIR* tblspcdir)\r\n{\r\n    XLogRecPtr startptr;\r\n    XLogRecPtr endptr;\r\n    XLogRecPtr minlsn;\r\n    char* labelfile = NULL;\r\n    int datadirpathlen;\r\n\r\n    datadirpathlen = strlen(t_thrd.proc_cxt.DataDir);\r\n\r\n    startptr = do_pg_start_backup(opt->label, opt->fastcheckpoint, &labelfile);\r\n    /* Get the slot minimum LSN */\r\n    ReplicationSlotsComputeRequiredXmin(false);\r\n    ReplicationSlotsComputeRequiredLSN(NULL);\r\n\r\n    minlsn = XLogGetReplicationSlotMinimumLSNByOther();\r\n    if (!XLByteEQ(minlsn, InvalidXLogRecPtr) && (minlsn < startptr)) {\r\n        /* If xlog file has been recycled, don't use this minlsn */\r\n        if (XlogFileIsExisted(t_thrd.proc_cxt.DataDir, minlsn, DEFAULT_TIMELINE_ID) == true) {\r\n            startptr = minlsn;\r\n        }\r\n    }\r\n    LWLockAcquire(FullBuildXlogCopyStartPtrLock, LW_EXCLUSIVE);\r\n    XlogCopyStartPtr = startptr;\r\n    LWLockRelease(FullBuildXlogCopyStartPtrLock);\r\n    ereport(INFO,\r\n        (errmsg(\"The starting position of the xlog copy of the full build is: %X/%X. The slot minimum LSN is: %X/%X.\",\r\n            (uint32)(startptr >> 32),\r\n            (uint32)startptr,\r\n            (uint32)(minlsn >> 32),\r\n            (uint32)minlsn)));\r\n    SendXlogRecPtrResult(startptr);\r\n\r\n    PG_ENSURE_ERROR_CLEANUP(base_backup_cleanup, (Datum)0);\r\n    {\r\n        List* tablespaces = NIL;\r\n        ListCell* lc = NULL;\r\n        struct dirent* de;\r\n        tablespaceinfo* ti = NULL;\r\n\r\n        /* Collect information about all tablespaces */\r\n        while ((de = ReadDir(tblspcdir, \"pg_tblspc\")) != NULL) {\r\n            char fullpath[MAXPGPATH];\r\n            char linkpath[MAXPGPATH];\r\n            char* relpath = NULL;\r\n            int rllen;\r\n            errno_t errorno = EOK;\r\n            int nRet = 0;\r\n\r\n            errorno = memset_s(fullpath, MAXPGPATH, '\\0', MAXPGPATH);\r\n            securec_check(errorno, \"\", \"\");\r\n\r\n            errorno = memset_s(linkpath, MAXPGPATH, '\\0', MAXPGPATH);\r\n            securec_check(errorno, \"\", \"\");\r\n\r\n            /* Skip special stuff */\r\n            if (strcmp(de->d_name, \".\") == 0 || strcmp(de->d_name, \"..\") == 0)\r\n                continue;\r\n\r\n            nRet = snprintf_s(fullpath, MAXPGPATH, MAXPGPATH - 1, \"pg_tblspc/%s\", de->d_name);\r\n            securec_check_ss(nRet, \"\", \"\");\r\n\r\n#if defined(HAVE_READLINK) || defined(WIN32)\r\n            rllen = readlink(fullpath, linkpath, sizeof(linkpath));\r\n            if (rllen < 0) {\r\n                ereport(WARNING, (errmsg(\"could not read symbolic link \\\"%s\\\": %m\", fullpath)));\r\n                continue;\r\n            } else if (rllen >= (int)sizeof(linkpath)) {\r\n                ereport(WARNING, (errmsg(\"symbolic link \\\"%s\\\" target is too long\", fullpath)));\r\n                continue;\r\n            }\r\n            linkpath[rllen] = '\\0';\r\n\r\n            /*\r\n             * Relpath holds the relative path of the tablespace directory\r\n             * when it's located within PGDATA, or NULL if it's located\r\n             * elsewhere.\r\n             */\r\n            if (rllen > datadirpathlen && strncmp(linkpath, t_thrd.proc_cxt.DataDir, datadirpathlen) == 0 &&\r\n                IS_DIR_SEP(linkpath[datadirpathlen]))\r\n                relpath = linkpath + datadirpathlen + 1;\r\n\r\n            ti = (tablespaceinfo*)palloc(sizeof(tablespaceinfo));\r\n            ti->oid = pstrdup(de->d_name);\r\n            ti->path = pstrdup(linkpath);\r\n            ti->relativePath = relpath ? pstrdup(relpath) : NULL;\r\n            ti->size = opt->progress ? sendTablespace(fullpath, true) : -1;\r\n            tablespaces = lappend(tablespaces, ti);\r\n#else\r\n\r\n            /*\r\n             * If the platform does not have symbolic links, it should not be\r\n             * possible to have tablespaces - clearly somebody else created\r\n             * them. Warn about it and ignore.\r\n             */\r\n            ereport(WARNING,\r\n                (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"tablespaces are not supported on this platform\")));\r\n#endif\r\n        }\r\n\r\n        /* Add a node for the base directory at the end */\r\n        ti = (tablespaceinfo*)palloc0(sizeof(tablespaceinfo));\r\n        ti->size = opt->progress ? sendDir(\".\", 1, true, tablespaces) : -1;\r\n        tablespaces = (List*)lappend(tablespaces, ti);\r\n\r\n        /* Send tablespace header */\r\n        SendBackupHeader(tablespaces);\r\n\r\n        /* Send off our tablespaces one by one */\r\n        foreach (lc, tablespaces) {\r\n            tablespaceinfo* iterti = (tablespaceinfo*)lfirst(lc);\r\n            StringInfoData buf;\r\n\r\n            /* Send CopyOutResponse message */\r\n            pq_beginmessage(&buf, 'H');\r\n            pq_sendbyte(&buf, 0);  /* overall format */\r\n            pq_sendint16(&buf, 0); /* natts */\r\n            pq_endmessage_noblock(&buf);\r\n\r\n            /* In the main tar, include the backup_label first. */\r\n            if (iterti->path == NULL)\r\n                sendFileWithContent(BACKUP_LABEL_FILE, labelfile);\r\n\r\n            /*\r\n             * if the tblspc created in datadir , the files under tblspc do not send,\r\n             * and send them as normal under datadir,\r\n             * so we just send these tblspcs only once.\r\n             */\r\n            if (iterti->path != NULL) {\r\n                /* Skip the tablespace if it's created in GAUSSDATA */\r\n                sendTablespace(iterti->path, false);\r\n            } else {\r\n                /* data dir */\r\n                sendDir(\".\", 1, false, tablespaces);\r\n            }\r\n\r\n            /* In the main tar, include pg_control last. */\r\n            if (iterti->path == NULL) {\r\n                struct stat statbuf;\r\n                TimeLineID primay_tli = 0;\r\n                char path[MAXPGPATH] = {0};\r\n\r\n                if (lstat(XLOG_CONTROL_FILE, &statbuf) != 0) {\r\n                    LWLockAcquire(FullBuildXlogCopyStartPtrLock, LW_EXCLUSIVE);\r\n                    XlogCopyStartPtr = InvalidXLogRecPtr;\r\n                    LWLockRelease(FullBuildXlogCopyStartPtrLock);\r\n                    ereport(ERROR,\r\n                        (errcode_for_file_access(),\r\n                            errmsg(\"could not stat control file \\\"%s\\\": %m\", XLOG_CONTROL_FILE)));\r\n                }\r\n\r\n                sendFile(XLOG_CONTROL_FILE, XLOG_CONTROL_FILE, &statbuf, false);\r\n                /* In the main tar, include the last timeline history file at last. */\r\n                primay_tli = t_thrd.xlog_cxt.ThisTimeLineID;\r\n                while (primay_tli > 1) {\r\n\r\n                    TLHistoryFilePath(path, primay_tli);\r\n                    if (lstat(path, &statbuf) == 0)\r\n                        sendFile(path, path, &statbuf, false);\r\n                    primay_tli--;\r\n                }\r\n            }\r\n\r\n            /*\r\n             * If we're including WAL, and this is the main data directory we\r\n             * don't terminate the tar stream here. Instead, we will append\r\n             * the xlog files below and terminate it then. This is safe since\r\n             * the main data directory is always sent *last*.\r\n             */\r\n            if (opt->includewal && iterti->path == NULL) {\r\n                Assert(lnext(lc) == NULL);\r\n            } else\r\n                pq_putemptymessage_noblock('c'); /* CopyDone */\r\n        }\r\n    }\r\n    PG_END_ENSURE_ERROR_CLEANUP(base_backup_cleanup, (Datum)0);\r\n\r\n    endptr = do_pg_stop_backup(labelfile, !opt->nowait);\r\n\r\n    SendXlogRecPtrResult(endptr);\r\n\r\n    LWLockAcquire(FullBuildXlogCopyStartPtrLock, LW_EXCLUSIVE);\r\n    XlogCopyStartPtr = InvalidXLogRecPtr;\r\n    LWLockRelease(FullBuildXlogCopyStartPtrLock);\r\n}",
		"comment":"/*\r\n * Actually do a base backup for the specified tablespaces.\r\n *\r\n * This is split out mainly to avoid complaints about \"variable might be\r\n * clobbered by longjmp\" from stupider versions of gcc.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"perform_base_backup"
	},
	"print_val":{
		"body":"static void print_val(char* s, uint64 val, unsigned int base, size_t len)\r\n{\r\n    int i;\r\n\r\n    for (i = len; i > 0; i--) {\r\n        int digit = val % base;\r\n\r\n        s[i - 1] = '0' + digit;\r\n        val = val / base;\r\n    }\r\n}",
		"comment":"/*\r\n * Functions for handling tar file format\r\n *\r\n * Copied from pg_dump, but modified to work with libpq for sending\r\n *\r\n * Utility routine to print possibly larger than 32 bit integers in a\r\n * portable fashion.  Filled with zeros.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"print_val"
	},
	"save_xlogloc":{
		"body":"static void save_xlogloc(const char* xloglocation)\r\n{\r\n    errno_t rc = 0;\r\n\r\n    if (0 == strncmp(xloglocation, t_thrd.proc_cxt.DataDir, strlen(t_thrd.proc_cxt.DataDir))) {\r\n        rc = strncpy_s(t_thrd.basebackup_cxt.g_xlog_location,\r\n            MAXPGPATH,\r\n            xloglocation + strlen(t_thrd.proc_cxt.DataDir) + 1,\r\n            MAXPGPATH - 1);\r\n        securec_check(rc, \"\", \"\");\r\n        t_thrd.basebackup_cxt.g_xlog_location[MAXPGPATH - 1] = '\\0';\r\n    }\r\n}",
		"comment":"/*\r\n * save xlog location\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"save_xlogloc"
	},
	"sendDir":{
		"body":"static int64 sendDir(const char* path, int basepathlen, bool sizeonly, List* tablespaces, bool skipmot)\r\n{\r\n    DIR* dir = NULL;\r\n    struct dirent* de = NULL;\r\n    char pathbuf[MAXPGPATH];\r\n    struct stat statbuf;\r\n    int64 size = 0;\r\n    int rc = 0;\r\n\r\n    dir = AllocateDir(path);\r\n    while ((de = ReadDir(dir, path)) != NULL) {\r\n        /* Skip special stuff */\r\n        if (strcmp(de->d_name, \".\") == 0 || strcmp(de->d_name, \"..\") == 0)\r\n            continue;\r\n        if (strncmp(de->d_name, t_thrd.basebackup_cxt.g_xlog_location, strlen(de->d_name)) == 0)\r\n            continue;\r\n        if (strcmp(de->d_name, u_sess->attr.attr_common.Log_directory) == 0)\r\n            continue;\r\n        /* Skip temporary files */\r\n        if (strncmp(de->d_name, PG_TEMP_FILE_PREFIX, strlen(PG_TEMP_FILE_PREFIX)) == 0)\r\n            continue;\r\n\r\n        /*\r\n         * If there's a backup_label file, it belongs to a backup started by\r\n         * the user with pg_start_backup(). It is *not* correct for this\r\n         * backup, our backup_label is injected into the tar separately.\r\n         */\r\n        if (strcmp(de->d_name, BACKUP_LABEL_FILE) == 0)\r\n            continue;\r\n        if (strcmp(de->d_name, DISABLE_CONN_FILE) == 0)\r\n            continue;\r\n\r\n        /*\r\n         * Check if the postmaster has signaled us to exit, and abort with an\r\n         * error in that case. The error handler further up will call\r\n         * do_pg_abort_backup() for us.\r\n         */\r\n        if (!PostmasterIsAlive()) {\r\n            ereport(ERROR, (errcode_for_file_access(), errmsg(\"Postmaster exited, aborting active base backup\")));\r\n        }\r\n\r\n        if (t_thrd.walsender_cxt.walsender_shutdown_requested || t_thrd.walsender_cxt.walsender_ready_to_stop)\r\n            ereport(ERROR, (errcode_for_file_access(), errmsg(\"shutdown requested, aborting active base backup\")));\r\n\r\n        if (t_thrd.postmaster_cxt.HaShmData &&\r\n            (t_thrd.walsender_cxt.server_run_mode != t_thrd.postmaster_cxt.HaShmData->current_mode))\r\n            ereport(ERROR, (errcode_for_file_access(), errmsg(\"server run mode changed, aborting active base backup\")));\r\n\r\n        rc = snprintf_s(pathbuf, MAXPGPATH, MAXPGPATH - 1, \"%s/%s\", path, de->d_name);\r\n        securec_check_ss(rc, \"\", \"\");\r\n\r\n        /* Skip postmaster.pid and postmaster.opts in the data directory */\r\n        if (strcmp(pathbuf, \"./postmaster.pid\") == 0 || strcmp(pathbuf, \"./postmaster.opts\") == 0)\r\n            continue;\r\n        /* For gs_basebackup, we should not skip these files */\r\n        if (strcmp(u_sess->attr.attr_common.application_name, \"gs_basebackup\") != 0) {\r\n            if (strcmp(pathbuf, \"./pg_ctl.lock\") == 0 || strcmp(pathbuf, \"./postgresql.conf.lock\") == 0 ||\r\n                strcmp(pathbuf, \"./postgresql.conf.bak\") == 0 || strcmp(pathbuf, \"./postgresql.conf\") == 0) {\r\n                continue;\r\n            }\r\n\r\n            if (strcmp(de->d_name, g_instance.attr.attr_security.ssl_cert_file) == 0 ||\r\n                strcmp(de->d_name, g_instance.attr.attr_security.ssl_key_file) == 0 ||\r\n                strcmp(de->d_name, g_instance.attr.attr_security.ssl_ca_file) == 0 ||\r\n                strcmp(de->d_name, g_instance.attr.attr_security.ssl_crl_file) == 0 ||\r\n                strcmp(de->d_name, ssl_cipher_file) == 0 || strcmp(de->d_name, ssl_rand_file) == 0) {\r\n                continue;\r\n            }\r\n\r\n            if (strcmp(pathbuf, \"./client.crt\") == 0 || strcmp(pathbuf, \"./client.key\") == 0) {\r\n                continue;\r\n            }\r\n        }\r\n        if (IS_PGXC_COORDINATOR && strcmp(pathbuf, \"./pg_hba.conf\") == 0)\r\n            continue;\r\n        /* Skip cn_drop_backup */\r\n        if (IS_PGXC_COORDINATOR && strcmp(pathbuf, \"./cn_drop_backup\") == 0)\r\n            continue;\r\n\r\n        /* Skip pg_control here to back up it last */\r\n        if (strcmp(pathbuf, \"./global/pg_control\") == 0)\r\n            continue;\r\n        if (strcmp(pathbuf, \"./global/pg_dw\") == 0)\r\n            continue;\r\n        if (strcmp(pathbuf, \"./global/pg_dw.build\") == 0)\r\n            continue;\r\n        if (strcmp(pathbuf, \"./global/config_exec_params\") == 0)\r\n            continue;\r\n\r\n        if (strcmp(pathbuf, \"./gaussdb.state\") == 0 || strcmp(pathbuf, \"./gs_build.pid\") == 0)\r\n            continue;\r\n\r\n        if (strcmp(pathbuf, \"./disc_readonly_test\") == 0)\r\n            continue;\r\n\r\n        if (NULL != strstr(pathbuf, \"./pg_rewind_bak\"))\r\n            continue;\r\n\r\n        /* skip mot files */\r\n        if (skipmot && (strcmp(pathbuf, \"./mot.ctrl\") == 0 || strncmp(pathbuf, \"./chkpt_\", strlen(\"./chkpt_\")) == 0)) {\r\n            continue;\r\n        }\r\n\r\n        /*\r\n         * 1 major version upgrade mode, following path contains\r\n         * old database backup, need to skip\r\n         * 2 pg_location is for relative tablespace, we need skip it\r\n         */\r\n        if (strcmp(pathbuf, \"./full_upgrade_bak\") == 0 || strcmp(pathbuf, \"./pg_location\") == 0)\r\n            continue;\r\n\r\n        if (strcmp(pathbuf, \"./delay_xlog_recycle\") == 0 || strcmp(pathbuf, \"./delay_ddl_recycle\") == 0)\r\n            continue;\r\n\r\n        if (lstat(pathbuf, &statbuf) != 0) {\r\n            if (errno != ENOENT)\r\n                ereport(\r\n                    ERROR, (errcode_for_file_access(), errmsg(\"could not stat file or directory \\\"%s\\\": %m\", pathbuf)));\r\n\r\n            /* If the file went away while scanning, it's no error. */\r\n            continue;\r\n        }\r\n\r\n        /*\r\n         * Skip pg_errorinfo, not useful to copy. But include\r\n         * it as an empty directory anyway, so we get permissions right.\r\n         */\r\n        if (strcmp(de->d_name, \"pg_errorinfo\") == 0) {\r\n            if (!sizeonly)\r\n                _tarWriteHeader(pathbuf + basepathlen + 1, NULL, &statbuf);\r\n            size += BUILD_PATH_LEN; /* Size of the header just added */\r\n            continue;\r\n        }\r\n\r\n        /*\r\n         * Skip physical slot file, not useful to copy, only include logical slot file.\r\n         */\r\n        if (strcmp(path, \"./pg_replslot\") == 0) {\r\n            bool isphysicalslot = false;\r\n            LWLockAcquire(ReplicationSlotControlLock, LW_SHARED);\r\n            for (int i = 0; i < g_instance.attr.attr_storage.max_replication_slots; i++) {\r\n                ReplicationSlot* s = &t_thrd.slot_cxt.ReplicationSlotCtl->replication_slots[i];\r\n                if (s->in_use && s->data.database == InvalidOid && strcmp(de->d_name, NameStr(s->data.name)) == 0) {\r\n                    isphysicalslot = true;\r\n                    break;\r\n                }\r\n            }\r\n            LWLockRelease(ReplicationSlotControlLock);\r\n\r\n            if (isphysicalslot)\r\n                continue;\r\n        }\r\n\r\n        /*\r\n         * We can skip pg_xlog, the WAL segments need to be fetched from the\r\n         * WAL archive anyway. But include it as an empty directory anyway, so\r\n         * we get permissions right.\r\n         */\r\n        if (strcmp(pathbuf, \"./pg_xlog\") == 0) {\r\n            if (!sizeonly) {\r\n                /* If pg_xlog is a symlink, write it as a directory anyway */\r\n#ifndef WIN32\r\n                if (S_ISLNK(statbuf.st_mode)) {\r\n#else\r\n                if (pgwin32_is_junction(pathbuf)) {\r\n#endif\r\n#if defined(HAVE_READLINK) || defined(WIN32)\r\n                    char linkpath[MAXPGPATH] = {0};\r\n                    int rllen;\r\n\r\n                    rllen = readlink(pathbuf, linkpath, sizeof(linkpath));\r\n                    if (rllen < 0)\r\n                        ereport(ERROR,\r\n                            (errcode_for_file_access(), errmsg(\"could not read symbolic link \\\"%s\\\": %m\", pathbuf)));\r\n                    if (rllen >= (int)sizeof(linkpath))\r\n                        ereport(ERROR,\r\n                            (errcode(ERRCODE_NAME_TOO_LONG),\r\n                                errmsg(\"symbolic link \\\"%s\\\" target is too long\", pathbuf)));\r\n                    linkpath[MAXPGPATH - 1] = '\\0';\r\n\r\n                    if (!sizeonly)\r\n                        _tarWriteHeader(pathbuf + basepathlen + 1, linkpath, &statbuf);\r\n#else\r\n\r\n                    /*\r\n                     * If the platform does not have symbolic links, it should not be\r\n                     * possible to have tablespaces - clearly somebody else created\r\n                     * them. Warn about it and ignore.\r\n                     */\r\n                    ereport(WARNING,\r\n                        (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\r\n                            errmsg(\"tablespaces are not supported on this platform\")));\r\n                    continue;\r\n#endif /* HAVE_READLINK */\r\n                } else if (S_ISDIR(statbuf.st_mode)) {\r\n                    statbuf.st_mode = S_IFDIR | S_IRWXU;\r\n                    _tarWriteHeader(pathbuf + basepathlen + 1, NULL, &statbuf);\r\n                }\r\n            }\r\n            size += 512; /* Size of the header just added */\r\n            continue;    /* don't recurse into pg_xlog */\r\n        }\r\n\r\n        /* Allow symbolic links in pg_tblspc only */\r\n        if (strcmp(path, \"./pg_tblspc\") == 0 &&\r\n#ifndef WIN32\r\n            S_ISLNK(statbuf.st_mode)\r\n#else\r\n            pgwin32_is_junction(pathbuf)\r\n#endif\r\n        ) {\r\n#if defined(HAVE_READLINK) || defined(WIN32)\r\n            char linkpath[MAXPGPATH];\r\n            int rllen;\r\n\r\n            rllen = readlink(pathbuf, linkpath, sizeof(linkpath));\r\n            if (rllen < 0)\r\n                ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not read symbolic link \\\"%s\\\": %m\", pathbuf)));\r\n            if (rllen >= (int)sizeof(linkpath))\r\n                ereport(ERROR,\r\n                    (errcode(ERRCODE_NAME_TOO_LONG), errmsg(\"symbolic link \\\"%s\\\" target is too long\", pathbuf)));\r\n            linkpath[rllen] = '\\0';\r\n            if (!sizeonly)\r\n                _tarWriteHeader(pathbuf + basepathlen + 1, linkpath, &statbuf);\r\n            size += BUILD_PATH_LEN; /* Size of the header just added */\r\n#else\r\n\r\n            /*\r\n             * If the platform does not have symbolic links, it should not be\r\n             * possible to have tablespaces - clearly somebody else created\r\n             * them. Warn about it and ignore.\r\n             */\r\n            ereport(WARNING,\r\n                (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"tablespaces are not supported on this platform\")));\r\n            continue;\r\n#endif /* HAVE_READLINK */\r\n        } else if (S_ISDIR(statbuf.st_mode)) {\r\n            bool skip_this_dir = false;\r\n            ListCell* lc = NULL;\r\n\r\n            /*\r\n             * Store a directory entry in the tar file so we can get the\r\n             * permissions right.\r\n             */\r\n            if (!sizeonly)\r\n                _tarWriteHeader(pathbuf + basepathlen + 1, NULL, &statbuf);\r\n            size += BUILD_PATH_LEN; /* Size of the header just added */\r\n\r\n            /*\r\n             * Call ourselves recursively for a directory, unless it happens\r\n             * to be a separate tablespace located within PGDATA.\r\n             */\r\n            foreach (lc, tablespaces) {\r\n                tablespaceinfo* ti = (tablespaceinfo*)lfirst(lc);\r\n\r\n                /*\r\n                 * ti->rpath is the tablespace relative path within PGDATA, or\r\n                 * NULL if the tablespace has been properly located somewhere\r\n                 * else.\r\n                 *\r\n                 * Skip past the leading \"./\" in pathbuf when comparing.\r\n                 */\r\n                if (ti->relativePath && strcmp(ti->relativePath, pathbuf + 2) == 0) {\r\n                    skip_this_dir = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!skip_this_dir)\r\n                size += sendDir(pathbuf, basepathlen, sizeonly, tablespaces);\r\n        } else if (S_ISREG(statbuf.st_mode)) {\r\n            bool sent = false;\r\n\r\n            if (!sizeonly)\r\n                sent = sendFile(pathbuf, pathbuf + basepathlen + 1, &statbuf, true);\r\n\r\n            if (sent || sizeonly) {\r\n                /* Add size, rounded up to 512byte block */\r\n                size += ((statbuf.st_size + 511) & ~511);\r\n                size += BUILD_PATH_LEN; /* Size of the header of the file */\r\n            }\r\n        } else\r\n            ereport(WARNING, (errmsg(\"skipping special file \\\"%s\\\"\", pathbuf)));\r\n    }\r\n    FreeDir(dir);\r\n    return size;\r\n}",
		"comment":"/*\r\n * Include all files from the given directory in the output tar stream. If\r\n * 'sizeonly' is true, we just calculate a total length and return it, without\r\n * actually sending anything.\r\n *\r\n * Omit any directory in the tablespaces list, to avoid backing up\r\n * tablespaces twice when they were created inside PGDATA.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"sendDir"
	},
	"sendFile":{
		"body":"static bool sendFile(char* readfilename, char* tarfilename, struct stat* statbuf, bool missing_ok)\r\n{\r\n    FILE* fp = NULL;\r\n    size_t cnt;\r\n    pgoff_t len = 0;\r\n    size_t pad;\r\n    errno_t rc = 0;\r\n    int check_loc = 0;\r\n    BlockNumber blkno = 0;\r\n    uint16 checksum = 0;\r\n    bool isNeedCheck = false;\r\n    int segNo = 0;\r\n    const int MAX_RETRY_LIMIT = 60;\r\n    int retryCnt = 0;\r\n\r\n    if (t_thrd.basebackup_cxt.buf_block == NULL) {\r\n        MemoryContext oldcxt = NULL;\r\n\r\n        oldcxt = MemoryContextSwitchTo(t_thrd.top_mem_cxt);\r\n        t_thrd.basebackup_cxt.buf_block = (char*)palloc0(TAR_SEND_SIZE);\r\n        MemoryContextSwitchTo(oldcxt);\r\n    }\r\n\r\n    /*\r\n     * repalloc to `MaxBuildAllocSize' in one time, to avoid many small step repalloc in `pq_putmessage_noblock'\r\n     * and low performance.\r\n     */\r\n    if (INT2SIZET(t_thrd.libpq_cxt.PqSendBufferSize) < MaxBuildAllocSize) {\r\n        t_thrd.libpq_cxt.PqSendBuffer = (char*)repalloc(t_thrd.libpq_cxt.PqSendBuffer, MaxBuildAllocSize);\r\n        t_thrd.libpq_cxt.PqSendBufferSize = MaxBuildAllocSize;\r\n    }\r\n\r\n    /*\r\n     * Some compilers will throw a warning knowing this test can never be true\r\n     * because pgoff_t can't exceed the compared maximum on their platform.\r\n     */\r\n    if (statbuf->st_size > MAX_TAR_MEMBER_FILELEN) {\r\n        ereport(WARNING,\r\n            (errcode(ERRCODE_NAME_TOO_LONG), errmsg(\"archive member \\\"%s\\\" too large for tar format\", tarfilename)));\r\n        return false;\r\n    }\r\n\r\n    fp = AllocateFile(readfilename, \"rb\");\r\n    if (fp == NULL) {\r\n        if (errno == ENOENT && missing_ok)\r\n            return false;\r\n        ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not open file \\\"%s\\\": %m\", readfilename)));\r\n    }\r\n\r\n    isNeedCheck = is_row_data_file(readfilename, &segNo);\r\n    ereport(DEBUG1, (errmsg(\"sendFile, filename is %s, isNeedCheck is %d\", readfilename, isNeedCheck)));\r\n\r\n    /* make sure data file size is integer multiple of BLCKSZ and change statbuf if needed */\r\n    if(isNeedCheck) {\r\n        statbuf->st_size = statbuf->st_size - (statbuf->st_size % BLCKSZ);\r\n    }\r\n\r\n    /* send the pkg header containing msg like file size */\r\n    _tarWriteHeader(tarfilename, NULL, statbuf);\r\n\r\n    while ((cnt = fread(t_thrd.basebackup_cxt.buf_block, 1, Min(TAR_SEND_SIZE, statbuf->st_size - len), fp)) > 0) {\r\n        if (t_thrd.walsender_cxt.walsender_ready_to_stop)\r\n            ereport(ERROR, (errcode_for_file_access(), errmsg(\"base backup receive stop message, aborting backup\")));\r\n    recheck:\r\n        if (cnt != (size_t) Min(TAR_SEND_SIZE, statbuf->st_size - len)) {\r\n            if (ferror(fp)) {\r\n                ereport(ERROR,\r\n                   (errcode_for_file_access(),\r\n                   errmsg(\"could not read file \\\"%s\\\": %m\", readfilename)));\r\n            }\r\n        }\r\n        if (g_instance.attr.attr_storage.enableIncrementalCheckpoint && isNeedCheck) {\r\n            /* len and cnt must be integer multiple of BLCKSZ. */\r\n            if (len % BLCKSZ != 0 || cnt % BLCKSZ != 0) {\r\n                ereport(ERROR,\r\n                   (errcode_for_file_access(),\r\n                   errmsg(\"base backup file length cannot be divisibed by 8k: file %s, len %ld, cnt %ld, aborting backup\",\r\n                   readfilename, len, cnt)));\r\n            }\r\n            for (check_loc = 0; (unsigned int)(check_loc) < cnt; check_loc += BLCKSZ) {\r\n                blkno = len / BLCKSZ + check_loc / BLCKSZ + (segNo * ((BlockNumber)RELSEG_SIZE));\r\n                PageHeader phdr = PageHeader(t_thrd.basebackup_cxt.buf_block + check_loc);\r\n                if (PageIsNew(phdr)) {\r\n                    continue;\r\n                }\r\n                checksum = pg_checksum_page(t_thrd.basebackup_cxt.buf_block + check_loc, blkno);\r\n\r\n                if (phdr->pd_checksum != checksum) {\r\n                    if (fseeko(fp, (off_t)len, SEEK_SET) != 0) {\r\n                        ereport(ERROR,\r\n                            (errcode_for_file_access(), errmsg(\"could not seek in file \\\"%s\\\": %m\", readfilename)));\r\n                    }\r\n                    cnt = fread(t_thrd.basebackup_cxt.buf_block, 1, Min(TAR_SEND_SIZE, statbuf->st_size - len), fp);\r\n                    if (cnt > 0 && retryCnt < MAX_RETRY_LIMIT) {\r\n                        retryCnt++;\r\n                        pg_usleep(100000);\r\n                        goto recheck;\r\n                    } else if (cnt > 0 && retryCnt == MAX_RETRY_LIMIT) {\r\n                        ereport(ERROR,\r\n                           (errcode_for_file_access(),\r\n                           errmsg(\"base backup cheksum failed in file \\\"%s\\\"(computed: %d, recorded: %d), aborting backup\",\r\n                           readfilename, checksum, phdr->pd_checksum)));\r\n                    } else {\r\n                        retryCnt = 0;\r\n                        break;\r\n                    }\r\n                }\r\n                retryCnt = 0;\r\n            }\r\n        }\r\n\r\n        /* Send the chunk as a CopyData message */\r\n        if (pq_putmessage_noblock('d', t_thrd.basebackup_cxt.buf_block, cnt))\r\n            ereport(ERROR, (errcode_for_file_access(), errmsg(\"base backup could not send data, aborting backup\")));\r\n\r\n        len += cnt;\r\n\r\n        if (len >= statbuf->st_size) {\r\n            /*\r\n             * Reached end of file. The file could be longer, if it was\r\n             * extended while we were sending it, but for a base backup we can\r\n             * ignore such extended data. It will be restored from WAL.\r\n             */\r\n            break;\r\n        }\r\n    }\r\n\r\n    /* If the file was truncated while we were sending it, pad it with zeros */\r\n    if (len < statbuf->st_size) {\r\n        rc = memset_s(t_thrd.basebackup_cxt.buf_block, TAR_SEND_SIZE, 0, TAR_SEND_SIZE);\r\n        securec_check(rc, \"\", \"\");\r\n        while (len < statbuf->st_size) {\r\n            cnt = Min(TAR_SEND_SIZE, statbuf->st_size - len);\r\n            (void)pq_putmessage_noblock('d', t_thrd.basebackup_cxt.buf_block, cnt);\r\n            len += cnt;\r\n        }\r\n    }\r\n\r\n    /* Pad to 512 byte boundary, per tar format requirements */\r\n    pad = ((len + 511) & ~511) - len;\r\n    if (pad > 0) {\r\n        rc = memset_s(t_thrd.basebackup_cxt.buf_block, pad, 0, pad);\r\n        securec_check(rc, \"\", \"\");\r\n        (void)pq_putmessage_noblock('d', t_thrd.basebackup_cxt.buf_block, pad);\r\n    }\r\n\r\n    (void)FreeFile(fp);\r\n    return true;\r\n}",
		"comment":"/*\r\n * Given the member, write the TAR header & send the file.\r\n *\r\n * If 'missing_ok' is true, will not throw an error if the file is not found.\r\n *\r\n * Returns true if the file was successfully sent, false if 'missing_ok',\r\n * and the file did not exist.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"sendFile"
	},
	"sendFileWithContent":{
		"body":"static void sendFileWithContent(const char* filename, const char* content)\r\n{\r\n    struct stat statbuf;\r\n    int pad, len;\r\n\r\n    len = strlen(content);\r\n\r\n    /*\r\n     * Construct a stat struct for the backup_label file we're injecting in\r\n     * the tar.\r\n     */\r\n    /* Windows doesn't have the concept of uid and gid */\r\n#ifdef WIN32\r\n    statbuf.st_uid = 0;\r\n    statbuf.st_gid = 0;\r\n#else\r\n    statbuf.st_uid = geteuid();\r\n    statbuf.st_gid = getegid();\r\n#endif\r\n    statbuf.st_mtime = time(NULL);\r\n    statbuf.st_mode = S_IRUSR | S_IWUSR;\r\n    statbuf.st_size = len;\r\n\r\n    _tarWriteHeader(filename, NULL, &statbuf);\r\n    /* Send the contents as a CopyData message */\r\n    (void)pq_putmessage_noblock('d', content, len);\r\n\r\n    /* Pad to 512 byte boundary, per tar format requirements */\r\n    pad = ((len + 511) & ~511) - len;\r\n    if (pad > 0) {\r\n        char buf[512];\r\n        errno_t rc = 0;\r\n\r\n        rc = memset_s(buf, sizeof(buf), 0, pad);\r\n        securec_check(rc, \"\", \"\");\r\n        (void)pq_putmessage_noblock('d', buf, pad);\r\n    }\r\n}",
		"comment":"/*\r\n * Inject a file with given name and content in the output tar stream.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"sendFileWithContent"
	},
	"sendTablespace":{
		"body":"static int64 sendTablespace(const char* path, bool sizeonly)\r\n{\r\n    int64 size = 0;\r\n    char pathbuf[MAXPGPATH] = {0};\r\n    char relativedirname[MAXPGPATH] = {0};\r\n    struct stat statbuf;\r\n    int rc = 0;\r\n\r\n    /*\r\n     * 'path' points to the tablespace location, but we only want to include\r\n     * the version directory in it that belongs to us.\r\n     */\r\n    rc = snprintf_s(relativedirname,\r\n        sizeof(relativedirname),\r\n        sizeof(relativedirname) - 1,\r\n        \"%s_%s\",\r\n        TABLESPACE_VERSION_DIRECTORY,\r\n        g_instance.attr.attr_common.PGXCNodeName);\r\n    securec_check_ss(rc, \"\", \"\");\r\n\r\n    rc = snprintf_s(pathbuf, sizeof(pathbuf), sizeof(pathbuf) - 1, \"%s/%s\", path, relativedirname);\r\n    securec_check_ss(rc, \"\", \"\");\r\n\r\n    /*\r\n     * Store a directory entry in the tar file so we get the permissions\r\n     * right.\r\n     */\r\n    if (lstat(pathbuf, &statbuf) != 0) {\r\n        if (errno != ENOENT)\r\n            ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not stat file or directory \\\"%s\\\": %m\", pathbuf)));\r\n\r\n        /* If the tablespace went away while scanning, it's no error. */\r\n        return 0;\r\n    }\r\n    if (!sizeonly)\r\n        _tarWriteHeader(relativedirname, NULL, &statbuf);\r\n    size = 512; /* Size of the header just added */\r\n\r\n    /* Send all the files in the tablespace version directory */\r\n    size += sendDir(pathbuf, strlen(path), sizeonly, NIL);\r\n\r\n    return size;\r\n}",
		"comment":"/*\r\n * Include the tablespace directory pointed to by 'path' in the output tar\r\n * stream.  If 'sizeonly' is true, we just calculate a total length and return\r\n * it, without actually sending anything.\r\n *\r\n * Only used to send auxiliary tablespaces, not GAUSSDATA.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"sendTablespace"
	},
	"send_int8_string":{
		"body":"static void send_int8_string(StringInfoData* buf, int64 intval)\r\n{\r\n    char is[32];\r\n    int rc = 0;\r\n\r\n    rc = snprintf_s(is, sizeof(is), sizeof(is) - 1, INT64_FORMAT, intval);\r\n    securec_check_ss(rc, \"\", \"\");\r\n\r\n    pq_sendint32(buf, strlen(is));\r\n    pq_sendbytes(buf, is, strlen(is));\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"send_int8_string"
	},
	"send_xlog_header":{
		"body":"static void send_xlog_header(const char* linkpath)\r\n{\r\n    StringInfoData buf;\r\n    char pg_xlog[] = \"data/pg_xlog\";\r\n\r\n    /* Construct and send the directory information */\r\n    pq_beginmessage(&buf, 'T'); /* RowDescription */\r\n    pq_sendint16(&buf, 1);      /* 1 fields */\r\n\r\n    /* Second field - xloglink */\r\n    pq_sendstring(&buf, \"xloglink\");\r\n    pq_sendint32(&buf, 0);\r\n    pq_sendint16(&buf, 0);\r\n    pq_sendint32(&buf, TEXTOID);\r\n    pq_sendint16(&buf, UINT16_MAX);\r\n    pq_sendint32(&buf, 0);\r\n    pq_sendint16(&buf, 0);\r\n    pq_endmessage_noblock(&buf);\r\n\r\n    /* Data row */\r\n    pq_beginmessage(&buf, 'D');\r\n    pq_sendint16(&buf, 1); /* number of columns */\r\n    if (linkpath == NULL) {\r\n        /* default data ,here we just send a fixed str */\r\n        pq_sendint32(&buf, strlen(pg_xlog));\r\n        pq_sendbytes(&buf, pg_xlog, strlen(pg_xlog));\r\n    } else {\r\n        pq_sendint32(&buf, strlen(linkpath));\r\n        pq_sendbytes(&buf, linkpath, strlen(linkpath));\r\n    }\r\n    pq_endmessage_noblock(&buf);\r\n\r\n    /* Send a CommandComplete message */\r\n    pq_puttextmessage_noblock('C', \"SELECT\");\r\n}",
		"comment":"/*\r\n * send xlog location header\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"send_xlog_header"
	},
	"send_xlog_location":{
		"body":"static void send_xlog_location()\r\n{\r\n    char fullpath[MAXPGPATH] = {0};\r\n    struct stat statbuf;\r\n    int rc = 0;\r\n\r\n    rc = snprintf_s(fullpath, sizeof(fullpath), sizeof(fullpath) - 1, \"%s/pg_xlog\", t_thrd.proc_cxt.DataDir);\r\n    securec_check_ss(rc, \"\", \"\");\r\n\r\n    if (lstat(fullpath, &statbuf) != 0) {\r\n        ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not stat control file \\\"%s\\\": %m\", fullpath)));\r\n    }\r\n\r\n#ifndef WIN32\r\n    if (S_ISLNK(statbuf.st_mode)) {\r\n#else\r\n    if (pgwin32_is_junction(fullpath)) {\r\n#endif\r\n#if defined(HAVE_READLINK) || defined(WIN32)\r\n        char linkpath[MAXPGPATH] = {0};\r\n        int rllen;\r\n\r\n        rllen = readlink(fullpath, linkpath, sizeof(linkpath));\r\n        if (rllen < 0)\r\n            ereport(ERROR, (errcode_for_file_access(), errmsg(\"could not read symbolic link \\\"%s\\\": %m\", fullpath)));\r\n        if (rllen >= (int)sizeof(linkpath))\r\n            ereport(\r\n                ERROR, (errcode(ERRCODE_NAME_TOO_LONG), errmsg(\"symbolic link \\\"%s\\\" target is too long\", fullpath)));\r\n        linkpath[MAXPGPATH - 1] = '\\0';\r\n\r\n        /* save xlog location to varible */\r\n        save_xlogloc(linkpath);\r\n\r\n        send_xlog_header(linkpath);\r\n\r\n#else\r\n\r\n        /*\r\n         * If the platform does not have symbolic links, it should not be\r\n         * possible to have tablespaces - clearly somebody else created\r\n         * them. Warn about it and ignore.\r\n         */\r\n        ereport(WARNING,\r\n            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(\"tablespaces are not supported on this platform\")));\r\n        continue;\r\n#endif /* HAVE_READLINK */\r\n    } else if (S_ISDIR(statbuf.st_mode)) {\r\n        statbuf.st_mode = S_IFDIR | S_IRWXU;\r\n        send_xlog_header(NULL);\r\n    }\r\n}",
		"comment":"/*\r\n *  if xlog location is a link ,send it to standby\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"send_xlog_location"
	},
	"ut_save_xlogloc":{
		"body":"void ut_save_xlogloc(const char* xloglocation)\r\n{\r\n    save_xlogloc(xloglocation);\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\basebackup.cpp",
		"name":"ut_save_xlogloc"
	}
}