{
	"CheckLogicalDecodingRequirements":{
		"body":"void CheckLogicalDecodingRequirements(Oid databaseId)\r\n{\r\n    CheckSlotRequirements();\r\n    if (g_instance.attr.attr_storage.wal_level < WAL_LEVEL_LOGICAL)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\r\n                errmsg(\"logical decoding requires wal_level >= logical\")));\r\n\r\n    if (databaseId == InvalidOid)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\r\n                errmsg(\"logical decoding requires a database connection\")));\r\n\r\n    /* ----\r\n     * description: We got to change that someday soon...\r\n     *\r\n     * There's basically three things missing to allow this:\r\n     * 1) We need to be able to correctly and quickly identify the timeline a\r\n     *	LSN belongs to\r\n     * 2) We need to force hot_standby_feedback to be enabled at all times so\r\n     *	the primary cannot remove rows we need.\r\n     * 3) support dropping replication slots referring to a database, in\r\n     *	dbase_redo. There can't be any active ones due to HS recovery\r\n     *	conflicts, so that should be relatively easy.\r\n     * ----\r\n     */\r\n}",
		"comment":"/*\r\n * Make sure the current settings & environment are capable of doing logical\r\n * decoding.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logical.cpp",
		"name":"CheckLogicalDecodingRequirements"
	},
	"CreateDecodingContext":{
		"body":"LogicalDecodingContext* CreateDecodingContext(XLogRecPtr start_lsn, List* output_plugin_options, bool fast_forward,\r\n    XLogPageReadCB read_page, LogicalOutputPluginWriterPrepareWrite prepare_write,\r\n    LogicalOutputPluginWriterWrite do_write)\r\n{\r\n    LogicalDecodingContext* ctx = NULL;\r\n    ReplicationSlot* slot = NULL;\r\n    MemoryContext old_context = NULL;\r\n\r\n    /* shorter lines... */\r\n    slot = t_thrd.slot_cxt.MyReplicationSlot;\r\n\r\n    /* first some sanity checks that are unlikely to be violated */\r\n    if (slot == NULL)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\r\n                errmsg(\"cannot perform logical decoding without a acquired slot\")));\r\n\r\n    /* make sure the passed slot is suitable, these are user facing errors */\r\n    if (slot->data.database == InvalidOid)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\r\n                (errmsg(\"cannot use physical replication slot for logical decoding\"))));\r\n\r\n    if (slot->data.database != u_sess->proc_cxt.MyDatabaseId)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\r\n                (errmsg(\"replication slot \\\"%s\\\" was not created in this database\", NameStr(slot->data.name)))));\r\n\r\n    if (XLByteEQ(start_lsn, InvalidXLogRecPtr)) {\r\n        /* continue from last position */\r\n        start_lsn = slot->data.confirmed_flush;\r\n    } else if (XLByteLT(start_lsn, slot->data.confirmed_flush)) {\r\n        /*\r\n         * It might seem like we should error out in this case, but it's\r\n         * pretty common for a client to acknowledge a LSN it doesn't have to\r\n         * do anything for, and thus didn't store persistently, because the\r\n         * xlog records didn't result in anything relevant for logical\r\n         * decoding. Clients have to be able to do that to support\r\n         * synchronous replication.\r\n         */\r\n        if (!RecoveryInProgress())\r\n            ereport(DEBUG1,\r\n                (errmsg(\"cannot stream from %X/%X, minimum is %X/%X, forwarding\",\r\n                    (uint32)(start_lsn >> 32),\r\n                    uint32(start_lsn),\r\n                    (uint32)(slot->data.confirmed_flush >> 32),\r\n                    (uint32)slot->data.confirmed_flush)));\r\n\r\n        start_lsn = slot->data.confirmed_flush;\r\n    }\r\n\r\n    ctx = StartupDecodingContext(output_plugin_options,\r\n        start_lsn,\r\n        InvalidTransactionId,\r\n        false,\r\n        fast_forward,\r\n        read_page,\r\n        prepare_write,\r\n        do_write);\r\n\r\n    /* call output plugin initialization callback */\r\n    old_context = MemoryContextSwitchTo(ctx->context);\r\n    if (ctx->callbacks.startup_cb != NULL)\r\n        startup_cb_wrapper(ctx, &ctx->options, false);\r\n    (void)MemoryContextSwitchTo(old_context);\r\n\r\n    if (!RecoveryInProgress())\r\n        ereport(LOG,\r\n            (errmsg(\"starting logical decoding for slot %s\", NameStr(slot->data.name)),\r\n                errdetail(\"streaming transactions committing after %X/%X, reading WAL from %X/%X\",\r\n                    (uint32)(slot->data.confirmed_flush >> 32),\r\n                    (uint32)slot->data.confirmed_flush,\r\n                    (uint32)(slot->data.restart_lsn >> 32),\r\n                    (uint32)slot->data.restart_lsn)));\r\n\r\n    return ctx;\r\n}",
		"comment":"/*\r\n * Create a new decoding context, for a logical slot that has previously been\r\n * used already.\r\n *\r\n * start_lsn contains the LSN of the last received data or InvalidXLogRecPtr\r\n * output_plugin_options contains options passed to the output plugin\r\n * read_page, prepare_write, do_write are callbacks that have to be filled to\r\n *	  perform the use-case dependent, actual, work.\r\n *\r\n * Needs to be called while in a memory context that's at least as long lived\r\n * as the decoding context because further memory contexts will be created\r\n * inside it.\r\n *\r\n * Returns an initialized decoding context after calling the output plugin's\r\n * startup function.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logical.cpp",
		"name":"CreateDecodingContext"
	},
	"CreateInitDecodingContext":{
		"body":"LogicalDecodingContext* CreateInitDecodingContext(const char* plugin, List* output_plugin_options,\r\n    bool need_full_snapshot, XLogPageReadCB read_page, LogicalOutputPluginWriterPrepareWrite prepare_write,\r\n    LogicalOutputPluginWriterWrite do_write)\r\n{\r\n    TransactionId xmin_horizon = InvalidTransactionId;\r\n    ReplicationSlot* slot = NULL;\r\n    LogicalDecodingContext* ctx = NULL;\r\n    MemoryContext old_context = NULL;\r\n    int rc = 0;\r\n\r\n    /* shorter lines... */\r\n    slot = t_thrd.slot_cxt.MyReplicationSlot;\r\n\r\n    /* first some sanity checks that are unlikely to be violated */\r\n    if (slot == NULL)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\r\n                errmsg(\"cannot perform logical decoding without a acquired slot\")));\r\n\r\n    if (plugin == NULL)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\r\n                errmsg(\"cannot initialize logical decoding without a specified plugin\")));\r\n\r\n    /* Make sure the passed slot is suitable. These are user facing errors. */\r\n    if (slot->data.database == InvalidOid)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\r\n                errmsg(\"cannot use physical replication slot created for logical decoding\")));\r\n\r\n    if (slot->data.database != u_sess->proc_cxt.MyDatabaseId)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\r\n                errmsg(\"replication slot \\\"%s\\\" was not created in this database\", NameStr(slot->data.name))));\r\n\r\n    if (IsTransactionState() && GetTopTransactionIdIfAny() != InvalidTransactionId)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_ACTIVE_SQL_TRANSACTION),\r\n                errmsg(\"cannot create logical replication slot in transaction that has performed writes\")));\r\n\r\n    /* register output plugin name with slot */\r\n    SpinLockAcquire(&slot->mutex);\r\n    rc = strncpy_s(NameStr(slot->data.plugin), NAMEDATALEN, plugin, NAMEDATALEN - 1);\r\n    securec_check(rc, \"\\0\", \"\\0\");\r\n    NameStr(slot->data.plugin)[NAMEDATALEN - 1] = '\\0';\r\n    SpinLockRelease(&slot->mutex);\r\n\r\n    /*\r\n     * The replication slot mechanism is used to prevent removal of required\r\n     * WAL. As there is no interlock between this and checkpoints required WAL\r\n     * could be removed before ReplicationSlotsComputeRequiredLSN() has been\r\n     * called to prevent that. In the very unlikely case that this happens\r\n     * we'll just retry.\r\n     */\r\n    while (true) {\r\n        XLogRecPtr segno;\r\n\r\n        /*\r\n         * Let's start with enough information if we can, so log a standby\r\n         * snapshot and start decoding at exactly that position.\r\n         */\r\n        if (!RecoveryInProgress()) {\r\n            XLogRecPtr flushptr;\r\n\r\n            /* start at current insert position */\r\n            slot->data.restart_lsn = GetXLogInsertRecPtr();\r\n\r\n            /* make sure we have enough information to start */\r\n            flushptr = LogStandbySnapshot();\r\n\r\n            /* and make sure it's fsynced to disk */\r\n            XLogFlush(flushptr);\r\n        } else\r\n            slot->data.restart_lsn = GetRedoRecPtr();\r\n\r\n        /* prevent WAL removal as fast as possible */\r\n        ReplicationSlotsComputeRequiredLSN(NULL);\r\n\r\n        /*\r\n         * If all required WAL is still there, great, otherwise retry. The\r\n         * slot should prevent further removal of WAL, unless there's a\r\n         * concurrent ReplicationSlotsComputeRequiredLSN() after we've written\r\n         * the new restart_lsn above, so normally we should never need to loop\r\n         * more than twice.\r\n         */\r\n        XLByteToSeg(slot->data.restart_lsn, segno);\r\n        XLogRecPtr LastRemovedSegno = XLogGetLastRemovedSegno();\r\n        if (XLByteLT(LastRemovedSegno, segno))\r\n            break;\r\n    }\r\n\r\n    /* ----\r\n     * This is a bit tricky: We need to determine a safe xmin horizon to start\r\n     * decoding from, to avoid starting from a running xacts record referring\r\n     * to xids whose rows have been vacuumed or pruned\r\n     * already. GetOldestSafeDecodingTransactionId() returns such a value, but\r\n     * without further interlock it's return value might immediately be out of\r\n     * date.\r\n     *\r\n     * So we have to acquire the ProcArrayLock to prevent computation of new\r\n     * xmin horizons by other backends, get the safe decoding xid, and inform\r\n     * the slot machinery about the new limit. Once that's done the\r\n     * ProcArrayLock can be be released as the slot machinery now is\r\n     * protecting against vacuum.\r\n     *\r\n     * Note that, temporarily, the data, not just the catalog, xmin has to be\r\n     * reserved if a data snapshot is to be exported.  Otherwise the initial\r\n     * data snapshot created here is not guaranteed to be valid. After that\r\n     * the data xmin doesn't need to be managed anymore and the global xmin\r\n     * should be recomputed. As we are fine with losing the pegged data xmin\r\n     * after crash - no chance a snapshot would get exported anymore - we can\r\n     * get away with just setting the slot's\r\n     * effective_xmin. ReplicationSlotRelease will reset it again.\r\n     *\r\n     * ----\r\n     */\r\n    (void)LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);\r\n\r\n    xmin_horizon = GetOldestSafeDecodingTransactionId(need_full_snapshot);\r\n\r\n    slot->effective_catalog_xmin = xmin_horizon;\r\n    slot->data.catalog_xmin = xmin_horizon;\r\n    if (need_full_snapshot)\r\n        slot->effective_xmin = xmin_horizon;\r\n\r\n    ReplicationSlotsComputeRequiredXmin(true);\r\n\r\n    LWLockRelease(ProcArrayLock);\r\n\r\n    ReplicationSlotMarkDirty();\r\n    ReplicationSlotSave();\r\n\r\n    ctx = StartupDecodingContext(\r\n        NIL, InvalidXLogRecPtr, xmin_horizon, need_full_snapshot, true, read_page, prepare_write, do_write);\r\n\r\n    /* call output plugin initialization callback */\r\n    old_context = MemoryContextSwitchTo(ctx->context);\r\n    if (ctx->callbacks.startup_cb != NULL)\r\n        startup_cb_wrapper(ctx, &ctx->options, true);\r\n    (void)MemoryContextSwitchTo(old_context);\r\n\r\n    return ctx;\r\n}",
		"comment":"/*\r\n * Create a new decoding context, for a new logical slot.\r\n *\r\n * plugin contains the name of the output plugin\r\n * output_plugin_options contains options passed to the output plugin\r\n * read_page, prepare_write, do_write are callbacks that have to be filled to\r\n *	  perform the use-case dependent, actual, work.\r\n *\r\n * Needs to be called while in a memory context that's at least as long lived\r\n * as the decoding context because further memory contexts will be created\r\n * inside it.\r\n *\r\n * Returns an initialized decoding context after calling the output plugin's\r\n * startup function.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logical.cpp",
		"name":"CreateInitDecodingContext"
	},
	"DecodingContextFindStartpoint":{
		"body":"void DecodingContextFindStartpoint(LogicalDecodingContext* ctx)\r\n{\r\n    XLogRecPtr startptr;\r\n\r\n    /* Initialize from where to start reading WAL. */\r\n    startptr = ctx->slot->data.restart_lsn;\r\n    if (!RecoveryInProgress()) {\r\n        ereport(DEBUG1,\r\n            (errmsg(\"searching for logical decoding starting point, starting at %X/%X\",\r\n                (uint32)(ctx->slot->data.restart_lsn >> 32),\r\n                (uint32)ctx->slot->data.restart_lsn)));\r\n    }\r\n\r\n    /* Wait for a consistent starting point */\r\n    for (;;) {\r\n        XLogRecord* record = 0;\r\n        char* err = NULL;\r\n\r\n        /* the read_page callback waits for new WAL */\r\n        record = XLogReadRecord(ctx->reader, startptr, &err);\r\n        if (err != NULL)\r\n            ereport(ERROR,\r\n                (errcode(ERRCODE_LOGICAL_DECODE_ERROR),\r\n                    errmsg(\"Stopped to parse any valid XLog Record at %X/%X: %s.\",\r\n                        (uint32)(ctx->reader->EndRecPtr >> 32),\r\n                        (uint32)ctx->reader->EndRecPtr,\r\n                        err)));\r\n\r\n        Assert(record);\r\n\r\n        startptr = InvalidXLogRecPtr;\r\n        if (record != NULL) {\r\n            LogicalDecodingProcessRecord(ctx, ctx->reader);\r\n        }\r\n        /* only continue till we found a consistent spot */\r\n        if (DecodingContextReady(ctx))\r\n            break;\r\n        CHECK_FOR_INTERRUPTS();\r\n    }\r\n\r\n    ctx->slot->data.confirmed_flush = ctx->reader->EndRecPtr;\r\n}",
		"comment":"/*\r\n * Read from the decoding slot, until it is ready to start extracting changes.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logical.cpp",
		"name":"DecodingContextFindStartpoint"
	},
	"DecodingContextReady":{
		"body":"bool DecodingContextReady(LogicalDecodingContext* ctx)\r\n{\r\n    return SnapBuildCurrentState(ctx->snapshot_builder) == SNAPBUILD_CONSISTENT;\r\n}",
		"comment":"/*\r\n * Returns true if an consistent initial decoding snapshot has been built.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logical.cpp",
		"name":"DecodingContextReady"
	},
	"FreeDecodingContext":{
		"body":"void FreeDecodingContext(LogicalDecodingContext* ctx)\r\n{\r\n    if (ctx->callbacks.shutdown_cb != NULL)\r\n        shutdown_cb_wrapper(ctx);\r\n\r\n    ReorderBufferFree(ctx->reorder);\r\n    FreeSnapshotBuilder(ctx->snapshot_builder);\r\n    XLogReaderFree(ctx->reader);\r\n    MemoryContextDelete(ctx->context);\r\n}",
		"comment":"/*\r\n * Free a previously allocated decoding context, invoking the shutdown\r\n * callback if necessary.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logical.cpp",
		"name":"FreeDecodingContext"
	},
	"LoadOutputPlugin":{
		"body":"static void LoadOutputPlugin(OutputPluginCallbacks* callbacks, const char* plugin)\r\n{\r\n    LogicalOutputPluginInit plugin_init;\r\n    CFunInfo tmpCF = load_external_function(plugin, \"_PG_output_plugin_init\", false, false);\r\n    plugin_init = (LogicalOutputPluginInit)tmpCF.user_fn;\r\n\r\n    if (plugin_init == NULL)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_LOGICAL_DECODE_ERROR),\r\n                errmsg(\"output plugins have to declare the _PG_output_plugin_init symbol\")));\r\n\r\n    /* ask the output plugin to fill the callback struct */\r\n    plugin_init(callbacks);\r\n\r\n    if (callbacks->begin_cb == NULL)\r\n        ereport(\r\n            ERROR, (errcode(ERRCODE_LOGICAL_DECODE_ERROR), errmsg(\"output plugins have to register a begin callback\")));\r\n    if (callbacks->change_cb == NULL)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_LOGICAL_DECODE_ERROR), errmsg(\"output plugins have to register a change callback\")));\r\n    if (callbacks->commit_cb == NULL)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_LOGICAL_DECODE_ERROR), errmsg(\"output plugins have to register a commit callback\")));\r\n}",
		"comment":"/*\r\n * Load the output plugin, lookup its output plugin init function, and check\r\n * that it provides the required callbacks.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logical.cpp",
		"name":"LoadOutputPlugin"
	},
	"LogicalConfirmReceivedLocation":{
		"body":"void LogicalConfirmReceivedLocation(XLogRecPtr lsn)\r\n{\r\n    Assert(!XLByteEQ(lsn, InvalidXLogRecPtr));\r\n    (void)LWLockAcquire(LogicalReplicationSlotPersistentDataLock, LW_EXCLUSIVE);\r\n    /* Do an unlocked check for candidate_lsn first. */\r\n    if (!XLByteEQ(t_thrd.slot_cxt.MyReplicationSlot->candidate_xmin_lsn, InvalidXLogRecPtr) ||\r\n        !XLByteEQ(t_thrd.slot_cxt.MyReplicationSlot->candidate_restart_valid, InvalidXLogRecPtr)) {\r\n        bool updated_xmin = false;\r\n        bool updated_restart = false;\r\n\r\n        /* use volatile pointer to prevent code rearrangement */\r\n        ReplicationSlot* slot = t_thrd.slot_cxt.MyReplicationSlot;\r\n\r\n        SpinLockAcquire(&slot->mutex);\r\n\r\n        slot->data.confirmed_flush = lsn;\r\n\r\n        /* if were past the location required for bumping xmin, do so */\r\n        if (!XLByteEQ(slot->candidate_xmin_lsn, InvalidXLogRecPtr) && XLByteLE(slot->candidate_xmin_lsn, lsn)) {\r\n            /*\r\n             * We have to write the changed xmin to disk *before* we change\r\n             * the in-memory value, otherwise after a crash we wouldn't know\r\n             * that some catalog tuples might have been removed already.\r\n             *\r\n             * Ensure that by first writing to ->xmin and only update\r\n             * ->effective_xmin once the new state is synced to disk. After a\r\n             * crash ->effective_xmin is set to ->xmin.\r\n             */\r\n            if (TransactionIdIsValid(slot->candidate_catalog_xmin) &&\r\n                slot->data.catalog_xmin != slot->candidate_catalog_xmin) {\r\n                slot->data.catalog_xmin = slot->candidate_catalog_xmin;\r\n                slot->candidate_catalog_xmin = InvalidTransactionId;\r\n                slot->candidate_xmin_lsn = InvalidXLogRecPtr;\r\n                updated_xmin = true;\r\n            }\r\n        }\r\n\r\n        if (!XLByteEQ(slot->candidate_restart_valid, InvalidXLogRecPtr) &&\r\n            XLByteLE(slot->candidate_restart_valid, lsn)) {\r\n            Assert(!XLByteEQ(slot->candidate_restart_lsn, InvalidXLogRecPtr));\r\n            Assert(XLByteLE(slot->data.restart_lsn, slot->candidate_restart_lsn));\r\n\r\n            slot->data.restart_lsn = slot->candidate_restart_lsn;\r\n            slot->candidate_restart_lsn = InvalidXLogRecPtr;\r\n            slot->candidate_restart_valid = InvalidXLogRecPtr;\r\n            updated_restart = true;\r\n        }\r\n\r\n        SpinLockRelease(&slot->mutex);\r\n\r\n        /* first write new xmin to disk, so we know whats up after a crash */\r\n        if (updated_xmin || updated_restart) {\r\n            ReplicationSlotMarkDirty();\r\n            ReplicationSlotSave();\r\n            if (!RecoveryInProgress())\r\n                ereport(DEBUG1, (errmsg(\"updated xmin: %d restart: %d\", updated_xmin, updated_restart)));\r\n        }\r\n        /*\r\n         * Now the new xmin is safely on disk, we can let the global value\r\n         * advance. We do not take ProcArrayLock or similar since we only\r\n         * advance xmin here and there's not much harm done by a concurrent\r\n         * computation missing that.\r\n         */\r\n        if (updated_xmin) {\r\n            SpinLockAcquire(&slot->mutex);\r\n            slot->effective_catalog_xmin = slot->data.catalog_xmin;\r\n            SpinLockRelease(&slot->mutex);\r\n\r\n            ReplicationSlotsComputeRequiredXmin(false);\r\n            ReplicationSlotsComputeRequiredLSN(NULL);\r\n        }\r\n    } else {\r\n        volatile ReplicationSlot* slot = t_thrd.slot_cxt.MyReplicationSlot;\r\n\r\n        SpinLockAcquire(&slot->mutex);\r\n        slot->data.confirmed_flush = lsn;\r\n        SpinLockRelease(&slot->mutex);\r\n    }\r\n    LWLockRelease(LogicalReplicationSlotPersistentDataLock);\r\n}",
		"comment":"/*\r\n * Handle a consumer's conformation having received all changes up to lsn.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logical.cpp",
		"name":"LogicalConfirmReceivedLocation"
	},
	"LogicalIncreaseRestartDecodingForSlot":{
		"body":"void LogicalIncreaseRestartDecodingForSlot(XLogRecPtr current_lsn, XLogRecPtr restart_lsn)\r\n{\r\n    bool updated_lsn = false;\r\n    ReplicationSlot* slot = NULL;\r\n\r\n    slot = t_thrd.slot_cxt.MyReplicationSlot;\r\n\r\n    Assert(slot != NULL);\r\n    Assert(!XLByteEQ(restart_lsn, InvalidXLogRecPtr));\r\n    Assert(!XLByteEQ(current_lsn, InvalidXLogRecPtr));\r\n\r\n    SpinLockAcquire(&slot->mutex);\r\n\r\n    /* don't overwrite if have a newer restart lsn */\r\n    if (XLByteLE(restart_lsn, slot->data.restart_lsn)) {\r\n    } else if (XLByteLE(current_lsn, slot->data.confirmed_flush)) {\r\n        /*\r\n         * We might have already flushed far enough to directly accept this lsn, in\r\n         * this case there is no need to check for existing candidate LSNs\r\n         */\r\n        slot->candidate_restart_valid = current_lsn;\r\n        slot->candidate_restart_lsn = restart_lsn;\r\n\r\n        /* our candidate can directly be used */\r\n        updated_lsn = true;\r\n    }\r\n    /*\r\n     * Only increase if the previous values have been applied, otherwise we\r\n     * might never end up updating if the receiver acks too slowly. A missed\r\n     * value here will just cause some extra effort after reconnecting.\r\n     */\r\n    if (XLByteEQ(slot->candidate_restart_valid, InvalidXLogRecPtr)) {\r\n        slot->candidate_restart_valid = current_lsn;\r\n        slot->candidate_restart_lsn = restart_lsn;\r\n        if (!RecoveryInProgress())\r\n            ereport(DEBUG1,\r\n                (errmsg(\"got new restart lsn %X/%X at %X/%X\",\r\n                    (uint32)(restart_lsn >> 32),\r\n                    (uint32)restart_lsn,\r\n                    (uint32)(current_lsn >> 32),\r\n                    (uint32)current_lsn)));\r\n    } else {\r\n        if (!RecoveryInProgress())\r\n            ereport(DEBUG1,\r\n                (errmsg(\"failed to increase restart lsn: proposed %X/%X, after %X/%X, current candidate %X/%X, current \"\r\n                        \"after %X/%X, flushed up to %X/%X\",\r\n                    (uint32)(restart_lsn >> 32),\r\n                    (uint32)restart_lsn,\r\n                    (uint32)(current_lsn >> 32),\r\n                    (uint32)current_lsn,\r\n                    (uint32)(slot->candidate_restart_lsn >> 32),\r\n                    (uint32)slot->candidate_restart_lsn,\r\n                    (uint32)(slot->candidate_restart_valid >> 32),\r\n                    (uint32)slot->candidate_restart_valid,\r\n                    (uint32)(slot->data.confirmed_flush >> 32),\r\n                    (uint32)slot->data.confirmed_flush)));\r\n    }\r\n    SpinLockRelease(&slot->mutex);\r\n\r\n    /* candidates are already valid with the current flush position, apply */\r\n    if (updated_lsn)\r\n        LogicalConfirmReceivedLocation(slot->data.confirmed_flush);\r\n}",
		"comment":"/*\r\n * Mark the minimal LSN (restart_lsn) we need to read to replay all\r\n * transactions that have not yet committed at current_lsn.\r\n *\r\n * Just like IncreaseRestartDecodingForSlot this nly takes effect when the\r\n * client has confirmed to have received current_lsn.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logical.cpp",
		"name":"LogicalIncreaseRestartDecodingForSlot"
	},
	"LogicalIncreaseXminForSlot":{
		"body":"void LogicalIncreaseXminForSlot(XLogRecPtr current_lsn, TransactionId xmin)\r\n{\r\n    bool updated_xmin = false;\r\n    ReplicationSlot* slot = NULL;\r\n\r\n    slot = t_thrd.slot_cxt.MyReplicationSlot;\r\n\r\n    Assert(slot != NULL);\r\n\r\n    SpinLockAcquire(&slot->mutex);\r\n\r\n    /*\r\n     * don't overwrite if we already have a newer xmin. This can\r\n     * happen if we restart decoding in a slot.\r\n     */\r\n    if (TransactionIdPrecedesOrEquals(xmin, slot->data.catalog_xmin)) {\r\n    } else if (XLByteLE(current_lsn, slot->data.confirmed_flush)) {\r\n        /*\r\n         * If the client has already confirmed up to this lsn, we directly\r\n         * can mark this as accepted. This can happen if we restart\r\n         * decoding in a slot.\r\n         */\r\n        slot->candidate_catalog_xmin = xmin;\r\n        slot->candidate_xmin_lsn = current_lsn;\r\n\r\n        /* our candidate can directly be used */\r\n        updated_xmin = true;\r\n    } else if (XLByteEQ(slot->candidate_xmin_lsn, InvalidXLogRecPtr)) {\r\n        /*\r\n         * Only increase if the previous values have been applied, otherwise we\r\n         * might never end up updating if the receiver acks too slowly.\r\n         */\r\n        slot->candidate_catalog_xmin = xmin;\r\n        slot->candidate_xmin_lsn = current_lsn;\r\n    }\r\n    SpinLockRelease(&slot->mutex);\r\n\r\n    /* candidate already valid with the current flush position, apply */\r\n    if (updated_xmin)\r\n        LogicalConfirmReceivedLocation(slot->data.confirmed_flush);\r\n}",
		"comment":"/*\r\n * Set the required catalog xmin horizon for historic snapshots in the current\r\n * replication slot.\r\n *\r\n * Note that in the most cases, we won't be able to immediately use the xmin\r\n * to increase the xmin horizon, we need to wait till the client has confirmed\r\n * receiving current_lsn with LogicalConfirmReceivedLocation().\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logical.cpp",
		"name":"LogicalIncreaseXminForSlot"
	},
	"OutputPluginPrepareWrite":{
		"body":"void OutputPluginPrepareWrite(struct LogicalDecodingContext* ctx, bool last_write)\r\n{\r\n    if (!ctx->accept_writes)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_LOGICAL_DECODE_ERROR),\r\n                errmsg(\"writes are only accepted in commit, begin and change callbacks\")));\r\n\r\n    ctx->prepare_write(ctx, ctx->write_location, ctx->write_xid, last_write);\r\n    ctx->prepared_write = true;\r\n}",
		"comment":"/*\r\n * Prepare a write using the context's output routine.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logical.cpp",
		"name":"OutputPluginPrepareWrite"
	},
	"OutputPluginWrite":{
		"body":"void OutputPluginWrite(struct LogicalDecodingContext* ctx, bool last_write)\r\n{\r\n    if (!ctx->prepared_write)\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_LOGICAL_DECODE_ERROR),\r\n                errmsg(\"OutputPluginPrepareWrite needs to be called before OutputPluginWrite\")));\r\n\r\n    ctx->write(ctx, ctx->write_location, ctx->write_xid, last_write);\r\n    ctx->prepared_write = false;\r\n}",
		"comment":"/*\r\n * Perform a write using the context's output routine.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logical.cpp",
		"name":"OutputPluginWrite"
	},
	"StartupDecodingContext":{
		"body":"static LogicalDecodingContext* StartupDecodingContext(List* output_plugin_options, XLogRecPtr start_lsn,\r\n    TransactionId xmin_horizon, bool need_full_snapshot, bool fast_forward, XLogPageReadCB read_page,\r\n    LogicalOutputPluginWriterPrepareWrite prepare_write, LogicalOutputPluginWriterWrite do_write)\r\n{\r\n    ReplicationSlot* slot = NULL;\r\n    MemoryContext context, old_context;\r\n    LogicalDecodingContext* ctx = NULL;\r\n\r\n    /* shorter lines... */\r\n    slot = t_thrd.slot_cxt.MyReplicationSlot;\r\n\r\n    context = AllocSetContextCreate(CurrentMemoryContext,\r\n        \"Changeset Extraction Context\",\r\n        ALLOCSET_DEFAULT_MINSIZE,\r\n        ALLOCSET_DEFAULT_INITSIZE,\r\n        ALLOCSET_DEFAULT_MAXSIZE);\r\n    old_context = MemoryContextSwitchTo(context);\r\n    ctx = (LogicalDecodingContext*)palloc0(sizeof(LogicalDecodingContext));\r\n\r\n    ctx->context = context;\r\n\r\n    /* (re-)load output plugins, so we detect a bad (removed) output plugin now. */\r\n    if (!fast_forward)\r\n        LoadOutputPlugin(&ctx->callbacks, NameStr(slot->data.plugin));\r\n\r\n    /*\r\n     * Now that the slot's xmin has been set, we can announce ourselves as a\r\n     * logical decoding backend which doesn't need to be checked individually\r\n     * when computing the xmin horizon because the xmin is enforced via\r\n     * replication slots.\r\n     */\r\n    (void)LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);\r\n    t_thrd.pgxact->vacuumFlags |= PROC_IN_LOGICAL_DECODING;\r\n    LWLockRelease(ProcArrayLock);\r\n\r\n    ctx->slot = slot;\r\n\r\n    ctx->reader = XLogReaderAllocate(read_page, ctx);\r\n    if (unlikely(ctx->reader == NULL))\r\n        ereport(ERROR,\r\n            (errcode(ERRCODE_INSUFFICIENT_RESOURCES),\r\n                errmsg(\"memory is temporarily unavailable while allocate xlog reader\")));\r\n\r\n    ctx->reader->private_data = ctx;\r\n\r\n    ctx->reorder = ReorderBufferAllocate();\r\n    ctx->snapshot_builder = AllocateSnapshotBuilder(ctx->reorder, xmin_horizon, start_lsn, need_full_snapshot);\r\n\r\n    ctx->reorder->private_data = ctx;\r\n\r\n    /* wrap output plugin callbacks, so we can add error context information */\r\n    ctx->reorder->begin = begin_cb_wrapper;\r\n    ctx->reorder->apply_change = change_cb_wrapper;\r\n    ctx->reorder->commit = commit_cb_wrapper;\r\n\r\n    ctx->out = makeStringInfo();\r\n    ctx->prepare_write = prepare_write;\r\n    ctx->write = do_write;\r\n\r\n    ctx->output_plugin_options = output_plugin_options;\r\n    ctx->fast_forward = fast_forward;\r\n\r\n    (void)MemoryContextSwitchTo(old_context);\r\n\r\n    return ctx;\r\n}",
		"comment":"/*\r\n * Helper function for CreateInitialDecodingContext() and\r\n * CreateDecodingContext() performing common tasks.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logical.cpp",
		"name":"StartupDecodingContext"
	},
	"begin_cb_wrapper":{
		"body":"static void begin_cb_wrapper(ReorderBuffer* cache, ReorderBufferTXN* txn)\r\n{\r\n    LogicalDecodingContext* ctx = (LogicalDecodingContext*)cache->private_data;\r\n    LogicalErrorCallbackState state;\r\n    ErrorContextCallback errcallback;\r\n\r\n    Assert(!ctx->fast_forward);\r\n\r\n    /* Push callback + info on the error context stack */\r\n    state.ctx = ctx;\r\n    state.callback_name = \"begin\";\r\n    state.report_location = txn->first_lsn;\r\n    errcallback.callback = output_plugin_error_callback;\r\n    errcallback.arg = (void*)&state;\r\n    errcallback.previous = t_thrd.log_cxt.error_context_stack;\r\n    t_thrd.log_cxt.error_context_stack = &errcallback;\r\n\r\n    /* set output state */\r\n    ctx->accept_writes = true;\r\n    ctx->write_xid = txn->xid;\r\n    ctx->write_location = txn->first_lsn;\r\n\r\n    /* do the actual work: call callback */\r\n    ctx->callbacks.begin_cb(ctx, txn);\r\n\r\n    /* Pop the error context stack */\r\n    t_thrd.log_cxt.error_context_stack = errcallback.previous;\r\n}",
		"comment":"/*\r\n * Callbacks for ReorderBuffer which add in some more information and then call\r\n * output_plugin.h plugins.\r\n */",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logical.cpp",
		"name":"begin_cb_wrapper"
	},
	"change_cb_wrapper":{
		"body":"static void change_cb_wrapper(\r\n    ReorderBuffer* cache, ReorderBufferTXN* txn, Relation relation, ReorderBufferChange* change)\r\n{\r\n    LogicalDecodingContext* ctx = (LogicalDecodingContext*)cache->private_data;\r\n    LogicalErrorCallbackState state;\r\n    ErrorContextCallback errcallback;\r\n    Assert(!ctx->fast_forward);\r\n\r\n    /* Push callback + info on the error context stack */\r\n    state.ctx = ctx;\r\n    state.callback_name = \"change\";\r\n    state.report_location = change->lsn;\r\n    errcallback.callback = output_plugin_error_callback;\r\n    errcallback.arg = (void*)&state;\r\n    errcallback.previous = t_thrd.log_cxt.error_context_stack;\r\n    t_thrd.log_cxt.error_context_stack = &errcallback;\r\n\r\n    /* set output state */\r\n    ctx->accept_writes = true;\r\n    ctx->write_xid = txn->xid;\r\n    /*\r\n     * report this change's lsn so replies from clients can give an up2date\r\n     * answer. This won't ever be enough (and shouldn't be!) to confirm\r\n     * receipt of this transaction, but it might allow another transaction's\r\n     * commit to be confirmed with one message.\r\n     */\r\n    ctx->write_location = change->lsn;\r\n\r\n    ctx->callbacks.change_cb(ctx, txn, relation, change);\r\n\r\n    /* Pop the error context stack */\r\n    t_thrd.log_cxt.error_context_stack = errcallback.previous;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logical.cpp",
		"name":"change_cb_wrapper"
	},
	"commit_cb_wrapper":{
		"body":"static void commit_cb_wrapper(ReorderBuffer* cache, ReorderBufferTXN* txn, XLogRecPtr commit_lsn)\r\n{\r\n    LogicalDecodingContext* ctx = (LogicalDecodingContext*)cache->private_data;\r\n    LogicalErrorCallbackState state;\r\n    ErrorContextCallback errcallback;\r\n\r\n    Assert(!ctx->fast_forward);\r\n\r\n    /* Push callback + info on the error context stack */\r\n    state.ctx = ctx;\r\n    state.callback_name = \"commit\";\r\n    state.report_location = txn->final_lsn; /* beginning of commit record */\r\n    errcallback.callback = output_plugin_error_callback;\r\n    errcallback.arg = (void*)&state;\r\n    errcallback.previous = t_thrd.log_cxt.error_context_stack;\r\n    t_thrd.log_cxt.error_context_stack = &errcallback;\r\n\r\n    /* set output state */\r\n    ctx->accept_writes = true;\r\n    ctx->write_xid = txn->xid;\r\n    ctx->write_location = txn->end_lsn; /* points to the end of the record */\r\n\r\n    /* do the actual work: call callback */\r\n    ctx->callbacks.commit_cb(ctx, txn, commit_lsn);\r\n\r\n    /* Pop the error context stack */\r\n    t_thrd.log_cxt.error_context_stack = errcallback.previous;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logical.cpp",
		"name":"commit_cb_wrapper"
	},
	"filter_by_origin_cb_wrapper":{
		"body":"bool filter_by_origin_cb_wrapper(LogicalDecodingContext* ctx, RepOriginId origin_id)\r\n{\r\n    LogicalErrorCallbackState state;\r\n    ErrorContextCallback errcallback;\r\n    bool ret = false;\r\n\r\n    /* Push callback + info on the error context stack */\r\n    state.ctx = ctx;\r\n    state.callback_name = \"shutdown\";\r\n    state.report_location = InvalidXLogRecPtr;\r\n    errcallback.callback = output_plugin_error_callback;\r\n    errcallback.arg = (void*)&state;\r\n    errcallback.previous = t_thrd.log_cxt.error_context_stack;\r\n    t_thrd.log_cxt.error_context_stack = &errcallback;\r\n\r\n    /* set output state */\r\n    ctx->accept_writes = false;\r\n\r\n    /* do the actual work: call callback */\r\n    ret = ctx->callbacks.filter_by_origin_cb(ctx, origin_id);\r\n\r\n    /* Pop the error context stack */\r\n    t_thrd.log_cxt.error_context_stack = errcallback.previous;\r\n\r\n    return ret;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logical.cpp",
		"name":"filter_by_origin_cb_wrapper"
	},
	"output_plugin_error_callback":{
		"body":"static void output_plugin_error_callback(void* arg)\r\n{\r\n    LogicalErrorCallbackState* state = (LogicalErrorCallbackState*)arg;\r\n    /* not all callbacks have an associated LSN  */\r\n    if (!XLByteEQ(state->report_location, InvalidXLogRecPtr)) {\r\n        (void)errcontext(\"slot \\\"%s\\\", output plugin \\\"%s\\\", in the %s callback, associated LSN %X/%X\",\r\n            NameStr(state->ctx->slot->data.name),\r\n            NameStr(state->ctx->slot->data.plugin),\r\n            state->callback_name,\r\n            (uint32)(state->report_location >> 32),\r\n            (uint32)state->report_location);\r\n    } else {\r\n        (void)errcontext(\"slot \\\"%s\\\", output plugin \\\"%s\\\", in the %s callback\",\r\n            NameStr(state->ctx->slot->data.name),\r\n            NameStr(state->ctx->slot->data.plugin),\r\n            state->callback_name);\r\n    }\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logical.cpp",
		"name":"output_plugin_error_callback"
	},
	"shutdown_cb_wrapper":{
		"body":"static void shutdown_cb_wrapper(LogicalDecodingContext* ctx)\r\n{\r\n    LogicalErrorCallbackState state;\r\n    ErrorContextCallback errcallback;\r\n    Assert(!ctx->fast_forward);\r\n\r\n    /* Push callback + info on the error context stack */\r\n    state.ctx = ctx;\r\n    state.callback_name = \"shutdown\";\r\n    state.report_location = InvalidXLogRecPtr;\r\n    errcallback.callback = output_plugin_error_callback;\r\n    errcallback.arg = (void*)&state;\r\n    errcallback.previous = t_thrd.log_cxt.error_context_stack;\r\n    t_thrd.log_cxt.error_context_stack = &errcallback;\r\n\r\n    /* set output state */\r\n    ctx->accept_writes = false;\r\n\r\n    /* do the actual work: call callback */\r\n    ctx->callbacks.shutdown_cb(ctx);\r\n\r\n    /* Pop the error context stack */\r\n    t_thrd.log_cxt.error_context_stack = errcallback.previous;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logical.cpp",
		"name":"shutdown_cb_wrapper"
	},
	"startup_cb_wrapper":{
		"body":"static void startup_cb_wrapper(LogicalDecodingContext* ctx, OutputPluginOptions* opt, bool is_init)\r\n{\r\n    LogicalErrorCallbackState state;\r\n    ErrorContextCallback errcallback;\r\n    Assert(!ctx->fast_forward);\r\n\r\n    /* Push callback + info on the error context stack */\r\n    state.ctx = ctx;\r\n    state.callback_name = \"startup\";\r\n    state.report_location = InvalidXLogRecPtr;\r\n    errcallback.callback = output_plugin_error_callback;\r\n    errcallback.arg = (void*)&state;\r\n    errcallback.previous = t_thrd.log_cxt.error_context_stack;\r\n    t_thrd.log_cxt.error_context_stack = &errcallback;\r\n\r\n    /* set output state */\r\n    ctx->accept_writes = false;\r\n\r\n    /* do the actual work: call callback */\r\n    ctx->callbacks.startup_cb(ctx, opt, is_init);\r\n\r\n    /* Pop the error context stack */\r\n    t_thrd.log_cxt.error_context_stack = errcallback.previous;\r\n}",
		"comment":"",
		"filename":"D:\\标注竞赛\\openGauss-server\\src\\gausskernel\\storage\\replication\\logical\\logical.cpp",
		"name":"startup_cb_wrapper"
	}
}